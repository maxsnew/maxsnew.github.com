//# 1 "web.bc.runtime.js"
// Generated by js_of_ocaml 3.4.0
(function(joo_global_object)
   {"use strict";
    var caml_oo_last_id=0;
    function caml_ml_string_length(s){return s.l}
    function caml_string_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_int64_add(x,y)
     {var
       z1=x[1] + y[1],
       z2=x[2] + y[2] + (z1 >> 24),
       z3=x[3] + y[3] + (z2 >> 24);
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_int64_mul(x,y)
     {var
       z1=x[1] * y[1],
       z2=(z1 * caml_int64_offset | 0) + x[2] * y[1] + x[1] * y[2],
       z3=
        (z2 * caml_int64_offset | 0)
        +
        x[3]
        *
        y[1]
        +
        x[2]
        *
        y[2]
        +
        x[1]
        *
        y[3];
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_int64_neg(x)
     {var y1=- x[1],y2=- x[2] + (y1 >> 24),y3=- x[3] + (y2 >> 24);
      return [255,y1 & 0xffffff,y2 & 0xffffff,y3 & 0xffff]}
    function caml_int64_of_int32(x)
     {return [255,x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff]}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_int64_sub(x,y)
     {var
       z1=x[1] - y[1],
       z2=x[2] - y[2] + (z1 >> 24),
       z3=x[3] - y[3] + (z2 >> 24);
      return [255,z1 & 0xffffff,z2 & 0xffffff,z3 & 0xffff]}
    function caml_int64_ucompare(x,y)
     {if(x[3] > y[3])return 1;
      if(x[3] < y[3])return - 1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return - 1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return - 1;
      return 0}
    function caml_int64_lsl1(x)
     {x[3] = x[3] << 1 | x[2] >> 23;
      x[2] = (x[2] << 1 | x[1] >> 23) & 0xffffff;
      x[1] = x[1] << 1 & 0xffffff}
    function caml_int64_lsr1(x)
     {x[1] = (x[1] >>> 1 | x[2] << 23) & 0xffffff;
      x[2] = (x[2] >>> 1 | x[3] << 23) & 0xffffff;
      x[3] = x[3] >>> 1}
    function caml_int64_udivmod(x,y)
     {var
       offset=0,
       modulus=caml_obj_dup(x),
       divisor=caml_obj_dup(y),
       quotient=[255,0,0,0];
      while(caml_int64_ucompare(modulus,divisor) > 0)
       {offset++;caml_int64_lsl1(divisor)}
      while(offset >= 0)
       {offset--;
        caml_int64_lsl1(quotient);
        if(caml_int64_ucompare(modulus,divisor) >= 0)
         {quotient[1]++;modulus = caml_int64_sub(modulus,divisor)}
        caml_int64_lsr1(divisor)}
      return [0,quotient,modulus]}
    function caml_int64_ult(x,y){return caml_int64_ucompare(x,y) < 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break
         }
      return [i,sign,base]}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_str_repeat(n,s)
     {if(s.repeat)return s.repeat(n);
      var r="",l=0;
      if(n == 0)return r;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function raw_array_sub(a,i,l)
     {var b=new Array(l);for(var j=0;j < l;j++)b[j] = a[i + j];return b}
    function caml_subarray_to_string(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,raw_array_sub(a,i,Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_string(s.c,0,s.c.length);
      s.t = 0}
    function caml_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_to_js_string(s)
     {switch(s.t)
       {case 9:return s.c;
        default:caml_convert_string_to_bytes(s);case 0:
         if(caml_is_ascii(s.c)){s.t = 9;return s.c}s.t = 8;
        case 8:return caml_utf16_of_utf8(s.c)
        }}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString = function(){return caml_to_js_string(this)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_new_string(s){return new MlBytes(0,s,s.length)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_new_string(msg))}
    var caml_global_data=[0];
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=caml_int64_udivmod([255,0xffffff,0xfffffff,0xffff],base64)[1],
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(r[2] == 10 && caml_int64_ult([255,0,0,0x8000],res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function caml_int64_is_zero(x){return (x[3] | x[2] | x[1]) == 0}
    function caml_int64_to_int32(x){return x[1] | x[2] << 24}
    function caml_int64_is_negative(x){return x[3] << 16 < 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_new_string(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=caml_int64_udivmod(x,wbase);
        x = p[1];
        buffer = cvtbl.charAt(caml_int64_to_int32(p[2])) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = name instanceof MlBytes?name.toString():name;
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = name instanceof MlBytes?name.toString():name;
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_string_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_string_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_string(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_string(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_string_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_bytes(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun(caml_new_string(this.root),caml_new_string(name));
        if(res !== 0)this.content[name] = new MlFakeFile(res[1])}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(content instanceof MlBytes)
       this.content[name] = new MlFakeFile(content);
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_string_of_array(content));
       else
        if(content.toString)
         {var mlstring=caml_new_string(content.toString());
          this.content[name] = new MlFakeFile(mlstring)}};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_array_of_string(s)
     {if(s.t != 4)caml_convert_string_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_string_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    var Buffer=joo_global_object.Buffer;
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len){this.fs.ftruncateSync(this.fd,len | 0)};
    MlNodeFile.prototype.length
    =
    function(){return this.fs.fstatSync(this.fd).size};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=Buffer.from(a);
      this.fs.writeSync(this.fd,buffer,buf_offset,len,offset);
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=Buffer.from(a);
      this.fs.readSync(this.fd,buffer,buf_offset,len,offset);
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (joo_global_object.Uint8Array)(1),buffer=Buffer.from(a);
      this.fs.readSync(this.fd,buffer,0,1,offset);
      return buffer[0]};
    MlNodeFile.prototype.close = function(){this.fs.closeSync(this.fd)};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name){return this.fs.existsSync(this.nm(name))?1:0};
    MlNodeDevice.prototype.readdir
    =
    function(name){return this.fs.readdirSync(this.nm(name))};
    MlNodeDevice.prototype.is_dir
    =
    function(name){return this.fs.statSync(this.nm(name)).isDirectory()?1:0};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {var b=this.fs.existsSync(this.nm(name))?1:0;
      this.fs.unlinkSync(this.nm(name));
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      var fd=this.fs.openSync(this.nm(name),res);
      return new MlNodeFile(fd)};
    MlNodeDevice.prototype.rename
    =
    function(o,n){this.fs.renameSync(this.nm(o),this.nm(n))};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_string_get(s,i)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    function caml_ba_set_1(ba,i0,v){return ba.set1(i0,v)}
    function bigstring_blit_string_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       caml_ba_set_1
        (v_bstr,v_dst_pos + i,caml_string_get(v_str,v_src_pos + i));
      return 0}
    var caml_blit_string_to_bigstring=bigstring_blit_string_bigstring_stub;
    function caml_make_vect(len,init)
     {var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function js_print_stderr(s)
     {var g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_js_to_string(s)
     {var tag=9;
      if(! caml_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_raise_constant(tag){throw tag}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=name.toString();
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_js_to_string(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_js_to_string(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_raise_not_a_dir(name)
     {name = name instanceof MlBytes?name.toString():name;
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_new_string(a[i]);
      return l}
    var caml_ml_channels=new Array();
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var string;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       string = buffer;
      else
       {string = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,string,0,len)}
      var
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes(chanid,buffer,offset,len)}
    function caml_ml_output_char(chanid,c)
     {var s=caml_new_string(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_bytes_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_int64_float_of_bits(x)
     {var exp=(x[3] & 0x7fff) >> 4;
      if(exp == 2047)
       return (x[1] | x[2] | x[3] & 0xf) == 0
               ?x[3] & 0x8000?- Infinity:Infinity
               :NaN;
      var k=Math.pow(2,- 24),res=(x[1] * k + x[2]) * k + (x[3] & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(x[3] & 0x8000)res = - res;
      return res}
    function caml_int64_of_bytes(a)
     {return [255,
              a[7] | a[6] << 8 | a[5] << 16,
              a[4] | a[3] << 8 | a[2] << 16,
              a[1] | a[0] << 8]}
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_js_var(x)
     {var x=x.toString();
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_new_string(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function caml_gc_minor(){return 0}
    function caml_trunc_float(x){return Math.trunc(x)}
    var caml_ephe_data_offset=2;
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_ba_uint8_get64(ba,i0)
     {var
       b1=ba.get1(i0),
       b2=ba.get1(i0 + 1) << 8,
       b3=ba.get1(i0 + 2) << 16,
       b4=ba.get1(i0 + 3),
       b5=ba.get1(i0 + 4) << 8,
       b6=ba.get1(i0 + 5) << 16,
       b7=ba.get1(i0 + 6),
       b8=ba.get1(i0 + 7) << 8;
      return [255,b1 | b2 | b3,b4 | b5 | b6,b7 | b8]}
    function caml_int64_compare(x,y)
     {var x3=x[3] << 16,y3=y[3] << 16;
      if(x3 > y3)return 1;
      if(x3 < y3)return - 1;
      if(x[2] > y[2])return 1;
      if(x[2] < y[2])return - 1;
      if(x[1] > y[1])return 1;
      if(x[1] < y[1])return - 1;
      return 0}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_string_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         if(a instanceof MlBytes)
          if(b instanceof MlBytes)
           {if(a !== b){var x=caml_string_compare(a,b);if(x != 0)return x}}
          else
           return 1;
         else
          if(a instanceof Array && a[0] === (a[0] | 0))
           {var ta=a[0];
            if(ta === 254)ta = 0;
            if(ta === 250)
             {a = a[1];continue}
            else
             if(b instanceof Array && b[0] === (b[0] | 0))
              {var tb=b[0];
               if(tb === 254)tb = 0;
               if(tb === 250)
                {b = b[1];continue}
               else
                if(ta != tb)
                 return ta < tb?- 1:1;
                else
                 switch(ta)
                  {case 248:
                    var x=caml_int_compare(a[2],b[2]);if(x != 0)return x;break;
                   case 251:caml_invalid_argument("equal: abstract value");
                   case 255:
                    var x=caml_int64_compare(a,b);if(x != 0)return x;break;
                   default:
                    if(a.length != b.length)return a.length < b.length?- 1:1;
                    if(a.length > 1)stack.push(a,b,1)}}
             else
              return 1}
          else
           if
            (b instanceof MlBytes
             ||
             b instanceof Array
             &&
             b[0]
             ===
             (b[0] | 0))
            return - 1;
           else
            if(typeof a != "number" && a && a.compare)
             {var cmp=a.compare(b,total);if(cmp != 0)return cmp}
            else
             if(typeof a == "function")
              caml_invalid_argument("compare: functional value");
             else
              {if(a < b)return - 1;
               if(a > b)return 1;
               if(a != b)
                {if(! total)return NaN;
                 if(a == a)return 1;
                 if(b == b)return - 1}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function caml_ba_num_dims(ba,_dim){return ba.num_dims}
    function caml_ba_get_1(ba,i0){return ba.get1(i0)}
    function bigstring_blit_bigstring_bytes_stub
     (v_bstr,v_src_pos,v_str,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var c=caml_ba_get_1(v_bstr,v_src_pos + i);
        caml_bytes_set(v_str,v_dst_pos + i,c)}
      return 0}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      return 0}
    if(! Math.imul)
     Math.imul
     =
     function(x,y){y |= 0;return ((x >> 16) * y << 16) + (x & 0xffff) * y | 0};
    var caml_mul=Math.imul;
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_string_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_return_exn_constant(tag){return tag}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_js_to_string(String(e))]}
    function caml_final_register_called_without_value(){return 0}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_ba_get_2(ba,i0,i1){return ba.get([i0,i1])}
    function caml_set_parser_trace(){return 0}
    function win_handle_fd(x){return x}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_ba_uint8_set16(ba,i0,v)
     {ba.set1(i0,v & 0xff);ba.set1(i0 + 1,v >>> 8 & 0xff);return 0}
    function raw_array_append_one(a,x)
     {var l=a.length,b=new Array(l + 1),i=0;
      for(;i < l;i++)b[i] = a[i];
      b[i] = x;
      return b}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      var n=f.length,argsLen=args.length,d=n - argsLen;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen
                (f.apply(null,raw_array_sub(args,0,n)),
                 raw_array_sub(args,n,argsLen - n));
       else
        return function(x)
         {return caml_call_gen(f,raw_array_append_one(args,x))}}
    function caml_js_wrap_callback(f)
     {return function()
       {return arguments.length > 0
                ?caml_call_gen(f,arguments)
                :caml_call_gen(f,[undefined])}}
    function caml_js_wrap_callback_arguments(f)
     {return function(){return caml_js_wrap_callback(f)(arguments)}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {caml_current_dir = root.rest?root.path + root.rest + "/":root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;prev = [0,caml_new_string(jsoo_mount_point[i].path),old]}
      return prev}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12};
    function caml_js_equals(x,y){return + (x == y)}
    function caml_hash_mix_string_str(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function caml_ba_blit(src,dst){dst.blit(src);return 0}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             switch(s)
              {case "_j":
                var t=new Array(8);
                for(var j=0;j < 8;j++)t[j] = reader.read8u();
                var v=caml_int64_of_bytes(t);
                if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                return v;
               case "_i":
                var v=reader.read32s();
                if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                return v;
               case "_n":
                switch(reader.read8u())
                 {case 1:
                   var v=reader.read32s();
                   if(intern_obj_table)intern_obj_table[obj_counter++] = v;
                   return v;
                  case 2:
                   caml_failwith("input_value: native integer value too large");
                  default:
                   caml_failwith("input_value: ill-formed native integer")}
               default:
                caml_failwith("input_value: unknown custom block identifier")}
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_js_from_array(a){return raw_array_sub(a,1,a.length - 1)}
    function caml_ba_slice(ba,vind){return ba.slice(caml_js_from_array(vind))}
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function caml_int64_div(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3] ^ y[3];
      if(x[3] & 0x8000)x = caml_int64_neg(x);
      if(y[3] & 0x8000)y = caml_int64_neg(y);
      var q=caml_int64_udivmod(x,y)[1];
      if(sign & 0x8000)q = caml_int64_neg(q);
      return q}
    function bigstring_find(bs,chr,pos,len)
     {while(len > 0){if(caml_ba_get_1(bs,pos) == chr)return pos;pos++;len--}
      return - 1}
    function caml_js_html_entities(s)
     {var str,temp=document.createElement("p");
      temp.innerHTML = s;
      str = temp.textContent || temp.innerText;
      temp = null;
      return str}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return [255,
              x & 0xffffff,
              Math.floor(x * caml_int64_offset) & 0xffffff,
              Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff]}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){return ba.set([i0,i1],v)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function caml_js_eval_string(s){return eval(s.toString())}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function MlBytesReader(s,i){this.s = caml_jsbytes_of_string(s);this.i = i}
    MlBytesReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_new_string(this.s.substring(i,i + len))}};
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_string(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_ba_reshape(ba,vind)
     {return ba.reshape(caml_js_from_array(vind))}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_string_arr(h,bs.data)}
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_record_backtrace(){return 0}
    function caml_get_global_data(){return caml_global_data}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_ba_uint8_get16(ba,i0)
     {var b1=ba.get1(i0),b2=ba.get1(i0 + 1) << 8;return b1 | b2}
    function caml_int64_shift_right_unsigned(x,s)
     {s = s & 63;
      if(s == 0)return x;
      if(s < 24)
       return [255,
               (x[1] >> s | x[2] << 24 - s) & 0xffffff,
               (x[2] >> s | x[3] << 24 - s) & 0xffffff,
               x[3] >> s];
      if(s < 48)
       return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 0xffffff,
               x[3] >> s - 24,
               0];
      return [255,x[3] >> s - 48,0,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_new_string("js_of_ocaml")]}
    function caml_sys_get_config(){return [0,caml_new_string("Unix"),32,0]}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    var
     bigstring_blit_bigstring_string_stub=
      bigstring_blit_bigstring_bytes_stub;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x)
     {return (x[3] << 16) * Math.pow(2,32) + x[2] * Math.pow(2,24) + x[1]}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_ba_create_from(data,data2,data_type,kind,layout,dims)
     {var n_dims=dims.length,size=caml_ba_get_size(dims);
      function offset_c(index)
       {var ofs=0;
        if(n_dims != index.length)
         caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
        for(var i=0;i < n_dims;i++)
         {if(index[i] < 0 || index[i] >= dims[i])caml_array_bound_error();
          ofs = ofs * dims[i] + index[i]}
        return ofs}
      function offset_fortran(index)
       {var ofs=0;
        if(n_dims != index.length)
         caml_invalid_argument("Bigarray.get/set: wrong number of indices");
        for(var i=n_dims - 1;i >= 0;i--)
         {if(index[i] < 1 || index[i] > dims[i])caml_array_bound_error();
          ofs = ofs * dims[i] + (index[i] - 1)}
        return ofs}
      var offset=layout == 0?offset_c:offset_fortran,dim0=dims[0];
      function get_std(index){var ofs=offset(index),v=data[ofs];return v}
      function get_int64(index)
       {var off=offset(index),l=data[off],h=data2[off];
        return [255,
                l & 0xffffff,
                l >>> 24 & 0xff | (h & 0xffff) << 8,
                h >>> 16 & 0xffff]}
      function get_complex(index)
       {var off=offset(index),r=data[off],i=data2[off];return [254,r,i]}
      var get=data_type == 1?get_int64:data_type == 2?get_complex:get_std;
      function get1_c(i)
       {if(i < 0 || i >= dim0)caml_array_bound_error();return data[i]}
      function get1_fortran(i)
       {if(i < 1 || i > dim0)caml_array_bound_error();return data[i - 1]}
      function get1_any(i){return get([i])}
      var get1=data_type == 0?layout == 0?get1_c:get1_fortran:get1_any;
      function set_std_raw(off,v){data[off] = v}
      function set_int64_raw(off,v)
       {data[off] = v[1] | (v[2] & 0xff) << 24;
        data2[off] = v[2] >>> 8 & 0xffff | v[3] << 16}
      function set_complex_raw(off,v){data[off] = v[1];data2[off] = v[2]}
      function set_std(index,v)
       {var ofs=offset(index);return set_std_raw(ofs,v)}
      function set_int64(index,v){return set_int64_raw(offset(index),v)}
      function set_complex(index,v){return set_complex_raw(offset(index),v)}
      var set=data_type == 1?set_int64:data_type == 2?set_complex:set_std;
      function set1_c(i,v)
       {if(i < 0 || i >= dim0)caml_array_bound_error();data[i] = v}
      function set1_fortran(i,v)
       {if(i < 1 || i > dim0)caml_array_bound_error();data[i - 1] = v}
      function set1_any(i,v){set([i],v)}
      var set1=data_type == 0?layout == 0?set1_c:set1_fortran:set1_any;
      function nth_dim(i)
       {if(i < 0 || i >= n_dims)caml_invalid_argument("Bigarray.dim");
        return dims[i]}
      function fill(v)
       {if(data_type == 0)for(var i=0;i < data.length;i++)set_std_raw(i,v);
        if(data_type == 1)for(var i=0;i < data.length;i++)set_int64_raw(i,v);
        if(data_type == 2)for(var i=0;i < data.length;i++)set_complex_raw(i,v)}
      function blit(from)
       {if(n_dims != from.num_dims)
         caml_invalid_argument("Bigarray.blit: dimension mismatch");
        for(var i=0;i < n_dims;i++)
         if(dims[i] != from.nth_dim(i))
          caml_invalid_argument("Bigarray.blit: dimension mismatch");
        data.set(from.data);
        if(data_type != 0)data2.set(from.data2)}
      function sub(ofs,len)
       {var changed_dim,mul=1;
        if(layout == 0)
         {for(var i=1;i < n_dims;i++)mul = mul * dims[i];changed_dim = 0}
        else
         {for(var i=0;i < n_dims - 1;i++)mul = mul * dims[i];
          changed_dim = n_dims - 1;
          ofs = ofs - 1}
        if(ofs < 0 || len < 0 || ofs + len > dims[changed_dim])
         caml_invalid_argument("Bigarray.sub: bad sub-array");
        var
         new_data=data.subarray(ofs * mul,(ofs + len) * mul),
         new_data2=
          data_type == 0?null:data2.subarray(ofs * mul,(ofs + len) * mul),
         new_dims=[];
        for(var i=0;i < n_dims;i++)new_dims[i] = dims[i];
        new_dims[changed_dim] = len;
        return caml_ba_create_from
                (new_data,new_data2,data_type,kind,layout,new_dims)}
      function slice(vind)
       {var num_inds=vind.length,index=[],sub_dims=[],ofs;
        if(num_inds >= n_dims)
         caml_invalid_argument("Bigarray.slice: too many indices");
        if(layout == 0)
         {for(var i=0;i < num_inds;i++)index[i] = vind[i];
          for(;i < n_dims;i++)index[i] = 0;
          ofs = offset(index);
          sub_dims = dims.slice(num_inds)}
        else
         {for(var i=0;i < num_inds;i++)index[n_dims - num_inds + i] = vind[i];
          for(var i=0;i < n_dims - num_inds;i++)index[i] = 1;
          ofs = offset(index);
          sub_dims = dims.slice(0,num_inds)}
        var
         size=caml_ba_get_size(sub_dims),
         new_data=data.subarray(ofs,ofs + size),
         new_data2=data_type == 0?null:data2.subarray(ofs,ofs + size);
        return caml_ba_create_from
                (new_data,new_data2,data_type,kind,layout,sub_dims)}
      function reshape(vdim)
       {var new_dim=[],num_dims=vdim.length;
        if(num_dims < 1)
         caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
        var num_elts=1;
        for(var i=0;i < num_dims;i++)
         {new_dim[i] = vdim[i];
          if(new_dim[i] < 0)
           caml_invalid_argument("Bigarray.reshape: negative dimension");
          num_elts = num_elts * new_dim[i]}
        if(num_elts != size)
         caml_invalid_argument("Bigarray.reshape: size mismatch");
        return caml_ba_create_from(data,data2,data_type,kind,layout,new_dim)}
      function compare(b,total)
       {if(layout != b.layout)return b.layout - layout;
        if(n_dims != b.num_dims)return b.num_dims - n_dims;
        for(var i=0;i < n_dims;i++)
         if(nth_dim(i) != b.nth_dim(i))return nth_dim(i) < b.nth_dim(i)?- 1:1;
        switch(kind)
         {case 0:
          case 1:
          case 10:
          case 11:
           var x,y;
           for(var i=0;i < data.length;i++)
            {x = data[i];
             y = b.data[i];
             if(x < y)return - 1;
             if(x > y)return 1;
             if(x != y)
              if(x != y)
               {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}
             if(data2)
              {x = data2[i];
               y = b.data2[i];
               if(x < y)return - 1;
               if(x > y)return 1;
               if(x != y)
                if(x != y)
                 {if(! total)return NaN;
                  if(x == x)return 1;
                  if(y == y)return - 1}}}
           break;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
          case 12:
           for(var i=0;i < data.length;i++)
            {if(data[i] < b.data[i])return - 1;
             if(data[i] > b.data[i])return 1}
           break;
          case 7:
           for(var i=0;i < data.length;i++)
            {if(data2[i] < b.data2[i])return - 1;
             if(data2[i] > b.data2[i])return 1;
             if(data[i] < b.data[i])return - 1;
             if(data[i] > b.data[i])return 1}
           break
          }
        return 0}
      return {data:data,
              data2:data2,
              data_type:data_type,
              num_dims:n_dims,
              nth_dim:nth_dim,
              kind:kind,
              layout:layout,
              size:size,
              sub:sub,
              slice:slice,
              blit:blit,
              fill:fill,
              reshape:reshape,
              get:get,
              get1:get1,
              set:set,
              set1:set1,
              compare:compare}}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_from(ta,null,0,12,0,[ta.length])}
    function bigstring_destroy_stub(v_bstr)
     {if(v_bstr.data2 != null)
       caml_invalid_argument("bigstring_destroy: unsupported kind");
      if(v_bstr.hasOwnProperty("__is_deallocated"))
       caml_invalid_argument
        ("bigstring_destroy: bigstring is already deallocated");
      var
       destroyed_data=new (v_bstr.data.__proto__.constructor)(0),
       destroyed_bigstring=
        caml_ba_create_from
         (destroyed_data,null,v_bstr.data_type,v_bstr.kind,v_bstr.layout,[0]);
      destroyed_bigstring.__is_deallocated = true;
      Object.assign(v_bstr,destroyed_bigstring);
      return 0}
    function caml_raw_backtrace_length(){return 0}
    function caml_ba_uint8_get32(ba,i0)
     {var
       b1=ba.get1(i0),
       b2=ba.get1(i0 + 1) << 8,
       b3=ba.get1(i0 + 2) << 16,
       b4=ba.get1(i0 + 3) << 24;
      return b1 | b2 | b3 | b4}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_ba_init(){return 0}
    function caml_final_release(){return 0}
    function caml_ba_get_generic(ba,index)
     {return ba.get(caml_js_from_array(index))}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_get_exception_backtrace(){return 0}
    function raw_array_cons(a,x)
     {var l=a.length,b=new Array(l + 1);
      b[0] = x;
      for(var i=1;i <= l;i++)b[i] = a[i - 1];
      return b}
    function caml_js_to_array(a){return raw_array_cons(a,0)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_format_float(fmt,x)
     {var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = x.toFixed(prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_int64_to_bytes(x)
     {return [x[3] >> 8,
              x[3] & 0xff,
              x[2] >> 16,
              x[2] >> 8 & 0xff,
              x[2] & 0xff,
              x[1] >> 16,
              x[1] >> 8 & 0xff,
              x[1] & 0xff]}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l + 7)caml_string_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_string_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l + 1)caml_string_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_string_unsafe_set(s,i + 0,b1);
      caml_string_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {return [255,
              (x[3] & 0x0000ff00)
              >>
              8
              |
              (x[3] & 0x000000ff)
              <<
              8
              |
              x[2]
              &
              0x00ff0000,
              (x[2] & 0x0000ff00)
              >>
              8
              |
              (x[2] & 0x000000ff)
              <<
              8
              |
              x[1]
              &
              0x00ff0000,
              (x[1] & 0x0000ff00) >> 8 | (x[1] & 0x000000ff) << 8]}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_string_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_string_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_gc_major(){return 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_string(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        state
        =
        tbl.lex_check[base + c] == state
         ?tbl.lex_trans[base + c]
         :tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_get_argv()
     {var g=joo_global_object,main="a.out",args=[];
      if(g.process && g.process.argv && g.process.argv.length > 1)
       {var argv=g.process.argv;
        main = argv[1];
        args = raw_array_sub(argv,2,argv.length - 2)}
      var p=caml_js_to_string(main),args2=[0,p];
      for(var i=0;i < args.length;i++)args2.push(caml_js_to_string(args[i]));
      return [0,p,args2]}
    function caml_js_to_bool(x){return + x}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    var caml_ephe_key_offset=3;
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    var caml_ba_views;
    function caml_ba_init_views()
     {if(! caml_ba_views)
       {var g=joo_global_object;
        caml_ba_views
        =
        [[g.Float32Array,
          g.Float64Array,
          g.Int8Array,
          g.Uint8Array,
          g.Int16Array,
          g.Uint16Array,
          g.Int32Array,
          g.Int32Array,
          g.Int32Array,
          g.Int32Array,
          g.Float32Array,
          g.Float64Array,
          g.Uint8Array],
         [0,0,0,0,0,0,0,1,0,0,2,2,0]]}}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_ba_uint8_set64(ba,i0,v)
     {ba.set1(i0,v[1] & 0xff);
      ba.set1(i0 + 1,v[1] >> 8 & 0xff);
      ba.set1(i0 + 2,v[1] >> 16);
      ba.set1(i0 + 3,v[2] & 0xff);
      ba.set1(i0 + 4,v[2] >> 8 & 0xff);
      ba.set1(i0 + 5,v[2] >> 16);
      ba.set1(i0 + 6,v[3] & 0xff);
      ba.set1(i0 + 7,v[3] >> 8);
      return 0}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        mem[dst + 1] = src == 0xff?curr_pos:mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        mem[dst + 1] = src == 0xff?- 1:mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_string(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        state
        =
        tbl.lex_check[base + c] == state
         ?tbl.lex_trans[base + c]
         :tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          pc_off
          =
          tbl.lex_check_code[base_code + c] == pstate
           ?tbl.lex_trans_code[base_code + c]
           :tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return [255,1,0,0x7ff0];
        return x > 0?[255,0,0,0x7ff0]:[255,0,0,0xfff0]}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return [255,r1,r2,r3]}
    var
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v)
          {var writer=new Writer(),stack=[];
           function extern_rec(v)
            {if(v instanceof Array && v[0] === (v[0] | 0))
              {if(v[0] == 255)
                {writer.write(8,0x12);
                 for(var i=0;i < 3;i++)writer.write(8,"_j\0".charCodeAt(i));
                 var b=caml_int64_to_bytes(v);
                 for(var i=0;i < 8;i++)writer.write(8,b[i]);
                 writer.size_32 += 4;
                 writer.size_64 += 3;
                 return}
               if(v[0] == 251)
                caml_failwith("output_value: abstract value (Abstract)");
               if(v[0] < 16 && v.length - 1 < 8)
                writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
               else
                writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
               writer.size_32 += v.length;
               writer.size_64 += v.length;
               if(v.length > 1)stack.push(v,1)}
             else
              if(v instanceof MlBytes)
               {var len=caml_ml_string_length(v);
                if(len < 0x20)
                 writer.write(8,0x20 + len);
                else
                 if(len < 0x100)
                  writer.write_code(8,0x09,len);
                 else
                  writer.write_code(32,0x0A,len);
                for(var i=0;i < len;i++)
                 writer.write(8,caml_string_unsafe_get(v,i));
                writer.size_32 += 1 + ((len + 4) / 4 | 0);
                writer.size_64 += 1 + ((len + 8) / 8 | 0)}
              else
               if(v != (v | 0))
                {var type_of_v=typeof v;
                 caml_failwith
                  ("output_value: abstract value (" + type_of_v + ")")}
               else
                if(v >= 0 && v < 0x40)
                 writer.write(8,0X40 + v);
                else
                 if(v >= - (1 << 7) && v < 1 << 7)
                  writer.write_code(8,0x00,v);
                 else
                  if(v >= - (1 << 15) && v < 1 << 15)
                   writer.write_code(16,0x01,v);
                  else
                   writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_channels[chanid].offset = caml_int64_to_float(pos);return 0}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function js_print_stdout(s)
     {var g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (name.toString()
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_gc_compaction(){return 0}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    var
     caml_ephe_get_key=caml_weak_get,
     caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function win_cleanup(){}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function caml_ba_dim_2(ba){return ba.nth_dim(1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function(){return caml_call_gen(f,[this,arguments])}}
    function unix_inet_addr_of_string(){return 0}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity)return caml_call_gen(f,arguments);
        var args=new Array(arity);
        for(var i=0;i < n && i < arity;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_get_current_callstack(){return [0]}
    function caml_int64_mod(x,y)
     {if(caml_int64_is_zero(y))caml_raise_zero_divide();
      var sign=x[3];
      if(x[3] & 0x8000)x = caml_int64_neg(x);
      if(y[3] & 0x8000)y = caml_int64_neg(y);
      var r=caml_int64_udivmod(x,y)[2];
      if(sign & 0x8000)r = caml_int64_neg(r);
      return r}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function win_startup(){}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_ba_set_3(ba,i0,i1,i2,v){return ba.set([i0,i1,i2],v)}
    function caml_js_instanceof(o,c){return o instanceof c}
    function caml_hash_mix_float(h,v0)
     {var
       v=caml_int64_bits_of_float(v0),
       lo=v[1] | v[2] << 24,
       hi=v[2] >>> 8 | v[3] << 16;
      h = caml_hash_mix_int(h,lo);
      h = caml_hash_mix_int(h,hi);
      return h}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_int64_shift_left(x,s)
     {s = s & 63;
      if(s == 0)return x;
      if(s < 24)
       return [255,
               x[1] << s & 0xffffff,
               (x[2] << s | x[1] >> 24 - s) & 0xffffff,
               (x[3] << s | x[2] >> 24 - s) & 0xffff];
      if(s < 48)
       return [255,
               0,
               x[1] << s - 24 & 0xffffff,
               (x[2] << s - 24 | x[1] >> 48 - s) & 0xffff];
      return [255,0,0,x[1] << s - 48 & 0xffff]}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {return caml_call_gen(f,raw_array_cons(arguments,this))}}
    function caml_sys_const_int_size(){return 32}
    var caml_blit_bigstring_to_string=bigstring_blit_bigstring_bytes_stub;
    function caml_is_js(){return 1}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_ba_dim_1(ba){return ba.nth_dim(0)}
    function caml_js_meth_call(o,f,args)
     {return o[f.toString()].apply(o,caml_js_from_array(args))}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_new_string(s)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    var JSON=joo_global_object.JSON;
    if(typeof JSON !== "object")JSON = {};
    (function()
       {"use strict";
        var
         rx_one=/^[\],:{}\s]*$/,
         rx_two=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
         rx_three=
          /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
         rx_four=/(?:^|:|,)(?:\s*\[)+/g,
         rx_escapable=
          /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
         rx_dangerous=
          /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        function f(n){return n < 10?"0" + n:n}
        function this_value(){return this.valueOf()}
        if(typeof Date.prototype.toJSON !== "function")
         {Date.prototype.toJSON
          =
          function()
           {return isFinite(this.valueOf())
                    ?this.getUTCFullYear()
                     +
                     "-"
                     +
                     f(this.getUTCMonth() + 1)
                     +
                     "-"
                     +
                     f(this.getUTCDate())
                     +
                     "T"
                     +
                     f(this.getUTCHours())
                     +
                     ":"
                     +
                     f(this.getUTCMinutes())
                     +
                     ":"
                     +
                     f(this.getUTCSeconds())
                     +
                     "Z"
                    :null};
          Boolean.prototype.toJSON = this_value;
          Number.prototype.toJSON = this_value;
          String.prototype.toJSON = this_value}
        var gap,indent,meta,rep;
        function quote(string)
         {rx_escapable.lastIndex = 0;
          return rx_escapable.test(string)
                  ?'"'
                   +
                   string.replace
                    (rx_escapable,
                     function(a)
                      {var c=meta[a];
                       return typeof c === "string"
                               ?c
                               :"\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(- 4)})
                   +
                   '"'
                  :'"' + string + '"'}
        function str(key,holder)
         {var i,k,v,length,mind=gap,partial,value=holder[key];
          if
           (value
            &&
            typeof value
            ===
            "object"
            &&
            typeof value.toJSON
            ===
            "function")
           value = value.toJSON(key);
          if(typeof rep === "function")value = rep.call(holder,key,value);
          switch(typeof value)
           {case "string":return quote(value);
            case "number":return isFinite(value)?String(value):"null";
            case "boolean":
            case "null":return String(value);
            case "object":
             if(! value)return "null";
             gap += indent;
             partial = [];
             if(Object.prototype.toString.apply(value) === "[object Array]")
              {length = value.length;
               for(i = 0;i < length;i += 1)
                partial[i] = str(i,value) || "null";
               v
               =
               partial.length === 0
                ?"[]"
                :gap
                  ?"[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                  :"[" + partial.join(",") + "]";
               gap = mind;
               return v}
             if(rep && typeof rep === "object")
              {length = rep.length;
               for(i = 0;i < length;i += 1)
                if(typeof rep[i] === "string")
                 {k = rep[i];
                  v = str(k,value);
                  if(v)partial.push(quote(k) + (gap?": ":":") + v)}}
             else
              for(k in value)
               if(Object.prototype.hasOwnProperty.call(value,k))
                {v = str(k,value);
                 if(v)partial.push(quote(k) + (gap?": ":":") + v)}
             v
             =
             partial.length === 0
              ?"{}"
              :gap
                ?"{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                :"{" + partial.join(",") + "}";
             gap = mind;
             return v
            }}
        if(typeof JSON.stringify !== "function")
         {meta
          =
          {"\b":"\\b",
           "\t":"\\t",
           "\n":"\\n",
           "\f":"\\f",
           "\r":"\\r",
           '"':'\\"',
           "\\":"\\\\"};
          JSON.stringify
          =
          function(value,replacer,space)
           {var i;
            gap = "";
            indent = "";
            if(typeof space === "number")
             for(i = 0;i < space;i += 1)indent += " ";
            else
             if(typeof space === "string")indent = space;
            rep = replacer;
            if
             (replacer
              &&
              typeof replacer
              !==
              "function"
              &&
              (typeof replacer
               !==
               "object"
               ||
               typeof replacer.length
               !==
               "number"))
             throw new Error("JSON.stringify");
            return str("",{"":value})}}
        if(typeof JSON.parse !== "function")
         JSON.parse
         =
         function(text,reviver)
          {var j;
           function walk(holder,key)
            {var k,v,value=holder[key];
             if(value && typeof value === "object")
              for(k in value)
               if(Object.prototype.hasOwnProperty.call(value,k))
                {v = walk(value,k);
                 if(v !== undefined)value[k] = v;else delete value[k]}
             return reviver.call(holder,key,value)}
           text = String(text);
           rx_dangerous.lastIndex = 0;
           if(rx_dangerous.test(text))
            text
            =
            text.replace
             (rx_dangerous,
              function(a)
               {return "\\u"
                       +
                       ("0000" + a.charCodeAt(0).toString(16)).slice(- 4)});
           if
            (rx_one.test
              (text.replace(rx_two,"@").replace(rx_three,"]").replace
                (rx_four,"")))
            {j = eval("(" + text + ")");
             return typeof reviver === "function"?walk({"":j},""):j}
           throw new SyntaxError("JSON.parse")}}
      ());
    function caml_json(){return JSON}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l + 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= s.l + 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_ml_pos_out(chanid){return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_string_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++){var p=a[i];o[p[1].toString()] = p[2]}
      return o}
    function caml_runtime_parameters(_unit){return caml_new_string("")}
    function caml_ba_create(kind,layout,dims_ml)
     {caml_ba_init_views();
      var
       dims=caml_js_from_array(dims_ml),
       size=caml_ba_get_size(dims),
       view=caml_ba_views[0][kind];
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size),data_type=caml_ba_views[1][kind],data2=null;
      if(data_type != 0)data2 = new view(size);
      return caml_ba_create_from(data,data2,data_type,kind,layout,dims)}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_sys_getcwd(){return caml_new_string(caml_current_dir)}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= s.l + 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_sys_const_big_endian(){return 0}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value_to_string(v,_fl)
     {return caml_string_of_array(caml_output_val(v))}
    function caml_output_value(chanid,v,_flags)
     {var s=caml_output_value_to_string(v);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_sys_system_command(cmd)
     {var cmd=cmd.toString();
      joo_global_object.console.log(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try {require("child_process").execSync(cmd);return 0}catch(e){return 1}
      else
       return 127}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get([i0,i1,i2])}
    var caml_ephe_blit_key=caml_weak_blit;
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_bytes_of_string(s){return s}
    function caml_hash_mix_int64(h,v)
     {var lo=v[1] | v[2] << 24,hi=v[2] >>> 8 | v[3] << 16;
      h = caml_hash_mix_int(h,lo);
      h = caml_hash_mix_int(h,hi);
      return h}
    function caml_hash_mix_string(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_string_str(h,v.c);break;
        case 2:h = caml_hash_mix_string_arr(h,v.c)
        }
      return h}
    var HASH_QUEUE_SIZE=256;
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > HASH_QUEUE_SIZE)sz = HASH_QUEUE_SIZE;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v instanceof Array && v[0] === (v[0] | 0))
         switch(v[0])
          {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
           case 250:queue[--rd] = v[1];break;
           case 255:h = caml_hash_mix_int64(h,v);num--;break;
           default:
            var tag=v.length - 1 << 10 | v[0];
            h = caml_hash_mix_int(h,tag);
            for(i = 1,len = v.length;i < len;i++)
             {if(wr >= sz)break;queue[wr++] = v[i]}
            break}
        else
         if(v instanceof MlBytes)
          {h = caml_hash_mix_string(h,v);num--}
         else
          if(v === (v | 0))
           {h = caml_hash_mix_int(h,v + v + 1);num--}
          else
           if(v === + v)
            {h = caml_hash_mix_float(h,v);num--}
           else
            if(v && v.hash && typeof v.hash === "function")
             h = caml_hash_mix_int(h,v.hash())}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function bigstring_memcmp_stub(v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     {for(var i=0;i < v_len;i++)
       {var
         a=caml_ba_get_1(v_s1,v_s1_pos + i),
         b=caml_ba_get_1(v_s2,v_s2_pos + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_obj_tag(x)
     {return x instanceof Array?x[0]:x instanceof MlBytes?252:1000}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=jsoo_floor_log2(x) + 1;
      x *= Math.pow(2,- exp);
      if(x < 0.5){x *= 2;exp -= 1}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l + 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function bigstring_blit_bytes_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     {for(var i=0;i < v_len;i++)
       caml_ba_set_1(v_bstr,v_dst_pos + i,caml_bytes_get(v_str,v_src_pos + i));
      return 0}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_ba_set_generic(ba,index,v)
     {return ba.set(caml_js_from_array(index),v)}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_ml_pos_out_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= s.l + 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_string_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      bits = x < y == x > 0?caml_int64_add(bits,one):caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y)
     {return [255,x[1] & y[1],x[2] & y[2],x[3] & y[3]]}
    function caml_sys_const_word_size(){return 32}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var dims=[];
      for(var i=0;i < ba.num_dims;i++)dims[i] = ba.nth_dim(i);
      return caml_ba_create_from
              (ba.data,ba.data2,ba.data_type,ba.kind,layout,dims)}
    function caml_input_value_from_bytes(s,ofs)
     {var reader=new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")return caml_new_string("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function bigstring_alloc(_,size){return caml_ba_create(12,0,[0,size])}
    function caml_js_from_string(s){return s.toString()}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_ba_sub(ba,ofs,len){return ba.sub(ofs,len)}
    function caml_gc_full_major(){return 0}
    function caml_int64_is_minus_one(x)
     {return x[3] == 0xffff && (x[1] & x[2]) == 0xffffff}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l + 3)caml_string_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_string_unsafe_set(s,i + 0,b1);
      caml_string_unsafe_set(s,i + 1,b2);
      caml_string_unsafe_set(s,i + 2,b3);
      caml_string_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_runtime_variant(_unit){return caml_new_string("")}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_ba_uint8_set32(ba,i0,v)
     {ba.set1(i0,v & 0xff);
      ba.set1(i0 + 1,v >>> 8 & 0xff);
      ba.set1(i0 + 2,v >>> 16 & 0xff);
      ba.set1(i0 + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_channels[chanid].offset = pos;return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function(){f.apply(null,raw_array_cons(arguments,this))}}
    function caml_ba_dim_3(ba){return ba.nth_dim(2)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l + 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_int64_or(x,y)
     {return [255,x[1] | y[1],x[2] | y[2],x[3] | y[3]]}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_lazy_make_forward(v){return [250,v]}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_ba_layout(ba){return ba.layout}
    var
     caml_md5_string=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(buf,0,len)}
    function caml_int64_shift_right(x,s)
     {s = s & 63;
      if(s == 0)return x;
      var h=x[3] << 16 >> 16;
      if(s < 24)
       return [255,
               (x[1] >> s | x[2] << 24 - s) & 0xffffff,
               (x[2] >> s | h << 24 - s) & 0xffffff,
               x[3] << 16 >> s >>> 16];
      var sign=x[3] << 16 >> 31;
      if(s < 48)
       return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 0xffffff,
               x[3] << 16 >> s - 24 >> 16 & 0xffffff,
               sign & 0xffff];
      return [255,
              x[3] << 16 >> s - 32 & 0xffffff,
              sign & 0xffffff,
              sign & 0xffff]}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape)
        {case 0:real.fun = x;break;case 1:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_string_of_bytes(s){return s}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_int64_is_min_int(x)
     {return x[3] == 0x8000 && (x[1] | x[2]) == 0}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_js_to_string("nan");
        return caml_js_to_string(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_js_to_string
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation");
      return eval(s.toString())}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity)return caml_call_gen(f,raw_array_cons(arguments,this));
        var args=new Array(arity + 1);
        args[0] = this;
        for(var i=1;i < n && i <= arity;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_ba_fill(ba,init){ba.fill(init);return 0}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_output_value_to_bytes(v,_fl)
     {return caml_string_of_array(caml_output_val(v))}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           case 255:
            count--;
            hash_accu = hash_accu * 65599 + obj[1] + (obj[2] << 24) | 0;
            break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(obj instanceof MlBytes)
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=obj.l,i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(obj === (obj | 0))
           {count--;hash_accu = hash_accu * 65599 + obj | 0}
          else
           if(obj === + obj)
            {count--;
             var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
             for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
           else
            if(obj && obj.hash && typeof obj.hash === "function")
             hash_accu = hash_accu * 65599 + obj.hash() | 0}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          state
          =
          n1
           !=
           0
           &&
           n2
           >=
           0
           &&
           n2
           <=
           tables[tbl_tablesize]
           &&
           tables.check[n2]
           ==
           state1
           ?tables.table[n2]
           :tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function raw_array_copy(a)
     {var l=a.length,b=new Array(l);
      for(var i=0;i < l;i++)b[i] = a[i];
      return b}
    function caml_output_value_to_buffer(s,ofs,len,v,_fl)
     {var t=caml_output_val(v);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation");
      return eval(s.toString())}
    function caml_blit_string(s1,i1,s2,i2,len)
     {return caml_blit_bytes(s1,i1,s2,i2,len)}
    function bigstring_blit_stub(s1,i1,s2,i2,len)
     {for(var i=0;i < len;i++)
       caml_ba_set_1(s2,i2 + i,caml_ba_get_1(s1,i1 + i));
      return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_int64_xor(x,y)
     {return [255,x[1] ^ y[1],x[2] ^ y[2],x[3] ^ y[3]]}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_read_file_content(name)
     {var root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return buf}
      caml_raise_no_such_file(name)}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_js_to_float(x){return x}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_ba_dim(ba,dim){return ba.nth_dim(dim)}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     bigstring_find:bigstring_find,
     bigstring_memcmp_stub:bigstring_memcmp_stub,
     bigstring_blit_stub:bigstring_blit_stub,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     bigstring_blit_bytes_bigstring_stub:bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_string_bigstring_stub:bigstring_blit_string_bigstring_stub,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     bigstring_blit_bigstring_string_stub:bigstring_blit_bigstring_string_stub,
     bigstring_blit_bigstring_bytes_stub:bigstring_blit_bigstring_bytes_stub,
     bigstring_destroy_stub:bigstring_destroy_stub,
     bigstring_alloc:bigstring_alloc,
     caml_json:caml_json,
     JSON:JSON,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_from_string:caml_js_from_string,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_is_js:caml_is_js,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_sys_exit:caml_sys_exit,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_get_public_method:caml_get_public_method,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_time:caml_sys_time,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_string_arr:caml_hash_mix_string_arr,
     caml_hash_mix_string_str:caml_hash_mix_string_str,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_format_float:caml_format_float,
     caml_format_int:caml_format_int,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_is_printable:caml_is_printable,
     caml_float_of_string:caml_float_of_string,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_failwith:caml_failwith,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     raw_array_append_one:raw_array_append_one,
     raw_array_cons:raw_array_cons,
     raw_array_copy:raw_array_copy,
     raw_array_sub:raw_array_sub,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_fill:caml_ba_fill,
     caml_ba_blit:caml_ba_blit,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_views:caml_ba_views,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init_views:caml_ba_init_views,
     caml_ba_init:caml_ba_init,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlBytesReader:MlBytesReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_udivmod:caml_int64_udivmod,
     caml_int64_lsr1:caml_int64_lsr1,
     caml_int64_lsl1:caml_int64_lsl1,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_minus_one:caml_int64_is_minus_one,
     caml_int64_is_min_int:caml_int64_is_min_int,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     caml_int64_ucompare:caml_int64_ucompare,
     caml_int64_offset:caml_int64_offset,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_ml_string_length:caml_ml_string_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_lessthan:caml_string_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_string_lessequal:caml_string_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_equal:caml_string_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_string_compare:caml_string_compare,
     caml_string_of_array:caml_string_of_array,
     caml_new_string:caml_new_string,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_js_to_string:caml_js_to_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_array_of_string:caml_array_of_string,
     caml_convert_string_to_array:caml_convert_string_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_string_bound_error:caml_string_bound_error,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_to_js_string:caml_to_js_string,
     caml_is_ascii:caml_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_string:caml_subarray_to_string,
     caml_str_repeat:caml_str_repeat};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_new_string("Out_of_memory"),0],"Out_of_memory");
    caml_register_global(1,[248,caml_new_string("Sys_error"),-1],"Sys_error");
    caml_register_global(2,[248,caml_new_string("Failure"),-2],"Failure");
    caml_register_global
     (3,[248,caml_new_string("Invalid_argument"),-3],"Invalid_argument");
    caml_register_global
     (4,[248,caml_new_string("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,[248,caml_new_string("Division_by_zero"),-5],"Division_by_zero");
    caml_register_global(6,[248,caml_new_string("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_new_string("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_new_string("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_new_string("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_new_string("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_new_string("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 "../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtrace=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_set_tag=runtime.caml_obj_set_tag,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_obj_truncate=runtime.caml_obj_truncate,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_native_code=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_new_string("%,"),
     cst_really_input=caml_new_string("really_input"),
     cst_input=caml_new_string("input"),
     cst_output_substring=caml_new_string("output_substring"),
     cst_output=caml_new_string("output"),
     cst_12g=caml_new_string("%.12g"),
     cst=caml_new_string("."),
     cst_false$1=caml_new_string("false"),
     cst_true$1=caml_new_string("true"),
     cst_false$0=caml_new_string("false"),
     cst_true$0=caml_new_string("true"),
     cst_bool_of_string=caml_new_string("bool_of_string"),
     cst_true=caml_new_string("true"),
     cst_false=caml_new_string("false"),
     cst_char_of_int=caml_new_string("char_of_int"),
     cst_Stdlib_Exit=caml_new_string("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=caml_new_string("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_new_string("option is None"),
     cst_result_is_Ok=caml_new_string("result is Ok _"),
     cst_result_is_Error=caml_new_string("result is Error _"),
     cst_true$2=caml_new_string("true"),
     cst_false$2=caml_new_string("false"),
     cst$1=caml_new_string("\\\\"),
     cst$2=caml_new_string("\\'"),
     cst_b=caml_new_string("\\b"),
     cst_t=caml_new_string("\\t"),
     cst_n=caml_new_string("\\n"),
     cst_r=caml_new_string("\\r"),
     cst_Char_chr=caml_new_string("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_new_string(" is not a latin1 character"),
     cst_04X=caml_new_string("%04X"),
     cst_U=caml_new_string("U+"),
     cst_is_not_an_Unicode_scalar_value=
      caml_new_string(" is not an Unicode scalar value"),
     cst_X=caml_new_string("%X"),
     err_no_pred=caml_new_string("U+0000 has no predecessor"),
     err_no_succ=caml_new_string("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_new_string("Stdlib.Sys.Break"),
     ocaml_version=caml_new_string("4.08.1"),
     cst_List_map2=caml_new_string("List.map2"),
     cst_List_iter2=caml_new_string("List.iter2"),
     cst_List_fold_left2=caml_new_string("List.fold_left2"),
     cst_List_fold_right2=caml_new_string("List.fold_right2"),
     cst_List_for_all2=caml_new_string("List.for_all2"),
     cst_List_exists2=caml_new_string("List.exists2"),
     cst_List_combine=caml_new_string("List.combine"),
     cst_List_rev_map2=caml_new_string("List.rev_map2"),
     cst_List_init=caml_new_string("List.init"),
     cst_List_nth$0=caml_new_string("List.nth"),
     cst_nth=caml_new_string("nth"),
     cst_List_nth=caml_new_string("List.nth"),
     cst_tl=caml_new_string("tl"),
     cst_hd=caml_new_string("hd"),
     cst_Bytes_of_seq_cannot_grow_bytes=
      caml_new_string("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Bytes_rcontains_from=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_new_string("Bytes.concat"),
     cst_String_blit_Bytes_blit_string=
      caml_new_string("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_new_string("Bytes.blit"),
     cst_String_fill_Bytes_fill=caml_new_string("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_new_string("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_new_string("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Bytes_rcontains_from$0=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from$0=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt$0=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from$0=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt$0=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from$0=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_String_concat=caml_new_string("String.concat"),
     cst$5=caml_new_string("()"),
     cst_Marshal_from_bytes=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_new_string("Marshal.data_size"),
     cst_Marshal_to_buffer_substring_out_of_bounds=
      caml_new_string("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=caml_new_string("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=caml_new_string("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=caml_new_string("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_new_string("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_new_string("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_new_string("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_new_string("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_new_string("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_new_string("Obj.extension_constructor"),
     cst_Array_map2_arrays_must_have_the_same_length=
      caml_new_string("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_have_the_same_length=
      caml_new_string("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_new_string("Array.blit"),
     cst_Array_fill=caml_new_string("Array.fill"),
     cst_Array_sub=caml_new_string("Array.sub"),
     cst_Array_init=caml_new_string("Array.init"),
     cst_Stdlib_Array_Bottom=caml_new_string("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_must_have_the_same_length=
      caml_new_string("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_must_have_the_same_length=
      caml_new_string("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_new_string("Float.array.blit"),
     cst_Float_array_blit$0=caml_new_string("Float.array.blit"),
     cst_Float_Array_fill=caml_new_string("Float.Array.fill"),
     cst_Float_Array_sub=caml_new_string("Float.Array.sub"),
     cst_Float_Array_concat=caml_new_string("Float.Array.concat"),
     cst_Float_Array_init=caml_new_string("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_new_string("Stdlib.Float.Array.Bottom"),
     cst_d=caml_new_string("%d"),
     cst_d$0=caml_new_string("%d"),
     zero$2=[255,0,0,0],
     one$2=[255,1,0,0],
     minus_one$2=[255,16777215,16777215,65535],
     min_int$2=[255,0,0,32768],
     max_int$2=[255,16777215,16777215,32767],
     cst_d$1=caml_new_string("%d"),
     cst_Lexing_lex_refill_cannot_grow_buffer=
      caml_new_string("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_new_string(""),0,0,-1],
     zero_pos=[0,caml_new_string(""),1,0,0],
     cst_syntax_error=caml_new_string("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_new_string("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_new_string("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_new_string("Set.remove_min_elt"),
     cst_Set_bal=caml_new_string("Set.bal"),
     cst_Set_bal$0=caml_new_string("Set.bal"),
     cst_Set_bal$1=caml_new_string("Set.bal"),
     cst_Set_bal$2=caml_new_string("Set.bal"),
     cst_Map_remove_min_elt=caml_new_string("Map.remove_min_elt"),
     cst_Map_bal=caml_new_string("Map.bal"),
     cst_Map_bal$0=caml_new_string("Map.bal"),
     cst_Map_bal$1=caml_new_string("Map.bal"),
     cst_Map_bal$2=caml_new_string("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_new_string("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_new_string("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_new_string("CamlinternalLazy.Undefined"),
     cst_count=caml_new_string("{count = "),
     cst_data=caml_new_string("; data = "),
     cst$6=caml_new_string("}"),
     cst_Sempty=caml_new_string("Sempty"),
     cst_Scons=caml_new_string("Scons ("),
     cst$7=caml_new_string(", "),
     cst$8=caml_new_string(")"),
     cst_Sapp=caml_new_string("Sapp ("),
     cst$9=caml_new_string(", "),
     cst$10=caml_new_string(")"),
     cst_Slazy=caml_new_string("Slazy"),
     cst_Sgen=caml_new_string("Sgen"),
     cst_Sbuffio=caml_new_string("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_new_string("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_new_string("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_new_string("Buffer.truncate"),
     cst_Buffer_add_channel=caml_new_string("Buffer.add_channel"),
     cst_Buffer_add_substring_add_subbytes=
      caml_new_string("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buffer=
      caml_new_string("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_new_string("Buffer.nth"),
     cst_Buffer_blit=caml_new_string("Buffer.blit"),
     cst_Buffer_sub=caml_new_string("Buffer.sub"),
     cst_c=caml_new_string("%c"),
     cst_s=caml_new_string("%s"),
     cst_i=caml_new_string("%i"),
     cst_li=caml_new_string("%li"),
     cst_ni=caml_new_string("%ni"),
     cst_Li=caml_new_string("%Li"),
     cst_f=caml_new_string("%f"),
     cst_B=caml_new_string("%B"),
     cst$21=caml_new_string("%{"),
     cst$22=caml_new_string("%}"),
     cst$23=caml_new_string("%("),
     cst$24=caml_new_string("%)"),
     cst_a=caml_new_string("%a"),
     cst_t$0=caml_new_string("%t"),
     cst$25=caml_new_string("%?"),
     cst_r$0=caml_new_string("%r"),
     cst_r$1=caml_new_string("%_r"),
     cst_u$0=caml_new_string("%u"),
     cst_Printf_bad_conversion=caml_new_string("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=caml_new_string("Printf: bad conversion %_"),
     cst$29=caml_new_string("@{"),
     cst$30=caml_new_string("@["),
     cst$31=caml_new_string("@{"),
     cst$32=caml_new_string("@["),
     cst$33=caml_new_string("@{"),
     cst$34=caml_new_string("@["),
     cst_0=caml_new_string("0"),
     cst_padding=caml_new_string("padding"),
     cst_precision=caml_new_string("precision"),
     cst$39=caml_new_string("'*'"),
     cst$37=caml_new_string("'-'"),
     cst_0$2=caml_new_string("'0'"),
     cst$38=caml_new_string("'*'"),
     cst_0$0=caml_new_string("0"),
     cst_0$1=caml_new_string("0"),
     cst_precision$0=caml_new_string("precision"),
     cst_precision$1=caml_new_string("precision"),
     cst$40=caml_new_string("'+'"),
     cst$41=caml_new_string("'#'"),
     cst$42=caml_new_string("' '"),
     cst_padding$0=caml_new_string("`padding'"),
     cst_precision$2=caml_new_string("`precision'"),
     cst$43=caml_new_string("'+'"),
     cst$44=caml_new_string("'_'"),
     sub_format=[0,0,caml_new_string("")],
     formatting_lit=[0,caml_new_string("@;"),1,0],
     cst_digit=caml_new_string("digit"),
     cst_character=caml_new_string("character ')'"),
     cst_character$0=caml_new_string("character '}'"),
     cst$48=caml_new_string("'#'"),
     cst$47=caml_new_string("'+'"),
     cst$46=caml_new_string("'+'"),
     cst$45=caml_new_string("' '"),
     cst$51=caml_new_string("'+'"),
     cst$50=caml_new_string("'+'"),
     cst$49=caml_new_string("' '"),
     cst_non_zero_widths_are_unsupported_for_c_conversions=
      caml_new_string("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=caml_new_string("unexpected end of format"),
     cst$35=caml_new_string(""),
     cst$36=caml_new_string(""),
     cst_b$0=caml_new_string("b"),
     cst_h=caml_new_string("h"),
     cst_hov=caml_new_string("hov"),
     cst_hv=caml_new_string("hv"),
     cst_v=caml_new_string("v"),
     cst_nan=caml_new_string("nan"),
     cst$28=caml_new_string("."),
     cst_neg_infinity=caml_new_string("neg_infinity"),
     cst_infinity=caml_new_string("infinity"),
     cst_12g$0=caml_new_string("%.12g"),
     cst_nd$0=caml_new_string("%+nd"),
     cst_nd$1=caml_new_string("% nd"),
     cst_ni$1=caml_new_string("%+ni"),
     cst_ni$2=caml_new_string("% ni"),
     cst_nx=caml_new_string("%nx"),
     cst_nx$0=caml_new_string("%#nx"),
     cst_nX=caml_new_string("%nX"),
     cst_nX$0=caml_new_string("%#nX"),
     cst_no=caml_new_string("%no"),
     cst_no$0=caml_new_string("%#no"),
     cst_nd=caml_new_string("%nd"),
     cst_ni$0=caml_new_string("%ni"),
     cst_nu=caml_new_string("%nu"),
     cst_ld$0=caml_new_string("%+ld"),
     cst_ld$1=caml_new_string("% ld"),
     cst_li$1=caml_new_string("%+li"),
     cst_li$2=caml_new_string("% li"),
     cst_lx=caml_new_string("%lx"),
     cst_lx$0=caml_new_string("%#lx"),
     cst_lX=caml_new_string("%lX"),
     cst_lX$0=caml_new_string("%#lX"),
     cst_lo=caml_new_string("%lo"),
     cst_lo$0=caml_new_string("%#lo"),
     cst_ld=caml_new_string("%ld"),
     cst_li$0=caml_new_string("%li"),
     cst_lu=caml_new_string("%lu"),
     cst_Ld$0=caml_new_string("%+Ld"),
     cst_Ld$1=caml_new_string("% Ld"),
     cst_Li$1=caml_new_string("%+Li"),
     cst_Li$2=caml_new_string("% Li"),
     cst_Lx=caml_new_string("%Lx"),
     cst_Lx$0=caml_new_string("%#Lx"),
     cst_LX=caml_new_string("%LX"),
     cst_LX$0=caml_new_string("%#LX"),
     cst_Lo=caml_new_string("%Lo"),
     cst_Lo$0=caml_new_string("%#Lo"),
     cst_Ld=caml_new_string("%Ld"),
     cst_Li$0=caml_new_string("%Li"),
     cst_Lu=caml_new_string("%Lu"),
     cst_d$3=caml_new_string("%+d"),
     cst_d$4=caml_new_string("% d"),
     cst_i$1=caml_new_string("%+i"),
     cst_i$2=caml_new_string("% i"),
     cst_x=caml_new_string("%x"),
     cst_x$0=caml_new_string("%#x"),
     cst_X$0=caml_new_string("%X"),
     cst_X$1=caml_new_string("%#X"),
     cst_o=caml_new_string("%o"),
     cst_o$0=caml_new_string("%#o"),
     cst_d$2=caml_new_string("%d"),
     cst_i$0=caml_new_string("%i"),
     cst_u=caml_new_string("%u"),
     cst$26=caml_new_string("%!"),
     cst$27=caml_new_string("@{"),
     cst_0c=caml_new_string("0c"),
     cst$20=caml_new_string("%%"),
     cst$12=caml_new_string("@]"),
     cst$13=caml_new_string("@}"),
     cst$14=caml_new_string("@?"),
     cst$15=caml_new_string("@\n"),
     cst$16=caml_new_string("@."),
     cst$17=caml_new_string("@@"),
     cst$18=caml_new_string("@%"),
     cst$19=caml_new_string("@"),
     cst$11=caml_new_string(".*"),
     cst_CamlinternalFormat_Type_mismatch=
      caml_new_string("CamlinternalFormat.Type_mismatch"),
     cst$59=caml_new_string(""),
     cst$60=caml_new_string("\n"),
     cst_a_boolean=caml_new_string("a boolean"),
     cst_an_integer=caml_new_string("an integer"),
     cst_an_integer$0=caml_new_string("an integer"),
     cst_a_float=caml_new_string("a float"),
     cst_a_float$0=caml_new_string("a float"),
     cst$56=caml_new_string(""),
     cst$57=caml_new_string(" "),
     cst$58=caml_new_string(""),
     cst_one_of=caml_new_string("one of: "),
     cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic=
      caml_new_string
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_new_string("no argument"),
     cst$55=caml_new_string("(?)"),
     cst_help$3=caml_new_string("--help"),
     cst_help$4=caml_new_string("-help"),
     cst_help$2=caml_new_string("-help"),
     cst_Display_this_list_of_options=
      caml_new_string(" Display this list of options"),
     cst_help=caml_new_string("-help"),
     cst_help$1=caml_new_string("--help"),
     cst_Display_this_list_of_options$0=
      caml_new_string(" Display this list of options"),
     cst_help$0=caml_new_string("--help"),
     cst$52=caml_new_string("}"),
     cst$53=caml_new_string("|"),
     cst$54=caml_new_string("{"),
     cst_none=caml_new_string("<none>"),
     cst_Stdlib_Arg_Bad=caml_new_string("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_new_string("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_new_string("Stdlib.Arg.Stop"),
     cst$62=caml_new_string(""),
     cst_Program_not_linked_with_g_cannot_print_stack_backtrace=
      caml_new_string
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_new_string("Raised at"),
     cst_Re_raised_at=caml_new_string("Re-raised at"),
     cst_Raised_by_primitive_operation_at=
      caml_new_string("Raised by primitive operation at"),
     cst_Called_from=caml_new_string("Called from"),
     cst_inlined=caml_new_string(" (inlined)"),
     cst$65=caml_new_string(""),
     partial=[4,0,0,0,0],
     cst_Out_of_memory=caml_new_string("Out of memory"),
     cst_Stack_overflow=caml_new_string("Stack overflow"),
     cst_Pattern_matching_failed=caml_new_string("Pattern matching failed"),
     cst_Assertion_failed=caml_new_string("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_new_string("Undefined recursive module"),
     cst$63=caml_new_string(""),
     cst$64=caml_new_string(""),
     cst$61=caml_new_string("_"),
     locfmt=
      [0,
       [11,
        caml_new_string('File "'),
        [2,
         0,
         [11,
          caml_new_string('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", characters "),
            [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(": "),[2,0,0]]]]]]]]]],
       caml_new_string('File "%s", line %d, characters %d-%d: %s')],
     cst_Stdlib_Fun_Finally_raised=
      caml_new_string("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_new_string("Digest.from_hex"),
     cst_Digest_from_hex=caml_new_string("Digest.from_hex"),
     cst_Digest_to_hex=caml_new_string("Digest.to_hex"),
     cst_Digest_substring=caml_new_string("Digest.substring"),
     cst_Random_int64=caml_new_string("Random.int64"),
     cst_Random_int32=caml_new_string("Random.int32"),
     cst_Random_int=caml_new_string("Random.int"),
     cst_x$1=caml_new_string("x"),
     cst_OCAMLRUNPARAM=caml_new_string("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_new_string("CAMLRUNPARAM"),
     cst$66=caml_new_string(""),
     cst_Weak_Make_hash_bucket_cannot_grow_more=
      caml_new_string("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_new_string("Weak.fill"),
     cst_Weak_blit=caml_new_string("Weak.blit"),
     cst_Weak_check=caml_new_string("Weak.check"),
     cst_Weak_get_copy=caml_new_string("Weak.get_copy"),
     cst_Weak_get=caml_new_string("Weak.get"),
     cst_Weak_set=caml_new_string("Weak.set"),
     cst_Weak_create=caml_new_string("Weak.create"),
     cst$84=caml_new_string(""),
     cst$85=caml_new_string(""),
     cst$83=caml_new_string("."),
     cst$80=caml_new_string(">"),
     cst$81=caml_new_string("</"),
     cst$82=caml_new_string(""),
     cst$77=caml_new_string(">"),
     cst$78=caml_new_string("<"),
     cst$79=caml_new_string(""),
     cst$76=caml_new_string("\n"),
     cst_Format_pp_set_geometry_max_indent_2=
      caml_new_string("Format.pp_set_geometry: max_indent < 2"),
     cst_Format_pp_set_geometry_margin_max_indent=
      caml_new_string("Format.pp_set_geometry: margin <= max_indent"),
     cst$72=caml_new_string(""),
     cst$73=caml_new_string(""),
     cst$74=caml_new_string(""),
     cst$75=caml_new_string(""),
     cst$68=caml_new_string(""),
     cst$69=caml_new_string(""),
     cst$70=caml_new_string(""),
     cst$71=caml_new_string(""),
     cst$67=caml_new_string(""),
     cst_Stdlib_Format_String_tag=caml_new_string("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=caml_new_string("end of input not found"),
     cst_scanf_bad_conversion_a=caml_new_string('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=caml_new_string('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_new_string("scanf: missing reader"),
     cst_scanf_bad_conversion_custom_converter=
      caml_new_string('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=caml_new_string('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=caml_new_string('scanf: bad conversion "%*"'),
     cst$91=caml_new_string('"'),
     cst$92=caml_new_string('"'),
     cst$89=caml_new_string('"'),
     cst$90=caml_new_string('"'),
     cst$88=caml_new_string('"'),
     cst_in_format=caml_new_string(' in format "'),
     cst_an=caml_new_string("an"),
     cst_x$2=caml_new_string("x"),
     cst_nfinity=caml_new_string("nfinity"),
     cst_digits=caml_new_string("digits"),
     cst_decimal_digits=caml_new_string("decimal digits"),
     cst_0b=caml_new_string("0b"),
     cst_0o=caml_new_string("0o"),
     cst_0u=caml_new_string("0u"),
     cst_0x=caml_new_string("0x"),
     cst_false$3=caml_new_string("false"),
     cst_true$3=caml_new_string("true"),
     cst_not_a_valid_float_in_hexadecimal_notation=
      caml_new_string("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_found_in_float_token=
      caml_new_string("no dot or exponent part found in float token"),
     cst$87=caml_new_string("-"),
     cst_unnamed_function=caml_new_string("unnamed function"),
     cst_unnamed_character_string=caml_new_string("unnamed character string"),
     cst_unnamed_Stdlib_input_channel=
      caml_new_string("unnamed Stdlib input channel"),
     cst$86=caml_new_string("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_new_string("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_new_string("binary"),
     cst_octal=caml_new_string("octal"),
     cst_hexadecimal=caml_new_string("hexadecimal"),
     cst_a_Char=caml_new_string("a Char"),
     cst_a_String=caml_new_string("a String"),
     cst$93=caml_new_string(""),
     cst$94=caml_new_string(""),
     cst$95=caml_new_string(""),
     cst$96=caml_new_string(""),
     cst$97=caml_new_string(""),
     cst$99=caml_new_string(""),
     cst$98=caml_new_string(""),
     cst_Illegal_character=caml_new_string("Illegal character "),
     cst_Filename_chop_extension=caml_new_string("Filename.chop_extension"),
     cst$110=caml_new_string(""),
     cst_Filename_chop_suffix=caml_new_string("Filename.chop_suffix"),
     cst$109=caml_new_string(""),
     cst$107=caml_new_string("./"),
     cst$106=caml_new_string(".\\"),
     cst$105=caml_new_string("../"),
     cst$104=caml_new_string("..\\"),
     cst$103=caml_new_string("./"),
     cst$102=caml_new_string("../"),
     cst$101=caml_new_string(""),
     cst$100=caml_new_string(""),
     current_dir_name=caml_new_string("."),
     parent_dir_name=caml_new_string(".."),
     dir_sep=caml_new_string("/"),
     cst_TMPDIR=caml_new_string("TMPDIR"),
     cst_tmp=caml_new_string("/tmp"),
     quotequote=caml_new_string("'\\''"),
     current_dir_name$0=caml_new_string("."),
     parent_dir_name$0=caml_new_string(".."),
     dir_sep$0=caml_new_string("\\"),
     cst_TEMP=caml_new_string("TEMP"),
     cst$108=caml_new_string("."),
     current_dir_name$1=caml_new_string("."),
     parent_dir_name$1=caml_new_string(".."),
     dir_sep$1=caml_new_string("/"),
     cst_Cygwin=caml_new_string("Cygwin"),
     cst_Win32=caml_new_string("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Series_is_closed$0=caml_new_string("Series is closed"),
     cst_Series_is_closed=caml_new_string("Series is closed"),
     cst_Bigarray_array3_of_genarray=
      caml_new_string("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarray=
      caml_new_string("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarray=
      caml_new_string("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarray=
      caml_new_string("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_non_cubic_data=
      caml_new_string("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_non_cubic_data$0=
      caml_new_string("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_non_rectangular_data=
      caml_new_string("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _m_=[0,0,[0,6,0]],
     _l_=[0,0,[0,7,0]],
     _k_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _j_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _h_=[0,1],
     _i_=[0,0],
     _a_=[255,0,0,32752],
     _b_=[255,0,0,65520],
     _c_=[255,1,0,32752],
     _d_=[255,16777215,16777215,32751],
     _e_=[255,0,0,16],
     _f_=[255,0,0,15536],
     _s_=[0,0,0],
     _t_=[0,caml_new_string("list.ml"),282,11],
     _y_=[0,caml_new_string("array.ml"),236,4],
     _A_=[0,caml_new_string("float.ml"),381,6],
     _z_=[0,caml_new_string("float.ml"),208,14],
     _L_=[255,16777215,16777215,65535],
     _K_=[255,0,0,0],
     _J_=[255,1,0,0],
     _I_=[255,1,0,0],
     _M_=[0,0,0,0],
     _N_=[0,0,0],
     _O_=[0,caml_new_string("set.ml"),547,18],
     _P_=[0,0,0,0],
     _Q_=[0,caml_new_string("map.ml"),398,10],
     _R_=[0,0,0],
     _S_=[0,caml_new_string("stream.ml"),53,12],
     _T_=[0,0],
     _U_=[0,caml_new_string("stream.ml"),82,12],
     _$_=[0,caml_new_string("buffer.ml"),205,9],
     ___=[0,caml_new_string("buffer.ml"),141,19],
     _Z_=[0,caml_new_string("buffer.ml"),159,8],
     _Y_=[0,caml_new_string("buffer.ml"),120,19],
     _X_=[0,caml_new_string("buffer.ml"),138,8],
     _W_=[0,caml_new_string("buffer.ml"),84,19],
     _V_=[0,caml_new_string("buffer.ml"),117,8],
     _aa_=[0,caml_new_string("camlinternalFormat.ml"),847,23],
     _al_=[0,caml_new_string("camlinternalFormat.ml"),811,21],
     _ad_=[0,caml_new_string("camlinternalFormat.ml"),812,21],
     _am_=[0,caml_new_string("camlinternalFormat.ml"),815,21],
     _ae_=[0,caml_new_string("camlinternalFormat.ml"),816,21],
     _an_=[0,caml_new_string("camlinternalFormat.ml"),819,19],
     _af_=[0,caml_new_string("camlinternalFormat.ml"),820,19],
     _ao_=[0,caml_new_string("camlinternalFormat.ml"),823,22],
     _ag_=[0,caml_new_string("camlinternalFormat.ml"),824,22],
     _ap_=[0,caml_new_string("camlinternalFormat.ml"),828,30],
     _ah_=[0,caml_new_string("camlinternalFormat.ml"),829,30],
     _aj_=[0,caml_new_string("camlinternalFormat.ml"),833,26],
     _ab_=[0,caml_new_string("camlinternalFormat.ml"),834,26],
     _ak_=[0,caml_new_string("camlinternalFormat.ml"),843,28],
     _ac_=[0,caml_new_string("camlinternalFormat.ml"),844,28],
     _ai_=[0,caml_new_string("camlinternalFormat.ml"),848,23],
     _aq_=[0,caml_new_string("camlinternalFormat.ml"),1556,4],
     _ar_=[0,caml_new_string("camlinternalFormat.ml"),1624,39],
     _as_=[0,caml_new_string("camlinternalFormat.ml"),1647,31],
     _at_=[0,caml_new_string("camlinternalFormat.ml"),1648,31],
     _au_=[0,caml_new_string("camlinternalFormat.ml"),1828,8],
     _aY_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aX_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aA_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", duplicate flag "),[1,0]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aB_=[0,1,0],
     _aC_=[0,0],
     _aE_=[1,0],
     _aD_=[1,1],
     _aG_=[1,1],
     _aF_=[1,1],
     _aK_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", flag "),
            [1,
             [11,
              caml_new_string(" is only allowed after the '"),
              [12,
               37,
               [11,caml_new_string("', before padding and precision"),0]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aH_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_new_string
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aI_=[0,0],
     _aJ_=[0,0],
     _aL_=[0,[12,64,0]],
     _aM_=[0,caml_new_string("@ "),1,0],
     _aN_=[0,caml_new_string("@,"),0,0],
     _aO_=[2,60],
     _aP_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": '"),
          [12,
           37,
           [11,
            caml_new_string("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_new_string(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aQ_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": integer "),
          [4,
           0,
           0,
           0,
           [11,caml_new_string(" is greater than the limit "),[4,0,0,0,0]]]]]],
       caml_new_string
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aR_=[0,caml_new_string("camlinternalFormat.ml"),2843,11],
     _aS_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,[11,caml_new_string('" at character number '),[4,0,0,0,0]]]]]]],
       caml_new_string
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aT_=[0,caml_new_string("camlinternalFormat.ml"),2905,34],
     _aU_=[0,caml_new_string("camlinternalFormat.ml"),2941,28],
     _aV_=[0,caml_new_string("camlinternalFormat.ml"),2975,25],
     _aW_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,
             0,
             [11,
              caml_new_string(" is incompatible with '"),
              [0,[11,caml_new_string("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _az_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,0,[11,caml_new_string(" expected, read "),[1,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _ay_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", '"),
            [0,[11,caml_new_string("' without "),[2,0,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ax_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", "),[2,0,0]]]]]],
       caml_new_string("invalid format %S: at character number %d, %s")],
     _aw_=
      [0,
       [11,caml_new_string("invalid box description "),[3,0,0]],
       caml_new_string("invalid box description %S")],
     _av_=[0,0,4],
     _bi_=[0,[2,0,[0,0]],caml_new_string("%s%c")],
     _bc_=[0,[2,0,0],caml_new_string("%s")],
     _bd_=[0,[2,0,0],caml_new_string("%s")],
     _ba_=[0,[2,0,0],caml_new_string("%s")],
     _bb_=[0,[2,0,0],caml_new_string("%s")],
     _a__=[0,[2,0,0],caml_new_string("%s")],
     _a$_=[0,[2,0,0],caml_new_string("%s")],
     _a4_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": unknown option '"),
         [2,0,[11,caml_new_string("'.\n"),0]]]],
       caml_new_string("%s: unknown option '%s'.\n")],
     _a7_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": wrong argument '"),
         [2,
          0,
          [11,
           caml_new_string("'; option '"),
           [2,
            0,
            [11,
             caml_new_string("' expects "),
             [2,0,[11,caml_new_string(".\n"),0]]]]]]]],
       caml_new_string("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": option '"),
         [2,0,[11,caml_new_string("' needs an argument.\n"),0]]]],
       caml_new_string("%s: option '%s' needs an argument.\n")],
     _a9_=
      [0,
       [2,0,[11,caml_new_string(": "),[2,0,[11,caml_new_string(".\n"),0]]]],
       caml_new_string("%s: %s.\n")],
     _a5_=[0,caml_new_string("-help")],
     _a6_=[0,caml_new_string("--help")],
     _a3_=[0,[2,0,0],caml_new_string("%s")],
     _a2_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _a1_=[0,caml_new_string("-help")],
     _aZ_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_new_string("  %s %s\n")],
     _a0_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_new_string("  %s %s%s\n")],
     _bn_=
      [0,[11,caml_new_string(", "),[2,0,[2,0,0]]],caml_new_string(", %s%s")],
     _bw_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bu_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bv_=
      [0,
       [11,
        caml_new_string
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_new_string
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bs_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(' file "'),
         [2,
          0,
          [12,
           34,
           [2,
            0,
            [11,
             caml_new_string(", line "),
             [4,
              0,
              0,
              0,
              [11,caml_new_string(", characters "),[4,0,0,0,[12,45,partial]]]]]]]]]],
       caml_new_string('%s file "%s"%s, line %d, characters %d-%d')],
     _bt_=
      [0,
       [2,0,[11,caml_new_string(" unknown location"),0]],
       caml_new_string("%s unknown location")],
     _br_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bq_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bo_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_new_string("(%s%s)")],
     _bp_=[0,[12,40,[2,0,[12,41,0]]],caml_new_string("(%s)")],
     _bm_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bl_=[0,[3,0,0],caml_new_string("%S")],
     _bF_=
      [0,
       [11,caml_new_string("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("minor_collections: %d\n")],
     _bG_=
      [0,
       [11,caml_new_string("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("major_collections: %d\n")],
     _bH_=
      [0,
       [11,caml_new_string("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_new_string("compactions:       %d\n")],
     _bI_=[0,[12,10,0],caml_new_string("\n")],
     _bJ_=[0,[8,0,0,[0,0],0],caml_new_string("%.0f")],
     _bK_=
      [0,
       [11,caml_new_string("minor_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("minor_words:    %*.0f\n")],
     _bL_=
      [0,
       [11,caml_new_string("promoted_words: "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("promoted_words: %*.0f\n")],
     _bM_=
      [0,
       [11,caml_new_string("major_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("major_words:    %*.0f\n")],
     _bN_=[0,[12,10,0],caml_new_string("\n")],
     _bO_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bP_=
      [0,
       [11,caml_new_string("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("top_heap_words: %*d\n")],
     _bQ_=
      [0,
       [11,caml_new_string("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("heap_words:     %*d\n")],
     _bR_=
      [0,
       [11,caml_new_string("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("live_words:     %*d\n")],
     _bS_=
      [0,
       [11,caml_new_string("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("free_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_new_string("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("largest_free:   %*d\n")],
     _bU_=
      [0,
       [11,caml_new_string("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("fragments:      %*d\n")],
     _bV_=[0,[12,10,0],caml_new_string("\n")],
     _bW_=
      [0,
       [11,caml_new_string("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("live_blocks: %d\n")],
     _bX_=
      [0,
       [11,caml_new_string("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("free_blocks: %d\n")],
     _bY_=
      [0,
       [11,caml_new_string("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("heap_chunks: %d\n")],
     _b1_=[255,1,0,0],
     _b2_=[255,0,0,0],
     _b3_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _b7_=[0,0],
     _b6_=[0,caml_new_string("hashtbl.ml"),108,23],
     _b__=[3,0,3],
     _b9_=[0,caml_new_string("")],
     _b8_=[0,caml_new_string(""),0,caml_new_string("")],
     _co_=[0,91],
     _cn_=[0,123],
     _cp_=[0,caml_new_string("scanf.ml"),1455,13],
     _cq_=[0,[3,0,[10,0]],caml_new_string("%S%!")],
     _cm_=[0,37,caml_new_string("")],
     _cl_=
      [0,
       [11,
        caml_new_string("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_new_string(": "),[2,0,0]]]],
       caml_new_string("scanf: bad input at char number %i: %s")],
     _ck_=
      [0,
       [11,
        caml_new_string("the character "),
        [1,[11,caml_new_string(" cannot start a boolean"),0]]],
       caml_new_string("the character %C cannot start a boolean")],
     _cj_=
      [0,
       [11,caml_new_string("bad character hexadecimal encoding \\"),[0,[0,0]]],
       caml_new_string("bad character hexadecimal encoding \\%c%c")],
     _ci_=
      [0,
       [11,caml_new_string("bad character decimal encoding \\"),[0,[0,[0,0]]]],
       caml_new_string("bad character decimal encoding \\%c%c%c")],
     _ch_=
      [0,
       [11,
        caml_new_string("character "),
        [1,
         [11,
          caml_new_string(" is not a valid "),
          [2,0,[11,caml_new_string(" digit"),0]]]]],
       caml_new_string("character %C is not a valid %s digit")],
     _cg_=
      [0,
       [11,
        caml_new_string("character "),
        [1,[11,caml_new_string(" is not a decimal digit"),0]]],
       caml_new_string("character %C is not a decimal digit")],
     _cf_=[0,caml_new_string("scanf.ml"),555,9],
     _ce_=
      [0,
       [11,caml_new_string("invalid boolean '"),[2,0,[12,39,0]]],
       caml_new_string("invalid boolean '%s'")],
     _cd_=
      [0,
       [11,
        caml_new_string("looking for "),
        [1,[11,caml_new_string(", found "),[1,0]]]],
       caml_new_string("looking for %C, found %C")],
     _cc_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cb_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: the specified length was too short for token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: the specified length was too short for token")],
     _ca_=
      [0,
       [11,caml_new_string("illegal escape character "),[1,0]],
       caml_new_string("illegal escape character %C")],
     _cx_=[0,caml_new_string("camlinternalOO.ml"),438,17],
     _cw_=[0,caml_new_string("camlinternalOO.ml"),420,13],
     _cv_=[0,caml_new_string("camlinternalOO.ml"),417,13],
     _cu_=[0,caml_new_string("camlinternalOO.ml"),414,13],
     _ct_=[0,caml_new_string("camlinternalOO.ml"),411,13],
     _cs_=[0,caml_new_string("camlinternalOO.ml"),408,13],
     _cr_=[0,caml_new_string("camlinternalOO.ml"),281,50],
     _cA_=[0,0],
     _cz_=[0,0],
     _cy_=[0,0],
     _cE_=[0,7,0],
     _cD_=[0,1,[0,3,[0,5,0]]],
     _cC_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_new_string("%s%06x%s")],
     _cF_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (706,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function _g_(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_h_
              :_i_}
    function string_of_int(n){return caml_new_string("" + n)}
    function int_of_string_opt(s)
     {try
       {var _Ax_=[0,caml_int_of_string(s)];return _Ax_}
      catch(_Ay_)
       {_Ay_ = caml_wrap_exception(_Ay_);
        if(_Ay_[1] === Failure)return 0;
        throw _Ay_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return _g_(s,cst);
        var
         match=caml_string_get(s,i),
         switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _Av_=[0,caml_float_of_string(s)];return _Av_}
      catch(_Aw_)
       {_Aw_ = caml_wrap_exception(_Aw_);
        if(_Aw_[1] === Failure)return 0;
        throw _Aw_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_j_,438,name)}
    function open_out_bin(name){return open_out_gen(_k_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_Au_)
             {_Au_ = caml_wrap_exception(_Au_);
              if(_Au_[1] !== Sys_error)throw _Au_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(s) - len | 0) < ofs))
         return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_At_){}
      try
       {var _Ar_=caml_ml_close_channel(oc);return _Ar_}
      catch(_As_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_l_,0,name)}
    function open_in_bin(name){return open_in_gen(_m_,0,name)}
    function input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _Aq_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _Aq_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _Aq_=res}
        return caml_string_of_bytes(_Aq_)}}
    function close_in_noerr(ic)
     {try
       {var _Ao_=caml_ml_close_channel(ic);return _Ao_}
      catch(_Ap_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_new_string("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_new_string("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function _n_(param,_Am_)
     {var
       str2=_Am_[2],
       fmt2=_Am_[1],
       str1=param[2],
       fmt1=param[1],
       _An_=_g_(str1,_g_(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_An_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1],f_already_ran=[0,0];
      exit_function[1]
      =
      function(param)
       {if(1 - f_already_ran[1]){f_already_ran[1] = 1;caml_call1(f,0)}
        return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       _g_,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       _n_,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(719,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       _g_,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       _n_,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(720,Stdlib_pervasives,"Stdlib__pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _Ak_=function(_Al_){return map(f,next,_Al_)};
        return [0,caml_call1(f,x),_Ak_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Aj_){return filter_map(f,next,_Aj_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Ai_){return filter(f,next,_Ai_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Ah_=caml_call1(f,x),_Ag_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_Ah_,next,_Ag_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_Ah_,next,_Ag_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_Af_){return flat_map_app(f,next,tail,_Af_)}]}
      var _Ae_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_Ae_)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_Ae_])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    var
     Stdlib_seq=
      [0,empty,return$0,map,filter,filter_map,flat_map,fold_left,iter];
    caml_register_global(721,Stdlib_seq,"Stdlib__seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param)
     {if(param){var _Ad_=param[1];if(_Ad_)return _Ad_}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _Ac_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_Ac_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_Ab_){return return$0(v,_Ab_)}}
      return empty}
    var
     Stdlib_option=
      [0,
       none,
       some,
       value,
       get,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(722,Stdlib_option,"Stdlib__option");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$1(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$0(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$0(ok,error,r0,match)
     {if(0 === r0[0])
       {var _z$_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_z$_,v1)}}
      else
       {var _Aa_=r0[1];
        if(0 !== match[0]){var e1=match[1];return caml_call2(error,_Aa_,e1)}}
      return 0}
    function compare$0(ok,error,r0,match)
     {if(0 === r0[0])
       {var _z9_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_z9_,v1)}
        return -1}
      var _z__=r0[1];
      if(0 === match[0])return 1;
      var e1=match[1];
      return caml_call2(error,_z__,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_z8_){return return$0(v,_z8_)}}
      return empty}
    var
     Stdlib_result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$1,
       map_error,
       fold$0,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$0,
       compare$0,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(723,Stdlib_result,"Stdlib__result");
    function equal$1(_z7_,_z6_){return _z7_ === _z6_?1:0}
    var compare$1=caml_int_compare;
    function to_int(param){return 0 === param?0:1}
    function to_float(param){return 0 === param?0.:1.}
    function to_string$0(param){return 0 === param?cst_false$2:cst_true$2}
    var
     Stdlib_bool=
      [0,
       function(_z5_){return 1 - _z5_},
       equal$1,
       compare$1,
       to_int,
       to_float,
       to_string$0];
    caml_register_global(724,Stdlib_bool,"Stdlib__bool");
    function chr(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {if(40 <= c)
       {if(92 === c)return cst$1;var switch$0=127 <= c?0:1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;var switch$0=1}
       else
        if(14 <= c)
         var switch$0=0;
        else
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r;
           default:var switch$0=0}
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var switch$0=65 <= c?90 < c?0:1:0;
      if(! switch$0)
       {var switch$1=192 <= c?214 < c?0:1:0;
        if(! switch$1)
         {var switch$2=216 <= c?222 < c?1:0:1;if(switch$2)return c}}
      return c + 32 | 0}
    function uppercase(c)
     {var switch$0=97 <= c?122 < c?0:1:0;
      if(! switch$0)
       {var switch$1=224 <= c?246 < c?0:1:0;
        if(! switch$1)
         {var switch$2=248 <= c?254 < c?1:0:1;if(switch$2)return c}}
      return c - 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c)if(! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c)if(! (122 < c))return c - 32 | 0;return c}
    function compare$2(c1,c2){return c1 - c2 | 0}
    function equal$2(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$2,
       equal$2];
    caml_register_global(725,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _z1_=0 <= i?1:0,_z2_=_z1_?i <= 55295?1:0:_z1_;
      if(_z2_)
       var _z3_=_z2_;
      else
       var _z4_=57344 <= i?1:0,_z3_=_z4_?i <= 1114111?1:0:_z4_;
      return _z3_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (_g_
                  (caml_format_int(cst_X,i),
                   cst_is_not_an_Unicode_scalar_value))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (_g_
                  (cst_U,
                   _g_
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_z0_){return _z0_}
    function equal$3(_zZ_,_zY_){return _zZ_ === _zY_?1:0}
    var compare$3=caml_int_compare;
    function hash(_zX_){return _zX_}
    function _o_(_zW_){return _zW_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_zV_){return _zV_},
       _o_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$3,
       compare$3,
       hash];
    caml_register_global(726,Stdlib_uchar,"Stdlib__uchar");
    var
     match=runtime.caml_sys_get_argv(0),
     _p_=match[2],
     match$0=runtime.caml_sys_get_config(0),
     os_type=match$0[1],
     match$1=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     _q_=match[1],
     big_endian=0,
     match$2=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _zT_=[0,caml_sys_getenv(s)];return _zT_}
      catch(_zU_)
       {_zU_ = caml_wrap_exception(_zU_);
        if(_zU_ === Not_found)return 0;
        throw _zU_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    var
     Stdlib_sys=
      [0,
       _p_,
       _q_,
       getenv_opt,
       interactive,
       os_type,
       match$1,
       unix,
       win32,
       cygwin,
       match$2,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled];
    caml_register_global(727,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$1 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$2(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$2(f,l)]}
      return 0}
    function _r_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_r_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _r_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zS_=caml_call1(p,a);
          if(_zS_){var param$0=l;continue}
          return _zS_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zR_=caml_call1(p,a);
          if(_zR_)return _zR_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _zQ_=caml_call2(p,a1,a2);
            if(_zQ_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _zQ_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _zP_=caml_call2(p,a1,a2);
            if(_zP_)return _zP_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zO_=0 === caml_compare(a,x)?1:0;
          if(_zO_)return _zO_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zN_=a === x?1:0;
          if(_zN_)return _zN_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _zM_=0 === caml_compare(a,x)?1:0;
          if(_zM_)return _zM_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_zL_=a === x?1:0;
          if(_zL_)return _zL_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _zK_=rev(no);
        return [0,rev(yes),_zK_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _s_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function chop(k,l)
     {var k$0=k,l$0=l;
      for(;;)
       {if(0 === k$0)return l$0;
        if(l$0){var l$1=l$0[2],k$1=k$0 - 1 | 0,k$0=k$1,l$0=l$1;continue}
        throw [0,Assert_failure,_t_]}}
    function fast_sort(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zH_=l[2];
            if(_zH_)
             {var x2=_zH_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _zI_=l[2];
            if(_zI_)
             {var _zJ_=_zI_[2];
              if(_zJ_)
               {var x3=_zJ_[1],x2$0=_zI_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x1$0,x3)
                          ?0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                            :[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x2$0,[0,x1$0,[0,x3,0]]]
                        :0 < caml_call2(cmp,x2$0,x3)
                          ?0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]
                          :[0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zE_=l[2];
            if(_zE_)
             {var x2=_zE_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _zF_=l[2];
            if(_zF_)
             {var _zG_=_zF_[2];
              if(_zG_)
               {var x3=_zG_[1],x2$0=_zF_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x2$0,x3)
                          ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]
                        :0 < caml_call2(cmp,x1$0,x3)
                          ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                            :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function sort_uniq(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zB_=l[2];
            if(_zB_)
             {var x2=_zB_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _zC_=l[2];
            if(_zC_)
             {var _zD_=_zC_[2];
              if(_zD_)
               {var
                 x3=_zD_[1],
                 x2$0=_zC_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]]}
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)return [0,x2$0,[0,x1$0,0]];
                  if(0 <= c$3)
                   {var c$4=caml_call2(cmp,x2$0,x3);
                    return 0 === c$4
                            ?[0,x2$0,[0,x1$0,0]]
                            :0 <= c$4
                              ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                              :[0,x2$0,[0,x3,[0,x1$0,0]]]}
                  return [0,x2$0,[0,x1$0,[0,x3,0]]]}
                var c$5=caml_call2(cmp,x2$0,x3);
                if(0 === c$5)return [0,x1$0,[0,x2$0,0]];
                if(0 <= c$5)
                 {var c$6=caml_call2(cmp,x1$0,x3);
                  return 0 === c$6
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 <= c$6
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]}
                return [0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zy_=l[2];
            if(_zy_)
             {var x2=_zy_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _zz_=l[2];
            if(_zz_)
             {var _zA_=_zz_[2];
              if(_zA_)
               {var
                 x3=_zA_[1],
                 x2$0=_zz_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]]}
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)return [0,x1$0,[0,x2$0,0]];
                  if(0 < c$3)return [0,x1$0,[0,x2$0,[0,x3,0]]];
                  var c$4=caml_call2(cmp,x1$0,x3);
                  return 0 === c$4
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 < c$4
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]}
                var c$5=caml_call2(cmp,x1$0,x3);
                if(0 === c$5)return [0,x2$0,[0,x1$0,0]];
                if(0 < c$5)return [0,x2$0,[0,x1$0,[0,x3,0]]];
                var c$6=caml_call2(cmp,x2$0,x3);
                return 0 === c$6
                        ?[0,x2$0,[0,x1$0,0]]
                        :0 < c$6
                          ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_zx_){return aux(tail,_zx_)}]}
        return 0}
      return function(_zw_){return aux(l,_zw_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _zv_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_zv_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$2,
       iteri,
       map$2,
       mapi,
       rev_map,
       filter_map$0,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(728,include,"Stdlib__list");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_zt_=n - 1 | 0,_zs_=0;
      if(! (_zt_ < 0))
       {var i=_zs_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _zu_=i + 1 | 0;
          if(_zt_ !== i){var i=_zu_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string$1(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         {var r=caml_create_bytes(len);
          caml_blit_bytes(s,ofs,r,0,len);
          return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function _u_(a,b)
     {var
       c=a + b | 0,
       _zr_=b < 0?1:0,
       match=c < 0?1:0,
       switch$0=
        0 === (a < 0?1:0)
         ?0 === _zr_?0 === match?0:1:0
         :0 === _zr_?0:0 === match?1:0;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=_u_(_u_(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var srcoff=0,dstoff=left;
      else
       var srcoff=- left | 0,dstoff=0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_bytes_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_string_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_string)}
    function iter$3(f,a)
     {var _zp_=caml_ml_bytes_length(a) - 1 | 0,_zo_=0;
      if(! (_zp_ < 0))
       {var i=_zo_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _zq_=i + 1 | 0;
          if(_zp_ !== i){var i=_zq_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _zm_=caml_ml_bytes_length(a) - 1 | 0,_zl_=0;
      if(! (_zm_ < 0))
       {var i=_zl_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _zn_=i + 1 | 0;
          if(_zm_ !== i){var i=_zn_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _zg_=param[2],_zh_=param[1];
            if(_zg_)
             {var
               x=(caml_ml_bytes_length(_zh_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=_zg_;
              continue}
            var _zk_=caml_ml_bytes_length(_zh_) + acc | 0}
          else
           var _zk_=acc;
          var dst=caml_create_bytes(_zk_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _zi_=param$0[2],_zj_=param$0[1];
              if(_zi_)
               {caml_blit_bytes(_zj_,0,dst,pos,caml_ml_bytes_length(_zj_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_zj_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_zj_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_zi_;
                continue}
              caml_blit_bytes(_zj_,0,dst,pos,caml_ml_bytes_length(_zj_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var
       _zf_=param - 9 | 0,
       switch$0=4 < _zf_ >>> 0?23 === _zf_?1:0:2 === _zf_?0:1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len)
         if(is_space(caml_bytes_unsafe_get(s,i[1]))){i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1])
           if(is_space(caml_bytes_unsafe_get(s,j[1]))){j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_y__=caml_ml_bytes_length(s) - 1 | 0,_y9_=0;
      if(! (_y__ < 0))
       {var i$0=_y9_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0);
          if(32 <= match)
           {var _zc_=match - 34 | 0;
            if(58 < _zc_ >>> 0)
             if(93 <= _zc_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_zc_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1)var _zd_=1,switch$0=2}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          switch(switch$0){case 0:var _zd_=4;break;case 1:var _zd_=2;break}
          n[1] = n[1] + _zd_ | 0;
          var _ze_=i$0 + 1 | 0;
          if(_y__ !== i$0){var i$0=_ze_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _za_=caml_ml_bytes_length(s) - 1 | 0,_y$_=0;
      if(! (_za_ < 0))
       {var i=_y$_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i);
          if(35 <= c)
           var switch$2=92 === c?1:127 <= c?0:2;
          else
           if(32 <= c)
            var switch$2=34 <= c?1:2;
           else
            if(14 <= c)
             var switch$2=0;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                var switch$2=3;
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                var switch$2=3;
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                var switch$2=3;
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                var switch$2=3;
                break;
               default:var switch$2=0}
          switch(switch$2)
           {case 0:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 2:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _zb_=i + 1 | 0;
          if(_za_ !== i){var i=_zb_;continue}
          break}}
      return s$0}
    function map$3(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_y7_=l - 1 | 0,_y6_=0;
      if(! (_y7_ < 0))
       {var i=_y6_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _y8_=i + 1 | 0;
          if(_y7_ !== i){var i=_y8_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_y4_=l - 1 | 0,_y3_=0;
      if(! (_y4_ < 0))
       {var i=_y3_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _y5_=i + 1 | 0;
          if(_y4_ !== i){var i=_y5_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$3(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$3(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i)if(! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_bytes_length(s) <= i))return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec(s,l,i,c);var _y1_=1;return _y1_}
        catch(_y2_)
         {_y2_ = caml_wrap_exception(_y2_);
          if(_y2_ === Not_found)return 0;
          throw _y2_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_bytes_length(s) <= i))
        try
         {rindex_rec(s,i,c);var _yZ_=1;return _yZ_}
        catch(_y0_)
         {_y0_ = caml_wrap_exception(_y0_);
          if(_y0_ === Not_found)return 0;
          throw _y0_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from)}
    var compare$4=runtime.caml_bytes_compare;
    function uppercase$0(s){return map$3(uppercase,s)}
    function lowercase$0(s){return map$3(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_yX_=i + 1 | 0;
        return [0,x,function(_yY_){return aux(_yX_,_yY_)}]}
      var _yV_=0;
      return function(_yW_){return aux(_yV_,_yW_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_yT_=i + 1 | 0;
        return [0,[0,i,x],function(_yU_){return aux(_yT_,_yU_)}]}
      var _yR_=0;
      return function(_yS_){return aux(_yR_,_yS_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_bytes);
            var new_buf=make(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$4=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$3,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$4,
       equal$4,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(729,include$0,"Stdlib__bytes");
    function make$0(n,c){return caml_string_of_bytes(make(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _yM_=param[2],_yN_=param[1];
            if(_yM_)
             {var
               x=(caml_ml_string_length(_yN_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=_yM_;
              continue}
            var _yQ_=caml_ml_string_length(_yN_) + acc | 0}
          else
           var _yQ_=acc;
          var dst=caml_create_bytes(_yQ_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _yO_=param$0[2],_yP_=param$0[1];
              if(_yO_)
               {caml_blit_string(_yP_,0,dst,pos,caml_ml_string_length(_yP_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_yP_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_yP_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_yO_;
                continue}
              caml_blit_string(_yP_,0,dst,pos,caml_ml_string_length(_yP_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _yK_=caml_ml_string_length(s) - 1 | 0,_yJ_=0;
      if(! (_yK_ < 0))
       {var i=_yJ_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _yL_=i + 1 | 0;
          if(_yK_ !== i){var i=_yL_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _yH_=caml_ml_string_length(s) - 1 | 0,_yG_=0;
      if(! (_yH_ < 0))
       {var i=_yG_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _yI_=i + 1 | 0;
          if(_yH_ !== i){var i=_yI_;continue}
          break}}
      return 0}
    function map$4(f,s)
     {return caml_string_of_bytes(map$3(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var
       _yF_=param - 9 | 0,
       switch$0=4 < _yF_ >>> 0?23 === _yF_?1:0:2 === _yF_?0:1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if(! is_space$0(caml_string_unsafe_get(s,0)))
       if
        (!
         is_space$0
          (caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
        return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var
         match=caml_string_unsafe_get(s,i),
         _yE_=match - 32 | 0,
         switch$0=
          59 < _yE_ >>> 0?33 < (_yE_ - 61 | 0) >>> 0?1:0:2 === _yE_?1:0;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec$0(s,l,i,c);var _yC_=1;return _yC_}
        catch(_yD_)
         {_yD_ = caml_wrap_exception(_yD_);
          if(_yD_ === Not_found)return 0;
          throw _yD_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_string_length(s) <= i))
        try
         {rindex_rec$0(s,i,c);var _yA_=1;return _yA_}
        catch(_yB_)
         {_yB_ = caml_wrap_exception(_yB_);
          if(_yB_ === Not_found)return 0;
          throw _yB_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    var compare$5=caml_string_compare;
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _yw_=caml_ml_string_length(s) - 1 | 0;
      if(! (_yw_ < 0))
       {var i=_yw_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _yy_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_yy_];
            j[1] = i}
          var _yz_=i - 1 | 0;
          if(0 !== i){var i=_yz_;continue}
          break}}
      var _yx_=r[1];
      return [0,sub$0(s,0,j[1]),_yx_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$5=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$4,
       iteri$1,
       map$4,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$5,
       equal$5,
       split_on_char,
       to_seq$3,
       to_seqi$0,
       of_seq$1];
    caml_register_global(730,include$1,"Stdlib__string");
    function equal$6(param,_yv_){return 1}
    function compare$6(param,_yu_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_unit=[0,equal$6,compare$6,to_string$2];
    caml_register_global(731,Stdlib_unit,"Stdlib__unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buff) - len | 0) < ofs))
         return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substring_out_of_bounds)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        {var len=caml_marshal_data_size(buff,ofs);
         return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                 ?invalid_arg(cst_Marshal_from_bytes$0)
                 :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(732,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    var double_field=caml_array_get,set_double_field=caml_array_set;
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _yt_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_yt_]}
    var
     first_non_constant_constructor_tag=0,
     last_non_constant_constructor_tag=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function of_val(x)
     {if(is_block(x))
       if(caml_obj_tag(x) !== 248)
        if(1 <= x.length - 1)var slot=x[1],switch$0=1;else var switch$0=0;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var slot=x;
      if(is_block(slot))
       if(caml_obj_tag(slot) === 248)
        var name=slot[1],switch$1=1;
       else
        var switch$1=0;
      else
       var switch$1=0;
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _yr_=0 <= l?1:0,_ys_=_yr_?l <= max_ephe_length?1:0:_yr_;
      if(1 - _ys_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _yo_=0 <= o?1:0,_yp_=_yo_?o < length$0(e)?1:0:_yo_,_yq_=1 - _yp_;
      return _yq_?invalid_arg(msg):_yq_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if(0 <= l)
       if(0 <= o1)
        if(! ((length$0(e1) - l | 0) < o1))
         if(0 <= o2)
          if(! ((length$0(e2) - l | 0) < o2))
           {var
             _ym_=0 !== l?1:0,
             _yn_=_ym_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_ym_;
            return _yn_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _v_=runtime.caml_ephe_blit_data,
     _w_=runtime.caml_ephe_check_data,
     _x_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_yl_){return runtime.caml_ephe_unset_data(_yl_)},
       _w_,
       _v_,
       max_ephe_length],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor_tag,
       last_non_constant_constructor_tag,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _x_];
    caml_register_global(733,Stdlib_obj,"Stdlib__obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_yj_=l - 1 | 0,_yi_=1;
        if(! (_yj_ < 1))
         {var i=_yi_;
          for(;;)
           {res[i + 1] = caml_call1(f,i);
            var _yk_=i + 1 | 0;
            if(_yj_ !== i){var i=_yk_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_yg_=sx - 1 | 0,_yf_=0;
      if(! (_yg_ < 0))
       {var x=_yf_;
        for(;;)
         {res[x + 1] = caml_make_vect(sy,init);
          var _yh_=x + 1 | 0;
          if(_yg_ !== x){var x=_yh_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         {var _yd_=(ofs + len | 0) - 1 | 0;
          if(! (_yd_ < ofs))
           {var i=ofs;
            for(;;)
             {a[i + 1] = v;
              var _ye_=i + 1 | 0;
              if(_yd_ !== i){var i=_ye_;continue}
              break}}
          return 0}
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((a1.length - 1 - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((a2.length - 1 - len | 0) < ofs2))
           return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _yb_=a.length - 1 - 1 | 0,_ya_=0;
      if(! (_yb_ < 0))
       {var i=_ya_;
        for(;;)
         {caml_call1(f,a[i + 1]);
          var _yc_=i + 1 | 0;
          if(_yb_ !== i){var i=_yc_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_have_the_same_length);
      var _x__=a.length - 1 - 1 | 0,_x9_=0;
      if(! (_x__ < 0))
       {var i=_x9_;
        for(;;)
         {caml_call2(f,a[i + 1],b[i + 1]);
          var _x$_=i + 1 | 0;
          if(_x__ !== i){var i=_x$_;continue}
          break}}
      return 0}
    function map$5(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_x7_=l - 1 | 0,_x6_=1;
      if(! (_x7_ < 1))
       {var i=_x6_;
        for(;;)
         {r[i + 1] = caml_call1(f,a[i + 1]);
          var _x8_=i + 1 | 0;
          if(_x7_ !== i){var i=_x8_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)
       return invalid_arg(cst_Array_map2_arrays_must_have_the_same_length);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_x4_=la - 1 | 0,_x3_=1;
      if(! (_x4_ < 1))
       {var i=_x3_;
        for(;;)
         {r[i + 1] = caml_call2(f,a[i + 1],b[i + 1]);
          var _x5_=i + 1 | 0;
          if(_x4_ !== i){var i=_x5_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _x1_=a.length - 1 - 1 | 0,_x0_=0;
      if(! (_x1_ < 0))
       {var i=_x0_;
        for(;;)
         {caml_call2(f,i,a[i + 1]);
          var _x2_=i + 1 | 0;
          if(_x1_ !== i){var i=_x2_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_xY_=l - 1 | 0,_xX_=1;
      if(! (_xY_ < 1))
       {var i=_xX_;
        for(;;)
         {r[i + 1] = caml_call2(f,i,a[i + 1]);
          var _xZ_=i + 1 | 0;
          if(_xY_ !== i){var i=_xZ_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[i + 1],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[i + 1] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_xV_=a.length - 1 - 1 | 0,_xU_=0;
      if(! (_xV_ < 0))
       {var i=_xU_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[i + 1]);
          var _xW_=i + 1 | 0;
          if(_xV_ !== i){var i=_xW_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_xS_=a.length - 1 - 1 | 0;
      if(! (_xS_ < 0))
       {var i=_xS_;
        for(;;)
         {r[1] = caml_call2(f,a[i + 1],r[1]);
          var _xT_=i - 1 | 0;
          if(0 !== i){var i=_xT_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[i + 1]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[i + 1])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[i + 1],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[i + 1])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _xL_=i31 + 1 | 0,_xM_=caml_check_bound(a,_xL_)[_xL_ + 1];
          if(caml_call2(cmp,caml_check_bound(a,i31)[i31 + 1],_xM_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _xN_=i31 + 2 | 0,
           _xO_=caml_check_bound(a,_xN_)[_xN_ + 1],
           _xP_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_xP_)[_xP_ + 1],_xO_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _xQ_=i31 + 1 | 0,_xR_=caml_check_bound(a,_xQ_)[_xQ_ + 1];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[i31 + 1],_xR_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[j + 1],e))
           {var _xK_=caml_check_bound(a,j)[j + 1];
            caml_check_bound(a,i$0)[i$0 + 1] = _xK_;
            var i$0=j;
            continue}
          return caml_check_bound(a,i$0)[i$0 + 1] = e}}
      function trickle(l,i,e)
       {try
         {var _xJ_=trickledown(l,i,e);return _xJ_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];return caml_check_bound(a,i$0)[i$0 + 1] = e}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_xI_=caml_check_bound(a,i$1)[i$1 + 1];
          caml_check_bound(a,i$0)[i$0 + 1] = _xI_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _xH_=bubbledown(l,i);return _xH_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xz_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xz_ < 0))
       {var i$2=_xz_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[i$2 + 1]);
          var _xG_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_xG_;continue}
          break}}
      var _xA_=l - 1 | 0;
      if(! (_xA_ < 2))
       {var i$0=_xA_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[i$0 + 1],
           _xE_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[i$0 + 1] = _xE_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_y_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[father + 1],e$0))
             caml_check_bound(a,i)[i + 1] = e$0;
            else
             {var _xy_=caml_check_bound(a,father)[father + 1];
              caml_check_bound(a,i)[i + 1] = _xy_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _xF_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_xF_;continue a}
            break}
          break}}
      var _xB_=1 < l?1:0;
      if(_xB_)
       {var e=caml_check_bound(a,1)[2],_xC_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _xC_;
        var _xD_=caml_check_bound(a,0)[1] = e}
      else
       var _xD_=_xB_;
      return _xD_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[src2ofs + 1],
         s1$1=caml_check_bound(a,src1ofs)[src1ofs + 1],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[d + 1] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[i2$0 + 1],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[d + 1] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[i1$0 + 1],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xq_=len - 1 | 0,_xp_=0;
        if(! (_xq_ < 0))
         {var i=_xp_;
          a:
          for(;;)
           {var
             _xr_=srcofs + i | 0,
             e=caml_check_bound(a,_xr_)[_xr_ + 1],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _xs_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_xs_)[_xs_ + 1],e))
                 {var
                   _xt_=j[1],
                   _xu_=caml_check_bound(dst,_xt_)[_xt_ + 1],
                   _xv_=j[1] + 1 | 0;
                  caml_check_bound(dst,_xv_)[_xv_ + 1] = _xu_;
                  j[1] += -1;
                  continue}}
              var _xw_=j[1] + 1 | 0;
              caml_check_bound(dst,_xw_)[_xw_ + 1] = e;
              var _xx_=i + 1 | 0;
              if(_xq_ !== i){var i=_xx_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[i + 1],_xn_=i + 1 | 0;
          return [0,x,function(_xo_){return aux(_xn_,_xo_)}]}
        return 0}
      var _xl_=0;
      return function(_xm_){return aux(_xl_,_xm_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[i + 1],_xj_=i + 1 | 0;
          return [0,[0,i,x],function(_xk_){return aux(_xj_,_xk_)}]}
        return 0}
      var _xh_=0;
      return function(_xi_){return aux(_xh_,_xi_)}}
    function of_seq$2(i$2)
     {var _xg_=0,l=fold_left(function(acc,x){return [0,x,acc]},_xg_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[i + 1] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$5,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(734,include$2,"Stdlib__array");
    var zero=0.,one=1.,minus_one=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _xf_=x == runtime.caml_trunc_float(x)?1:0;
      return _xf_?is_finite(x):_xf_}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$7(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$1(x,y)
     {if(! (x < y))
       {var switch$0=caml_signbit_float(y)?1:caml_signbit_float(x)?0:1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$1(x,y)
     {if(! (x < y))
       {var switch$0=caml_signbit_float(y)?1:caml_signbit_float(x)?0:1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x)
       if(y == y)
        {if(! (x < y))
          {var switch$0=caml_signbit_float(y)?1:caml_signbit_float(x)?0:1;
           if(switch$0)return [0,y,x]}
         return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=caml_signbit_float(y)?1:caml_signbit_float(x)?0:1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=caml_signbit_float(y)?1:caml_signbit_float(x)?0:1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=caml_signbit_float(y)?1:caml_signbit_float(x)?0:1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _xd_=(ofs + len | 0) - 1 | 0;
      if(! (_xd_ < ofs))
       {var i=ofs;
        for(;;)
         {a[i + 1] = v;
          var _xe_=i + 1 | 0;
          if(_xd_ !== i){var i=_xe_;continue}
          break}}
      return 0}
    function unsafe_blit(src,sofs,dst,dofs,len)
     {var _xb_=len - 1 | 0,_xa_=0;
      if(! (_xb_ < 0))
       {var i=_xa_;
        for(;;)
         {dst[(dofs + i | 0) + 1] = src[(sofs + i | 0) + 1];
          var _xc_=i + 1 | 0;
          if(_xb_ !== i){var i=_xc_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _w8_=ofs < 0?1:0;
      if(_w8_)
       var _w9_=_w8_;
      else
       {var _w__=len < 0?1:0;
        if(_w__)
         var _w9_=_w__;
        else
         var
          _w$_=(ofs + len | 0) < 0?1:0,
          _w9_=_w$_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _w9_?invalid_arg(msg):_w9_}
    function make$1(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_w6_=l - 1 | 0,_w5_=0;
        if(! (_w6_ < 0))
         {var i=_w5_;
          for(;;)
           {res[i + 1] = caml_call1(f,i);
            var _w7_=i + 1 | 0;
            if(_w6_ !== i){var i=_w7_;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$1(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      unsafe_blit(a1,0,result,0,l1);
      unsafe_blit(a2,0,result,l1,l2);
      return result}
    function concat$2(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            unsafe_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_z_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      unsafe_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      unsafe_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return unsafe_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_w4_){return a[_w4_ + 1]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[i + 1] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _w2_=a.length - 1 - 1 | 0,_w1_=0;
      if(! (_w2_ < 0))
       {var i=_w1_;
        for(;;)
         {caml_call1(f,a[i + 1]);
          var _w3_=i + 1 | 0;
          if(_w2_ !== i){var i=_w3_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg
               (cst_Float_Array_iter2_arrays_must_have_the_same_length);
      var _wZ_=a.length - 1 - 1 | 0,_wY_=0;
      if(! (_wZ_ < 0))
       {var i=_wY_;
        for(;;)
         {caml_call2(f,a[i + 1],b[i + 1]);
          var _w0_=i + 1 | 0;
          if(_wZ_ !== i){var i=_w0_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wW_=l - 1 | 0,_wV_=0;
      if(! (_wW_ < 0))
       {var i=_wV_;
        for(;;)
         {r[i + 1] = caml_call1(f,a[i + 1]);
          var _wX_=i + 1 | 0;
          if(_wW_ !== i){var i=_wX_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)
       return invalid_arg
               (cst_Float_Array_map2_arrays_must_have_the_same_length);
      var r=caml_floatarray_create(la),_wT_=la - 1 | 0,_wS_=0;
      if(! (_wT_ < 0))
       {var i=_wS_;
        for(;;)
         {r[i + 1] = caml_call2(f,a[i + 1],b[i + 1]);
          var _wU_=i + 1 | 0;
          if(_wT_ !== i){var i=_wU_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _wQ_=a.length - 1 - 1 | 0,_wP_=0;
      if(! (_wQ_ < 0))
       {var i=_wP_;
        for(;;)
         {caml_call2(f,i,a[i + 1]);
          var _wR_=i + 1 | 0;
          if(_wQ_ !== i){var i=_wR_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wN_=l - 1 | 0,_wM_=0;
      if(! (_wN_ < 0))
       {var i=_wM_;
        for(;;)
         {r[i + 1] = caml_call2(f,i,a[i + 1]);
          var _wO_=i + 1 | 0;
          if(_wN_ !== i){var i=_wO_;continue}
          break}}
      return r}
    function fold_left$2(f,x,a)
     {var r=[0,x],_wK_=a.length - 1 - 1 | 0,_wJ_=0;
      if(! (_wK_ < 0))
       {var i=_wJ_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[i + 1]);
          var _wL_=i + 1 | 0;
          if(_wK_ !== i){var i=_wL_;continue}
          break}}
      return r[1]}
    function fold_right$1(f,a,x)
     {var r=[0,x],_wH_=a.length - 1 - 1 | 0;
      if(! (_wH_ < 0))
       {var i=_wH_;
        for(;;)
         {r[1] = caml_call2(f,a[i + 1],r[1]);
          var _wI_=i - 1 | 0;
          if(0 !== i){var i=_wI_;continue}
          break}}
      return r[1]}
    function exists$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[i + 1]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[i + 1])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[i + 1],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[i + 1])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         if
          (!
           (0
            <=
            caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
          return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _wG_=trickledown(l,i,e);return _wG_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _wF_=bubbledown(l,i);return _wF_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_wz_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_wz_ < 0))
       {var i$2=_wz_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _wE_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_wE_;continue}
          break}}
      var _wA_=l - 1 | 0;
      if(! (_wA_ < 2))
       {var i$0=_wA_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_A_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _wD_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_wD_;continue a}
            break}
          break}}
      var _wB_=1 < l?1:0;
      if(_wB_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _wC_=caml_array_set(a,0,e)}
      else
       var _wC_=_wB_;
      return _wC_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _wx_=len - 1 | 0,_ww_=0;
        if(! (_wx_ < 0))
         {var i=_ww_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               if(0 < caml_call2(cmp,caml_array_get(dst,j[1]),e))
                {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                 j[1] += -1;
                 continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _wy_=i + 1 | 0;
              if(_wx_ !== i){var i=_wy_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[i + 1],_wu_=i + 1 | 0;
          return [0,x,function(_wv_){return aux(_wu_,_wv_)}]}
        return 0}
      var _ws_=0;
      return function(_wt_){return aux(_ws_,_wt_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[i + 1],_wq_=i + 1 | 0;
          return [0,[0,i,x],function(_wr_){return aux(_wq_,_wr_)}]}
        return 0}
      var _wo_=0;
      return function(_wp_){return aux(_wo_,_wp_)}}
    function of_seq$3(i$2)
     {var
       _wn_=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_wn_,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[i + 1] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_wl_=l - 1 | 0,_wk_=1;
      if(! (_wl_ < 1))
       {var i=_wk_;
        for(;;)
         {r[i + 1] = caml_call1(f,a[i + 1]);
          var _wm_=i + 1 | 0;
          if(_wl_ !== i){var i=_wm_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wi_=l - 1 | 0,_wh_=0;
      if(! (_wi_ < 0))
       {var i=_wh_;
        for(;;)
         {r[i + 1] = caml_call1(f,a[i + 1]);
          var _wj_=i + 1 | 0;
          if(_wi_ !== i){var i=_wj_;continue}
          break}}
      return r}
    var
     _B_=caml_floatarray_create,
     _C_=caml_array_set,
     _D_=caml_array_get,
     _E_=
      [0,
       function(_wg_){return _wg_.length - 1},
       _D_,
       _C_,
       make$1,
       _B_,
       init$3,
       append$1,
       concat$2,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$6,
       mapi$3,
       fold_left$2,
       fold_right$1,
       iter2$1,
       map2$1,
       for_all$1,
       exists$1,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _F_=caml_floatarray_create,
     _G_=caml_array_set,
     _H_=caml_array_get,
     Stdlib_float=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$7,
       min$1,
       max$1,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_wf_){return _wf_.length - 1},
        _H_,
        _G_,
        make$1,
        _F_,
        init$3,
        append$1,
        concat$2,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$6,
        mapi$3,
        fold_left$2,
        fold_right$1,
        iter2$1,
        map2$1,
        for_all$1,
        exists$1,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _E_];
    caml_register_global(735,Stdlib_float,"Stdlib__float");
    var zero$0=0,one$0=1,minus_one$0=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$8(_we_,_wd_){return _we_ === _wd_?1:0}
    var compare$7=caml_int_compare;
    function to_string$3(x){return caml_new_string("" + x)}
    var
     Stdlib_int=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$8,
       compare$7,
       to_string$3];
    caml_register_global(736,Stdlib_int,"Stdlib__int");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if(! (0 < caml_int_compare(0,n)))
       if(! (0 < caml_int_compare(n,2147483647)))return [0,n];
      return 0}
    function to_string$4(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _wb_=[0,caml_int_of_string(s)];return _wb_}
      catch(_wc_)
       {_wc_ = caml_wrap_exception(_wc_);
        if(_wc_[1] === Failure)return 0;
        throw _wc_}}
    var compare$8=caml_int_compare;
    function equal$9(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$4,
       compare$8,
       unsigned_compare,
       equal$9];
    caml_register_global(737,Stdlib_int32,"Stdlib__int32");
    function succ$2(n){return caml_int64_add(n,_I_)}
    function pred$2(n){return caml_int64_sub(n,_J_)}
    function abs$2(n)
     {return caml_greaterequal(n,_K_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_L_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if(! (0 < caml_int64_compare(zero$2,n)))
       if(! (0 < caml_int64_compare(n,max_int$3)))
        return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$5(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _v$_=[0,caml_int64_of_string(s)];return _v$_}
      catch(_wa_)
       {_wa_ = caml_wrap_exception(_wa_);
        if(_wa_[1] === Failure)return 0;
        throw _wa_}}
    var compare$9=caml_int64_compare;
    function equal$10(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$5,
       compare$9,
       unsigned_compare$0,
       equal$10];
    caml_register_global(738,Stdlib_int64,"Stdlib__int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if(! (0 < caml_int_compare(0,n)))
       if(! (0 < caml_int_compare(n,2147483647)))return [0,n];
      return 0}
    function to_string$6(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _v9_=[0,caml_int_of_string(s)];return _v9_}
      catch(_v__)
       {_v__ = caml_wrap_exception(_v__);
        if(_v__[1] === Failure)return 0;
        throw _v__}}
    var compare$10=caml_int_compare;
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$2,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$6,
       compare$10,
       unsigned_compare$1,
       equal$11];
    caml_register_global(739,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _v6_=0 <= result?1:0,
       _v7_=_v6_?buf[12] !== dummy_pos?1:0:_v6_;
      if(_v7_)
       {buf[11] = buf[12];
        var _v8_=buf[12];
        buf[12] = [0,_v8_[1],_v8_[2],_v8_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _v3_=0 <= result?1:0,
       _v4_=_v3_?buf[12] !== dummy_pos?1:0:_v3_;
      if(_v4_)
       {buf[11] = buf[12];
        var _v5_=buf[12];
        buf[12] = [0,_v5_[1],_v5_[2],_v5_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _vP_=with_positions?zero_pos:dummy_pos,
       _vQ_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _vR_=[0],
       _vS_=0,
       _vT_=0,
       _vU_=0,
       _vV_=0,
       _vW_=0,
       _vX_=0,
       _vY_=0,
       _vZ_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_grow_buffer);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_v1_=t.length - 1 - 1 | 0,_v0_=0;
                  if(! (_v1_ < 0))
                   {var i=_v0_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[i + 1];
                      if(0 <= v)caml_check_bound(t,i)[i + 1] = v - s | 0;
                      var _v2_=i + 1 | 0;
                      if(_v1_ !== i){var i=_v2_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _vZ_,
              _vY_,
              _vX_,
              _vW_,
              _vV_,
              _vU_,
              _vT_,
              _vS_,
              _vR_,
              _vQ_,
              _vP_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _vE_=with_positions?zero_pos:dummy_pos,
       _vF_=with_positions?zero_pos:dummy_pos,
       _vG_=[0],
       _vH_=1,
       _vI_=0,
       _vJ_=0,
       _vK_=0,
       _vL_=0,
       _vM_=0,
       _vN_=caml_ml_string_length(s),
       _vO_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _vO_,
              _vN_,
              _vM_,
              _vL_,
              _vK_,
              _vJ_,
              _vI_,
              _vH_,
              _vG_,
              _vF_,
              _vE_]}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _vC_=lcp !== dummy_pos?1:0,
       _vD_=_vC_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_vC_;
      return _vD_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(740,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _vx_=env[13],
                _vy_=
                 caml_call1(caml_check_bound(tables[1],_vx_)[_vx_ + 1],env),
                _vz_=4,
                cmd$0=_vz_,
                arg$1=_vy_}
             catch(_vB_)
              {_vB_ = caml_wrap_exception(_vB_);
               if(_vB_ !== Parse_error)throw _vB_;
               var cmd$0=5,arg$1=0}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _vA_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_vA_)[_vA_ + 1] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[tok + 1] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _vw_=env[11] - n | 0;return caml_check_bound(env[2],_vw_)[_vw_ + 1]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _vt_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_vt_)[_vt_ + 1],
           _vu_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_vu_)[_vu_ + 1];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _vv_=env[11];
        return caml_check_bound(env[4],_vv_)[_vv_ + 1]}}
    function symbol_end_pos(param)
     {var _vs_=env[11];return caml_check_bound(env[4],_vs_)[_vs_ + 1]}
    function rhs_start_pos(n)
     {var _vr_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_vr_)[_vr_ + 1]}
    function rhs_end_pos(n)
     {var _vq_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_vq_)[_vq_ + 1]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_vp_){return runtime.caml_set_parser_trace(_vp_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(741,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _vo_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_vo_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_vj_=height(lr);
               if(_vj_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_vk_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_vk_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_vl_=height(rl);
               if(_vl_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_vm_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_vm_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _vn_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_vn_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vi_=param$0[1];
               if(_vi_){var param$0=_vi_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vh_=param$0[1];
               if(_vh_){var param$0=_vh_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vf_=param$0[3],_vg_=param$0[2];
               if(_vf_){var param$0=_vf_;continue}
               return _vg_}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vd_=param$0[3],_ve_=param$0[2];
               if(_vd_){var param$0=_vd_;continue}
               return [0,_ve_]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _vc_=param[1];
             if(_vc_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_vc_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _vb_=remove_min_elt(match);
               return join(t,min_elt(match),_vb_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _M_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _va_=0 === c?1:0;
               if(_va_)return _va_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _u$_=remove_min_elt(r);return bal(l,min_elt(r),_u$_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _u9_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_u9_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _u__=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_u__)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _u5_=split(v1,match),
                _u6_=_u5_[1];
               if(0 === _u5_[2])
                {var r2=_u5_[3],_u7_=inter(r1,r2);
                 return concat(inter(l1,_u6_),_u7_)}
               var r2$0=_u5_[3],_u8_=inter(r1,r2$0);
               return join(inter(l1,_u6_),v1,_u8_)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              if(s2$0)
               {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
                if(s1$0 === s2$0)return 0;
                var match=split_bis(v1,s2$0);
                if(match)
                 {var r2=match[2],l2=match[1],_u4_=disjoint(l1,l2);
                  if(_u4_)
                   {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                  return _u4_}
                return 0}
             return 1}}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _u0_=split(v1,match),
                _u1_=_u0_[1];
               if(0 === _u0_[2])
                {var r2=_u0_[3],_u2_=diff(r1,r2);
                 return join(diff(l1,_u1_),v1,_u2_)}
               var r2$0=_u0_[3],_u3_=diff(r1,r2$0);
               return concat(diff(l1,_u1_),_u3_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _uX_=subset(l1,l2);
                   if(_uX_){var s1$0=r1,s2$0=r2;continue}
                   return _uX_}
                 if(0 <= c)
                  {var _uY_=subset([0,0,v1,r1,0],r2);
                   if(_uY_){var s1$0=l1;continue}
                   return _uY_}
                 var _uZ_=subset([0,l1,v1,0,0],l2);
                 if(_uZ_){var s1$0=r1;continue}
                 return _uZ_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uU_=caml_call1(p,v);
               if(_uU_)
                {var _uV_=for_all(p,l);
                 if(_uV_){var param$0=r;continue}
                 var _uW_=_uV_}
               else
                var _uW_=_uU_;
               return _uW_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uR_=caml_call1(p,v);
               if(_uR_)
                var _uS_=_uR_;
               else
                {var _uT_=exists(p,l);
                 if(! _uT_){var param$0=r;continue}
                 var _uS_=_uT_}
               return _uS_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0)if(r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _uP_=concat(lf,rf);return [0,join(lt,v,rt),_uP_]}
             var _uQ_=join(lf,v,rf);
             return [0,concat(lt,rt),_uQ_]}
           return _N_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_uO_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _uO_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0)if(v === v$0)if(r === r$0)return t;
             if(0 === l$0)
              var switch$0=0;
             else
              var
               _uN_=max_elt(l$0),
               switch$0=0 <= caml_call2(Ord[1],_uN_,v$0)?1:0;
             if(! switch$0)
              {if(0 === r$0)
                var switch$1=0;
               else
                var
                 _uM_=min_elt(r$0),
                 switch$1=0 <= caml_call2(Ord[1],v$0,_uM_)?1:0;
               if(! switch$1)return join(l$0,v$0,r$0)}
             return union(l$0,add(v$0,r$0))}
           return 0}
         function of_list(l)
          {if(l)
            {var _uB_=l[2],_uC_=l[1];
             if(_uB_)
              {var _uD_=_uB_[2],_uE_=_uB_[1];
               if(_uD_)
                {var _uF_=_uD_[2],_uG_=_uD_[1];
                 if(_uF_)
                  {var _uH_=_uF_[2],_uI_=_uF_[1];
                   if(_uH_)
                    {if(_uH_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _uJ_=l[2];
                                 if(_uJ_)
                                  {var l$4=_uJ_[2],x1=_uJ_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _uK_=l[2];
                                 if(_uK_)
                                  {var _uL_=_uK_[2];
                                   if(_uL_)
                                    {var l$5=_uL_[2],x2=_uL_[1],x1$0=_uK_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_O_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_uH_[1];
                     return add(x4,add(_uI_,add(_uG_,add(_uE_,singleton(_uC_)))))}
                   return add(_uI_,add(_uG_,add(_uE_,singleton(_uC_))))}
                 return add(_uG_,add(_uE_,singleton(_uC_)))}
               return add(_uE_,singleton(_uC_))}
             return singleton(_uC_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_uz_=cons_enum(t,rest);
             return [0,x,function(_uA_){return seq_of_enum(_uz_,_uA_)}]}
           return 0}
         function to_seq(c)
          {var _ux_=cons_enum(c,0);
           return function(_uy_){return seq_of_enum(_ux_,_uy_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _uv_=[0,v,r,c]}
             else
              var _uv_=c;
             return function(_uw_){return seq_of_enum(_uv_,_uw_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(742,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_uu_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_uu_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_up_=height(lr);
               if(_up_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _uq_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_uq_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_ur_=height(rl);
               if(_ur_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _us_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_us_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _ut_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_ut_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _uo_=0 === c?1:0;
               if(_uo_)return _uo_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _un_=param$0[1];
               if(_un_){var param$0=_un_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _um_=param$0[1];
               if(_um_){var param$0=_um_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _uj_=param$0[4],_uk_=param$0[3],_ul_=param$0[2];
               if(_uj_){var param$0=_uj_;continue}
               return [0,_ul_,_uk_]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _ug_=param$0[4],_uh_=param$0[3],_ui_=param$0[2];
               if(_ug_){var param$0=_ug_;continue}
               return [0,[0,_ui_,_uh_]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _uf_=param[1];
             if(_uf_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_uf_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _tU_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _tU_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _tU_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uc_=caml_call2(p,v,d);
               if(_uc_)
                {var _ud_=for_all(p,l);
                 if(_ud_){var param$0=r;continue}
                 var _ue_=_ud_}
               else
                var _ue_=_uc_;
               return _ue_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _t$_=caml_call2(p,v,d);
               if(_t$_)
                var _ua_=_t$_;
               else
                {var _ub_=exists(p,l);
                 if(! _ub_){var param$0=r;continue}
                 var _ua_=_ub_}
               return _ua_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _P_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _t7_=merge(f,r1,r2),
                _t8_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_t8_,_t7_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _t9_=merge(f,r1$0,r2$0),
              _t__=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_t__,_t9_)}
           throw [0,Assert_failure,_Q_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0)if(r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _t5_=concat(lf,rf);return [0,join(lt,v,d,rt),_t5_]}
             var _t6_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_t6_]}
           return _R_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _t2_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_t2_)
                  {var _t3_=caml_call2(cmp,d1,d2);
                   if(_t3_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _t4_=_t3_}
                 else
                  var _t4_=_t2_;
                 return _t4_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_t1_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _t1_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_tZ_=cons_enum(t,rest);
             return [0,[0,k,v],function(_t0_){return seq_of_enum(_tZ_,_t0_)}]}
           return 0}
         function to_seq(m)
          {var _tX_=cons_enum(m,0);
           return function(_tY_){return seq_of_enum(_tX_,_tY_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _tV_=[0,v,d,r,c]}
             else
              var _tV_=c;
             return function(_tW_){return seq_of_enum(_tV_,_tW_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(743,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _tT_=s[1];
      if(_tT_)
       {var tl=_tT_[2],hd=_tT_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _tS_=s[1];
      if(_tS_)
       {var tl=_tS_[2],hd=_tS_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _tR_=s[1];if(_tR_){var hd=_tR_[1];return hd}throw Empty}
    function top_opt(s)
     {var _tQ_=s[1];if(_tQ_){var hd=_tQ_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$1(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$1,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(744,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_tP_=q[3];
      return _tP_
              ?(q[1] = q[1] + 1 | 0,_tP_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _tO_=q[2];if(_tO_){var content=_tO_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _tN_=q[2];if(_tN_){var content=_tN_[1];return [0,content]}return 0}
    function take(q)
     {var _tK_=q[2];
      if(_tK_)
       {var _tL_=_tK_[1],_tM_=_tK_[2];
        return _tM_?(q[1] = q[1] - 1 | 0,q[2] = _tM_,_tL_):(clear$0(q),_tL_)}
      throw Empty$0}
    function take_opt(q)
     {var _tH_=q[2];
      if(_tH_)
       {var _tI_=_tH_[1],_tJ_=_tH_[2];
        return _tJ_
                ?(q[1] = q[1] - 1 | 0,q[2] = _tJ_,[0,_tI_])
                :(clear$0(q),[0,_tI_])}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$2(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _tF_=0 < q1[1]?1:0;
      if(_tF_)
       {var _tG_=q2[3];
        return _tG_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _tG_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _tF_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_tE_){return aux(next,_tE_)}]}
        return 0}
      var _tC_=q[2];
      return function(_tD_){return aux(_tC_,_tD_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$2,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(745,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        blk[1] = result;
        caml_obj_set_tag(blk,250);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      blk[1] = result;
      caml_obj_set_tag(blk,250);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(746,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250)if(t !== 246)if(t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(747,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_S_]}
           case 2:
            var
             f=d$0[1],
             _ty_=caml_obj_tag(f),
             d$1=250 === _ty_?f[1]:246 === _ty_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _tz_=d$0[1],_tA_=_tz_[1];
            if(_tA_)
             {var _tB_=_tA_[1];
              if(_tB_){var a$0=_tB_[1];_tz_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_tz_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _tz_[1] = _T_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _tt_=s[2];
        if(typeof _tt_ === "number")
         return 0;
        else
         switch(_tt_[0])
          {case 0:var a=_tt_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_U_]}
           case 2:
            var
             f=_tt_[1],
             _tu_=caml_obj_tag(f),
             _tv_=250 === _tu_?f[1]:246 === _tu_?force_lazy_block(f):f;
            s[2] = _tv_;
            continue;
           case 3:
            var _tw_=_tt_[1],_tx_=_tw_[1];
            if(_tx_){var a$1=_tx_[1];return a$1}
            var x=caml_call1(_tw_[2],s[1]);
            _tw_[1] = [0,x];
            return x;
           default:
            var b=_tt_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _tr_=s[2];
        if(typeof _tr_ !== "number")
         switch(_tr_[0])
          {case 0:var d=_tr_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _ts_=_tr_[1];
            if(_ts_[1]){s[1] = s[1] + 1 | 0;_ts_[1] = 0;return 0}
            break;
           case 4:
            var b=_tr_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _tq_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_tq_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _tp_=data(s);return [0,[0,0,[1,data(i),_tp_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tn_)
                  {var _to_=data(s);return [1,data(caml_call1(f,0)),_to_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tl_)
                  {var _tm_=data(s);return [0,caml_call1(f,0),_tm_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_tk_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_tj_){return data(caml_call1(f,0))}]]]]}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string$0,
       of_bytes,
       of_channel,
       iter$9,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(748,Stdlib_stream,"Stdlib__stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((b[2] - len | 0) < ofs))return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if(0 <= len)
       if(0 <= srcoff)
        if(! ((src[2] - len | 0) < srcoff))
         if(0 <= dstoff)
          if(! ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
           return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs)if(! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var len=b[3],new_len=[0,len];
      for(;;)
       {if(new_len[1] < (b[2] + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((b[2] + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buffer);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        return 0}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_V_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_W_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_X_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Y_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_Z_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,___]}
    function add_substring(b,s,offset,len)
     {var _tg_=offset < 0?1:0;
      if(_tg_)
       var _th_=_tg_;
      else
       var
        _ti_=len < 0?1:0,
        _th_=_ti_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_th_)invalid_arg(cst_Buffer_add_substring_add_subbytes);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len$1)
     {var _te_=len$1 < 0?1:0,_tf_=_te_ || (max_string_length < len$1?1:0);
      if(_tf_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len$1 | 0))resize(b,len$1);
      var len=len$1;
      for(;;)
       {var _td_=0 < len?1:0;
        if(_td_)
         {var n=input(ic,b[1],b[2],len);
          b[2] = b[2] + n | 0;
          if(0 === n)throw End_of_file;
          var len$0=len - n | 0,len=len$0;
          continue}
        return _td_}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start);
            if(40 === opening)
             var switch$0=0;
            else
             if(123 === opening)
              var switch$0=0;
             else
              {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
               for(;;)
                {if(lim$0 <= i$3)
                  var stop=lim$0;
                 else
                  {var
                    match=caml_string_get(s,i$3),
                    switch$1=
                     91 <= match
                      ?97 <= match?123 <= match?0:1:95 === match?1:0
                      :58 <= match?65 <= match?1:0:48 <= match?1:0;
                   if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                   var stop=i$3}
                 var
                  match$0=[0,sub$0(s,start,stop - start | 0),stop],
                  switch$0=1;
                 break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _tb_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_$_];var _tb_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _tb_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _tc_=92 === previous?1:0;
        return _tc_?add_char(b,previous):_tc_}}
    function truncate(b,len)
     {if(0 <= len)if(! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_get(b[1],i),_s$_=i + 1 | 0;
        return [0,x,function(_ta_){return aux(_s$_,_ta_)}]}
      var _s9_=0;
      return function(_s__){return aux(_s9_,_s__)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_get(b[1],i),_s7_=i + 1 | 0;
        return [0,[0,i,x],function(_s8_){return aux(_s7_,_s8_)}]}
      var _s5_=0;
      return function(_s6_){return aux(_s5_,_s6_)}}
    function add_seq$1(b,seq)
     {return iter(function(_s4_){return add_char(b,_s4_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_buffer=
      [0,
       create$2,
       contents,
       to_bytes,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(749,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string$1(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _s3_=i + 1 | 0;
        if(31 !== i){var i=_s3_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_s2_=[0,ndec];else var _s2_=0;
          return [0,[8,0,pad_of_pad_opt(pad_opt$5),_s2_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    var default_float_precision=-6;
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _s0_=len < min_len?1:0;
      if(_s0_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _s1_=0}
      else
       var _s1_=_s0_;
      return _s1_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(fconv)
     {switch(fconv)
       {case 15:return 70;
        case 0:
        case 1:
        case 2:return 102;
        case 3:
        case 4:
        case 5:return 101;
        case 6:
        case 7:
        case 8:return 69;
        case 9:
        case 10:
        case 11:return 103;
        case 12:
        case 13:
        case 14:return 71;
        case 16:
        case 17:
        case 18:return 104;
        default:return 72}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_new_string("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_new_string("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")
       return 0 === prec?0:buffer_add_string(buf,cst$11);
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_new_string("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv)
       {case 1:
        case 4:
        case 7:
        case 10:
        case 13:
        case 17:
        case 20:return buffer_add_char(buf,43);
        case 2:
        case 5:
        case 8:
        case 11:
        case 14:
        case 18:
        case 21:return buffer_add_char(buf,32);
        default:return 0}}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return _g_(cst$19,make$0(1,c))}}
    function string_of_formatting_gen(formatting_gen)
     {if(0 === formatting_gen[0])
       {var match=formatting_gen[1],str=match[2];return str}
      var match$0=formatting_gen[1],str$0=match$0[2];
      return str$0}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _sY_=caml_ml_string_length(str) - 1 | 0,_sX_=0;
      if(! (_sY_ < 0))
       {var i=_sX_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _sZ_=i + 1 | 0;
          if(_sY_ !== i){var i=_sZ_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$26);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           bprint_string_literal(buf,cst$27);
           bprint_string_literal(buf,string_of_formatting_gen(fmting_gen));
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _sN_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_sS_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _sT_=is_in_char_set(_sS_,c);
                 if(_sT_)
                  var
                   _sU_=is_in_char_set(_sS_,before),
                   _sV_=_sU_?is_in_char_set(_sS_,after):_sU_,
                   _sW_=1 - _sV_;
                 else
                  var _sW_=_sT_;
                 return _sW_}
               return is_alone},
            is_alone=is_alone$0(_sN_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_sN_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0;
               if(48 < switcher >>> 0)
                var switch$0=210 <= switcher?(print_char(buf,255),1):0;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 var switch$0=0}
               if(! switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_sN_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var match$0=char_of_int(i$1),switcher$1=match$0 - 45 | 0;
                 if(48 < switcher$1 >>> 0)
                  var
                   switch$1=
                    210 <= switcher$1
                     ?(print_char(buf,254),print_char(buf,255),1)
                     :0;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_sN_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     var switch$1=0}
                   else
                    var switch$1=0}
                 if(! switch$1)
                  {if(! is_in_char_set(_sN_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0)
                      if(is_in_char_set(_sN_,char_of_int(j$0)))
                       {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _sO_=108;break;
             case 1:var _sO_=110;break;
             default:var _sO_=78}
           buffer_add_char(buf,_sO_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$1=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$1[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _sQ_=int_of_custom_arity(arity),
            _sP_=1;
           if(! (_sQ_ < 1))
            {var i$8=_sP_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _sR_=i$8 + 1 | 0;
               if(_sQ_ !== i$8){var i$8=_sR_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _sp_=function(param){return 0},
         _sq_=function(param){return 0},
         _sr_=function(param){return 0};
        return [0,function(param){return 0},_sr_,_sq_,_sp_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _ss_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_ss_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _st_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _st_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _su_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _su_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _sv_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _sv_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _sw_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _sw_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _sx_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _sx_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _sy_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _sy_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _sz_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _sz_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _sA_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _sA_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _sB_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _sC_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _sD_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _sD_,
                  _sC_,
                  _sB_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _sE_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _sE_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _sF_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _sF_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _sG_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _sG_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _sH_=function(param){caml_call1(de$12,0);return 0},
           _sI_=function(param){caml_call1(ed$12,0);return 0},
           _sJ_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _sJ_,
                  _sI_,
                  _sH_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _sK_=function(param){caml_call1(de$13,0);return 0},
           _sL_=function(param){caml_call1(ed$13,0);return 0},
           _sM_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _sM_,
                  _sL_,
                  _sK_]}}
    function trans(ty1,match)
     {if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:var switch$0=0;break;
          case 11:var switch$0=1;break;
          case 12:var switch$0=2;break;
          case 13:var switch$0=3;break;
          case 14:var switch$0=4;break;
          case 8:var switch$0=5;break;
          case 9:var switch$0=6;break;
          default:throw [0,Assert_failure,_aa_]}
      else
       switch(ty1[0])
        {case 0:
          var _r8_=ty1[1];
          if(typeof match === "number")
           var switch$1=1;
          else
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_r8_,rest2)];
             case 8:var switch$0=5,switch$1=0;break;
             case 9:var switch$0=6,switch$1=0;break;
             case 10:var switch$0=0,switch$1=0;break;
             case 11:var switch$0=1,switch$1=0;break;
             case 12:var switch$0=2,switch$1=0;break;
             case 13:var switch$0=3,switch$1=0;break;
             case 14:var switch$0=4,switch$1=0;break;
             default:var switch$1=1}
          if(switch$1)var switch$0=7;
          break;
         case 1:
          var _r9_=ty1[1];
          if(typeof match === "number")
           var switch$2=1;
          else
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_r9_,rest2$0)];
             case 8:var switch$0=5,switch$2=0;break;
             case 9:var switch$0=6,switch$2=0;break;
             case 10:var switch$0=0,switch$2=0;break;
             case 11:var switch$0=1,switch$2=0;break;
             case 12:var switch$0=2,switch$2=0;break;
             case 13:var switch$0=3,switch$2=0;break;
             case 14:var switch$0=4,switch$2=0;break;
             default:var switch$2=1}
          if(switch$2)var switch$0=7;
          break;
         case 2:
          var _r__=ty1[1];
          if(typeof match === "number")
           var switch$3=1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_r__,rest2$1)];
             case 8:var switch$0=5,switch$3=0;break;
             case 9:var switch$0=6,switch$3=0;break;
             case 10:var switch$0=0,switch$3=0;break;
             case 11:var switch$0=1,switch$3=0;break;
             case 12:var switch$0=2,switch$3=0;break;
             case 13:var switch$0=3,switch$3=0;break;
             case 14:var switch$0=4,switch$3=0;break;
             default:var switch$3=1}
          if(switch$3)var switch$0=7;
          break;
         case 3:
          var _r$_=ty1[1];
          if(typeof match === "number")
           var switch$4=1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_r$_,rest2$2)];
             case 8:var switch$0=5,switch$4=0;break;
             case 9:var switch$0=6,switch$4=0;break;
             case 10:var switch$0=0,switch$4=0;break;
             case 11:var switch$0=1,switch$4=0;break;
             case 12:var switch$0=2,switch$4=0;break;
             case 13:var switch$0=3,switch$4=0;break;
             case 14:var switch$0=4,switch$4=0;break;
             default:var switch$4=1}
          if(switch$4)var switch$0=7;
          break;
         case 4:
          var _sa_=ty1[1];
          if(typeof match === "number")
           var switch$5=1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_sa_,rest2$3)];
             case 8:var switch$0=5,switch$5=0;break;
             case 9:var switch$0=6,switch$5=0;break;
             case 10:var switch$0=0,switch$5=0;break;
             case 11:var switch$0=1,switch$5=0;break;
             case 12:var switch$0=2,switch$5=0;break;
             case 13:var switch$0=3,switch$5=0;break;
             case 14:var switch$0=4,switch$5=0;break;
             default:var switch$5=1}
          if(switch$5)var switch$0=7;
          break;
         case 5:
          var _sb_=ty1[1];
          if(typeof match === "number")
           var switch$6=1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_sb_,rest2$4)];
             case 8:var switch$0=5,switch$6=0;break;
             case 9:var switch$0=6,switch$6=0;break;
             case 10:var switch$0=0,switch$6=0;break;
             case 11:var switch$0=1,switch$6=0;break;
             case 12:var switch$0=2,switch$6=0;break;
             case 13:var switch$0=3,switch$6=0;break;
             case 14:var switch$0=4,switch$6=0;break;
             default:var switch$6=1}
          if(switch$6)var switch$0=7;
          break;
         case 6:
          var _sc_=ty1[1];
          if(typeof match === "number")
           var switch$7=1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_sc_,rest2$5)];
             case 8:var switch$0=5,switch$7=0;break;
             case 9:var switch$0=6,switch$7=0;break;
             case 10:var switch$0=0,switch$7=0;break;
             case 11:var switch$0=1,switch$7=0;break;
             case 12:var switch$0=2,switch$7=0;break;
             case 13:var switch$0=3,switch$7=0;break;
             case 14:var switch$0=4,switch$7=0;break;
             default:var switch$7=1}
          if(switch$7)var switch$0=7;
          break;
         case 7:
          var _sd_=ty1[1];
          if(typeof match === "number")
           var switch$8=1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_sd_,rest2$6)];
             case 8:var switch$0=5,switch$8=0;break;
             case 9:var switch$0=6,switch$8=0;break;
             case 10:var switch$0=0,switch$8=0;break;
             case 11:var switch$0=1,switch$8=0;break;
             case 12:var switch$0=2,switch$8=0;break;
             case 13:var switch$0=3,switch$8=0;break;
             case 14:var switch$0=4,switch$8=0;break;
             default:var switch$8=1}
          if(switch$8)var switch$0=7;
          break;
         case 8:
          var _se_=ty1[2],_sf_=ty1[1];
          if(typeof match === "number")
           var switch$9=1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_sg_=trans(_se_,rest2$7);
              return [8,trans(_sf_,ty2),_sg_];
             case 10:var switch$0=0,switch$9=0;break;
             case 11:var switch$0=1,switch$9=0;break;
             case 12:var switch$0=2,switch$9=0;break;
             case 13:var switch$0=3,switch$9=0;break;
             case 14:var switch$0=4,switch$9=0;break;
             default:var switch$9=1}
          if(switch$9)throw [0,Assert_failure,_aj_];
          break;
         case 9:
          var _sh_=ty1[3],_si_=ty1[2],_sj_=ty1[1];
          if(typeof match === "number")
           var switch$10=1;
          else
           switch(match[0])
            {case 8:var switch$0=5,switch$10=0;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_si_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_sj_,ty22,trans(_sh_,rest2$8)];
             case 10:var switch$0=0,switch$10=0;break;
             case 11:var switch$0=1,switch$10=0;break;
             case 12:var switch$0=2,switch$10=0;break;
             case 13:var switch$0=3,switch$10=0;break;
             case 14:var switch$0=4,switch$10=0;break;
             default:var switch$10=1}
          if(switch$10)throw [0,Assert_failure,_ak_];
          break;
         case 10:
          var _sk_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_sk_,rest2$9)]}
          throw [0,Assert_failure,_al_];
         case 11:
          var _sl_=ty1[1];
          if(typeof match === "number")
           var switch$11=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$11=0;break;
             case 11:var rest2$10=match[1];return [11,trans(_sl_,rest2$10)];
             default:var switch$11=1}
          if(switch$11)throw [0,Assert_failure,_am_];
          break;
         case 12:
          var _sm_=ty1[1];
          if(typeof match === "number")
           var switch$12=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$12=0;break;
             case 11:var switch$0=1,switch$12=0;break;
             case 12:var rest2$11=match[1];return [12,trans(_sm_,rest2$11)];
             default:var switch$12=1}
          if(switch$12)throw [0,Assert_failure,_an_];
          break;
         case 13:
          var _sn_=ty1[1];
          if(typeof match === "number")
           var switch$13=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$13=0;break;
             case 11:var switch$0=1,switch$13=0;break;
             case 12:var switch$0=2,switch$13=0;break;
             case 13:var rest2$12=match[1];return [13,trans(_sn_,rest2$12)];
             default:var switch$13=1}
          if(switch$13)throw [0,Assert_failure,_ao_];
          break;
         default:
          var _so_=ty1[1];
          if(typeof match === "number")
           var switch$14=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$14=0;break;
             case 11:var switch$0=1,switch$14=0;break;
             case 12:var switch$0=2,switch$14=0;break;
             case 13:var switch$0=3,switch$14=0;break;
             case 14:var rest2$13=match[1];return [14,trans(_so_,rest2$13)];
             default:var switch$14=1}
          if(switch$14)throw [0,Assert_failure,_ap_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ad_];
        case 1:throw [0,Assert_failure,_ae_];
        case 2:throw [0,Assert_failure,_af_];
        case 3:throw [0,Assert_failure,_ag_];
        case 4:throw [0,Assert_failure,_ah_];
        case 5:throw [0,Assert_failure,_ab_];
        case 6:throw [0,Assert_failure,_ac_];
        default:throw [0,Assert_failure,_ai_]}}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _r6_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_r7_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _r7_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_r7_,_r6_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?0 === prec?fmtty:[2,fmtty]:fmtty}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mismatch,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _r5_=match[2];
        if(typeof _r5_ !== "number" && 2 === _r5_[0])
         {var rest$0=_r5_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_format(fmt,fmtty)
     {var _r4_=type_format_gen(fmt,fmtty);
      if(typeof _r4_[2] === "number"){var fmt$0=_r4_[1];return fmt$0}
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _rz_=type_padding(pad,fmtty),
           _rA_=_rz_[2],
           _rB_=_rz_[1];
          if(typeof _rA_ !== "number" && 1 === _rA_[0])
           {var
             fmtty_rest$1=_rA_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_rB_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _rC_=type_padding(pad$0,fmtty),
           _rD_=_rC_[2],
           _rE_=_rC_[1];
          if(typeof _rD_ !== "number" && 1 === _rD_[0])
           {var
             fmtty_rest$2=_rD_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_rE_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _rF_=type_padprec(pad$1,prec,fmtty),
           _rG_=_rF_[3],
           _rH_=_rF_[2],
           _rI_=_rF_[1];
          if(typeof _rG_ !== "number" && 2 === _rG_[0])
           {var
             fmtty_rest$3=_rG_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_rI_,_rH_,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _rJ_=type_padprec(pad$2,prec$0,fmtty),
           _rK_=_rJ_[3],
           _rL_=_rJ_[2],
           _rM_=_rJ_[1];
          if(typeof _rK_ !== "number" && 3 === _rK_[0])
           {var
             fmtty_rest$4=_rK_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_rM_,_rL_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _rN_=type_padprec(pad$3,prec$1,fmtty),
           _rO_=_rN_[3],
           _rP_=_rN_[2],
           _rQ_=_rN_[1];
          if(typeof _rO_ !== "number" && 4 === _rO_[0])
           {var
             fmtty_rest$5=_rO_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_rQ_,_rP_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _rR_=type_padprec(pad$4,prec$2,fmtty),
           _rS_=_rR_[3],
           _rT_=_rR_[2],
           _rU_=_rR_[1];
          if(typeof _rS_ !== "number" && 5 === _rS_[0])
           {var
             fmtty_rest$6=_rS_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_rU_,_rT_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _rV_=type_padprec(pad$5,prec$3,fmtty),
           _rW_=_rV_[3],
           _rX_=_rV_[2],
           _rY_=_rV_[1];
          if(typeof _rW_ !== "number" && 6 === _rW_[0])
           {var
             fmtty_rest$7=_rW_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_rY_,_rX_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _rZ_=type_padding(pad$6,fmtty),
           _r0_=_rZ_[2],
           _r1_=_rZ_[1];
          if(typeof _r0_ !== "number" && 7 === _r0_[0])
           {var
             fmtty_rest$8=_r0_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_r1_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _r2_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_r2_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _r3_=type_ignored_format_substitution(sub_fmtty$3,rest,fmtty),
               match$27=_r3_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_r3_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substitution(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substitution(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substitution
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substitution
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substitution
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substitution
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substitution
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substitution
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substitution
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substitution
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _rx_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_rx_))
             throw Type_mismatch;
            var _ry_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_ry_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substitution
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substitution
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substitution
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substitution
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substitution
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _rw_=2 === padty$0?48:32,res=make(width$0,_rw_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         if(0 < len)
          {if(43 === caml_string_get(str,0))
            var switch$1=1;
           else
            if(45 === caml_string_get(str,0))
             var switch$1=1;
            else
             if(32 === caml_string_get(str,0))
              var switch$1=1;
             else
              var switch$0=0,switch$1=0;
           if(switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0);
             var switch$0=1}}
         else
          var switch$0=0;
         if(! switch$0)
          {if(1 < len)
            if(48 === caml_string_get(str,0))
             {if(120 === caml_string_get(str,1))
               var switch$3=1;
              else
               if(88 === caml_string_get(str,1))
                var switch$3=1;
               else
                var switch$2=0,switch$3=0;
              if(switch$3)
               {caml_bytes_set(res,1,caml_string_get(str,1));
                blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0);
                var switch$2=1}}
            else
             var switch$2=0;
           else
            var switch$2=0;
           if(! switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0);
      if(58 <= c)
       var switch$0=71 <= c?5 < (c - 97 | 0) >>> 0?1:0:65 <= c?0:1;
      else
       {if(32 === c)
         var switch$1=1;
        else
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0))
               if(1 < len)
                {var
                  switch$2=
                   120 === caml_string_get(str,1)
                    ?0
                    :88 === caml_string_get(str,1)?0:1;
                 if(! switch$2)
                  {var res$1=make(prec$0 + 2 | 0,48);
                   caml_bytes_set(res$1,1,caml_string_get(str,1));
                   blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                   return caml_string_of_bytes(res$1)}}
              var switch$0=0,switch$1=0;
              break;
             case 0:
             case 2:var switch$1=1;break;
             case 1:
             case 3:
             case 4:var switch$0=1,switch$1=0;break;
             default:var switch$0=0,switch$1=0}}
         else
          var switch$0=1,switch$1=0;
        if(switch$1)
         {if(len < (prec$0 + 1 | 0))
           {var res$0=make(prec$0 + 1 | 0,48);
            caml_bytes_set(res$0,0,c);
            blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
            return caml_string_of_bytes(res$0)}
          var switch$0=1}}
      if(! switch$0)
       if(len < prec$0)
        {var res=make(prec$0,48);
         blit$0(str,0,res,prec$0 - len | 0,len);
         return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_rr_=caml_ml_string_length(s) - 1 | 0,_rq_=0;
        if(! (_rr_ < 0))
         {var i$0=_rq_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _rv_=i$0 + 1 | 0;
            if(_rr_ !== i$0){var i$0=_rv_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _rt_=caml_ml_string_length(s) - 1 | 0,
         _rs_=0;
        if(! (_rt_ < 0))
         {var i=_rs_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _ru_=i + 1 | 0;
            if(_rt_ !== i){var i=_ru_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _rp_=cst_d$3;break;
        case 2:var _rp_=cst_d$4;break;
        case 4:var _rp_=cst_i$1;break;
        case 5:var _rp_=cst_i$2;break;
        case 6:var _rp_=cst_x;break;
        case 7:var _rp_=cst_x$0;break;
        case 8:var _rp_=cst_X$0;break;
        case 9:var _rp_=cst_X$1;break;
        case 10:var _rp_=cst_o;break;
        case 11:var _rp_=cst_o$0;break;
        case 0:
        case 13:var _rp_=cst_d$2;break;
        case 3:
        case 14:var _rp_=cst_i$0;break;
        default:var _rp_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_rp_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _ro_=cst_ld$0;break;
        case 2:var _ro_=cst_ld$1;break;
        case 4:var _ro_=cst_li$1;break;
        case 5:var _ro_=cst_li$2;break;
        case 6:var _ro_=cst_lx;break;
        case 7:var _ro_=cst_lx$0;break;
        case 8:var _ro_=cst_lX;break;
        case 9:var _ro_=cst_lX$0;break;
        case 10:var _ro_=cst_lo;break;
        case 11:var _ro_=cst_lo$0;break;
        case 0:
        case 13:var _ro_=cst_ld;break;
        case 3:
        case 14:var _ro_=cst_li$0;break;
        default:var _ro_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_ro_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _rn_=cst_nd$0;break;
        case 2:var _rn_=cst_nd$1;break;
        case 4:var _rn_=cst_ni$1;break;
        case 5:var _rn_=cst_ni$2;break;
        case 6:var _rn_=cst_nx;break;
        case 7:var _rn_=cst_nx$0;break;
        case 8:var _rn_=cst_nX;break;
        case 9:var _rn_=cst_nX$0;break;
        case 10:var _rn_=cst_no;break;
        case 11:var _rn_=cst_no$0;break;
        case 0:
        case 13:var _rn_=cst_nd;break;
        case 3:
        case 14:var _rn_=cst_ni$0;break;
        default:var _rn_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_rn_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _rm_=cst_Ld$0;break;
        case 2:var _rm_=cst_Ld$1;break;
        case 4:var _rm_=cst_Li$1;break;
        case 5:var _rm_=cst_Li$2;break;
        case 6:var _rm_=cst_Lx;break;
        case 7:var _rm_=cst_Lx$0;break;
        case 8:var _rm_=cst_LX;break;
        case 9:var _rm_=cst_LX$0;break;
        case 10:var _rm_=cst_Lo;break;
        case 11:var _rm_=cst_Lo$0;break;
        case 0:
        case 13:var _rm_=cst_Ld;break;
        case 3:
        case 14:var _rm_=cst_Li$0;break;
        default:var _rm_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_rm_,n))}
    function convert_float(fconv,prec$0,x)
     {if(16 <= fconv)
       {if(17 <= fconv)
         switch(fconv - 17 | 0)
          {case 2:var switch$0=0;break;
           case 0:
           case 3:var sign=43,switch$0=1;break;
           default:var sign=32,switch$0=1}
        else
         var switch$0=0;
        if(! switch$0)var sign=45;
        var str=runtime.caml_hexstring_of_float(x,prec$0,sign);
        return 19 <= fconv?uppercase_ascii$1(str):str}
      if(15 === fconv)
       var _rj_=cst_12g$0;
      else
       {var prec=abs(prec$0),symb=char_of_fconv(fconv),buf=buffer_create(16);
        buffer_add_char(buf,37);
        bprint_fconv_flag(buf,fconv);
        buffer_add_char(buf,46);
        buffer_add_string(buf,caml_new_string("" + prec));
        buffer_add_char(buf,symb);
        var _rj_=buffer_contents(buf)}
      var str$0=caml_format_float(_rj_,x);
      if(15 === fconv)
       {var
         len=caml_ml_string_length(str$0),
         match$0=runtime.caml_classify_float(x);
        if(3 === match$0)return x < 0.?cst_neg_infinity:cst_infinity;
        if(4 <= match$0)return cst_nan;
        var i=0;
        for(;;)
         {if(i === len)
           var _rl_=0;
          else
           {var
             match=caml_string_get(str$0,i),
             _rk_=match - 46 | 0,
             switch$1=
              23 < _rk_ >>> 0?55 === _rk_?1:0:21 < (_rk_ - 1 | 0) >>> 0?1:0;
            if(! switch$1){var i$0=i + 1 | 0,i=i$0;continue}
            var _rl_=1}
          return _rl_?str$0:_g_(str$0,cst$28)}}
      return str$0}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_int_padding_precision(k,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _rg_=pad[2],_rh_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_rh_,_rg_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_rh_,_rg_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_rh_,_rg_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _ri_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_ri_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_ri_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_ri_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var str=convert_float(fconv,default_float_precision,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _rd_=pad$5[2],_re_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision,x),
                            str$0=fix_padding(_re_,_rd_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_re_,_rd_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_re_,_rd_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _rf_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision,x),
                          str$0=fix_padding(_rf_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_rf_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_rf_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _rb_=fmt$0[1];
           if(0 === _rb_[0])
            {var
              rest$13=fmt$0[2],
              match=_rb_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_rb_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_aq_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _rc_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_rc_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_rc_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_ar_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_ra_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_as_];
         default:throw [0,Assert_failure,_at_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _q$_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_q$_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_q$_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _q__=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_q__,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_q__,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {var _qG_=make_iprintf(k,o,fmt);return function(_qY_){return _qG_}}
          var _qH_=make_iprintf(k,o,fmt),_qI_=function(_qX_){return _qH_};
          return function(_qW_){return _qI_}}
        var _qJ_=make_iprintf(k,o,fmt);
        return function(_qV_){return _qJ_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(0 === prec)
             {var _qK_=make_iprintf(k,o,fmt);
              return function(_q9_){return _qK_}}
            var _qL_=make_iprintf(k,o,fmt),_qM_=function(_q8_){return _qL_};
            return function(_q7_){return _qM_}}
          var _qN_=make_iprintf(k,o,fmt);
          return function(_q6_){return _qN_}}
        if(typeof prec === "number")
         {if(0 === prec)
           {var _qO_=make_iprintf(k,o,fmt),_qP_=function(_q5_){return _qO_};
            return function(_q4_){return _qP_}}
          var
           _qQ_=make_iprintf(k,o,fmt),
           _qR_=function(_q3_){return _qQ_},
           _qS_=function(_q2_){return _qR_};
          return function(_q1_){return _qS_}}
        var _qT_=make_iprintf(k,o,fmt),_qU_=function(_q0_){return _qT_};
        return function(_qZ_){return _qU_}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_pX_=make_iprintf(k$0,o,rest);
           return function(_qF_){return _pX_};
          case 1:
           var rest$0=fmt$0[1],_pY_=make_iprintf(k$0,o,rest$0);
           return function(_qE_){return _pY_};
          case 2:
           var _pZ_=fmt$0[1];
           if(typeof _pZ_ === "number")
            {var rest$1=fmt$0[2],_p0_=make_iprintf(k$0,o,rest$1);
             return function(_qA_){return _p0_}}
           else
            {if(0 === _pZ_[0])
              {var rest$2=fmt$0[2],_p1_=make_iprintf(k$0,o,rest$2);
               return function(_qD_){return _p1_}}
             var
              rest$3=fmt$0[2],
              _p2_=make_iprintf(k$0,o,rest$3),
              _p3_=function(_qC_){return _p2_};
             return function(_qB_){return _p3_}}
          case 3:
           var _p4_=fmt$0[1];
           if(typeof _p4_ === "number")
            {var rest$4=fmt$0[2],_p5_=make_iprintf(k$0,o,rest$4);
             return function(_qw_){return _p5_}}
           else
            {if(0 === _p4_[0])
              {var rest$5=fmt$0[2],_p6_=make_iprintf(k$0,o,rest$5);
               return function(_qz_){return _p6_}}
             var
              rest$6=fmt$0[2],
              _p7_=make_iprintf(k$0,o,rest$6),
              _p8_=function(_qy_){return _p7_};
             return function(_qx_){return _p8_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _p9_=fmt$0[1];
           if(typeof _p9_ === "number")
            {var rest$12=fmt$0[2],_p__=make_iprintf(k$0,o,rest$12);
             return function(_qs_){return _p__}}
           else
            {if(0 === _p9_[0])
              {var rest$13=fmt$0[2],_p$_=make_iprintf(k$0,o,rest$13);
               return function(_qv_){return _p$_}}
             var
              rest$14=fmt$0[2],
              _qa_=make_iprintf(k$0,o,rest$14),
              _qb_=function(_qu_){return _qa_};
             return function(_qt_){return _qb_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_qc_=make_iprintf(k$0,o,rest$15);
           return function(_qr_){return _qc_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _qd_=make_iprintf(k$0,o,rest$17),
            _qe_=function(_qq_){return _qd_};
           return function(_qp_){return _qe_};
          case 16:
           var rest$18=fmt$0[1],_qf_=make_iprintf(k$0,o,rest$18);
           return function(_qo_){return _qf_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _qg_=fmt$0[1];
           if(0 === _qg_[0])
            {var
              rest$19=fmt$0[2],
              match=_qg_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_qg_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_au_];
          case 20:
           var rest$21=fmt$0[3],_qh_=make_iprintf(k$0,o,rest$21);
           return function(_qn_){return _qh_};
          case 21:
           var rest$22=fmt$0[2],_qi_=make_iprintf(k$0,o,rest$22);
           return function(_qm_){return _qi_};
          case 22:
           var rest$23=fmt$0[1],_qj_=make_iprintf(k$0,o,rest$23);
           return function(_ql_){return _qj_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_qk_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_qk_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_pV_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_pW_){return _pV_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _pT_=acc$0[2],_pU_=acc$0[1];
           if(0 === _pT_[0])
            {var acc$1=_pT_[1];
             output_acc(o,_pU_);
             output_string(o,cst$29);
             var acc$0=acc$1;
             continue}
           var acc$2=_pT_[1];
           output_acc(o,_pU_);
           output_string(o,cst$30);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pR_=acc$0[2],_pS_=acc$0[1];
           if(0 === _pR_[0])
            {var acc$1=_pR_[1];
             bufput_acc(b,_pS_);
             add_string(b,cst$31);
             var acc$0=acc$1;
             continue}
           var acc$2=_pR_[1];
           bufput_acc(b,_pS_);
           add_string(b,cst$32);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pP_=acc$0[2],_pQ_=acc$0[1];
           if(0 === _pP_[0])
            {var acc$1=_pP_[1];
             strput_acc(b,_pQ_);
             add_string(b,cst$33);
             var acc$0=acc$1;
             continue}
           var acc$2=_pP_[1];
           strput_acc(b,_pQ_);
           add_string(b,cst$34);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$35))return _av_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_aw_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match)if(32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var
           match=caml_string_get(str,j$0),
           switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _pN_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_pN_}
       catch(_pO_)
        {_pO_ = caml_wrap_exception(_pO_);
         if(_pO_[1] !== Failure)throw _pO_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      if(caml_string_notequal(box_name,cst$36))
       if(caml_string_notequal(box_name,cst_b$0))
        if(caml_string_notequal(box_name,cst_h))
         if(caml_string_notequal(box_name,cst_hov))
          if(caml_string_notequal(box_name,cst_hv))
           if(caml_string_notequal(box_name,cst_v))
            var box_type=invalid_box(0),switch$0=1;
           else
            var box_type=1,switch$0=1;
          else
           var box_type=2,switch$0=1;
         else
          var box_type=3,switch$0=1;
        else
         var box_type=0,switch$0=1;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=0 === prec?[0,0,fmt]:[0,1,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ax_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_ay_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_az_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _pM_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_pM_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aL_;
            else
             {var c=caml_string_get(str,str_ind$0);
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  var switch$0=0;
                 else
                  switch(switcher)
                   {case 0:
                     var
                      match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]],
                      switch$0=1}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var
                      match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]],
                      switch$0=1}}
                else
                 var switch$0=0;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]],
                 switch$0=1;
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aM_,fmt_rest$5]],
                      switch$0=1;
                     break;
                    case 5:
                     if((str_ind$0 + 1 | 0) < end_ind)
                      if(37 === caml_string_get(str,str_ind$0 + 1 | 0))
                       var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]],
                        switch$0=1,
                        switch$1=0;
                      else
                       var switch$1=1;
                     else
                      var switch$1=1;
                     if(switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]],
                       switch$0=1;
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aN_,fmt_rest$8]],
                      switch$0=1;
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]],
                      switch$0=1;
                     break;
                    case 27:
                     var
                      match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 28:
                     var
                      match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]],
                      switch$0=1;
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]],
                      switch$0=1;
                     break;
                    default:var switch$0=0}}
                else
                 var switch$0=0;
              if(! switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number")if(0 === match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aF_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$37);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$38)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        if(124 <= symb)
         var switch$0=0;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]],
             switch$0=1;
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _pl_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _pl_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_pl_,switch$0=1;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind),switch$0=1;break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _pn_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_pn_,
             switch$0=1;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_pt_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _pt_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_pt_,switch$0=1;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _pu_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _pu_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_pu_,switch$0=1;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _pL_=i + 1 | 0;
                    if(c !== i){var i=_pL_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aP_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _pK_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_pK_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_pK_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0);
                  if(46 <= c$1)
                   if(64 === c$1)
                    var switch$0=0;
                   else
                    {if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}
                     var switch$0=1}
                  else
                   if(37 === c$1)
                    var switch$0=0;
                   else
                    {if(45 <= c$1)
                      {var str_ind$2=str_ind$0 + 1 | 0;
                       if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                       var c$2=caml_string_get(str,str_ind$2);
                       if(37 === c$2)
                        {if((str_ind$2 + 1 | 0) === end_ind)
                          unexpected_end_of_format(end_ind);
                         var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                         if(37 !== c$3)
                          if(64 !== c$3)return fail_single_percent(str_ind$2);
                         add_range(c$0,c$3);
                         var _pI_=str_ind$2 + 2 | 0;
                         if(counter < 50)
                          {var counter$2=counter + 1 | 0;
                           return parse_char_set_content(counter$2,_pI_,end_ind)}
                         return caml_trampoline_return
                                 (parse_char_set_content,[0,_pI_,end_ind])}
                       if(93 === c$2)
                        {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                       add_range(c$0,c$2);
                       var _pJ_=str_ind$2 + 1 | 0;
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return parse_char_set_content(counter$1,_pJ_,end_ind)}
                       return caml_trampoline_return
                               (parse_char_set_content,[0,_pJ_,end_ind])}
                     var switch$0=1}
                  if(! switch$0)
                   if(37 === c$0)
                    {add_char(c$1);
                     var _pH_=str_ind$0 + 1 | 0;
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return parse_char_set_content(counter$0,_pH_,end_ind)}
                     return caml_trampoline_return
                             (parse_char_set_content,[0,_pH_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,str_ind$1=str_ind$0,reverse=1;
            else
             var str_ind$1=str_ind,reverse=0;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _pz_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _pz_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_pz_,switch$0=1;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]],
             switch$0=1;
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _pA_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _pB_=_pA_;
              else
               var
                _pB_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,
                     cst_non_zero_widths_are_unsupported_for_c_conversions);
              var _pC_=_pB_}
            else
             var _pC_=char_format(fmt_rest$21);
            var fmt_result=_pC_,switch$0=1;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _pD_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_pD_,
             switch$0=1;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _pE_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _pE_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_pE_,switch$0=1;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]],
             switch$0=1;
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _pF_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _pF_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_pF_,switch$0=1;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _pm_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _pm_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_pm_,switch$0=1;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]],
             switch$0=1;
            break;
           case 76:
           case 108:
           case 110:
            if(str_ind === end_ind)
             var switch$1=1;
            else
             {var symb$0=caml_string_get(str,str_ind),_pG_=symb$0 - 88 | 0;
              if(32 < _pG_ >>> 0)
               var switch$2=0;
              else
               switch(_pG_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _ps_=1,switch$2=1;break;
                 default:var switch$2=0}
              if(! switch$2)var _ps_=0;
              if(_ps_)var switch$0=0,switch$1=0;else var switch$1=1}
            if(switch$1)
             {var match$15=parse(str_ind,end_ind),fmt_rest$13=match$15[1];
              if(108 <= symb)
               if(111 <= symb)
                var switch$3=0;
               else
                {var switcher$0=symb - 108 | 0;
                 switch(switcher$0)
                  {case 0:var counter=0,switch$3=1;break;
                   case 1:var switch$3=0;break;
                   default:var counter=1,switch$3=1}}
              else
               if(76 === symb)var counter=2,switch$3=1;else var switch$3=0;
              if(! switch$3)throw [0,Assert_failure,_aT_];
              if(get_ign(0))
               var ignored$5=[11,counter],_pr_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _pr_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_pr_,switch$0=1}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=caml_call3(failwith_message(_aK_),str,pct_ind,symb),
             switch$0=1;
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _pv_=get_space(0),
             _pw_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_pw_,_pv_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _px_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _py_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_py_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _px_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_px_,switch$0=1;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             plus$2=get_plus(0),
             plus$3=plus$2,
             space$2=space$1;
            for(;;)
             {if(0 === plus$3)
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$1=symb - 101 | 0;
                   if(3 < switcher$1 >>> 0)
                    var switch$4=0;
                   else
                    switch(switcher$1)
                     {case 0:var fconv=3,switch$4=1;break;
                      case 1:var fconv=0,switch$4=1;break;
                      case 2:var fconv=9,switch$4=1;break;
                      default:var fconv=16,switch$4=1}}
                 else
                  if(69 <= symb)
                   {var switcher$2=symb - 69 | 0;
                    switch(switcher$2)
                     {case 0:var fconv=6,switch$4=1;break;
                      case 1:var fconv=15,switch$4=1;break;
                      case 2:var fconv=12,switch$4=1;break;
                      default:var fconv=19,switch$4=1}}
                  else
                   var switch$4=0;
                 if(! switch$4)throw [0,Assert_failure,_aV_]}
               else
                {if(73 <= symb)
                  {var switcher$3=symb - 101 | 0;
                   if(3 < switcher$3 >>> 0)
                    var switch$5=0;
                   else
                    switch(switcher$3)
                     {case 0:var fconv=5,switch$5=1;break;
                      case 1:var fconv=2,switch$5=1;break;
                      case 2:var fconv=11,switch$5=1;break;
                      default:var fconv=18,switch$5=1}}
                 else
                  if(69 <= symb)
                   {var switcher$4=symb - 69 | 0;
                    switch(switcher$4)
                     {case 0:var fconv=8,switch$5=1;break;
                      case 1:var switch$5=0;break;
                      case 2:var fconv=14,switch$5=1;break;
                      default:var fconv=21,switch$5=1}}
                  else
                   var switch$5=0;
                 if(! switch$5)
                  {if(legacy_behavior$0){var space$2=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$49)}}
              else
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$5=symb - 101 | 0;
                   if(3 < switcher$5 >>> 0)
                    var switch$6=0;
                   else
                    switch(switcher$5)
                     {case 0:var fconv=4,switch$6=1;break;
                      case 1:var fconv=1,switch$6=1;break;
                      case 2:var fconv=10,switch$6=1;break;
                      default:var fconv=17,switch$6=1}}
                 else
                  if(69 <= symb)
                   {var switcher$6=symb - 69 | 0;
                    switch(switcher$6)
                     {case 0:var fconv=7,switch$6=1;break;
                      case 1:var switch$6=0;break;
                      case 2:var fconv=13,switch$6=1;break;
                      default:var fconv=20,switch$6=1}}
                  else
                   var switch$6=0;
                 if(! switch$6)
                  {if(legacy_behavior$0){var plus$3=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$50)}}
               else
                {if(legacy_behavior$0){var space$2=0;continue}
                 var fconv=incompatible_flag(pct_ind,str_ind,32,cst$51)}
              var match$13=parse(str_ind,end_ind),fmt_rest$11=match$13[1];
              if(get_ign(0))
               {var match=get_prec(0);
                if(typeof match === "number")
                 var
                  _po_=
                   0 === match?0:incompatible_flag(pct_ind,str_ind,95,cst$39);
                else
                 var ndec=match[1],_po_=[0,ndec];
                var
                 ignored$4=[6,get_pad_opt(95),_po_],
                 _pp_=[0,[23,ignored$4,fmt_rest$11]]}
              else
               var
                _pq_=get_prec(0),
                match$14=make_padprec_fmt_ebb(get_pad(0),_pq_,fmt_rest$11),
                fmt_rest$12=match$14[3],
                prec$3=match$14[2],
                pad$5=match$14[1],
                _pp_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
              var fmt_result=_pp_,switch$0=1;
              break}
            break;
           default:var switch$0=0}
        if(! switch$0)
         {if(108 <= symb)
           if(111 <= symb)
            var switch$7=0;
           else
            {var switcher=symb - 108 | 0;
             switch(switcher)
              {case 0:
                var
                 _o7_=caml_string_get(str,str_ind),
                 _o8_=get_space(0),
                 _o9_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_o9_,_o8_,_o7_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _o__=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _pa_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_pa_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _o__=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _o$_=_o__,switch$8=1;
                break;
               case 1:var switch$7=0,switch$8=0;break;
               default:
                var
                 _pb_=caml_string_get(str,str_ind),
                 _pc_=get_space(0),
                 _pd_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_pd_,_pc_,_pb_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _pe_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _pf_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_pf_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _pe_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _o$_=_pe_,switch$8=1}
             if(switch$8)var fmt_result=_o$_,switch$7=1}
          else
           if(76 === symb)
            {var
              _pg_=caml_string_get(str,str_ind),
              _ph_=get_space(0),
              _pi_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_pi_,_ph_,_pg_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _pj_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _pk_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_pk_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _pj_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_pj_,switch$7=1}
           else
            var switch$7=0;
          if(! switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aH_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _oY_=1 - plus_used[1],plus$0=_oY_?plus:_oY_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$40);
          var _oZ_=1 - hash_used[1],hash$0=_oZ_?hash:_oZ_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _o0_=1 - space_used[1],space$0=_o0_?space:_o0_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _o1_=1 - pad_used[1],_o2_=_o1_?caml_notequal([0,pad],_aI_):_o1_;
          if(_o2_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _o3_=1 - prec_used[1],
           _o4_=_o3_?caml_notequal([0,prec],_aJ_):_o3_;
          if(_o4_)
           {var _o5_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_o5_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$43)}
        var _o6_=1 - ign_used[1],ign$0=_o6_?ign:_o6_;
        if(ign$0)
         {var
           switch$9=
            38 <= symb
             ?44 === symb?0:64 === symb?0:1
             :33 === symb?0:37 <= symb?0:1,
           switch$10=switch$9?0:legacy_behavior$0?1:0;
          if(! switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$44)}
        return fmt_result}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number")if(0 === match)return parse_conv(0);
          if(0 === minus)
           {if(typeof match === "number")return parse_conv(_aD_);
            var n=match[1];
            return parse_conv([0,1,n])}
          if(typeof match === "number")return parse_conv(_aE_);
          var n$0=match[1];
          return parse_conv([0,0,n$0])}
        return parse_conv(pad)}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _oX_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_oX_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aC_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _oU_=flag[1],_oV_=_oU_?1 - legacy_behavior$0:_oU_;
          if(_oV_)
           {var _oW_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aA_),str,str_ind,_oW_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _oP_=space[1],
           _oQ_=hash[1],
           _oR_=plus[1],
           _oS_=minus[1],
           _oT_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            0 === _oT_
             ?0 === _oS_?1:0
             :0 === _oS_
               ?2
               :legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0),
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _oS_,
                       _oR_,
                       _oQ_,
                       _oP_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _oS_,
                     _oR_,
                     _oQ_,
                     _oP_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oS_,_oR_,_oQ_,_oP_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oS_,_oR_,_oQ_,_oP_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oS_,_oR_,_oQ_,_oP_,ign,_aB_)}}}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str];
            if(is_open_tag)
             var formatting$0=[0,sub_format$0];
            else
             {if(typeof sub_fmt === "number")
               var switch$0=0;
              else
               if(11 === sub_fmt[0])
                if(typeof sub_fmt[2] === "number")
                 {var str$0=sub_fmt[1];
                  try
                   {open_box_of_string(str$0);var switch$1=1}
                  catch(_oO_)
                   {_oO_ = caml_wrap_exception(_oO_);
                    if(_oO_[1] !== Failure)throw _oO_;
                    var switch$0=1,switch$1=0}
                  if(switch$1)var switch$0=1}
                else
                 var switch$0=0;
               else
                var switch$0=0;
              var formatting$0=[1,sub_format$0]}
            var _oM_=[0,[18,formatting$0,fmt_rest$0]];
            return _oM_}
          throw Not_found}
        catch(_oN_)
         {_oN_ = caml_wrap_exception(_oN_);
          if(_oN_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _oN_}}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _oF_=str_ind === end_ind?1:0,
           _oG_=_oF_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_oG_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$0?58 <= match$0?0:1:45 === match$0?1:0;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _oH_=[0,s,width,0],
             _oI_=str_ind_3 + 1 | 0,
             next_ind=_oI_,
             formatting_lit$0=_oH_,
             switch$1=1;
           else
            var switch$1=0;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _oJ_=[0,s$0,width,offset],
               _oK_=str_ind_5 + 1 | 0,
               next_ind=_oK_,
               formatting_lit$0=_oJ_,
               switch$1=1}
            else
             var switch$1=0}
          if(! switch$1)throw Not_found}
        catch(_oL_)
         {_oL_ = caml_wrap_exception(_oL_);
          if(_oL_ !== Not_found)if(_oL_[1] !== Failure)throw _oL_;
          var next_ind=str_ind,formatting_lit$0=formatting_lit}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$2?58 <= match$2?0:1:45 === match$2?1:0;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _oD_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _oD_=0;
          var _oC_=_oD_}
        catch(_oE_)
         {_oE_ = caml_wrap_exception(_oE_);
          if(_oE_ !== Not_found)if(_oE_[1] !== Failure)throw _oE_;
          var _oC_=0}
        if(_oC_)
         {var
           match=_oC_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aO_,fmt_rest$0]]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aQ_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aR_]}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aS_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aW_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {if(0 === plus$0)
           if(0 === hash$0)
            if(0 === space$0)
             {var switcher=symb - 88 | 0;
              if(32 < switcher >>> 0)
               var switch$0=1;
              else
               switch(switcher)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6;
                 default:var switch$0=1}}
            else
             {if(100 === symb)return 2;
              if(105 === symb)return 5;
              var switch$0=1}
           else
            if(0 === space$0)
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               var switch$0=0;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:var switch$0=0}}
            else
             var switch$0=0;
          else
           if(0 === hash$0)
            if(0 === space$0)
             {if(100 === symb)return 1;
              if(105 === symb)return 4;
              var switch$0=1}
            else
             var switch$0=1;
           else
            var switch$0=0;
          if(! switch$0)
           {var switcher$1=symb - 88 | 0;
            if(! (32 < switcher$1 >>> 0))
             switch(switcher$1)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$48)
               }}
          if(0 === plus$0)
           {if(0 === space$0)throw [0,Assert_failure,_aU_];
            if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$45)}
          if(0 === space$0)
           {if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$46)}
          if(legacy_behavior$0){var space$0=0;continue}
          return incompatible_flag(pct_ind,str_ind,32,cst$47)}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _oA_=[0,type_format(fmt,fmtty),str];return _oA_}
      catch(_oB_)
       {_oB_ = caml_wrap_exception(_oB_);
        if(_oB_ === Type_mismatch)
         {var _oz_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aX_),str,_oz_)}
        throw _oB_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _ox_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _ox_}
      catch(_oy_)
       {_oy_ = caml_wrap_exception(_oy_);
        if(_oy_ === Type_mismatch)
         return caml_call2(failwith_message(_aY_),str,str$0);
        throw _oy_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_formatting_gen,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(750,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_ow_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _ow_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_ov_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _ov_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_ou_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_ot_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_os_){return 0},oc,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ksprintf];
    caml_register_global(751,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$0=t;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _or_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_or_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_oq_=_g_(prefix,h);
        return _g_
                (fold_left$0(function(x,y){return _g_(x,_g_(sep,y))},_oq_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a1_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _on_=0,_ol_=_on_}
      catch(_op_)
       {_op_ = caml_wrap_exception(_op_);
        if(_op_ !== Not_found)throw _op_;
        var
         _ol_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_options],0]}
      try
       {assoc3(cst_help$1,speclist);var _om_=0,add2=_om_}
      catch(_oo_)
       {_oo_ = caml_wrap_exception(_oo_);
        if(_oo_ !== Not_found)throw _oo_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_options$0],
           0]}
      return append(speclist,append(_ol_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a2_),errmsg);
      var _oi_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _oj_=0 < caml_ml_string_length(doc)?1:0;
                 if(_oj_)
                  {if(11 === spec[0])
                    {var l=spec[1],_ok_=make_symlist(cst$54,cst$53,cst$52,l);
                     return caml_call3(bprintf(buf,_a0_),key,_ok_,doc)}
                   return caml_call2(bprintf(buf,_aZ_),key,doc)}
                 return _oj_},
               _oi_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _oh_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a3_),_oh_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _of_=[0,bool_of_string(x)];return _of_}
      catch(_og_)
       {_og_ = caml_wrap_exception(_og_);
        if(_og_[1] === Invalid_argument)return 0;
        throw _og_}}
    function int_of_string_opt$0(x)
     {try
       {var _od_=[0,caml_int_of_string(x)];return _od_}
      catch(_oe_)
       {_oe_ = caml_wrap_exception(_oe_);
        if(_oe_[1] === Failure)return 0;
        throw _oe_}}
    function float_of_string_opt(x)
     {try
       {var _ob_=[0,caml_float_of_string(x)];return _ob_}
      catch(_oc_)
       {_oc_ = caml_wrap_exception(_oc_);
        if(_oc_[1] === Failure)return 0;
        throw _oc_}}
    function parse_and_expand_argv_dynamic_aux
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[initpos + 1]
           :cst$55;
        switch(error[0])
         {case 0:
           var _oa_=error[1];
           if(caml_string_notequal(_oa_,cst_help$3))
            if(caml_string_notequal(_oa_,cst_help$4))
             caml_call2(bprintf(b,_a4_),progname,_oa_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a7_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a8_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a9_),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a5_))
         if(! caml_equal(error,_a6_))return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var _n5_=current[1],s=caml_check_bound(argv[1],_n5_)[_n5_ + 1];
            if(1 <= caml_ml_string_length(s))
             if(45 === caml_string_get(s,0))
              {try
                {var
                  follow$1=0,
                  _n7_=assoc3(s,speclist[1]),
                  action=_n7_,
                  follow$0=follow$1}
               catch(_n__)
                {_n__ = caml_wrap_exception(_n__);
                 if(_n__ !== Not_found)throw _n__;
                 try
                  {var
                    match=split$0(s),
                    arg=match[2],
                    keyword=match[1],
                    follow=[0,arg],
                    _n6_=assoc3(keyword,speclist[1])}
                 catch(_n$_)
                  {_n$_ = caml_wrap_exception(_n$_);
                   if(_n$_ === Not_found)throw [0,Stop,[0,s]];
                   throw _n$_}
                 var action=_n6_,follow$0=follow}
               var
                no_arg$0=
                 function(s,follow)
                  {function no_arg(param)
                    {if(follow)
                      {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                     return 0}
                   return no_arg},
                no_arg=no_arg$0(s,follow$0),
                get_arg$0=
                 function(s,follow)
                  {function get_arg(param)
                    {if(follow){var arg=follow[1];return arg}
                     if((current[1] + 1 | 0) < argv[1].length - 1)
                      {var _n9_=current[1] + 1 | 0;
                       return caml_check_bound(argv[1],_n9_)[_n9_ + 1]}
                     throw [0,Stop,[2,s]]}
                   return get_arg},
                get_arg=get_arg$0(s,follow$0),
                consume_arg$0=
                 function(follow)
                  {function consume_arg(param)
                    {return follow?0:(current[1]++,0)}
                   return consume_arg},
                consume_arg=consume_arg$0(follow$0),
                treat_action$0=
                 function(s,no_arg,get_arg,consume_arg)
                  {function treat_action(param)
                    {switch(param[0])
                      {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                       case 1:
                        var
                         f$0=param[1],
                         arg=get_arg(0),
                         match=bool_of_string_opt$0(arg);
                        if(match)
                         {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg,cst_a_boolean]];
                       case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                       case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                       case 4:
                        var f$1=param[1],arg$0=get_arg(0);
                        caml_call1(f$1,arg$0);
                        return consume_arg(0);
                       case 5:
                        var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                       case 6:
                        var
                         f$2=param[1],
                         arg$1=get_arg(0),
                         match$0=int_of_string_opt$0(arg$1);
                        if(match$0)
                         {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                       case 7:
                        var
                         r$2=param[1],
                         arg$2=get_arg(0),
                         match$1=int_of_string_opt$0(arg$2);
                        if(match$1)
                         {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                       case 8:
                        var
                         f$3=param[1],
                         arg$3=get_arg(0),
                         match$2=float_of_string_opt(arg$3);
                        if(match$2)
                         {var x$1=match$2[1];
                          caml_call1(f$3,x$1);
                          return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$3,cst_a_float]];
                       case 9:
                        var
                         r$3=param[1],
                         arg$4=get_arg(0),
                         match$3=float_of_string_opt(arg$4);
                        if(match$3)
                         {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                       case 10:
                        var specs=param[1];
                        no_arg(0);
                        return iter$2(treat_action,specs);
                       case 11:
                        var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                        if(mem(arg$5,symb))
                         {caml_call1(f$4,arg$5);return consume_arg(0)}
                        throw [0,
                               Stop,
                               [1,
                                s,
                                arg$5,
                                _g_(cst_one_of,make_symlist(cst$58,cst$57,cst$56,symb))]];
                       case 12:
                        var f$5=param[1];
                        no_arg(0);
                        for(;;)
                         {if(current[1] < (argv[1].length - 1 - 1 | 0))
                           {var _n8_=current[1] + 1 | 0;
                            caml_call1(f$5,caml_check_bound(argv[1],_n8_)[_n8_ + 1]);
                            consume_arg(0);
                            continue}
                          return 0}
                       default:
                        var f$6=param[1];
                        if(1 - allow_expand)
                         throw [0,
                                Invalid_argument,
                                cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic];
                        var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                        consume_arg(0);
                        var
                         before=sub$1(argv[1],0,current[1] + 1 | 0),
                         after=
                          sub$1
                           (argv[1],
                            current[1] + 1 | 0,
                            (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                        argv[1]
                        =
                        caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                        return 0}}
                   return treat_action},
                treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
               treat_action(action);
               var switch$0=1}
             else
              var switch$0=0;
            else
             var switch$0=0;
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Bad){var m=exn[2];throw convert_error([3,m])}
            if(exn[1] === Stop){var e=exn[2];throw convert_error(e)}
            throw exn}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_aux
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_aux
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _n4_=parse_argv(0,_p_,l,f,msg);return _n4_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a__),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_a$_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _n3_=parse_argv_dynamic(0,_p_,l,f,msg);return _n3_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_ba_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bb_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,_p_],
         spec=[0,l],
         current$0=[0,current[1]],
         _n2_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _n2_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bc_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bd_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_n0_)
       {_n0_ = caml_wrap_exception(_n0_);
        if(_n0_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_n1_)
           {_n1_ = caml_wrap_exception(_n1_);
            if(_n1_ === Not_found)return len;
            throw _n1_}
          return loop(n + 1 | 0)}
        throw _n0_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$4
              (function(c)
                {if(9 === c)if(! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$2
              (function(ksd)
                {var _nY_=ksd[2],_nZ_=ksd[1];
                 if(caml_string_notequal(ksd[3],cst$59))
                  {if(11 === _nY_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _nZ_,
                             _nY_,
                             _g_(cst$60,_g_(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_nZ_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_nZ_,_nY_,_g_(prefix,_g_(spaces,suffix))]}
                   return [0,_nZ_,_nY_,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s);
          if(0 < len)
           if(13 === caml_string_get(s,len - 1 | 0))
            var _nX_=sub$0(s,0,len - 1 | 0),switch$0=1;
           else
            var switch$0=0;
          else
           var switch$0=0;
          if(! switch$0)var _nX_=s;
          var word=_nX_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_nW_)
       {_nW_ = caml_wrap_exception(_nW_);
        if(_nW_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _nW_}}
    var _be_=10,_bf_=1;
    function read_arg(_nV_){return read_aux(_bf_,_be_,_nV_)}
    var _bg_=0,_bh_=0;
    function read_arg0(_nU_){return read_aux(_bh_,_bg_,_nU_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bi_),s,sep)},args);
      return close_out(oc)}
    var _bj_=10;
    function write_arg(_nS_,_nT_){return write_aux(_bj_,_nS_,_nT_)}
    var _bk_=0;
    function write_arg0(_nQ_,_nR_){return write_aux(_bk_,_nQ_,_nR_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(752,Stdlib_arg,"Stdlib__arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[i + 1];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bl_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$61
              :caml_call1(sprintf(_bm_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$62;
      var _nO_=other_fields(x,i + 1 | 0),_nP_=field(x,i);
      return caml_call2(sprintf(_bn_),_nP_,_nO_)}
    function fields(x)
     {var match=x.length - 1;
      if(2 < match >>> 0)
       {var _nL_=other_fields(x,2),_nM_=field(x,1);
        return caml_call2(sprintf(_bo_),_nM_,_nL_)}
      switch(match)
       {case 0:return cst$63;
        case 1:return cst$64;
        default:var _nN_=field(x,1);return caml_call1(sprintf(_bp_),_nN_)}}
    function to_string$7(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try {var _nJ_=caml_call1(hd,x),_nI_=_nJ_}catch(_nK_){var _nI_=0}
            if(_nI_){var s=_nI_[1];return s}
            var param$0=tl;
            continue}
          if(x === Out_of_memory)return cst_Out_of_memory;
          if(x === Stack_overflow)return cst_Stack_overflow;
          if(x[1] === Match_failure)
           {var match=x[2],char$0=match[3],line=match[2],file=match[1];
            return caml_call5
                    (sprintf(locfmt),
                     file,
                     line,
                     char$0,
                     char$0 + 5 | 0,
                     cst_Pattern_matching_failed)}
          if(x[1] === Assert_failure)
           {var
             match$0=x[2],
             char$1=match$0[3],
             line$0=match$0[2],
             file$0=match$0[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$0,
                     line$0,
                     char$1,
                     char$1 + 6 | 0,
                     cst_Assertion_failed)}
          if(x[1] === Undefined_recursive_module)
           {var
             match$1=x[2],
             char$2=match$1[3],
             line$1=match$1[2],
             file$1=match$1[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$1,
                     line$1,
                     char$2,
                     char$2 + 6 | 0,
                     cst_Undefined_recursive_module)}
          if(0 === caml_obj_tag(x))
           {var constructor=x[1][1];return _g_(constructor,fields(x))}
          return x[1]}}
      return conv(printers[1])}
    function print(fct,arg)
     {try
       {var _nH_=caml_call1(fct,arg);return _nH_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _nG_=to_string$7(x);
        caml_call1(eprintf(_bq_),_nG_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _nF_=caml_call1(fct,arg);return _nF_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _nE_=to_string$7(x);
        caml_call1(eprintf(_br_),_nE_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos
                  ?cst_Raised_by_primitive_operation_at
                  :cst_Called_from}
      if(0 === slot[0])
       {var
         _nx_=slot[5],
         _ny_=slot[4],
         _nz_=slot[3],
         _nA_=slot[6]?cst_inlined:cst$65,
         _nB_=slot[2],
         _nC_=info(slot[1]);
        return [0,caml_call6(sprintf(_bs_),_nC_,_nB_,_nA_,_nz_,_ny_,_nx_)]}
      if(slot[1])return 0;
      var _nD_=info(0);
      return [0,caml_call1(sprintf(_bt_),_nD_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_nv_=a.length - 1 - 1 | 0,_nu_=0;
        if(! (_nv_ < 0))
         {var i=_nu_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[i + 1]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bu_),str)}
            var _nw_=i + 1 | 0;
            if(_nv_ !== i){var i=_nw_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bv_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtrace(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_ns_=a.length - 1 - 1 | 0,_nr_=0;
        if(! (_ns_ < 0))
         {var i=_nr_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[i + 1]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bw_),str)}
            var _nt_=i + 1 | 0;
            if(_ns_ !== i){var i=_nt_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_cannot_print_stack_backtrace}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _nq_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[i + 1],
             _np_=0 === param[0]?1:0;
            if(! _np_){var i$0=i - 1 | 0,i=i$0;continue}
            var _nq_=_np_}
          return _nq_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtrace(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var uncaught_exception_handler=[0,0];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = [0,fn];return 0}
    function _bx_(_no_){return runtime.caml_raw_backtrace_next_slot(_no_)}
    function _by_(_nn_){return runtime.caml_convert_raw_backtrace_slot(_nn_)}
    function _bz_(_nm_,_nl_)
     {return runtime.caml_raw_backtrace_slot(_nm_,_nl_)}
    function _bA_(_nk_){return runtime.caml_raw_backtrace_length(_nk_)}
    var
     _bB_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       format_backtrace_slot];
    function _bC_(_nj_){return runtime.caml_get_current_callstack(_nj_)}
    function _bD_(_ni_){return caml_get_exception_raw_backtrace(_ni_)}
    function _bE_(_nh_){return runtime.caml_backtrace_status(_nh_)}
    var
     Stdlib_printexc=
      [0,
       to_string$7,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_ng_){return runtime.caml_record_backtrace(_ng_)},
       _bE_,
       register_printer,
       _bD_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       _bC_,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bB_,
       _bA_,
       _bz_,
       _by_,
       _bx_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(753,Stdlib_printexc,"Stdlib__printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _nf_=caml_call1(finally$0,0);return _nf_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtrace(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtrace(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(754,Stdlib_fun,"Stdlib__fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_m0_=st[4];
      caml_call1(fprintf(c,_bF_),_m0_);
      var _m1_=st[5];
      caml_call1(fprintf(c,_bG_),_m1_);
      var _m2_=st[14];
      caml_call1(fprintf(c,_bH_),_m2_);
      fprintf(c,_bI_);
      var
       _m3_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bJ_),_m3_)),
       _m4_=st[1];
      caml_call2(fprintf(c,_bK_),l1,_m4_);
      var _m5_=st[2];
      caml_call2(fprintf(c,_bL_),l1,_m5_);
      var _m6_=st[3];
      caml_call2(fprintf(c,_bM_),l1,_m6_);
      fprintf(c,_bN_);
      var
       _m7_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bO_),_m7_)),
       _m8_=st[15];
      caml_call2(fprintf(c,_bP_),l2,_m8_);
      var _m9_=st[6];
      caml_call2(fprintf(c,_bQ_),l2,_m9_);
      var _m__=st[8];
      caml_call2(fprintf(c,_bR_),l2,_m__);
      var _m$_=st[10];
      caml_call2(fprintf(c,_bS_),l2,_m$_);
      var _na_=st[12];
      caml_call2(fprintf(c,_bT_),l2,_na_);
      var _nb_=st[13];
      caml_call2(fprintf(c,_bU_),l2,_nb_);
      fprintf(c,_bV_);
      var _nc_=st[9];
      caml_call1(fprintf(c,_bW_),_nc_);
      var _nd_=st[11];
      caml_call1(fprintf(c,_bX_),_nd_);
      var _ne_=st[7];
      return caml_call1(fprintf(c,_bY_),_ne_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _bZ_(_mZ_){return runtime.caml_final_release(_mZ_)}
    function _b0_(_mY_,_mX_)
     {return runtime.caml_final_register_called_without_value(_mY_,_mX_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_mW_,_mV_){return runtime.caml_final_register(_mW_,_mV_)},
       _b0_,
       _bZ_,
       create_alarm,
       delete_alarm];
    caml_register_global(755,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(str) - len | 0) < ofs))
         return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _mU_=10 <= n?87:48;return n + _mU_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _mT_=i + 1 | 0;
        if(15 !== i){var i=_mT_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_mR_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _mR_ | 0));
        var _mS_=i + 1 | 0;
        if(15 !== i){var i=_mS_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$5,
       equal$5,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(756,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[i$0 + 1] = i$0;
        var _mQ_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_mQ_;continue}
        var accu=[0,cst_x$1],_mM_=54 + max(55,l) | 0,_mL_=0;
        if(! (_mM_ < 0))
         {var i=_mL_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[k + 1];
            accu[1] = string(_g_(accu[1],caml_new_string("" + x)));
            var
             _mN_=accu[1],
             _mH_=caml_string_get(_mN_,3) << 24,
             _mI_=caml_string_get(_mN_,2) << 16,
             _mJ_=caml_string_get(_mN_,1) << 8,
             _mK_=((caml_string_get(_mN_,0) + _mJ_ | 0) + _mI_ | 0) + _mH_ | 0,
             _mO_=(caml_check_bound(s[1],j)[j + 1] ^ _mK_) & 1073741823;
            caml_check_bound(s[1],j)[j + 1] = _mO_;
            var _mP_=i + 1 | 0;
            if(_mM_ !== i){var i=_mP_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$2(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$2(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _mE_=s[2],
       curval=caml_check_bound(s[1],_mE_)[_mE_ + 1],
       _mF_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_mF_)[_mF_ + 1]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _mG_=s[2];
      caml_check_bound(s[1],_mG_)[_mG_ + 1] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound))
       if(0 < bound)
        for(;;)
         {var r=bits(s),v=caml_mod(r,bound);
          if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
          return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b2_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_b1_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b3_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b4_=
      [0,
       make$2,
       make_self_init,
       copy$5,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b4_,
       get_state,
       set_state];
    caml_register_global(757,Stdlib_random,"Stdlib__random");
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function ongoing_traversal(h)
     {var _mC_=h.length - 1 < 4?1:0,_mD_=_mC_ || (h[4] < 0?1:0);return _mD_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cK_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cK_}
    catch(_mA_)
     {_mA_ = caml_wrap_exception(_mA_);
      if(_mA_ !== Not_found)throw _mA_;
      try
       {var _cJ_=caml_sys_getenv(cst_CAMLRUNPARAM),_b5_=_cJ_}
      catch(_mB_)
       {_mB_ = caml_wrap_exception(_mB_);
        if(_mB_ !== Not_found)throw _mB_;
        var _b5_=cst$66}
      var params=_b5_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_mz_){return caml_call1(_b4_[2],0)}];
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x))
         if(! (max_array_length < (x * 2 | 0)))
          {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _mx_=caml_obj_tag(prng),
          _my_=250 === _mx_?prng[1]:246 === _mx_?force_lazy_block(prng):prng,
          seed=caml_call1(_b4_[4],_my_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {h[1] = 0;
      var len=h[2].length - 1,_mv_=len - 1 | 0,_mu_=0;
      if(! (_mv_ < 0))
       {var i=_mu_;
        for(;;)
         {caml_check_bound(h[2],i)[i + 1] = 0;
          var _mw_=i + 1 | 0;
          if(_mv_ !== i){var i=_mw_;continue}
          break}}
      return 0}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1)
       if(len !== abs(h[4]))
        {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b6_]}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _mr_=init[4],_ms_=init[3],_mt_=map$5(copy_bucketlist,init[2]);
      return [0,init[1],_mt_,_ms_,_mr_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _mi_=nsize < max_array_length?1:0;
      if(_mi_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _mk_=osize - 1 | 0,_mj_=0;
        if(! (_mk_ < 0))
         {var i$0=_mj_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[i$0 + 1],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[nidx + 1];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[nidx + 1] = cell$0;
                caml_check_bound(ndata_tail,nidx)[nidx + 1] = cell$0;
                var cell=next;
                continue}
              var _mq_=i$0 + 1 | 0;
              if(_mk_ !== i$0){var i$0=_mq_;continue a}
              break}
            break}}
        if(inplace)
         {var _mm_=nsize - 1 | 0,_ml_=0;
          if(! (_mm_ < 0))
           {var i=_ml_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[i + 1];
              if(match$0)match$0[3] = 0;
              var _mp_=i + 1 | 0;
              if(_mm_ !== i){var i=_mp_;continue}
              break}}
          var _mn_=0}
        else
         var _mn_=inplace;
        var _mo_=_mn_}
      else
       var _mo_=_mi_;
      return _mo_}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[i + 1]];
      caml_check_bound(h[2],i)[i + 1] = bucket;
      h[1] = h[1] + 1 | 0;
      var _mh_=h[2].length - 1 << 1 < h[1]?1:0;
      return _mh_?resize$0(key_index,h):_mh_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[i + 1],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :caml_check_bound(h[2],i)[i + 1] = next}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mg_=key_index(h,key),match=caml_check_bound(h[2],_mg_)[_mg_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _mf_=key_index(h,key),match=caml_check_bound(h[2],_mf_)[_mf_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _me_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_me_)[_me_ + 1])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[i + 1],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _mb_=0}
        else
         var _mb_=1;
        if(_mb_)
         {caml_check_bound(h[2],i)[i + 1] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _mc_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_mc_)return resize$0(key_index,h);
          var _md_=_mc_}
        else
         var _md_=_mb_;
        return _md_}}
    function mem$2(h,key)
     {var
       _ma_=key_index(h,key),
       param$0=caml_check_bound(h[2],_ma_)[_ma_ + 1],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_l$_=0 === caml_compare(k,key)?1:0;
          if(_l$_)return _l$_;
          var param=next;
          continue}
        return 0}}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_l7_=d.length - 1 - 1 | 0,_l6_=0;
        if(! (_l7_ < 0))
         {var i=_l6_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[i + 1]);
            var _l__=i + 1 | 0;
            if(_l7_ !== i){var i=_l__;continue}
            break}}
        var _l8_=1 - old_trav,_l9_=_l8_?flip_ongoing_traversal(h):_l8_;
        return _l9_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[i + 1] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0?(prec$0[3] = 0,0):caml_check_bound(h[2],i)[i + 1] = 0}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _l3_=d.length - 1 - 1 | 0,_l2_=0;
        if(! (_l3_ < 0))
         {var i=_l2_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[i + 1]);
            var _l5_=i + 1 | 0;
            if(_l3_ !== i){var i=_l5_;continue}
            break}}
        var _l4_=0;
        return _l4_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$3(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_lY_=d.length - 1 - 1 | 0,_lX_=0;
        if(! (_lY_ < 0))
         {var i=_lX_;
          for(;;)
           {var _l0_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[i + 1],_l0_);
            var _l1_=i + 1 | 0;
            if(_lY_ !== i){var i=_l1_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _lZ_=accu[1];
        return _lZ_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _lU_=h[2],
       _lV_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_lV_,_lU_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _lW_=h[2];
      iter$5
       (function(b)
         {var l=bucket_length(0,b);
          return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
        _lW_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_lT_){return aux(i$0,next,_lT_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[i$0 + 1],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _lQ_=0,_lR_=0;
      return function(_lS_){return aux(_lR_,_lQ_,_lS_)}}
    function to_seq_keys(m)
     {var _lM_=to_seq$9(m);
      function _lN_(_lP_){return _lP_[1]}
      return function(_lO_){return map(_lN_,_lM_,_lO_)}}
    function to_seq_values(m)
     {var _lI_=to_seq$9(m);
      function _lJ_(_lL_){return _lL_[2]}
      return function(_lK_){return map(_lJ_,_lI_,_lK_)}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _lH_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _lH_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[i + 1]];
        caml_check_bound(h[2],i)[i + 1] = bucket;
        h[1] = h[1] + 1 | 0;
        var _lG_=h[2].length - 1 << 1 < h[1]?1:0;
        return _lG_?resize$0(key_index,h):_lG_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[i + 1],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :caml_check_bound(h[2],i)[i + 1] = next}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _lF_=key_index(h,key),match=caml_check_bound(h[2],_lF_)[_lF_ + 1];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _lE_=key_index(h,key),match=caml_check_bound(h[2],_lE_)[_lE_ + 1];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _lD_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_lD_)[_lD_ + 1])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[i + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _lA_=0}
          else
           var _lA_=1;
          if(_lA_)
           {caml_check_bound(h[2],i)[i + 1] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _lB_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_lB_)return resize$0(key_index,h);
            var _lC_=_lB_}
          else
           var _lC_=_lA_;
          return _lC_}}
      function mem(h,key)
       {var
         _lz_=key_index(h,key),
         param$0=caml_check_bound(h[2],_lz_)[_lz_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_ly_=caml_call2(H[1],k,key);
            if(_ly_)return _ly_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$3,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _lx_=include[1];
      function create(sz){return caml_call2(_lx_,_b7_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    var
     Stdlib_hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$3,
       length$4,
       randomize,
       is_randomized,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(758,Stdlib_hashtbl,"Stdlib__hashtbl");
    function weak_create(l)
     {var _lv_=0 <= l?1:0,_lw_=_lv_?l <= _x_[15]?1:0:_lv_;
      if(1 - _lw_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _ls_=0 <= o?1:0,_lt_=_ls_?o < length$5(e)?1:0:_ls_,_lu_=1 - _lt_;
      return _lu_?invalid_arg(msg):_lu_}
    function set(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if(0 <= l)
       if(0 <= o1)
        if(! ((length$5(e1) - l | 0) < o1))
         if(0 <= o2)
          if(! ((length$5(e2) - l | 0) < o2))
           {var
             _lq_=0 !== l?1:0,
             _lr_=_lq_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_lq_;
            return _lr_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((length$5(ar) - len | 0) < ofs))
         {var _lo_=(ofs + len | 0) - 1 | 0;
          if(! (_lo_ < ofs))
           {var i=ofs;
            for(;;)
             {set(ar,i,x);
              var _lp_=i + 1 | 0;
              if(_lo_ !== i){var i=_lp_;continue}
              break}}
          return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$0(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _lm_=t[1].length - 1 - 1 | 0,_ll_=0;
        if(! (_lm_ < 0))
         {var i=_ll_;
          for(;;)
           {caml_check_bound(t[1],i)[i + 1] = emptybucket;
            caml_check_bound(t[2],i)[i + 1] = [0];
            var _ln_=i + 1 | 0;
            if(_lm_ !== i){var i=_ln_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _lk_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$0(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lk_,
                 init)}
      function iter(f,t)
       {var _lj_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$0(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lj_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _li_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _li_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _ld_=0,_le_=t[1],_lf_=0;
        return fold_right$0
                (function(_lg_,_lh_){return count_bucket(_lf_,_lg_,_lh_)},
                 _le_,
                 _ld_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)
             failwith(cst_Weak_Make_hash_bucket_cannot_grow_more);
            var
             newbucket=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket,sz,d);
            caml_check_bound(newhashes,sz)[sz + 1] = h;
            caml_check_bound(t[1],index)[index + 1] = newbucket;
            caml_check_bound(t[2],index)[index + 1] = newhashes;
            var _k$_=sz <= t[3]?1:0,_la_=_k$_?t[3] < newsz?1:0:_k$_;
            if(_la_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _k4_=t[5],
                 bucket=caml_check_bound(t[1],_k4_)[_k4_ + 1],
                 _k5_=t[5],
                 hbucket=caml_check_bound(t[2],_k5_)[_k5_ + 1],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _k6_=caml_check_bound(hbucket,j)[j + 1];
                        caml_check_bound(hbucket,i$0)[i$0 + 1] = _k6_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _k7_=t[5];
                      caml_check_bound(t[1],_k7_)[_k7_ + 1] = emptybucket;
                      var _k8_=t[5];
                      caml_check_bound(t[2],_k8_)[_k8_ + 1] = [0]}
                    else
                     {caml_obj_truncate(bucket,prev_len + 2 | 0);
                      caml_obj_truncate(hbucket,prev_len)}
                    var _k9_=t[3] < n?1:0,_k__=_k9_?prev_len <= t[3]?1:0:_k9_;
                    if(_k__)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _lc_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_lc_;continue}
                break}}
            var _lb_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_lb_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_k3_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(0 === match){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      var
                       oh=caml_check_bound(t[2],j)[j + 1],
                       setter$0=
                        function(i)
                         {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                          return setter},
                       setter=setter$0(i$0),
                       h=caml_check_bound(oh,i$0)[i$0 + 1];
                      add_aux(newt,setter,0,h,get_index(newt,h));
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _k3_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _lb_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          return caml_check_bound(hashes,i$3)[i$3 + 1] = h}}
      function add(t,d)
       {var h=caml_call1(H[2],d);return add_aux(t,set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$0(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,d,function(h,index){add_aux(t,set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$0(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _k2_=0;
        return find_shadow(t,d,function(w,i){return set(w,i,0)},_k2_)}
      function mem(t,d)
       {var _k1_=0;return find_shadow(t,d,function(w,i){return 1},_k1_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$0(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$5(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _kT_=0,
         totlen=
          fold_left$1(function(_k0_,_kZ_){return _k0_ + _kZ_ | 0},_kT_,lens),
         _kU_=len - 1 | 0,
         _kW_=len / 2 | 0,
         _kV_=caml_check_bound(lens,_kU_)[_kU_ + 1],
         _kX_=caml_check_bound(lens,_kW_)[_kW_ + 1],
         _kY_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_kY_,_kX_,_kV_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,weak_create,length$5,set,get$0,get_copy,check$0,fill$2,blit$4,Make$0];
    caml_register_global(759,Stdlib_weak,"Stdlib__weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _kS_=caml_string_notequal(s,cst$67);
      return _kS_?format_pp_text(state,caml_ml_string_length(s),s):_kS_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_b8_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var match$12=peek_opt(state[28]);
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _kQ_=0 <= size$0?1:0,
           _kR_=_kQ_ || (state[9] <= pending_count?1:0);
          if(_kR_)
           {take(state[28]);
            var size$1=0 <= size$0?size$0:pp_infinity;
            if(typeof token === "number")
             switch(token)
              {case 0:
                var match$3=top_opt(state[3]);
                if(match$3)
                 {var
                   match$4=match$3[1],
                   tabs=match$4[1],
                   add_tab=
                    function(n,ls)
                     {if(ls)
                       {var l=ls[2],x=ls[1];
                        return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                      return [0,n,0]};
                  tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                break;
               case 1:pop_opt(state[2]);break;
               case 2:pop_opt(state[3]);break;
               case 3:
                var match$5=top_opt(state[2]);
                if(match$5)
                 {var match$6=match$5[1],width$0=match$6[2];
                  break_line(state,width$0)}
                else
                 pp_output_newline(state);
                break;
               case 4:
                if(state[10] !== (state[6] - state[9] | 0))
                 {var match$1=take_opt(state[28]);
                  if(match$1)
                   {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                    state[12] = state[12] - length | 0;
                    state[9] = state[9] + size | 0}}
                break;
               default:
                var match$7=pop_opt(state[5]);
                if(match$7)
                 {var
                   tag_name=match$7[1],
                   marker=caml_call1(state[25],tag_name);
                  pp_output_string(state,marker)}}
            else
             switch(token[0])
              {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
               case 1:
                var
                 breaks=token[2],
                 fits=token[1],
                 off=breaks[2],
                 before=breaks[1],
                 match$8=top_opt(state[2]);
                if(match$8)
                 {var
                   match$9=match$8[1],
                   width$1=match$9[2],
                   box_type$0=match$9[1];
                  switch(box_type$0)
                   {case 0:break_same_line(state,fits);break;
                    case 1:break_new_line(state,breaks,width$1);break;
                    case 2:break_new_line(state,breaks,width$1);break;
                    case 3:
                     if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                      break_new_line(state,breaks,width$1);
                     else
                      break_same_line(state,fits);
                     break;
                    case 4:
                     if(state[11])
                      break_same_line(state,fits);
                     else
                      if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                       break_new_line(state,breaks,width$1);
                      else
                       if(((state[6] - width$1 | 0) + off | 0) < state[10])
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                     break;
                    default:break_same_line(state,fits)}}
                break;
               case 2:
                var
                 off$0=token[2],
                 n=token[1],
                 insertion_point=state[6] - state[9] | 0,
                 match$10=top_opt(state[3]);
                if(match$10)
                 {var match$11=match$10[1],tabs$0=match$11[1],_kO_=tabs$0[1];
                  if(_kO_)
                   {var first=_kO_[1],param=tabs$0[1];
                    for(;;)
                     {if(param)
                       {var tail=param[2],head=param[1];
                        if(! (insertion_point <= head)){var param=tail;continue}
                        var _kP_=head}
                      else
                       var _kP_=first;
                      var tab=_kP_;
                      break}}
                  else
                   var tab=insertion_point;
                  var offset=tab - insertion_point | 0;
                  if(0 <= offset)
                   break_same_line(state,[0,cst$69,offset + n | 0,cst$68]);
                  else
                   break_new_line
                    (state,[0,cst$71,tab + off$0 | 0,cst$70],state[6])}
                break;
               case 3:
                var
                 ty=token[2],
                 off$1=token[1],
                 insertion_point$0=state[6] - state[9] | 0;
                if(state[8] < insertion_point$0)
                 {var match=top_opt(state[2]);
                  if(match)
                   {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                    if(state[9] < width)
                     {var switcher=box_type - 1 | 0;
                      if(! (3 < switcher >>> 0))break_line(state,width)}}
                  else
                   pp_output_newline(state)}
                var
                 width$2=state[9] - off$1 | 0,
                 box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                push([0,box_type$1,width$2],state[2]);
                break;
               case 4:var tbox=token[1];push(tbox,state[3]);break;
               default:
                var
                 tag_name$0=token[1],
                 marker$0=caml_call1(state[24],tag_name$0);
                pp_output_string(state,marker$0);
                push(tag_name$0,state[5])}
            state[12] = length$0 + state[12] | 0;
            continue}
          return _kR_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_b9_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _kL_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _kM_=queue_elem[2];
        if(typeof _kM_ !== "number")
         switch(_kM_[0])
          {case 3:
            var _kN_=1 - ty;
            return _kN_
                    ?(queue_elem[1] = state[13] + _kL_ | 0,pop_opt(state[1]),0)
                    :_kN_;
           case 1:
           case 2:
            return ty
                    ?(queue_elem[1] = state[13] + _kL_ | 0,pop_opt(state[1]),0)
                    :ty
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _kJ_=state[14] === state[15]?1:0;
      if(_kJ_)
       {var _kK_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_kK_),_kK_)}
      return _kJ_}
    function pp_close_box(state,param)
     {var _kH_=1 < state[14]?1:0;
      if(_kH_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _kI_=0}
      else
       var _kI_=_kH_;
      return _kI_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _kG_=state[23];
      if(_kG_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _kG_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _kE_=state[22];
      if(_kE_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _kF_=0}
      else
       var _kF_=_kE_;
      return _kF_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_functions(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _kD_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_kD_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _kC_=state[14] < state[15]?1:0;
      return _kC_?enqueue_string_as(state,size,s):_kC_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_new_string("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _kB_=state[14] < state[15]?1:0;
      return _kB_?enqueue_advance(state,[0,size,3,0]):_kB_}
    function pp_print_if_newline(state,param)
     {var _kA_=state[14] < state[15]?1:0;
      return _kA_?enqueue_advance(state,[0,size,4,0]):_kA_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _kz_=state[14] < state[15]?1:0;
      if(_kz_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _kz_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$75,width,cst$74],[0,cst$73,offset,cst$72])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _ky_=state[14] < state[15]?1:0;
      if(_ky_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _ky_}
    function pp_close_tbox(state,param)
     {var _kv_=1 < state[14]?1:0;
      if(_kv_)
       {var _kw_=state[14] < state[15]?1:0;
        if(_kw_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _kx_=0}
        else
         var _kx_=_kw_}
      else
       var _kx_=_kv_;
      return _kx_}
    function pp_print_tbreak(state,width,offset)
     {var _ku_=state[14] < state[15]?1:0;
      if(_ku_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _ku_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _kt_=state[14] < state[15]?1:0;
      if(_kt_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _kt_}
    function pp_set_max_boxes(state,n)
     {var _kr_=1 < n?1:0,_ks_=_kr_?(state[15] = n,0):_kr_;return _ks_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _kq_=1 < n$0?1:0;
      if(_kq_)
       {var n$1=state[6] - n$0 | 0,_kp_=1 <= n$1?1:0;
        if(_kp_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _kp_}
      return _kq_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _ko_=1 <= n?1:0;
      if(_ko_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _ko_}
    function check_geometry(geometry)
     {var
       _km_=1 < geometry[1]?1:0,
       _kn_=_km_?geometry[1] < geometry[2]?1:0:_km_;
      return _kn_}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_geometry(state,max_indent,margin)
     {if(2 <= max_indent)
       {if(margin <= max_indent)
         throw [0,
                Invalid_argument,
                cst_Format_pp_set_geometry_margin_max_indent];
        pp_set_margin(state,margin);
        return pp_set_max_indent(state,max_indent)}
      throw [0,Invalid_argument,cst_Format_pp_set_geometry_max_indent_2]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {return check_geometry([0,max_indent,margin])
              ?pp_set_geometry(state,max_indent,margin)
              :0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functions(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functions(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$76,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _kl_=0 < n$0?1:0;
        if(_kl_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _kl_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_ki_,_kj_,_kk_){return output_substring(oc,_ki_,_kj_,_kk_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_kh_){return display_newline(state,_kh_)};
      state[20] = function(_kg_){return display_indent(state,_kg_)};
      state[21] = function(_kf_){return display_indent(state,_kf_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return _g_(cst$78,_g_(s,cst$77))}
      return cst$79}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return _g_(cst$81,_g_(s,cst$80))}
      return cst$82}
    function default_pp_print_open_tag(_ke_){return 0}
    function default_pp_print_close_tag(_kd_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_b__,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _ka_=create$0(0),_kb_=create$0(0),_kc_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _kc_,
              _kb_,
              _ka_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$83,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _j4_(_j$_){return 0}
      function _j5_(_j__){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_j9_){return 0},_j5_,_j4_);
      ppf[19] = function(_j8_){return display_newline(ppf,_j8_)};
      ppf[20] = function(_j7_){return display_indent(ppf,_j7_)};
      ppf[21] = function(_j6_){return display_indent(ppf,_j6_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _j0_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_j1_,_j2_,_j3_)
                {return output_substring(oc,_j1_,_j2_,_j3_)},
               _j0_)}
    function formatter_of_buffer(b)
     {function _jV_(_jZ_){return 0}
      return make_formatter
              (function(_jW_,_jX_,_jY_)
                {return add_substring(b,_jW_,_jX_,_jY_)},
               _jV_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_buffer(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_jU_){return add_symbolic_output_item(sob,0)}
      function h(_jT_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_jS_){return pp_open_hbox(std_formatter,_jS_)}
    function open_vbox(_jR_){return pp_open_vbox(std_formatter,_jR_)}
    function open_hvbox(_jQ_){return pp_open_hvbox(std_formatter,_jQ_)}
    function open_hovbox(_jP_){return pp_open_hovbox(std_formatter,_jP_)}
    function open_box(_jO_){return pp_open_box(std_formatter,_jO_)}
    function close_box(_jN_){return pp_close_box(std_formatter,_jN_)}
    function open_tag(_jM_){return pp_open_tag(std_formatter,_jM_)}
    function close_tag(_jL_){return pp_close_tag(std_formatter,_jL_)}
    function open_stag(_jK_){return pp_open_stag(std_formatter,_jK_)}
    function close_stag(_jJ_){return pp_close_stag(std_formatter,_jJ_)}
    function print_as(_jH_,_jI_){return pp_print_as(std_formatter,_jH_,_jI_)}
    function print_string$0(_jG_){return pp_print_string(std_formatter,_jG_)}
    function print_int$0(_jF_){return pp_print_int(std_formatter,_jF_)}
    function print_float$0(_jE_){return pp_print_float(std_formatter,_jE_)}
    function print_char$0(_jD_){return pp_print_char(std_formatter,_jD_)}
    function print_bool(_jC_){return pp_print_bool(std_formatter,_jC_)}
    function print_break(_jA_,_jB_)
     {return pp_print_break(std_formatter,_jA_,_jB_)}
    function print_cut(_jz_){return pp_print_cut(std_formatter,_jz_)}
    function print_space(_jy_){return pp_print_space(std_formatter,_jy_)}
    function force_newline(_jx_){return pp_force_newline(std_formatter,_jx_)}
    function print_flush(_jw_){return pp_print_flush(std_formatter,_jw_)}
    function print_newline$0(_jv_)
     {return pp_print_newline(std_formatter,_jv_)}
    function print_if_newline(_ju_)
     {return pp_print_if_newline(std_formatter,_ju_)}
    function open_tbox(_jt_){return pp_open_tbox(std_formatter,_jt_)}
    function close_tbox(_js_){return pp_close_tbox(std_formatter,_js_)}
    function print_tbreak(_jq_,_jr_)
     {return pp_print_tbreak(std_formatter,_jq_,_jr_)}
    function set_tab(_jp_){return pp_set_tab(std_formatter,_jp_)}
    function print_tab(_jo_){return pp_print_tab(std_formatter,_jo_)}
    function set_margin(_jn_){return pp_set_margin(std_formatter,_jn_)}
    function get_margin(_jm_){return std_formatter[6]}
    function set_max_indent(_jl_)
     {return pp_set_max_indent(std_formatter,_jl_)}
    function get_max_indent(_jk_){return std_formatter[8]}
    function set_geometry(_ji_,_jj_)
     {return pp_set_geometry(std_formatter,_ji_,_jj_)}
    function safe_set_geometry(_jg_,_jh_)
     {return pp_safe_set_geometry(std_formatter,_jg_,_jh_)}
    function get_geometry(_jf_){return pp_get_geometry(std_formatter,_jf_)}
    function set_max_boxes(_je_){return pp_set_max_boxes(std_formatter,_je_)}
    function get_max_boxes(_jd_){return std_formatter[15]}
    function over_max_boxes(_jc_)
     {return pp_over_max_boxes(std_formatter,_jc_)}
    function set_ellipsis_text(_jb_)
     {return pp_set_ellipsis_text(std_formatter,_jb_)}
    function get_ellipsis_text(_ja_){return std_formatter[16]}
    function set_formatter_out_channel(_i$_)
     {return pp_set_formatter_out_channel(std_formatter,_i$_)}
    function set_formatter_out_functions(_i__)
     {return pp_set_formatter_out_functions(std_formatter,_i__)}
    function get_formatter_out_functions(_i9_)
     {return pp_get_formatter_out_functions(std_formatter,_i9_)}
    function set_formatter_output_functions(_i7_,_i8_)
     {return pp_set_formatter_output_functions(std_formatter,_i7_,_i8_)}
    function get_formatter_output_functions(_i6_)
     {return pp_get_formatter_output_functions(std_formatter,_i6_)}
    function set_formatter_stag_functions(_i5_)
     {return pp_set_formatter_stag_functions(std_formatter,_i5_)}
    function get_formatter_stag_functions(_i4_)
     {return pp_get_formatter_stag_functions(std_formatter,_i4_)}
    function set_print_tags(_i3_)
     {return pp_set_print_tags(std_formatter,_i3_)}
    function get_print_tags(_i2_){return std_formatter[22]}
    function set_mark_tags(_i1_){return pp_set_mark_tags(std_formatter,_i1_)}
    function get_mark_tags(_i0_){return std_formatter[23]}
    function set_tags(_iZ_){return pp_set_tags(std_formatter,_iZ_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _iX_=param$0[2],_iY_=param$0[1];
          if(_iX_)
           {caml_call2(pp_v,ppf,_iY_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=_iX_;
            continue}
          return caml_call2(pp_v,ppf,_iY_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _iW_=left[1] !== len?1:0;
        return _iW_?flush(0):_iW_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_iV_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iL_=acc[2],_iM_=acc[1];
          if(0 === _iL_[0])
           {var acc$0=_iL_[1];
            output_acc$0(ppf,_iM_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_iL_[1];
          output_acc$0(ppf,_iM_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iN_=acc[1];
          if(typeof _iN_ === "number")
           var switch$1=1;
          else
           if(0 === _iN_[0])
            {var _iO_=_iN_[2];
             if(typeof _iO_ === "number")
              var switch$2=1;
             else
              if(1 === _iO_[0])
               var
                p$1=_iN_[1],
                size=_iO_[2],
                s$0=acc[2],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var p$0=_iN_,s=acc[2],switch$0=2;
          break;
         case 3:
          var _iP_=acc[1];
          if(typeof _iP_ === "number")
           var switch$3=1;
          else
           if(0 === _iP_[0])
            {var _iQ_=_iP_[2];
             if(typeof _iQ_ === "number")
              var switch$4=1;
             else
              if(1 === _iQ_[0])
               var
                p$3=_iP_[1],
                size$0=_iQ_[2],
                c$0=acc[2],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var p$2=_iP_,c=acc[2],switch$0=3;
          break;
         case 4:
          var _iR_=acc[1];
          if(typeof _iR_ === "number")
           var switch$5=1;
          else
           if(0 === _iR_[0])
            {var _iS_=_iR_[2];
             if(typeof _iS_ === "number")
              var switch$6=1;
             else
              if(1 === _iS_[0])
               var
                p$1=_iR_[1],
                size=_iS_[2],
                s$0=acc[2],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var p$0=_iR_,s=acc[2],switch$0=2;
          break;
         case 5:
          var _iT_=acc[1];
          if(typeof _iT_ === "number")
           var switch$7=1;
          else
           if(0 === _iT_[0])
            {var _iU_=_iT_[2];
             if(typeof _iU_ === "number")
              var switch$8=1;
             else
              if(1 === _iU_[0])
               var
                p$3=_iT_[1],
                size$0=_iU_[2],
                c$0=acc[2],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var p$2=_iT_,c=acc[2],switch$0=3;
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iz_=acc[2],_iA_=acc[1];
          if(0 === _iz_[0])
           {var acc$0=_iz_[1];
            strput_acc$0(ppf,_iA_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_iz_[1];
          strput_acc$0(ppf,_iA_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iB_=acc[1];
          if(typeof _iB_ === "number")
           var switch$1=1;
          else
           if(0 === _iB_[0])
            {var _iC_=_iB_[2];
             if(typeof _iC_ === "number")
              var switch$2=1;
             else
              if(1 === _iC_[0])
               var
                p$1=_iB_[1],
                size=_iC_[2],
                s$0=acc[2],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var p$0=_iB_,s=acc[2],switch$0=2;
          break;
         case 3:
          var _iD_=acc[1];
          if(typeof _iD_ === "number")
           var switch$3=1;
          else
           if(0 === _iD_[0])
            {var _iE_=_iD_[2];
             if(typeof _iE_ === "number")
              var switch$4=1;
             else
              if(1 === _iE_[0])
               var
                p$3=_iD_[1],
                size$0=_iE_[2],
                c$0=acc[2],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var p$2=_iD_,c=acc[2],switch$0=3;
          break;
         case 4:
          var _iF_=acc[1];
          if(typeof _iF_ === "number")
           var switch$5=1;
          else
           if(0 === _iF_[0])
            {var _iG_=_iF_[2];
             if(typeof _iG_ === "number")
              var switch$6=1;
             else
              if(1 === _iG_[0])
               var
                p$1=_iF_[1],
                size=_iG_[2],
                s$0=acc[2],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var p$0=_iF_,s=acc[2],switch$0=2;
          break;
         case 5:
          var _iH_=acc[1];
          if(typeof _iH_ === "number")
           var switch$7=1;
          else
           if(0 === _iH_[0])
            {var _iI_=_iH_[2];
             if(typeof _iI_ === "number")
              var switch$8=1;
             else
              if(1 === _iI_[0])
               var
                p$3=_iH_[1],
                size$0=_iI_[2],
                c$0=acc[2],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var p$2=_iH_,c=acc[2],switch$0=3;
          break;
         case 6:
          var _iJ_=acc[1];
          if(typeof _iJ_ !== "number" && 0 === _iJ_[0])
           {var _iK_=_iJ_[2];
            if(typeof _iK_ !== "number" && 1 === _iK_[0])
             {var f$1=acc[2],size$1=_iK_[2],p$4=_iJ_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_iJ_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_iy_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _iy_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_iw_=0;
      return make_iprintf(function(_ix_){return 0},_iw_,fmt)}
    function fprintf$0(ppf)
     {function _it_(_iv_){return 0}
      return function(_iu_){return kfprintf$0(_it_,ppf,_iu_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_is_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _is_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_functions(state,f,g,h,i)
     {pp_set_formatter_output_functions(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_functions(_io_,_ip_,_iq_,_ir_)
     {return pp_set_all_formatter_output_functions
              (std_formatter,_io_,_ip_,_iq_,_ir_)}
    function get_all_formatter_output_functions(_in_)
     {return pp_get_all_formatter_output_functions(std_formatter,_in_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_im_){return stringify(mot,cst$84,_im_)};
      state[25] = function(_il_){return stringify(mct,cst$85,_il_)};
      var _ih_=0;
      state[26] = function(_ik_){return stringify(pot,_ih_,_ik_)};
      var _ii_=0;
      state[27] = function(_ij_){return stringify(pct,_ii_,_ij_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_functions(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_ig_)
     {return pp_set_formatter_tag_functions(std_formatter,_ig_)}
    function get_formatter_tag_functions(_if_)
     {return pp_get_formatter_tag_functions(std_formatter,_if_)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functions,
       set_formatter_output_functions,
       pp_get_formatter_output_functions,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_functions,
       set_formatter_stag_functions,
       pp_get_formatter_stag_functions,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_buffer,
       pp_print_list,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_functions,
       get_all_formatter_output_functions,
       pp_set_all_formatter_output_functions,
       pp_get_all_formatter_output_functions,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(760,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_ie_)
       {_ie_ = caml_wrap_exception(_ie_);
        if(_ie_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _ie_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _id_=ib[9];
      if(typeof _id_ === "number")
       return 0 === _id_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _id_[0])return cst_unnamed_Stdlib_input_channel;
        var fname=_id_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _b$_=0;
    function from_function$0(_ic_){return create$4(_b$_,_ic_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$86,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$87))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_ib_){return open_in_file(open_in,_ib_)}
    function from_file_bin(_ia_){return open_in_file(open_in_bin,_ia_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _h$_=ib[9];
      if(typeof _h$_ === "number")
       return 0;
      else
       {if(0 === _h$_[0]){var ic=_h$_[1];return caml_ml_close_channel(ic)}
        var ic$0=_h$_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _h9_=assq(ic,memo[1]);return _h9_}
      catch(_h__)
       {_h__ = caml_wrap_exception(_h__);
        if(_h__ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _h__}}
    function memo_from_channel(_h8_)
     {return memo_from_ic(scan_raise_at_end,_h8_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_ca_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cb_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_found_in_float_token)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexadecimal_notation)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cd_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_h6_=1 - ib[1];
         if(_h6_)
          {var
            _h7_=c - 9 | 0,
            switch$0=
             4 < _h7_ >>> 0?23 === _h7_?1:0:1 < (_h7_ - 2 | 0) >>> 0?1:0;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _h6_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_ce_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cf_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=_g_(cst_0b,token_string(ib));break;
        case 3:var tok=_g_(cst_0o,token_string(ib));break;
        case 4:var tok=_g_(cst_0u,token_string(ib));break;
        case 5:var tok=_g_(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l)
       if(43 === caml_string_get(tok,0))return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cg_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_ch_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_h4_,_h5_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_h4_,_h5_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_h2_,_h3_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_h2_,_h3_)}
    function is_hexa_digit(param)
     {var
       _h1_=param - 48 | 0,
       switch$0=
        22 < _h1_ >>> 0
         ?5 < (_h1_ - 49 | 0) >>> 0?0:1
         :6 < (_h1_ - 10 | 0) >>> 0?1:0;
      return switch$0?1:0}
    function scan_hexadecimal_int(_hZ_,_h0_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_hZ_,_h0_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal_int(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal_int(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             var switch$0=120 === c$0?1:0}
           else
            if(88 === c$0)
             var switch$0=1;
            else
             {if(98 <= c$0)
               return scan_binary_int(store_char(width,ib,c$0),ib);
              var switch$0=0}
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c)if(101 !== c)return width;
      return scan_optionally_signed_decimal_int(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _hW_=len - 1 | 0,
       _hV_=0;
      if(! (_hW_ < 0))
       {var i=_hV_;
        for(;;)
         {var c=peek_char(ib),_hX_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _hX_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _hY_=i + 1 | 0;
          if(_hW_ !== i){var i=_hY_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _hI_=0 === width?1:0,_hJ_=_hI_ || end_of_input(ib);
      if(_hJ_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _hK_=0 === width$0?1:0,
       _hL_=_hK_ || end_of_input(ib);
      if(_hL_)bad_hex_float(0);
      var c=peek_char(ib);
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _hM_=0 === width$1?1:0,
             _hN_=_hM_ || end_of_input(ib);
            if(_hN_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}
          var switch$0=0}
        else
         var switch$0=26 === switcher?1:0}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _hQ_=0 === width$3?1:0,
           _hR_=_hQ_ || end_of_input(ib);
          if(_hR_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4)
           if(! end_of_input(ib))
            {var
              match=peek_char(ib),
              _hS_=match - 46 | 0,
              switch$1=
               34 < _hS_ >>> 0?66 === _hS_?1:0:32 < (_hS_ - 1 | 0) >>> 0?1:0,
              width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
             if(0 !== width$5)
              if(! end_of_input(ib))
               {var c$0=peek_char(ib);
                if(46 === c$0)
                 {var width$6=store_char(width$5,ib,c$0);
                  if(0 === width$6)
                   var switch$2=0;
                  else
                   if(end_of_input(ib))
                    var switch$2=0;
                   else
                    {var match$0=peek_char(ib);
                     if(80 === match$0)
                      var switch$3=0;
                     else
                      if(112 === match$0)
                       var switch$3=0;
                      else
                       var
                        precision$0=min(width$6,precision),
                        width$10=
                         width$6
                         -
                         (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                         |
                         0,
                        switch$3=1;
                     if(! switch$3)var width$10=width$6;
                     var width$7=width$10,switch$2=1}
                  if(! switch$2)var width$7=width$6;
                  var width$8=width$7}
                else
                 var width$8=width$5;
                if(0 !== width$8)
                 if(! end_of_input(ib))
                  {var c$1=peek_char(ib);
                   if(80 !== c$1)if(112 !== c$1)return width$8;
                   var
                    width$9=store_char(width$8,ib,c$1),
                    _hT_=0 === width$9?1:0,
                    _hU_=_hT_ || end_of_input(ib);
                   if(_hU_)bad_hex_float(0);
                   return scan_optionally_signed_decimal_int(width$9,ib)}
                return width$8}
             return width$5}
          return width$4}
        var switch$0=73 === c?1:0}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _hO_=0 === width$2?1:0,
         _hP_=_hO_ || end_of_input(ib);
        if(_hP_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _hE_=0 === width?1:0,_hF_=_hE_ || end_of_input(ib);
      if(_hF_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _hG_=0 === width$0?1:0,
       _hH_=_hG_ || end_of_input(ib);
      if(_hH_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _hq_=0 === width?1:0,_hr_=_hq_ || end_of_input(ib);
      if(_hr_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _hs_=0 === width$0?1:0,
       _ht_=_hs_ || end_of_input(ib);
      if(_ht_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _hu_=0 === width$1?1:0,
           _hv_=_hu_ || end_of_input(ib);
          if(_hv_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _hw_=0 === width$2?1:0,
          _hx_=_hw_ || end_of_input(ib);
         if(_hx_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0)
          if(120 !== c$0)return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _hy_=0 === width$3?1:0,
          _hz_=_hy_ || end_of_input(ib);
         if(_hz_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _hA_=0 === width$4?1:0,
          _hB_=_hA_ || end_of_input(ib);
         if(_hB_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1);
            if(0 === width$5)
             var switch$1=0;
            else
             if(end_of_input(ib))
              var switch$1=0;
             else
              {var match=peek_char(ib);
               if(80 === match)
                var switch$2=0;
               else
                if(112 === match)
                 var switch$2=0;
                else
                 var
                  precision$0=min(width$5,precision),
                  width$10=
                   width$5
                   -
                   (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                   |
                   0,
                  switch$2=1;
               if(! switch$2)var width$10=width$5;
               var width$6=width$10,switch$1=1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6,switch$0=0}
          else
           var switch$0=1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)
            var width$7=width$4,switch$0=0;
           else
            var switch$0=1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8)
          if(! end_of_input(ib))
           {var c$2=peek_char(ib);
            if(80 !== c$2)if(112 !== c$2)return width$8;
            var
             width$9=store_char(width$8,ib,c$2),
             _hC_=0 === width$9?1:0,
             _hD_=_hC_ || end_of_input(ib);
            if(_hD_)bad_hex_float(0);
            return scan_optionally_signed_decimal_int(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var
         _hp_=c - 9 | 0,
         switch$0=4 < _hp_ >>> 0?23 === _hp_?1:0:1 < (_hp_ - 2 | 0) >>> 0?1:0;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cc_),message)):c}
    function check_next_char_for_char(_hn_,_ho_)
     {return check_next_char(cst_a_Char,_hn_,_ho_)}
    function check_next_char_for_string(_hl_,_hm_)
     {return check_next_char(cst_a_String,_hl_,_hm_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib);
      if(40 <= c0)
       if(58 <= c0)
        {var switcher$0=c0 - 92 | 0;
         if(28 < switcher$0 >>> 0)
          var switch$0=0;
         else
          switch(switcher$0)
           {case 28:
             var
              get_digit=
               function(param)
                {var
                  c=next_char(ib),
                  _hk_=c - 48 | 0,
                  switch$0=
                   22 < _hk_ >>> 0
                    ?5 < (_hk_ - 49 | 0) >>> 0?0:1
                    :6 < (_hk_ - 10 | 0) >>> 0?1:0;
                 return switch$0?c:bad_input_escape(c)},
              c1=get_digit(0),
              c2=get_digit(0),
              _hg_=hexadecimal_value_of_char(c2),
              c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _hg_ | 0;
             if(0 <= c$0)
              if(255 < c$0)
               var switch$1=0;
              else
               var _hi_=char_of_int(c$0),switch$1=1;
             else
              var switch$1=0;
             if(! switch$1)
              var _hi_=bad_input(caml_call2(sprintf(_cj_),c1,c2));
             return store_char(width - 2 | 0,ib,_hi_);
            case 0:
            case 6:
            case 18:
            case 22:
            case 24:var switch$0=1;break;
            default:var switch$0=0}}
       else
        {if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0;
           if(0 <= c)
            if(255 < c)var switch$2=0;else var _hj_=char_of_int(c),switch$2=1;
           else
            var switch$2=0;
           if(! switch$2)
            var _hj_=bad_input(caml_call3(sprintf(_ci_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_hj_)}
         var switch$0=0}
      else
       var switch$0=34 === c0?1:39 <= c0?1:0;
      if(switch$0)
       {if(110 <= c0)
         if(117 <= c0)
          var switch$3=0;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _hh_=10,switch$3=1;break;
             case 4:var _hh_=13,switch$3=1;break;
             case 6:var _hh_=9,switch$3=1;break;
             default:var switch$3=0}}
        else
         if(98 === c0)var _hh_=8,switch$3=1;else var switch$3=0;
        if(! switch$3)var _hh_=c0;
        return store_char(width,ib,_hh_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _he_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_he_)}
              return caml_trampoline_return(skip_spaces,[0,_he_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _hf_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_hf_)}
                return caml_trampoline_return(skip_spaces,[0,_hf_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_ha_=0 < i$0?1:0;
          if(_ha_)
           {var _hb_=1 - ib[1];
            if(_hb_)
             var _hc_=is_in_char_set(char_set,c),_hd_=_hc_?c !== stp?1:0:_hc_;
            else
             var _hd_=_hb_}
          else
           var _hd_=_ha_;
          if(_hd_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _hd_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _g$_=1 - ib[1];
        if(_g$_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _g$_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cl_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cm_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_g9_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_g9_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_g9_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _g__=fmt$0[1];
           if(0 === _g__[0])
            {var
              rest$0=fmt$0[2],
              match=_g__[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_g__[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {caml_call3(scan,max_int,max_int,ib);
            var x=caml_call1(token,ib);
            return [0,x,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion)}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(0 === pad[1])return invalid_arg(cst_scanf_bad_conversion$0);
          var _g8_=pad[2];
          if(typeof prec === "number")
           {if(0 === prec)
             {caml_call3(scan,_g8_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            return invalid_arg(cst_scanf_bad_conversion$1)}
          var p$0=prec[1];
          caml_call3(scan,_g8_,p$0,ib);
          var x$2=caml_call1(token,ib);
          return [0,x$2,make_scanf(ib,fmt,readers)]}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _gT_=fmt$0[2],_gU_=fmt$0[1];
           if(typeof _gT_ !== "number")
            switch(_gT_[0])
             {case 17:
               var
                rest$1=_gT_[2],
                fmting_lit=_gT_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$1];
               return pad_prec_scanf
                       (ib,str_rest,readers,_gU_,0,scan$0,token_string);
              case 18:
               var _gV_=_gT_[1];
               if(0 === _gV_[0])
                {var
                  rest$2=_gT_[2],
                  match$0=_gV_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cn_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$2),
                          readers,
                          _gU_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$3=_gT_[2],
                match$1=_gV_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_co_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$3),
                        readers,
                        _gU_,
                        0,
                        scan$2,
                        token_string)
              }
           var scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,_gT_,readers,_gU_,0,scan,token_string);
          case 3:
           var
            rest$4=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$4,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$5=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$5,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$6=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$7=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$8=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           var _gW_=fmt$0[1];
           if(15 === _gW_)
            {var rest$9=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$9,readers,pad$4,prec$3,scan_caml_float,token_float)}
           if(16 <= _gW_)
            {var rest$10=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$10,readers,pad$5,prec$4,scan_hex_float,token_float)}
           var rest$11=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
           return pad_prec_scanf
                   (ib,rest$11,readers,pad$6,prec$5,scan_float,token_float);
          case 9:
           var
            rest$12=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_g7_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_ck_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$12,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$13=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$13;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$14=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_g6_){return check_char(ib,_g6_)},str$0);
           var fmt$0=rest$14;
           continue;
          case 12:
           var rest$15=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$15;
           continue;
          case 13:
           var rest$16=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _gX_=format_of_string_fmtty(s,fmtty),fmt$3=_gX_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$16,readers)];
          case 14:
           var rest$17=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _gZ_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=_gZ_,
              fmt$4=fmt$8}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _gY_=bad_input(msg$0),
              fmt$5=_gY_[1],
              fmt$4=_gY_[2]}
           return [0,
                   [0,fmt$5,s$0],
                   make_scanf(ib,concat_fmt(fmt$4,rest$17),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$18=fmt$0[2],
            formatting_lit=fmt$0[1],
            _g0_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_g5_){return check_char(ib,_g5_)},_g0_);
           var fmt$0=rest$18;
           continue;
          case 18:
           var _g1_=fmt$0[1];
           if(0 === _g1_[0])
            {var rest$19=fmt$0[2],match$4=_g1_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$19),fmt$0=fmt$10;
             continue}
           var rest$20=fmt$0[2],match$5=_g1_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$20),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _g2_=fmt$0[3],_g3_=fmt$0[2],_g4_=fmt$0[1];
           if(typeof _g2_ !== "number" && 17 === _g2_[0])
            {var
              rest$21=_g2_[2],
              fmting_lit$0=_g2_[1],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_g4_);
             scan_chars_in_char_set(_g3_,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$21];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var width=width_of_pad_opt(_g4_);
           scan_chars_in_char_set(_g3_,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,_g2_,readers)];
          case 21:
           var
            rest$22=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$22,readers)];
          case 22:
           var rest$23=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$23,readers)];
          case 23:
           var
            rest$24=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$24),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cp_];
          default:
           return invalid_arg(cst_scanf_bad_conversion_custom_converter)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _gS_=[0,make_scanf(ib,fmt,readers)],_gR_=_gS_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          if(exc[1] === Scan_failure)
           var switch$0=0;
          else
           if(exc[1] === Failure)
            var switch$0=0;
           else
            if(exc === End_of_file)
             var switch$0=0;
            else
             {if(exc[1] !== Invalid_argument)throw exc;
              var
               msg=exc[2],
               _gQ_=
                invalid_arg
                 (_g_(msg,_g_(cst_in_format,_g_(escaped$1(str),cst$88)))),
               switch$0=1}
          if(! switch$0)var _gQ_=[1,exc];
          var _gR_=_gQ_}
        if(0 === _gR_[0]){var args=_gR_[1];return apply(f,args)}
        var exc=_gR_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _gP_=format_of_string_format(str,format),fmt=_gP_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _gO_(x){return x}
      return sscanf_format(_g_(cst$90,_g_(escaped$1(s),cst$89)),fmt,_gO_)}
    function unescaped(s)
     {function _gN_(x){return x}
      return caml_call1(sscanf(_g_(cst$92,_g_(s,cst$91)),_cq_),_gN_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(761,Stdlib_scanf,"Stdlib__scanf");
    var register=caml_register_named_value;
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(762,Stdlib_callback,"Stdlib__callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_gK_=caml_ml_string_length(s) - 1 | 0,_gJ_=0;
      if(! (_gK_ < 0))
       {var i=_gJ_;
        for(;;)
         {var _gL_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _gL_ | 0;
          var _gM_=i + 1 | 0;
          if(_gK_ !== i){var i=_gM_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare$11=caml_string_compare,
     Vars=caml_call1(Stdlib_map[1],[0,compare$11]),
     compare$12=caml_string_compare,
     Meths=caml_call1(Stdlib_map[1],[0,compare$12]),
     compare$13=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$13]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _gD_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _gD_;
      var _gF_=len - 1 | 0,_gE_=0;
      if(! (_gF_ < 0))
       {var i=_gE_;
        for(;;)
         {var
           _gH_=(i * 2 | 0) + 3 | 0,
           _gG_=caml_check_bound(pub_labels,i)[i + 1];
          caml_check_bound(methods,_gH_)[_gH_ + 1] = _gG_;
          var _gI_=i + 1 | 0;
          if(_gF_ !== i){var i=_gI_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_gB_=old_size < new_size?1:0;
      if(_gB_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _gC_=0}
      else
       var _gC_=_gB_;
      return _gC_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _gz_=caml_call2(Meths[27],name,table[3]);return _gz_}
      catch(_gA_)
       {_gA_ = caml_wrap_exception(_gA_);
        if(_gA_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _gA_}}
    function get_method_labels(table,names)
     {return map$5(function(_gy_){return get_method_label(table,_gy_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[label + 1]
                =
                element)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _gw_=assoc(label,table[6]);return _gw_}
      catch(_gx_)
       {_gx_ = caml_wrap_exception(_gx_);
        if(_gx_ === Not_found)
         return caml_check_bound(table[2],label)[label + 1];
        throw _gx_}}
    function to_list$3(arr){return arr === 0?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$2
         (function(_gv_){return get_method_label(table,_gv_)},virt_meths$0),
       concr_meth_labs=
        map$2
         (function(_gu_){return get_method_label(table,_gu_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _gl_=Vars[1],_gm_=table[7];
      function _gn_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_gn_,_gm_,_gl_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _gq_=by_label[1];
          try
           {var _gs_=caml_call2(Labs[27],label,table[4]),_gr_=_gs_}
          catch(_gt_)
           {_gt_ = caml_wrap_exception(_gt_);
            if(_gt_ !== Not_found)throw _gt_;
            var _gr_=1}
          by_label[1] = caml_call3(Labs[4],label,_gr_,_gq_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _go_=0,_gp_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _gp_,
        _go_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _gk_=caml_call2(Vars[27],v,table[7]);
          return caml_call3(Vars[4],v,_gk_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _gj_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _gj_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _gh_=caml_call2(Vars[27],name,table[7]);return _gh_}
      catch(_gi_)
       {_gi_ = caml_wrap_exception(_gi_);
        if(_gi_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$93))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _gi_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _f$_=nmeths - 1 | 0,
       _f__=0;
      if(! (_f$_ < 0))
       {var i$0=_f__;
        for(;;)
         {var
           _gf_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[i$0 + 1]);
          caml_check_bound(res,i$0)[i$0 + 1] = _gf_;
          var _gg_=i$0 + 1 | 0;
          if(_f$_ !== i$0){var i$0=_gg_;continue}
          break}}
      var _gb_=nvals - 1 | 0,_ga_=0;
      if(! (_gb_ < 0))
       {var i=_ga_;
        for(;;)
         {var
           _gd_=i + nmeths | 0,
           _gc_=new_variable(table,caml_check_bound(vals,i)[i + 1]);
          caml_check_bound(res,_gd_)[_gd_ + 1] = _gc_;
          var _ge_=i + 1 | 0;
          if(_gb_ !== i){var i=_ge_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _f8_=caml_call2(Vars[27],name,table[7]);return _f8_}
      catch(_f9_)
       {_f9_ = caml_wrap_exception(_f9_);
        if(_f9_ === Not_found)throw [0,Assert_failure,_cr_];
        throw _f9_}}
    function get_variables(table,names)
     {return map$5(function(_f7_){return get_variable(table,_f7_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(public_methods === 0)return new_table([0]);
      var
       tags=map$5(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _f2_=0,
       _f3_=to_array(concr_meths),
       _f4_=
        [0,
         map$5
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_f3_),
         _f2_],
       _f5_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$5(function(_f6_){return get_variable(cla,_f6_)},_f5_),
                 _f4_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_f1_=0 !== inits?1:0;
      return _f1_?iter_f(obj,inits):_f1_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initializers(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cv_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_fX_=0;
      if(! (n < 0))
       {var i=_fX_;
        for(;;)
         {var _fZ_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[i + 1],_fZ_,0];
          var _f0_=i + 1 | 0;
          if(n !== i){var i=_f0_;continue}
          break}}
      var _fY_=r[1];
      if(tables){tables[2] = _fY_;return res}
      throw [0,Assert_failure,_cs_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[i + 1],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cx_]}
                if(tables$0)
                 {var _fW_=tables$0[3];
                  if(_fW_){var tables$0=_fW_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_ct_]}
                throw [0,Assert_failure,_cw_]}
              throw [0,Assert_failure,_cu_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table);
      if(0 === (n % 2 | 0))
       var switch$0=0;
      else
       if((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n)
        var switch$0=0;
       else
        var n$0=new_method(table),switch$0=1;
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[n$0 + 1] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _fQ_=i[1],
           label=caml_check_bound(methods,_fQ_)[_fQ_ + 1],
           next=
            function(param)
             {i[1]++;
              var _fV_=i[1];
              return caml_check_bound(methods,_fV_)[_fV_ + 1]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[n + 1]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[e + 1][n + 1]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][n + 1],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[n + 1] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[n + 1])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[e + 1][n + 1])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][n + 1],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[n + 1])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[e + 1][n + 1])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][n + 1],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[n + 1],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[e + 1][n + 1],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][n + 1],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,obj[m + 1])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,obj[e + 1][m + 1])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _fT_=caml_call1(obj[1][m + 1],obj);
                     return caml_call2(obj[1][n + 1],obj,_fT_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _fS_=obj[n + 1];
                     return caml_call2(caml_get_public_method(_fS_,m,0),_fS_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _fR_=obj[e + 1][n + 1];
                     return caml_call2(caml_get_public_method(_fR_,m,0),_fR_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _fU_=caml_call1(obj[1][n + 1],obj);
                     return caml_call2(caml_get_public_method(_fU_,m,0),_fU_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initializers,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(763,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(764,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(765,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _fO_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _fO_}
        catch(_fP_)
         {_fP_ = caml_wrap_exception(_fP_);
          if(_fP_ === Not_found)return [1,id];
          throw _fP_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _fM_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _fM_}
        catch(_fN_)
         {_fN_ = caml_wrap_exception(_fN_);
          if(_fN_ === Not_found)throw [0,Error,_g_(cst_Illegal_character,s)];
          throw _fN_}}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fL_=match[1],switcher=_fL_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_fL_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fK_=match[1],switch$0=43 === _fK_?0:45 === _fK_?0:1;
          if(! switch$0)
           {junk(strm);store(_fK_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _fH_=match[1];
            if(58 <= _fH_)
             {var switch$0=69 === _fH_?0:101 === _fH_?0:1;
              if(! switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _fH_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _fI_=match$0[1],_fJ_=_fI_ - 69 | 0;
                    if(32 < _fJ_ >>> 0)
                     {var switcher=_fJ_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_fI_);continue}}
                    else
                     {var switcher$0=_fJ_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _fH_){junk(s);store(_fH_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fF_=match[1];
            if(94 <= _fF_)
             var
              _fG_=_fF_ - 95 | 0,
              switch$0=30 < _fG_ >>> 0?32 <= _fG_?1:0:29 === _fG_?0:1;
            else
             if(65 <= _fF_)
              var switch$0=92 === _fF_?0:1;
             else
              if(33 <= _fF_)
               switch(_fF_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:var switch$0=0;break;
                 default:var switch$0=1}
              else
               var switch$0=1;
            if(! switch$0){junk(strm);store(_fF_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _fE_=match[1],switcher=_fE_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_fE_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fC_=match[1];
            if(91 <= _fC_)
             var
              _fD_=_fC_ - 95 | 0,
              switch$0=27 < _fD_ >>> 0?97 <= _fD_?0:1:1 === _fD_?1:0;
            else
             var
              switch$0=
               48 <= _fC_?6 < (_fC_ - 58 | 0) >>> 0?0:1:39 === _fC_?0:1;
            if(! switch$0){junk(strm);store(_fC_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _ft_=match[1];
            if(124 <= _ft_)
             var switch$0=127 <= _ft_?192 <= _ft_?1:0:125 === _ft_?0:2;
            else
             {var _fu_=_ft_ - 65 | 0;
              if(57 < _fu_ >>> 0)
               if(58 <= _fu_)
                var switch$0=0;
               else
                {var switcher=_fu_ + 65 | 0;
                 switch(switcher)
                  {case 34:
                    junk(strm);
                    reset_buffer(0);
                    for(;;)
                     {var match$1=peek$0(strm);
                      if(match$1)
                       {var _fw_=match$1[1];
                        if(34 === _fw_){junk(strm);return [0,[4,get_string(0)]]}
                        if(92 === _fw_)
                         {junk(strm);
                          try
                           {var c$0=escape(strm)}
                          catch(_fB_)
                           {_fB_ = caml_wrap_exception(_fB_);
                            if(_fB_ === Failure$0)throw [0,Error,cst$96];
                            throw _fB_}
                          store(c$0);
                          continue}
                        junk(strm);
                        store(_fw_);
                        continue}
                      throw Failure$0}
                   case 39:
                    junk(strm);
                    try
                     {var match$2=peek$0(strm);
                      if(! match$2)throw Failure$0;
                      var _fx_=match$2[1];
                      if(92 === _fx_)
                       {junk(strm);
                        try
                         {var _fy_=escape(strm)}
                        catch(_fA_)
                         {_fA_ = caml_wrap_exception(_fA_);
                          if(_fA_ === Failure$0)throw [0,Error,cst$97];
                          throw _fA_}
                        var c=_fy_}
                      else
                       {junk(strm);var c=_fx_}}
                    catch(_fz_)
                     {_fz_ = caml_wrap_exception(_fz_);
                      if(_fz_ === Failure$0)throw [0,Error,cst$94];
                      throw _fz_}
                    var match$0=peek$0(strm);
                    if(match$0)
                     if(39 === match$0[1]){junk(strm);return [0,[5,c]]}
                    throw [0,Error,cst$95];
                   case 40:
                    junk(strm);
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return maybe_comment(counter$0,strm)}
                    return caml_trampoline_return(maybe_comment,[0,strm]);
                   case 45:junk(strm);return neg_number(strm);
                   case 9:
                   case 10:
                   case 12:
                   case 13:
                   case 26:
                   case 32:junk(strm);continue;
                   case 48:
                   case 49:
                   case 50:
                   case 51:
                   case 52:
                   case 53:
                   case 54:
                   case 55:
                   case 56:
                   case 57:
                    junk(strm);reset_buffer(0);store(_ft_);return number(strm);
                   case 33:
                   case 35:
                   case 36:
                   case 37:
                   case 38:
                   case 42:
                   case 43:
                   case 47:
                   case 58:
                   case 60:
                   case 61:
                   case 62:
                   case 63:
                   case 64:var switch$0=2;break;
                   default:var switch$0=0}}
              else
               {var _fv_=_fu_ - 26 | 0;
                if(5 < _fv_ >>> 0)
                 var switch$0=1;
                else
                 switch(_fv_)
                  {case 4:var switch$0=1;break;
                   case 1:
                   case 3:var switch$0=2;break;
                   default:var switch$0=0}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_ft_)];
              case 1:
               junk(strm);reset_buffer(0);store(_ft_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_ft_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match)
         if(42 === match[1])
          {junk(strm);
           comment(strm);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return next_token$0(counter$0,strm)}
           return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fq_=match[1];
          if(58 <= _fq_)
           {var switcher=_fq_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _fq_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _fr_=match$0[1],switcher$0=_fr_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _fs_=match$1[1],switcher$1=_fs_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_fq_ - 48 | 0) * 100 | 0)
                               +
                               ((_fr_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_fs_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$99]}}
             throw [0,Error,cst$98]}
          junk(strm);
          return _fq_}
        throw Failure$0}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _fp_=match$1[1];
                    if(41 === _fp_){junk(strm);return 0}
                    if(42 === _fp_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(766,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_fo_){return caml_call1(_b4_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x))
           if(! (max_array_length < (x * 2 | 0)))
            {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _fm_=caml_obj_tag(prng),
            _fn_=250 === _fm_?prng[1]:246 === _fm_?force_lazy_block(prng):prng,
            seed=caml_call1(_b4_[4],_fn_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_fk_=len - 1 | 0,_fj_=0;
        if(! (_fk_ < 0))
         {var i=_fj_;
          for(;;)
           {caml_check_bound(h[2],i)[i + 1] = 0;
            var _fl_=i + 1 | 0;
            if(_fk_ !== i){var i=_fl_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _fg_=init[4],_fh_=init[3],_fi_=copy$1(init[2]);
        return [0,init[1],_fi_,_fh_,_fg_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hkey=param$0[1];
              if(caml_call1(H[7],c))return [0,hkey,c,do_bucket(rest)];
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_fd_=d.length - 1 - 1 | 0,_fc_=0;
        if(! (_fd_ < 0))
         {var i=_fc_;
          for(;;)
           {var _fe_=do_bucket(caml_check_bound(d,i)[i + 1]);
            caml_check_bound(d,i)[i + 1] = _fe_;
            var _ff_=i + 1 | 0;
            if(_fd_ !== i){var i=_ff_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _e8_=nsize < max_array_length?1:0,
         _e9_=_e8_?(osize >>> 1 | 0) <= h[1]?1:0:_e8_;
        if(_e9_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var nidx=key_index(h,hkey);
                return ndata[nidx + 1]
                       =
                       [0,hkey,data,caml_check_bound(ndata,nidx)[nidx + 1]]}
              return 0},
           _e$_=osize - 1 | 0,
           _e__=0;
          if(! (_e$_ < 0))
           {var i=_e__;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[i + 1]);
              var _fb_=i + 1 | 0;
              if(_e$_ !== i){var i=_fb_;continue}
              break}}
          var _fa_=0}
        else
         var _fa_=_e9_;
        return _fa_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[i + 1]];
        caml_check_bound(h[2],i)[i + 1] = bucket;
        h[1] = h[1] + 1 | 0;
        var _e7_=h[2].length - 1 << 1 < h[1]?1:0;
        return _e7_?resize(h):_e7_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              return [0,hk,c,remove_bucket(next)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _e6_=remove_bucket(caml_check_bound(h[2],i)[i + 1]);
        return caml_check_bound(h[2],i)[i + 1] = _e6_}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e5_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e5_)[_e5_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e4_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e4_)[_e4_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$0=rest;
              continue}
            return 0}}
        var _e3_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_e3_)[_e3_ + 1])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(0 === match)return caml_call3(H[6],c,key,info);
                var param$0=next;
                continue}
              var param$0=next;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[i + 1];
        try
         {var _e1_=replace_bucket(l);return _e1_}
        catch(_e2_)
         {_e2_ = caml_wrap_exception(_e2_);
          if(_e2_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[i + 1] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _e0_=h[2].length - 1 << 1 < h[1]?1:0;
            return _e0_?resize(h):_e0_}
          throw _e2_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _eZ_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_eZ_)[_eZ_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(0 === match)return 1;
              var param=rest;
              continue}
            var param=rest;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_eX_=d$0.length - 1 - 1 | 0,_eW_=0;
        if(! (_eX_ < 0))
         {var i=_eW_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[i + 1],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  {var d=match$0[1],k=match[1];
                   caml_call2(f,k,d);
                   var switch$0=1}
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                var param=rest;
                continue}
              var _eY_=i + 1 | 0;
              if(_eX_ !== i){var i=_eY_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_eT_=d$0.length - 1 - 1 | 0,_eS_=0;
        if(! (_eT_ < 0))
         {var i=_eS_;
          a:
          for(;;)
           {var
             _eU_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[i + 1],
             b=b$0,
             accu=_eU_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  var
                   d=match$0[1],
                   k=match[1],
                   accu$0=caml_call3(f,k,d,accu),
                   switch$0=1;
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _eV_=i + 1 | 0;
              if(_eT_ !== i){var i=_eV_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                 if(match$1)
                  {var new_d=match$1[1];
                   caml_call3(H[6],c,k,new_d);
                   return [0,hk,c,do_bucket(rest)]}
                 var param$0=rest;
                 continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_eP_=d.length - 1 - 1 | 0,_eO_=0;
        if(! (_eP_ < 0))
         {var i=_eO_;
          for(;;)
           {var _eQ_=do_bucket(caml_check_bound(d,i)[i + 1]);
            caml_check_bound(d,i)[i + 1] = _eQ_;
            var _eR_=i + 1 | 0;
            if(_eP_ !== i){var i=_eR_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _eL_=h[2],
         _eM_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_eM_,_eL_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eN_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length(0,b);
            return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
          _eN_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$0=rest;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _eI_=h[2],
         _eJ_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_eJ_,_eI_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eK_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
          _eK_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var data=match$0[1],key=match[1];
                 return [0,
                         [0,key,data],
                         function(_eH_){return aux(i$0,next,_eH_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[i$0 + 1],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _eE_=0,_eF_=0;
        return function(_eG_){return aux(_eF_,_eE_,_eG_)}}
      function to_seq_keys(m)
       {var _eA_=to_seq(m);
        function _eB_(_eD_){return _eD_[1]}
        return function(_eC_){return map(_eB_,_eA_,_eC_)}}
      function to_seq_values(m)
       {var _ew_=to_seq(m);
        function _ex_(_ez_){return _ez_[2]}
        return function(_ey_){return map(_ex_,_ew_,_ey_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_x_[1],1)}
    function get_key$0(t){return caml_call2(_x_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_x_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_x_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_x_[6],t,0)}
    function check_key$0(t){return caml_call2(_x_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_x_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_x_[9],t)}
    function get_data_copy(t){return caml_call1(_x_[10],t)}
    function set_data(t,d){return caml_call2(_x_[11],t,d)}
    function unset_data(t){return caml_call1(_x_[12],t)}
    function check_data(t){return caml_call1(_x_[13],t)}
    function blit_data(t1,t2){return caml_call2(_x_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$1(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _ev_=include[1];
      function create(sz){return caml_call2(_ev_,_cy_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_x_[1],2)}
    function get_key1(t){return caml_call2(_x_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_x_[4],t,0)}
    function set_key1(t,k){return caml_call3(_x_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_x_[6],t,0)}
    function check_key1(t){return caml_call2(_x_[7],t,0)}
    function get_key2(t){return caml_call2(_x_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_x_[4],t,1)}
    function set_key2(t,k){return caml_call3(_x_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_x_[6],t,1)}
    function check_key2(t){return caml_call2(_x_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_x_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_x_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_x_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_x_[9],t)}
    function get_data_copy$0(t){return caml_call1(_x_[10],t)}
    function set_data$0(t,d){return caml_call2(_x_[11],t,d)}
    function unset_data$0(t){return caml_call1(_x_[12],t)}
    function check_data$0(t){return caml_call1(_x_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_x_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _eu_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _eu_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0)
          {var k2$0=match$0[1],k1$0=match[1];
           if(caml_call2(H1[1],k1,k1$0))if(caml_call2(H2[1],k2,k2$0))return 0;
           return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0){var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _et_=check_key1(c);return _et_?check_key2(c):_et_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$2(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_er_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_er_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _es_=include[1];
      function create(sz){return caml_call2(_es_,_cz_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_x_[1],n)}
    function length$6(k){return caml_call1(_x_[2],k)}
    function get_key$1(t,n){return caml_call2(_x_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_x_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_x_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_x_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_x_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_x_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_x_[9],t)}
    function get_data_copy$1(t){return caml_call1(_x_[10],t)}
    function set_data$1(t,d){return caml_call2(_x_[11],t,d)}
    function unset_data$1(t){return caml_call1(_x_[12],t)}
    function check_data$1(t){return caml_call1(_x_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_x_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _ep_=k.length - 1 - 1 | 0,_eo_=0;
        if(! (_ep_ < 0))
         {var i=_eo_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[i + 1]);
            var _eq_=i + 1 | 0;
            if(_ep_ !== i){var i=_eq_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_ek_=k.length - 1 - 1 | 0,_ej_=0;
        if(! (_ek_ < 0))
         {var i=_ej_;
          for(;;)
           {var _el_=h[1],_em_=caml_check_bound(k,i)[i + 1];
            h[1] = (caml_call2(H[2],seed,_em_) * 65599 | 0) + _el_ | 0;
            var _en_=i + 1 | 0;
            if(_ek_ !== i){var i=_en_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_ei_=caml_check_bound(k,i)[i + 1];
              if(caml_call2(H[1],_ei_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[i + 1] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _eg_=k.length - 1 - 1 | 0,_ef_=0;
        if(! (_eg_ < 0))
         {var i=_ef_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[i + 1]);
            var _eh_=i + 1 | 0;
            if(_eg_ !== i){var i=_eh_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _ec_=i < 0?1:0;
          if(_ec_)
           var _ed_=_ec_;
          else
           {var _ee_=check_key$1(c,i);
            if(_ee_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ed_=_ee_}
          return _ed_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$3(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _eb_=include[1];
      function create(sz){return caml_call2(_eb_,_cA_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$1,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$2,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$3,
        MakeSeeded$3],
       [0,
        function(_ea_)
         {return MakeSeeded$0
                  ([0,_ea_[3],_ea_[1],_ea_[2],_ea_[5],_ea_[4],_ea_[6],_ea_[7]])}]];
    caml_register_global(767,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$100))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$101))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _d__=caml_ml_string_length(n) < 1?1:0,
       _d$_=_d__ || (47 !== caml_string_get(n,0)?1:0);
      return _d$_}
    function is_implicit(n)
     {var _d5_=is_relative(n);
      if(_d5_)
       {var
         _d6_=caml_ml_string_length(n) < 2?1:0,
         _d7_=_d6_ || caml_string_notequal(sub$0(n,0,2),cst$103);
        if(_d7_)
         var
          _d8_=caml_ml_string_length(n) < 3?1:0,
          _d9_=_d8_ || caml_string_notequal(sub$0(n,0,3),cst$102);
        else
         var _d9_=_d7_}
      else
       var _d9_=_d5_;
      return _d9_}
    function check_suffix(name,suff)
     {var
       _d3_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _d4_=
        _d3_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_d3_;
      return _d4_}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cI_=caml_sys_getenv(cst_TMPDIR),_cB_=_cI_}
    catch(_d2_)
     {_d2_ = caml_wrap_exception(_d2_);
      if(_d2_ !== Not_found)throw _d2_;
      var _cB_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _d0_=l - 1 | 0,_dZ_=0;
      if(! (_d0_ < 0))
       {var i=_dZ_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _d1_=i + 1 | 0;
          if(_d0_ !== i){var i=_d1_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function basename(_dY_)
     {return generic_basename(is_dir_sep,current_dir_name,_dY_)}
    function dirname(_dX_)
     {return generic_dirname(is_dir_sep,current_dir_name,_dX_)}
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_dU_=47 === c?1:0;
      if(_dU_)
       var _dV_=_dU_;
      else
       var _dW_=92 === c?1:0,_dV_=_dW_ || (58 === c?1:0);
      return _dV_}
    function is_relative$0(n)
     {var
       _dO_=caml_ml_string_length(n) < 1?1:0,
       _dP_=_dO_ || (47 !== caml_string_get(n,0)?1:0);
      if(_dP_)
       {var
         _dQ_=caml_ml_string_length(n) < 1?1:0,
         _dR_=_dQ_ || (92 !== caml_string_get(n,0)?1:0);
        if(_dR_)
         var
          _dS_=caml_ml_string_length(n) < 2?1:0,
          _dT_=_dS_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _dT_=_dR_}
      else
       var _dT_=_dP_;
      return _dT_}
    function is_implicit$0(n)
     {var _dF_=is_relative$0(n);
      if(_dF_)
       {var
         _dG_=caml_ml_string_length(n) < 2?1:0,
         _dH_=_dG_ || caml_string_notequal(sub$0(n,0,2),cst$107);
        if(_dH_)
         {var
           _dI_=caml_ml_string_length(n) < 2?1:0,
           _dJ_=_dI_ || caml_string_notequal(sub$0(n,0,2),cst$106);
          if(_dJ_)
           {var
             _dK_=caml_ml_string_length(n) < 3?1:0,
             _dL_=_dK_ || caml_string_notequal(sub$0(n,0,3),cst$105);
            if(_dL_)
             var
              _dM_=caml_ml_string_length(n) < 3?1:0,
              _dN_=_dM_ || caml_string_notequal(sub$0(n,0,3),cst$104);
            else
             var _dN_=_dL_}
          else
           var _dN_=_dJ_}
        else
         var _dN_=_dH_}
      else
       var _dN_=_dF_;
      return _dN_}
    function check_suffix$0(name,suff)
     {var _dC_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_dC_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _dD_=lowercase_ascii$1(suff),
        _dE_=caml_string_equal(lowercase_ascii$1(s),_dD_);
      else
       var _dE_=_dC_;
      return _dE_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _dB_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_dB_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cH_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cH_}
    catch(_dA_)
     {_dA_ = caml_wrap_exception(_dA_);
      if(_dA_ !== Not_found)throw _dA_;
      var temp_dir_name=cst$108}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _dy_=1;
        if(! (n < 1))
         {var j=_dy_;
          for(;;)
           {add_char(b,92);
            var _dz_=j + 1 | 0;
            if(n !== j){var j=_dz_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _dw_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_dw_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dw_,i$0])}
          if(92 === c)
           {var _dx_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_dx_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dx_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _dv_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_dv_)}
            return caml_trampoline_return(loop$0,[0,_dv_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function drive_and_path(s)
     {var _dr_=2 <= caml_ml_string_length(s)?1:0;
      if(_dr_)
       var
        param=caml_string_get(s,0),
        switch$0=91 <= param?25 < (param - 97 | 0) >>> 0?0:1:65 <= param?1:0,
        _ds_=switch$0?1:0,
        _dt_=_ds_?58 === caml_string_get(s,1)?1:0:_ds_;
      else
       var _dt_=_dr_;
      if(_dt_)
       {var _du_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_du_]}
      return [0,cst$109,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return _g_(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    function basename$1(_dq_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_dq_)}
    function dirname$1(_dp_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_dp_)}
    if(caml_string_notequal(os_type,cst_Cygwin))
     if(caml_string_notequal(os_type,cst_Win32))
      var
       current_dir_name$2=current_dir_name,
       parent_dir_name$2=parent_dir_name,
       dir_sep$2=dir_sep,
       is_dir_sep$1=is_dir_sep,
       is_relative$1=is_relative,
       is_implicit$1=is_implicit,
       check_suffix$1=check_suffix,
       chop_suffix_opt$1=chop_suffix_opt,
       temp_dir_name$0=_cB_,
       quote$1=quote,
       basename$2=basename,
       dirname$2=dirname,
       switch$0=1;
     else
      var
       _cG_=
        [0,
         current_dir_name$0,
         parent_dir_name$0,
         dir_sep$0,
         is_dir_sep$0,
         is_relative$0,
         is_implicit$0,
         check_suffix$0,
         chop_suffix_opt$0,
         temp_dir_name,
         quote$0,
         basename$0,
         dirname$0],
       switch$0=0;
    else
     var
      _cG_=
       [0,
        current_dir_name$1,
        parent_dir_name$1,
        dir_sep$1,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        chop_suffix_opt$0,
        _cB_,
        quote,
        basename$1,
        dirname$1],
      switch$0=0;
    if(! switch$0)
     var
      current_dir_name$2=_cG_[1],
      parent_dir_name$2=_cG_[2],
      dir_sep$2=_cG_[3],
      is_dir_sep$1=is_dir_sep$0,
      is_relative$1=is_relative$0,
      is_implicit$1=is_implicit$0,
      check_suffix$1=check_suffix$0,
      chop_suffix_opt$1=chop_suffix_opt$0,
      temp_dir_name$0=_cG_[9],
      quote$1=_cG_[10],
      basename$2=_cG_[11],
      dirname$2=_cG_[12];
    function concat$3(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l)
       if(! is_dir_sep$1(dirname,l - 1 | 0))
        return _g_(dirname,_g_(dir_sep$2,filename));
      return _g_(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1)
         if(! is_dir_sep$1(name,i$1))
          {if(46 === caml_string_get(name,i$1))
            {var i$2=i$1 - 1 | 0,i=i$2;
             for(;;)
              {if(0 <= i)
                if(! is_dir_sep$1(name,i))
                 {if(46 === caml_string_get(name,i))
                   {var i$0=i - 1 | 0,i=i$0;continue}
                  return caml_ml_string_length(name) - i$1 | 0}
               return 0}}
           var i$3=i$1 - 1 | 0,i$1=i$3;
           continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$110:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_do_){return caml_call1(_b4_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _dm_=caml_obj_tag(prng$0),
       _dn_=
        250 === _dm_?prng$0[1]:246 === _dm_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b4_[4],_dn_) & 16777215;
      return concat$3(temp_dir,caml_call3(sprintf(_cC_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cD_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_dk_,_dj_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cE_;
      if(_dk_)var sth$0=_dk_[1],perms=sth$0;else var perms=384;
      if(_dj_)
       var sth$1=_dj_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _dl_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _dl_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$3,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1];
    caml_register_global(768,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0.)if(x[2] == 0.)return _cF_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _di_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_di_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(769,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       map$5,
       iteri$2,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(770,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$2,
       iteri,
       map$2,
       mapi,
       rev_map,
       filter_map$0,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(771,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$3,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$4,
       equal$4,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(772,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$4,
       iteri$1,
       map$4,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$5,
       equal$5,
       split_on_char,
       to_seq$3,
       to_seqi$0,
       of_seq$1];
    caml_register_global(773,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(774,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0];
    caml_register_global(775,Stdlib_stdLabels,"Stdlib__stdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$8(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_native_code(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code
                         (time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_native_code(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$8,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_native_code
                         (time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snapshots(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code(event_name)})}
    var
     Stdlib_spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snapshots];
    caml_register_global(776,Stdlib_spacetime,"Stdlib__spacetime");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_df_=n - 1 | 0,_de_=0;
      if(! (_df_ < 0))
       {var i=_de_;
        for(;;)
         {var _dg_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[i + 1] = _dg_;
          var _dh_=i + 1 | 0;
          if(_df_ !== i){var i=_dh_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var
       _c$_=dims(arr),
       _da_=1,
       _db_=
        fold_left$1(function(_dd_,_dc_){return caml_mul(_dd_,_dc_)},_da_,_c$_);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_db_)}
    var Genarray=[0,dims,size_in_bytes];
    function create$9(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$1(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$0(arr)
     {var _c9_=[0];
      return function(_c__){return runtime.caml_ba_set_generic(arr,_c9_,_c__)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$9(kind,layout);caml_call1(set$0(a),v);return a}
    function create$10(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _c8_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c8_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return 0 === match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function of_array(kind,layout,data)
     {var
       ba=create$10(kind,layout,data.length - 1),
       ofs=0 === layout?0:1,
       _c6_=data.length - 1 - 1 | 0,
       _c5_=0;
      if(! (_c6_ < 0))
       {var i=_c5_;
        for(;;)
         {runtime.caml_ba_set_1
           (ba,i + ofs | 0,caml_check_bound(data,i)[i + 1]);
          var _c7_=i + 1 | 0;
          if(_c6_ !== i){var i=_c7_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _c3_=caml_ba_dim_2(arr),_c4_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c4_),_c3_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2),
       ofs=0 === layout?0:1,
       _cY_=dim1 - 1 | 0,
       _cX_=0;
      if(! (_cY_ < 0))
       {var i=_cX_;
        for(;;)
         {var row=caml_check_bound(data,i)[i + 1];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_non_rectangular_data);
          var _c0_=dim2 - 1 | 0,_cZ_=0;
          if(! (_c0_ < 0))
           {var j=_cZ_;
            for(;;)
             {runtime.caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[j + 1]);
              var _c2_=j + 1 | 0;
              if(_c0_ !== j){var j=_c2_;continue}
              break}}
          var _c1_=i + 1 | 0;
          if(_cY_ !== i){var i=_c1_;continue}
          break}}
      return ba}
    function create$12(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _cU_=runtime.caml_ba_dim_3(arr),
       _cV_=caml_ba_dim_2(arr),
       _cW_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_cW_),_cV_),
               _cU_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$12(kind,layout,dim1,dim2,dim3),
       ofs=0 === layout?0:1,
       _cM_=dim1 - 1 | 0,
       _cL_=0;
      if(! (_cM_ < 0))
       {var i=_cL_;
        for(;;)
         {var row=caml_check_bound(data,i)[i + 1];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_non_cubic_data);
          var _cO_=dim2 - 1 | 0,_cN_=0;
          if(! (_cO_ < 0))
           {var j=_cN_;
            for(;;)
             {var col=caml_check_bound(row,j)[j + 1];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_non_cubic_data$0);
              var _cR_=dim3 - 1 | 0,_cQ_=0;
              if(! (_cR_ < 0))
               {var k=_cQ_;
                for(;;)
                 {runtime.caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[k + 1]);
                  var _cT_=k + 1 | 0;
                  if(_cR_ !== k){var k=_cT_;continue}
                  break}}
              var _cS_=j + 1 | 0;
              if(_cO_ !== j){var j=_cS_;continue}
              break}}
          var _cP_=i + 1 | 0;
          if(_cM_ !== i){var i=_cP_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarray)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarray)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarray)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarray)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       Genarray,
       [0,create$9,caml_ba_change_layout,size_in_bytes$0,get$1,set$0,of_value],
       [0,create$10,caml_ba_change_layout,size_in_bytes$1,slice,of_array],
       [0,
        create$11,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$12,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(777,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 "../.js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_from_string=runtime.caml_js_from_string,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_to_byte_string=runtime.caml_js_to_byte_string,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_new_string("parseFloat"),
     cst_parseInt=caml_new_string("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_new_string("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_new_string("jsError"),
     cst_can_t_retrieve_file_name_not_implemented=
      caml_new_string("can't retrieve file name: not implemented"),
     cst_endings=caml_new_string("endings"),
     cst_type=caml_new_string("type"),
     cst_loadstart=caml_new_string("loadstart"),
     cst_progress=caml_new_string("progress"),
     cst_abort=caml_new_string("abort"),
     cst_error=caml_new_string("error"),
     cst_load=caml_new_string("load"),
     cst_loadend=caml_new_string("loadend"),
     cst_a$1=caml_new_string("a"),
     cst_area$1=caml_new_string("area"),
     cst_audio$1=caml_new_string("audio"),
     cst_base$1=caml_new_string("base"),
     cst_blockquote$1=caml_new_string("blockquote"),
     cst_body$1=caml_new_string("body"),
     cst_br$1=caml_new_string("br"),
     cst_button$1=caml_new_string("button"),
     cst_canvas$1=caml_new_string("canvas"),
     cst_caption$1=caml_new_string("caption"),
     cst_col$1=caml_new_string("col"),
     cst_colgroup$1=caml_new_string("colgroup"),
     cst_del$1=caml_new_string("del"),
     cst_div$1=caml_new_string("div"),
     cst_dl$1=caml_new_string("dl"),
     cst_embed$1=caml_new_string("embed"),
     cst_fieldset$1=caml_new_string("fieldset"),
     cst_form$1=caml_new_string("form"),
     cst_frame$1=caml_new_string("frame"),
     cst_frameset$1=caml_new_string("frameset"),
     cst_h1$1=caml_new_string("h1"),
     cst_h2$1=caml_new_string("h2"),
     cst_h3$1=caml_new_string("h3"),
     cst_h4$1=caml_new_string("h4"),
     cst_h5$1=caml_new_string("h5"),
     cst_h6$1=caml_new_string("h6"),
     cst_head$1=caml_new_string("head"),
     cst_hr$1=caml_new_string("hr"),
     cst_html$1=caml_new_string("html"),
     cst_iframe$1=caml_new_string("iframe"),
     cst_img$1=caml_new_string("img"),
     cst_input$2=caml_new_string("input"),
     cst_ins$1=caml_new_string("ins"),
     cst_label$1=caml_new_string("label"),
     cst_legend$1=caml_new_string("legend"),
     cst_li$1=caml_new_string("li"),
     cst_link$1=caml_new_string("link"),
     cst_map$1=caml_new_string("map"),
     cst_meta$1=caml_new_string("meta"),
     cst_object$1=caml_new_string("object"),
     cst_ol$1=caml_new_string("ol"),
     cst_optgroup$1=caml_new_string("optgroup"),
     cst_option$1=caml_new_string("option"),
     cst_p$1=caml_new_string("p"),
     cst_param$1=caml_new_string("param"),
     cst_pre$1=caml_new_string("pre"),
     cst_q$1=caml_new_string("q"),
     cst_script$1=caml_new_string("script"),
     cst_select$2=caml_new_string("select"),
     cst_style$1=caml_new_string("style"),
     cst_table$1=caml_new_string("table"),
     cst_tbody$1=caml_new_string("tbody"),
     cst_td$1=caml_new_string("td"),
     cst_textarea$1=caml_new_string("textarea"),
     cst_tfoot$1=caml_new_string("tfoot"),
     cst_th$1=caml_new_string("th"),
     cst_thead$1=caml_new_string("thead"),
     cst_title$1=caml_new_string("title"),
     cst_tr$1=caml_new_string("tr"),
     cst_ul$1=caml_new_string("ul"),
     cst_video$1=caml_new_string("video"),
     cst_KeyH=caml_new_string("KeyH"),
     cst_Digit6=caml_new_string("Digit6"),
     cst_BrowserRefresh=caml_new_string("BrowserRefresh"),
     cst_Backslash=caml_new_string("Backslash"),
     cst_AltLeft=caml_new_string("AltLeft"),
     cst_AltRight=caml_new_string("AltRight"),
     cst_ArrowDown=caml_new_string("ArrowDown"),
     cst_ArrowLeft=caml_new_string("ArrowLeft"),
     cst_ArrowRight=caml_new_string("ArrowRight"),
     cst_ArrowUp=caml_new_string("ArrowUp"),
     cst_Backquote=caml_new_string("Backquote"),
     cst_Backspace=caml_new_string("Backspace"),
     cst_BracketLeft=caml_new_string("BracketLeft"),
     cst_BracketRight=caml_new_string("BracketRight"),
     cst_BrowserBack=caml_new_string("BrowserBack"),
     cst_BrowserFavorites=caml_new_string("BrowserFavorites"),
     cst_BrowserForward=caml_new_string("BrowserForward"),
     cst_BrowserHome=caml_new_string("BrowserHome"),
     cst_Delete=caml_new_string("Delete"),
     cst_BrowserSearch=caml_new_string("BrowserSearch"),
     cst_BrowserStop=caml_new_string("BrowserStop"),
     cst_CapsLock=caml_new_string("CapsLock"),
     cst_Comma=caml_new_string("Comma"),
     cst_ContextMenu=caml_new_string("ContextMenu"),
     cst_ControlLeft=caml_new_string("ControlLeft"),
     cst_ControlRight=caml_new_string("ControlRight"),
     cst_Digit0=caml_new_string("Digit0"),
     cst_Digit1=caml_new_string("Digit1"),
     cst_Digit2=caml_new_string("Digit2"),
     cst_Digit3=caml_new_string("Digit3"),
     cst_Digit4=caml_new_string("Digit4"),
     cst_Digit5=caml_new_string("Digit5"),
     cst_F6=caml_new_string("F6"),
     cst_F1=caml_new_string("F1"),
     cst_Digit7=caml_new_string("Digit7"),
     cst_Digit8=caml_new_string("Digit8"),
     cst_Digit9=caml_new_string("Digit9"),
     cst_End=caml_new_string("End"),
     cst_Enter=caml_new_string("Enter"),
     cst_Equal=caml_new_string("Equal"),
     cst_Escape=caml_new_string("Escape"),
     cst_F10=caml_new_string("F10"),
     cst_F11=caml_new_string("F11"),
     cst_F12=caml_new_string("F12"),
     cst_F2=caml_new_string("F2"),
     cst_F3=caml_new_string("F3"),
     cst_F4=caml_new_string("F4"),
     cst_F5=caml_new_string("F5"),
     cst_KeyA=caml_new_string("KeyA"),
     cst_F7=caml_new_string("F7"),
     cst_F8=caml_new_string("F8"),
     cst_F9=caml_new_string("F9"),
     cst_Home=caml_new_string("Home"),
     cst_Insert=caml_new_string("Insert"),
     cst_IntlBackslash=caml_new_string("IntlBackslash"),
     cst_IntlYen=caml_new_string("IntlYen"),
     cst_KeyB=caml_new_string("KeyB"),
     cst_KeyC=caml_new_string("KeyC"),
     cst_KeyD=caml_new_string("KeyD"),
     cst_KeyE=caml_new_string("KeyE"),
     cst_KeyF=caml_new_string("KeyF"),
     cst_KeyG=caml_new_string("KeyG"),
     cst_Numpad4=caml_new_string("Numpad4"),
     cst_KeyX=caml_new_string("KeyX"),
     cst_KeyP=caml_new_string("KeyP"),
     cst_KeyI=caml_new_string("KeyI"),
     cst_KeyJ=caml_new_string("KeyJ"),
     cst_KeyK=caml_new_string("KeyK"),
     cst_KeyL=caml_new_string("KeyL"),
     cst_KeyM=caml_new_string("KeyM"),
     cst_KeyN=caml_new_string("KeyN"),
     cst_KeyO=caml_new_string("KeyO"),
     cst_KeyQ=caml_new_string("KeyQ"),
     cst_KeyR=caml_new_string("KeyR"),
     cst_KeyS=caml_new_string("KeyS"),
     cst_KeyT=caml_new_string("KeyT"),
     cst_KeyU=caml_new_string("KeyU"),
     cst_KeyV=caml_new_string("KeyV"),
     cst_KeyW=caml_new_string("KeyW"),
     cst_MetaRight=caml_new_string("MetaRight"),
     cst_KeyY=caml_new_string("KeyY"),
     cst_KeyZ=caml_new_string("KeyZ"),
     cst_MediaPlayPause=caml_new_string("MediaPlayPause"),
     cst_MediaStop=caml_new_string("MediaStop"),
     cst_MediaTrackNext=caml_new_string("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_new_string("MediaTrackPrevious"),
     cst_MetaLeft=caml_new_string("MetaLeft"),
     cst_Minus=caml_new_string("Minus"),
     cst_NumLock=caml_new_string("NumLock"),
     cst_Numpad0=caml_new_string("Numpad0"),
     cst_Numpad1=caml_new_string("Numpad1"),
     cst_Numpad2=caml_new_string("Numpad2"),
     cst_Numpad3=caml_new_string("Numpad3"),
     cst_PageUp=caml_new_string("PageUp"),
     cst_NumpadDivide=caml_new_string("NumpadDivide"),
     cst_Numpad5=caml_new_string("Numpad5"),
     cst_Numpad6=caml_new_string("Numpad6"),
     cst_Numpad7=caml_new_string("Numpad7"),
     cst_Numpad8=caml_new_string("Numpad8"),
     cst_Numpad9=caml_new_string("Numpad9"),
     cst_NumpadAdd=caml_new_string("NumpadAdd"),
     cst_NumpadDecimal=caml_new_string("NumpadDecimal"),
     cst_NumpadEnter=caml_new_string("NumpadEnter"),
     cst_NumpadEqual=caml_new_string("NumpadEqual"),
     cst_NumpadMultiply=caml_new_string("NumpadMultiply"),
     cst_NumpadSubtract=caml_new_string("NumpadSubtract"),
     cst_OSLeft=caml_new_string("OSLeft"),
     cst_OSRight=caml_new_string("OSRight"),
     cst_PageDown=caml_new_string("PageDown"),
     cst_ShiftRight=caml_new_string("ShiftRight"),
     cst_Pause=caml_new_string("Pause"),
     cst_Period=caml_new_string("Period"),
     cst_PrintScreen=caml_new_string("PrintScreen"),
     cst_Quote=caml_new_string("Quote"),
     cst_ScrollLock=caml_new_string("ScrollLock"),
     cst_Semicolon=caml_new_string("Semicolon"),
     cst_ShiftLeft=caml_new_string("ShiftLeft"),
     cst_Slash=caml_new_string("Slash"),
     cst_Space=caml_new_string("Space"),
     cst_Tab=caml_new_string("Tab"),
     cst_VolumeDown=caml_new_string("VolumeDown"),
     cst_VolumeMute=caml_new_string("VolumeMute"),
     cst_VolumeUp=caml_new_string("VolumeUp"),
     cst_mouseout$0=caml_new_string("mouseout"),
     cst_mouseover$0=caml_new_string("mouseover"),
     cst_video$0=caml_new_string("video"),
     cst_audio$0=caml_new_string("audio"),
     cst_ul$0=caml_new_string("ul"),
     cst_tr$0=caml_new_string("tr"),
     cst_title$0=caml_new_string("title"),
     cst_thead$0=caml_new_string("thead"),
     cst_th$0=caml_new_string("th"),
     cst_tfoot$0=caml_new_string("tfoot"),
     cst_textarea$0=caml_new_string("textarea"),
     cst_td$0=caml_new_string("td"),
     cst_tbody$0=caml_new_string("tbody"),
     cst_table$0=caml_new_string("table"),
     cst_style$0=caml_new_string("style"),
     cst_select$1=caml_new_string("select"),
     cst_script$0=caml_new_string("script"),
     cst_q$0=caml_new_string("q"),
     cst_pre$0=caml_new_string("pre"),
     cst_param$0=caml_new_string("param"),
     cst_p$0=caml_new_string("p"),
     cst_option$0=caml_new_string("option"),
     cst_optgroup$0=caml_new_string("optgroup"),
     cst_ol$0=caml_new_string("ol"),
     cst_object$0=caml_new_string("object"),
     cst_meta$0=caml_new_string("meta"),
     cst_map$0=caml_new_string("map"),
     cst_link$0=caml_new_string("link"),
     cst_li$0=caml_new_string("li"),
     cst_legend$0=caml_new_string("legend"),
     cst_label$0=caml_new_string("label"),
     cst_ins$0=caml_new_string("ins"),
     cst_input$1=caml_new_string("input"),
     cst_img$0=caml_new_string("img"),
     cst_iframe$0=caml_new_string("iframe"),
     cst_html$0=caml_new_string("html"),
     cst_hr$0=caml_new_string("hr"),
     cst_head$0=caml_new_string("head"),
     cst_h6$0=caml_new_string("h6"),
     cst_h5$0=caml_new_string("h5"),
     cst_h4$0=caml_new_string("h4"),
     cst_h3$0=caml_new_string("h3"),
     cst_h2$0=caml_new_string("h2"),
     cst_h1$0=caml_new_string("h1"),
     cst_frame$0=caml_new_string("frame"),
     cst_frameset$0=caml_new_string("frameset"),
     cst_form$0=caml_new_string("form"),
     cst_embed$0=caml_new_string("embed"),
     cst_fieldset$0=caml_new_string("fieldset"),
     cst_dl$0=caml_new_string("dl"),
     cst_div$0=caml_new_string("div"),
     cst_del$0=caml_new_string("del"),
     cst_colgroup$0=caml_new_string("colgroup"),
     cst_col$0=caml_new_string("col"),
     cst_caption$0=caml_new_string("caption"),
     cst_canvas$0=caml_new_string("canvas"),
     cst_button$0=caml_new_string("button"),
     cst_br$0=caml_new_string("br"),
     cst_body$0=caml_new_string("body"),
     cst_blockquote$0=caml_new_string("blockquote"),
     cst_base$0=caml_new_string("base"),
     cst_area$0=caml_new_string("area"),
     cst_a$0=caml_new_string("a"),
     cst_canvas=caml_new_string("canvas"),
     cst_video=caml_new_string("video"),
     cst_audio=caml_new_string("audio"),
     cst_iframe=caml_new_string("iframe"),
     cst_frame=caml_new_string("frame"),
     cst_frameset=caml_new_string("frameset"),
     cst_address=caml_new_string("address"),
     cst_noscript=caml_new_string("noscript"),
     cst_dt=caml_new_string("dt"),
     cst_dd=caml_new_string("dd"),
     cst_abbr=caml_new_string("abbr"),
     cst_var=caml_new_string("var"),
     cst_kbd=caml_new_string("kbd"),
     cst_samp=caml_new_string("samp"),
     cst_code=caml_new_string("code"),
     cst_dfn=caml_new_string("dfn"),
     cst_cite=caml_new_string("cite"),
     cst_strong=caml_new_string("strong"),
     cst_em=caml_new_string("em"),
     cst_small=caml_new_string("small"),
     cst_big=caml_new_string("big"),
     cst_b=caml_new_string("b"),
     cst_i=caml_new_string("i"),
     cst_tt=caml_new_string("tt"),
     cst_span=caml_new_string("span"),
     cst_sup=caml_new_string("sup"),
     cst_sub=caml_new_string("sub"),
     cst_td=caml_new_string("td"),
     cst_th=caml_new_string("th"),
     cst_tr=caml_new_string("tr"),
     cst_tbody=caml_new_string("tbody"),
     cst_tfoot=caml_new_string("tfoot"),
     cst_thead=caml_new_string("thead"),
     cst_colgroup=caml_new_string("colgroup"),
     cst_col=caml_new_string("col"),
     cst_caption=caml_new_string("caption"),
     cst_table=caml_new_string("table"),
     cst_script=caml_new_string("script"),
     cst_area=caml_new_string("area"),
     cst_map=caml_new_string("map"),
     cst_param=caml_new_string("param"),
     cst_object=caml_new_string("object"),
     cst_img=caml_new_string("img"),
     cst_a=caml_new_string("a"),
     cst_del=caml_new_string("del"),
     cst_ins=caml_new_string("ins"),
     cst_hr=caml_new_string("hr"),
     cst_br=caml_new_string("br"),
     cst_pre=caml_new_string("pre"),
     cst_blockquote=caml_new_string("blockquote"),
     cst_q=caml_new_string("q"),
     cst_h6=caml_new_string("h6"),
     cst_h5=caml_new_string("h5"),
     cst_h4=caml_new_string("h4"),
     cst_h3=caml_new_string("h3"),
     cst_h2=caml_new_string("h2"),
     cst_h1=caml_new_string("h1"),
     cst_p=caml_new_string("p"),
     cst_embed=caml_new_string("embed"),
     cst_div=caml_new_string("div"),
     cst_li=caml_new_string("li"),
     cst_dl=caml_new_string("dl"),
     cst_ol=caml_new_string("ol"),
     cst_ul=caml_new_string("ul"),
     cst_legend=caml_new_string("legend"),
     cst_fieldset=caml_new_string("fieldset"),
     cst_label=caml_new_string("label"),
     cst_button=caml_new_string("button"),
     cst_textarea=caml_new_string("textarea"),
     cst_input$0=caml_new_string("input"),
     cst_select$0=caml_new_string("select"),
     cst_option=caml_new_string("option"),
     cst_optgroup=caml_new_string("optgroup"),
     cst_form=caml_new_string("form"),
     cst_body=caml_new_string("body"),
     cst_style=caml_new_string("style"),
     cst_base=caml_new_string("base"),
     cst_meta=caml_new_string("meta"),
     cst_title=caml_new_string("title"),
     cst_link=caml_new_string("link"),
     cst_head=caml_new_string("head"),
     cst_html=caml_new_string("html"),
     cst_click=caml_new_string("click"),
     cst_dblclick=caml_new_string("dblclick"),
     cst_mousedown=caml_new_string("mousedown"),
     cst_mouseup=caml_new_string("mouseup"),
     cst_mouseover=caml_new_string("mouseover"),
     cst_mousemove=caml_new_string("mousemove"),
     cst_mouseout=caml_new_string("mouseout"),
     cst_keypress=caml_new_string("keypress"),
     cst_keydown=caml_new_string("keydown"),
     cst_keyup=caml_new_string("keyup"),
     cst_mousewheel=caml_new_string("mousewheel"),
     cst_DOMMouseScroll=caml_new_string("DOMMouseScroll"),
     cst_touchstart=caml_new_string("touchstart"),
     cst_touchmove=caml_new_string("touchmove"),
     cst_touchend=caml_new_string("touchend"),
     cst_touchcancel=caml_new_string("touchcancel"),
     cst_dragstart=caml_new_string("dragstart"),
     cst_dragend=caml_new_string("dragend"),
     cst_dragenter=caml_new_string("dragenter"),
     cst_dragover=caml_new_string("dragover"),
     cst_dragleave=caml_new_string("dragleave"),
     cst_drag=caml_new_string("drag"),
     cst_drop=caml_new_string("drop"),
     cst_hashchange=caml_new_string("hashchange"),
     cst_change=caml_new_string("change"),
     cst_input=caml_new_string("input"),
     cst_timeupdate=caml_new_string("timeupdate"),
     cst_submit=caml_new_string("submit"),
     cst_scroll=caml_new_string("scroll"),
     cst_focus=caml_new_string("focus"),
     cst_blur=caml_new_string("blur"),
     cst_load$0=caml_new_string("load"),
     cst_unload=caml_new_string("unload"),
     cst_beforeunload=caml_new_string("beforeunload"),
     cst_resize=caml_new_string("resize"),
     cst_orientationchange=caml_new_string("orientationchange"),
     cst_popstate=caml_new_string("popstate"),
     cst_error$0=caml_new_string("error"),
     cst_abort$0=caml_new_string("abort"),
     cst_select=caml_new_string("select"),
     cst_online=caml_new_string("online"),
     cst_offline=caml_new_string("offline"),
     cst_checking=caml_new_string("checking"),
     cst_noupdate=caml_new_string("noupdate"),
     cst_downloading=caml_new_string("downloading"),
     cst_progress$0=caml_new_string("progress"),
     cst_updateready=caml_new_string("updateready"),
     cst_cached=caml_new_string("cached"),
     cst_obsolete=caml_new_string("obsolete"),
     cst_DOMContentLoaded=caml_new_string("DOMContentLoaded"),
     cst_animationstart=caml_new_string("animationstart"),
     cst_animationend=caml_new_string("animationend"),
     cst_animationiteration=caml_new_string("animationiteration"),
     cst_animationcancel=caml_new_string("animationcancel"),
     cst_canplay=caml_new_string("canplay"),
     cst_canplaythrough=caml_new_string("canplaythrough"),
     cst_durationchange=caml_new_string("durationchange"),
     cst_emptied=caml_new_string("emptied"),
     cst_ended=caml_new_string("ended"),
     cst_loadeddata=caml_new_string("loadeddata"),
     cst_loadedmetadata=caml_new_string("loadedmetadata"),
     cst_loadstart$0=caml_new_string("loadstart"),
     cst_pause=caml_new_string("pause"),
     cst_play=caml_new_string("play"),
     cst_playing=caml_new_string("playing"),
     cst_ratechange=caml_new_string("ratechange"),
     cst_seeked=caml_new_string("seeked"),
     cst_seeking=caml_new_string("seeking"),
     cst_stalled=caml_new_string("stalled"),
     cst_suspend=caml_new_string("suspend"),
     cst_volumechange=caml_new_string("volumechange"),
     cst_waiting=caml_new_string("waiting"),
     cst_Js_of_ocaml_Dom_html_Canvas_not_available=
      caml_new_string("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_new_string("checkbox"),
     cst_file=caml_new_string("file"),
     cst_password=caml_new_string("password"),
     cst_radio=caml_new_string("radio"),
     cst_reset=caml_new_string("reset"),
     cst_submit$0=caml_new_string("submit"),
     cst_text=caml_new_string("text"),
     cst_readystatechange=caml_new_string("readystatechange"),
     cst_loadstart$1=caml_new_string("loadstart"),
     cst_progress$1=caml_new_string("progress"),
     cst_abort$1=caml_new_string("abort"),
     cst_error$1=caml_new_string("error"),
     cst_load$1=caml_new_string("load"),
     cst_timeout=caml_new_string("timeout"),
     cst_loadend$0=caml_new_string("loadend"),
     cst_Worker_onmessage_is_undefined$0=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefined=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_undefined=
      caml_new_string("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_new_string("webglcontextlost"),
     cst_webglcontextrestored=caml_new_string("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_new_string("webglcontextcreationerror"),
     cst_g=caml_new_string("g"),
     cst=caml_new_string("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_new_string(""),
     cst$13=caml_new_string(""),
     cst$21=caml_new_string(""),
     cst$14=caml_new_string("#"),
     cst$15=caml_new_string("?"),
     cst$20=caml_new_string(""),
     cst$16=caml_new_string("/"),
     cst$17=caml_new_string("/"),
     cst$19=caml_new_string(":"),
     cst$18=caml_new_string(""),
     cst_http$1=caml_new_string("http://"),
     cst$22=caml_new_string(""),
     cst$30=caml_new_string(""),
     cst$23=caml_new_string("#"),
     cst$24=caml_new_string("?"),
     cst$29=caml_new_string(""),
     cst$25=caml_new_string("/"),
     cst$26=caml_new_string("/"),
     cst$28=caml_new_string(":"),
     cst$27=caml_new_string(""),
     cst_https$1=caml_new_string("https://"),
     cst$31=caml_new_string(""),
     cst$36=caml_new_string(""),
     cst$32=caml_new_string("#"),
     cst$33=caml_new_string("?"),
     cst$35=caml_new_string(""),
     cst$34=caml_new_string("/"),
     cst_file$2=caml_new_string("file://"),
     cst$12=caml_new_string(""),
     cst$11=caml_new_string(""),
     cst$10=caml_new_string(""),
     cst$9=caml_new_string(""),
     cst$8=caml_new_string(""),
     cst$7=caml_new_string(""),
     cst$6=caml_new_string(""),
     cst$4=caml_new_string("="),
     cst$5=caml_new_string("&"),
     cst$2=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_file$0=caml_new_string("file"),
     cst_file$1=caml_new_string("file:"),
     cst_http=caml_new_string("http"),
     cst_http$0=caml_new_string("http:"),
     cst_https=caml_new_string("https"),
     cst_https$0=caml_new_string("https:"),
     cst$1=caml_new_string(" "),
     cst_2B=caml_new_string("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_new_string("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_new_string("+"),
     cst_Js_of_ocaml_Url_Not_an_http_protocol=
      caml_new_string("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9=
      caml_new_string
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_new_string
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     js_of_ocaml_version=caml_new_string("3.4.0"),
     git_version=caml_new_string(""),
     cst_Jstable_keys=caml_new_string("Jstable.keys"),
     dummy_string=caml_new_string(""),
     cst_is_not_a_valid_length$0=caml_new_string(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_new_string("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_new_string("length conversion error: "),
     cst_deg$0=caml_new_string("deg"),
     cst_grad$0=caml_new_string("grad"),
     cst_rad$0=caml_new_string("rad"),
     cst_turns$0=caml_new_string("turns"),
     cst_deg=caml_new_string("deg"),
     cst_grad=caml_new_string("grad"),
     cst_rad=caml_new_string("rad"),
     cst_turns=caml_new_string("turns"),
     cst_is_not_a_valid_length=caml_new_string(" is not a valid length"),
     cst_0$0=caml_new_string("0"),
     cst_d_d_s_S=caml_new_string("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=caml_new_string("length conversion error: "),
     cst_pc$0=caml_new_string("pc"),
     cst_ch$0=caml_new_string("ch"),
     cst_cm$0=caml_new_string("cm"),
     cst_em$1=caml_new_string("em"),
     cst_ex$0=caml_new_string("ex"),
     cst_gd$0=caml_new_string("gd"),
     cst_in$0=caml_new_string("in"),
     cst_mm$0=caml_new_string("mm"),
     cst_pt$0=caml_new_string("pt"),
     cst_px$0=caml_new_string("px"),
     cst_rem$0=caml_new_string("rem"),
     cst_vh$0=caml_new_string("vh"),
     cst_vm$0=caml_new_string("vm"),
     cst_vw$0=caml_new_string("vw"),
     cst_0=caml_new_string("0"),
     cst_em$0=caml_new_string("em"),
     cst_ex=caml_new_string("ex"),
     cst_px=caml_new_string("px"),
     cst_gd=caml_new_string("gd"),
     cst_rem=caml_new_string("rem"),
     cst_vw=caml_new_string("vw"),
     cst_vh=caml_new_string("vh"),
     cst_vm=caml_new_string("vm"),
     cst_ch=caml_new_string("ch"),
     cst_mm=caml_new_string("mm"),
     cst_cm=caml_new_string("cm"),
     cst_in=caml_new_string("in"),
     cst_pt=caml_new_string("pt"),
     cst_pc=caml_new_string("pc"),
     cst$39=caml_new_string("): "),
     cst_color_conversion_error$0=caml_new_string("color conversion error ("),
     cst$38=caml_new_string("): "),
     cst_color_conversion_error=caml_new_string("color conversion error ("),
     cst_is_not_a_valid_color$0=caml_new_string(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_new_string
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_new_string
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_new_string
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_new_string("rgb"),
     cst_rgba=caml_new_string("rgba"),
     cst_rgb$0=caml_new_string("rgb"),
     cst_rgba$0=caml_new_string("rgba"),
     cst_hsl=caml_new_string("hsl"),
     cst_hsla=caml_new_string("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_new_string("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_new_string("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_new_string("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_new_string
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_new_string("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_new_string("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_new_string(" is not a valid color"),
     cst_is_out_of_valid_range=caml_new_string(" is out of valid range"),
     partial=[8,0,0,0,[12,41,0]],
     partial$0=[12,41,0],
     cst_lightgrey$0=caml_new_string("lightgrey"),
     cst_darkslategray$0=caml_new_string("darkslategray"),
     cst_cornsilk$0=caml_new_string("cornsilk"),
     cst_blue$0=caml_new_string("blue"),
     cst_aliceblue$0=caml_new_string("aliceblue"),
     cst_antiquewhite$0=caml_new_string("antiquewhite"),
     cst_aqua$0=caml_new_string("aqua"),
     cst_aquamarine$0=caml_new_string("aquamarine"),
     cst_azure$0=caml_new_string("azure"),
     cst_beige$0=caml_new_string("beige"),
     cst_bisque$0=caml_new_string("bisque"),
     cst_black$0=caml_new_string("black"),
     cst_blanchedalmond$0=caml_new_string("blanchedalmond"),
     cst_blueviolet$0=caml_new_string("blueviolet"),
     cst_brown$0=caml_new_string("brown"),
     cst_burlywood$0=caml_new_string("burlywood"),
     cst_cadetblue$0=caml_new_string("cadetblue"),
     cst_chartreuse$0=caml_new_string("chartreuse"),
     cst_chocolate$0=caml_new_string("chocolate"),
     cst_coral$0=caml_new_string("coral"),
     cst_cornflowerblue$0=caml_new_string("cornflowerblue"),
     cst_darkkhaki$0=caml_new_string("darkkhaki"),
     cst_crimson$0=caml_new_string("crimson"),
     cst_cyan$0=caml_new_string("cyan"),
     cst_darkblue$0=caml_new_string("darkblue"),
     cst_darkcyan$0=caml_new_string("darkcyan"),
     cst_darkgoldenrod$0=caml_new_string("darkgoldenrod"),
     cst_darkgray$0=caml_new_string("darkgray"),
     cst_darkgreen$0=caml_new_string("darkgreen"),
     cst_darkgrey$0=caml_new_string("darkgrey"),
     cst_darkmagenta$0=caml_new_string("darkmagenta"),
     cst_darkolivegreen$0=caml_new_string("darkolivegreen"),
     cst_darkorange$0=caml_new_string("darkorange"),
     cst_darkorchid$0=caml_new_string("darkorchid"),
     cst_darkred$0=caml_new_string("darkred"),
     cst_darksalmon$0=caml_new_string("darksalmon"),
     cst_darkseagreen$0=caml_new_string("darkseagreen"),
     cst_darkslateblue$0=caml_new_string("darkslateblue"),
     cst_greenyellow$0=caml_new_string("greenyellow"),
     cst_floralwhite$0=caml_new_string("floralwhite"),
     cst_darkslategrey$0=caml_new_string("darkslategrey"),
     cst_darkturquoise$0=caml_new_string("darkturquoise"),
     cst_darkviolet$0=caml_new_string("darkviolet"),
     cst_deeppink$0=caml_new_string("deeppink"),
     cst_deepskyblue$0=caml_new_string("deepskyblue"),
     cst_dimgray$0=caml_new_string("dimgray"),
     cst_dimgrey$0=caml_new_string("dimgrey"),
     cst_dodgerblue$0=caml_new_string("dodgerblue"),
     cst_firebrick$0=caml_new_string("firebrick"),
     cst_forestgreen$0=caml_new_string("forestgreen"),
     cst_fuchsia$0=caml_new_string("fuchsia"),
     cst_gainsboro$0=caml_new_string("gainsboro"),
     cst_ghostwhite$0=caml_new_string("ghostwhite"),
     cst_gold$0=caml_new_string("gold"),
     cst_goldenrod$0=caml_new_string("goldenrod"),
     cst_gray$0=caml_new_string("gray"),
     cst_green$0=caml_new_string("green"),
     cst_lavenderblush$0=caml_new_string("lavenderblush"),
     cst_grey$0=caml_new_string("grey"),
     cst_honeydew$0=caml_new_string("honeydew"),
     cst_hotpink$0=caml_new_string("hotpink"),
     cst_indianred$0=caml_new_string("indianred"),
     cst_indigo$0=caml_new_string("indigo"),
     cst_ivory$0=caml_new_string("ivory"),
     cst_khaki$0=caml_new_string("khaki"),
     cst_lavender$0=caml_new_string("lavender"),
     cst_lawngreen$0=caml_new_string("lawngreen"),
     cst_lemonchiffon$0=caml_new_string("lemonchiffon"),
     cst_lightblue$0=caml_new_string("lightblue"),
     cst_lightcoral$0=caml_new_string("lightcoral"),
     cst_lightcyan$0=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray$0=caml_new_string("lightgray"),
     cst_lightgreen$0=caml_new_string("lightgreen"),
     cst_paleturquoise$0=caml_new_string("paleturquoise"),
     cst_mediumslateblue$0=caml_new_string("mediumslateblue"),
     cst_limegreen$0=caml_new_string("limegreen"),
     cst_lightpink$0=caml_new_string("lightpink"),
     cst_lightsalmon$0=caml_new_string("lightsalmon"),
     cst_lightseagreen$0=caml_new_string("lightseagreen"),
     cst_lightskyblue$0=caml_new_string("lightskyblue"),
     cst_lightslategray$0=caml_new_string("lightslategray"),
     cst_lightslategrey$0=caml_new_string("lightslategrey"),
     cst_lightsteelblue$0=caml_new_string("lightsteelblue"),
     cst_lightyellow$0=caml_new_string("lightyellow"),
     cst_lime$0=caml_new_string("lime"),
     cst_linen$0=caml_new_string("linen"),
     cst_magenta$0=caml_new_string("magenta"),
     cst_maroon$0=caml_new_string("maroon"),
     cst_mediumaquamarine$0=caml_new_string("mediumaquamarine"),
     cst_mediumblue$0=caml_new_string("mediumblue"),
     cst_mediumorchid$0=caml_new_string("mediumorchid"),
     cst_mediumpurple$0=caml_new_string("mediumpurple"),
     cst_mediumseagreen$0=caml_new_string("mediumseagreen"),
     cst_navy$0=caml_new_string("navy"),
     cst_mediumspringgreen$0=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise$0=caml_new_string("mediumturquoise"),
     cst_mediumvioletred$0=caml_new_string("mediumvioletred"),
     cst_midnightblue$0=caml_new_string("midnightblue"),
     cst_mintcream$0=caml_new_string("mintcream"),
     cst_mistyrose$0=caml_new_string("mistyrose"),
     cst_moccasin$0=caml_new_string("moccasin"),
     cst_navajowhite$0=caml_new_string("navajowhite"),
     cst_oldlace$0=caml_new_string("oldlace"),
     cst_olive$0=caml_new_string("olive"),
     cst_olivedrab$0=caml_new_string("olivedrab"),
     cst_orange$0=caml_new_string("orange"),
     cst_orangered$0=caml_new_string("orangered"),
     cst_orchid$0=caml_new_string("orchid"),
     cst_palegoldenrod$0=caml_new_string("palegoldenrod"),
     cst_palegreen$0=caml_new_string("palegreen"),
     cst_skyblue$0=caml_new_string("skyblue"),
     cst_rosybrown$0=caml_new_string("rosybrown"),
     cst_palevioletred$0=caml_new_string("palevioletred"),
     cst_papayawhip$0=caml_new_string("papayawhip"),
     cst_peachpuff$0=caml_new_string("peachpuff"),
     cst_peru$0=caml_new_string("peru"),
     cst_pink$0=caml_new_string("pink"),
     cst_plum$0=caml_new_string("plum"),
     cst_powderblue$0=caml_new_string("powderblue"),
     cst_purple$0=caml_new_string("purple"),
     cst_red$0=caml_new_string("red"),
     cst_royalblue$0=caml_new_string("royalblue"),
     cst_saddlebrown$0=caml_new_string("saddlebrown"),
     cst_salmon$0=caml_new_string("salmon"),
     cst_sandybrown$0=caml_new_string("sandybrown"),
     cst_seagreen$0=caml_new_string("seagreen"),
     cst_seashell$0=caml_new_string("seashell"),
     cst_sienna$0=caml_new_string("sienna"),
     cst_silver$0=caml_new_string("silver"),
     cst_thistle$0=caml_new_string("thistle"),
     cst_slateblue$0=caml_new_string("slateblue"),
     cst_slategray$0=caml_new_string("slategray"),
     cst_slategrey$0=caml_new_string("slategrey"),
     cst_snow$0=caml_new_string("snow"),
     cst_springgreen$0=caml_new_string("springgreen"),
     cst_steelblue$0=caml_new_string("steelblue"),
     cst_tan$0=caml_new_string("tan"),
     cst_teal$0=caml_new_string("teal"),
     cst_tomato$0=caml_new_string("tomato"),
     cst_turquoise$0=caml_new_string("turquoise"),
     cst_violet$0=caml_new_string("violet"),
     cst_wheat$0=caml_new_string("wheat"),
     cst_white$0=caml_new_string("white"),
     cst_whitesmoke$0=caml_new_string("whitesmoke"),
     cst_yellow$0=caml_new_string("yellow"),
     cst_yellowgreen$0=caml_new_string("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_new_string(" is not a valid color name"),
     cst_aliceblue=caml_new_string("aliceblue"),
     cst_antiquewhite=caml_new_string("antiquewhite"),
     cst_aqua=caml_new_string("aqua"),
     cst_aquamarine=caml_new_string("aquamarine"),
     cst_azure=caml_new_string("azure"),
     cst_beige=caml_new_string("beige"),
     cst_bisque=caml_new_string("bisque"),
     cst_black=caml_new_string("black"),
     cst_blanchedalmond=caml_new_string("blanchedalmond"),
     cst_blue=caml_new_string("blue"),
     cst_blueviolet=caml_new_string("blueviolet"),
     cst_brown=caml_new_string("brown"),
     cst_burlywood=caml_new_string("burlywood"),
     cst_cadetblue=caml_new_string("cadetblue"),
     cst_chartreuse=caml_new_string("chartreuse"),
     cst_chocolate=caml_new_string("chocolate"),
     cst_coral=caml_new_string("coral"),
     cst_cornflowerblue=caml_new_string("cornflowerblue"),
     cst_cornsilk=caml_new_string("cornsilk"),
     cst_crimson=caml_new_string("crimson"),
     cst_cyan=caml_new_string("cyan"),
     cst_darkblue=caml_new_string("darkblue"),
     cst_darkcyan=caml_new_string("darkcyan"),
     cst_darkgoldenrod=caml_new_string("darkgoldenrod"),
     cst_darkgray=caml_new_string("darkgray"),
     cst_darkgreen=caml_new_string("darkgreen"),
     cst_darkgrey=caml_new_string("darkgrey"),
     cst_darkkhaki=caml_new_string("darkkhaki"),
     cst_darkmagenta=caml_new_string("darkmagenta"),
     cst_darkolivegreen=caml_new_string("darkolivegreen"),
     cst_darkorange=caml_new_string("darkorange"),
     cst_darkorchid=caml_new_string("darkorchid"),
     cst_darkred=caml_new_string("darkred"),
     cst_darksalmon=caml_new_string("darksalmon"),
     cst_darkseagreen=caml_new_string("darkseagreen"),
     cst_darkslateblue=caml_new_string("darkslateblue"),
     cst_darkslategray=caml_new_string("darkslategray"),
     cst_darkslategrey=caml_new_string("darkslategrey"),
     cst_darkturquoise=caml_new_string("darkturquoise"),
     cst_darkviolet=caml_new_string("darkviolet"),
     cst_deeppink=caml_new_string("deeppink"),
     cst_deepskyblue=caml_new_string("deepskyblue"),
     cst_dimgray=caml_new_string("dimgray"),
     cst_dimgrey=caml_new_string("dimgrey"),
     cst_dodgerblue=caml_new_string("dodgerblue"),
     cst_firebrick=caml_new_string("firebrick"),
     cst_floralwhite=caml_new_string("floralwhite"),
     cst_forestgreen=caml_new_string("forestgreen"),
     cst_fuchsia=caml_new_string("fuchsia"),
     cst_gainsboro=caml_new_string("gainsboro"),
     cst_ghostwhite=caml_new_string("ghostwhite"),
     cst_gold=caml_new_string("gold"),
     cst_goldenrod=caml_new_string("goldenrod"),
     cst_gray=caml_new_string("gray"),
     cst_grey=caml_new_string("grey"),
     cst_green=caml_new_string("green"),
     cst_greenyellow=caml_new_string("greenyellow"),
     cst_honeydew=caml_new_string("honeydew"),
     cst_hotpink=caml_new_string("hotpink"),
     cst_indianred=caml_new_string("indianred"),
     cst_indigo=caml_new_string("indigo"),
     cst_ivory=caml_new_string("ivory"),
     cst_khaki=caml_new_string("khaki"),
     cst_lavender=caml_new_string("lavender"),
     cst_lavenderblush=caml_new_string("lavenderblush"),
     cst_lawngreen=caml_new_string("lawngreen"),
     cst_lemonchiffon=caml_new_string("lemonchiffon"),
     cst_lightblue=caml_new_string("lightblue"),
     cst_lightcoral=caml_new_string("lightcoral"),
     cst_lightcyan=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray=caml_new_string("lightgray"),
     cst_lightgreen=caml_new_string("lightgreen"),
     cst_lightgrey=caml_new_string("lightgrey"),
     cst_lightpink=caml_new_string("lightpink"),
     cst_lightsalmon=caml_new_string("lightsalmon"),
     cst_lightseagreen=caml_new_string("lightseagreen"),
     cst_lightskyblue=caml_new_string("lightskyblue"),
     cst_lightslategray=caml_new_string("lightslategray"),
     cst_lightslategrey=caml_new_string("lightslategrey"),
     cst_lightsteelblue=caml_new_string("lightsteelblue"),
     cst_lightyellow=caml_new_string("lightyellow"),
     cst_lime=caml_new_string("lime"),
     cst_limegreen=caml_new_string("limegreen"),
     cst_linen=caml_new_string("linen"),
     cst_magenta=caml_new_string("magenta"),
     cst_maroon=caml_new_string("maroon"),
     cst_mediumaquamarine=caml_new_string("mediumaquamarine"),
     cst_mediumblue=caml_new_string("mediumblue"),
     cst_mediumorchid=caml_new_string("mediumorchid"),
     cst_mediumpurple=caml_new_string("mediumpurple"),
     cst_mediumseagreen=caml_new_string("mediumseagreen"),
     cst_mediumslateblue=caml_new_string("mediumslateblue"),
     cst_mediumspringgreen=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise=caml_new_string("mediumturquoise"),
     cst_mediumvioletred=caml_new_string("mediumvioletred"),
     cst_midnightblue=caml_new_string("midnightblue"),
     cst_mintcream=caml_new_string("mintcream"),
     cst_mistyrose=caml_new_string("mistyrose"),
     cst_moccasin=caml_new_string("moccasin"),
     cst_navajowhite=caml_new_string("navajowhite"),
     cst_navy=caml_new_string("navy"),
     cst_oldlace=caml_new_string("oldlace"),
     cst_olive=caml_new_string("olive"),
     cst_olivedrab=caml_new_string("olivedrab"),
     cst_orange=caml_new_string("orange"),
     cst_orangered=caml_new_string("orangered"),
     cst_orchid=caml_new_string("orchid"),
     cst_palegoldenrod=caml_new_string("palegoldenrod"),
     cst_palegreen=caml_new_string("palegreen"),
     cst_paleturquoise=caml_new_string("paleturquoise"),
     cst_palevioletred=caml_new_string("palevioletred"),
     cst_papayawhip=caml_new_string("papayawhip"),
     cst_peachpuff=caml_new_string("peachpuff"),
     cst_peru=caml_new_string("peru"),
     cst_pink=caml_new_string("pink"),
     cst_plum=caml_new_string("plum"),
     cst_powderblue=caml_new_string("powderblue"),
     cst_purple=caml_new_string("purple"),
     cst_red=caml_new_string("red"),
     cst_rosybrown=caml_new_string("rosybrown"),
     cst_royalblue=caml_new_string("royalblue"),
     cst_saddlebrown=caml_new_string("saddlebrown"),
     cst_salmon=caml_new_string("salmon"),
     cst_sandybrown=caml_new_string("sandybrown"),
     cst_seagreen=caml_new_string("seagreen"),
     cst_seashell=caml_new_string("seashell"),
     cst_sienna=caml_new_string("sienna"),
     cst_silver=caml_new_string("silver"),
     cst_skyblue=caml_new_string("skyblue"),
     cst_slateblue=caml_new_string("slateblue"),
     cst_slategray=caml_new_string("slategray"),
     cst_slategrey=caml_new_string("slategrey"),
     cst_snow=caml_new_string("snow"),
     cst_springgreen=caml_new_string("springgreen"),
     cst_steelblue=caml_new_string("steelblue"),
     cst_tan=caml_new_string("tan"),
     cst_teal=caml_new_string("teal"),
     cst_thistle=caml_new_string("thistle"),
     cst_tomato=caml_new_string("tomato"),
     cst_turquoise=caml_new_string("turquoise"),
     cst_violet=caml_new_string("violet"),
     cst_wheat=caml_new_string("wheat"),
     cst_white=caml_new_string("white"),
     cst_whitesmoke=caml_new_string("whitesmoke"),
     cst_yellow=caml_new_string("yellow"),
     cst_yellowgreen=caml_new_string("yellowgreen"),
     cst_vkern$0=caml_new_string("vkern"),
     cst_view$0=caml_new_string("view"),
     cst_use$0=caml_new_string("use"),
     cst_tspan$0=caml_new_string("tspan"),
     cst_tref$0=caml_new_string("tref"),
     cst_title$3=caml_new_string("title"),
     cst_textpath$0=caml_new_string("textpath"),
     cst_text$1=caml_new_string("text"),
     cst_symbol$0=caml_new_string("symbol"),
     cst_switch$0=caml_new_string("switch"),
     cst_svg$0=caml_new_string("svg"),
     cst_style$3=caml_new_string("style"),
     cst_stop$0=caml_new_string("stop"),
     cst_set$0=caml_new_string("set"),
     cst_script$3=caml_new_string("script"),
     cst_rect$0=caml_new_string("rect"),
     cst_radialgradient$0=caml_new_string("radialgradient"),
     cst_polyline$0=caml_new_string("polyline"),
     cst_polygon$0=caml_new_string("polygon"),
     cst_pattern$0=caml_new_string("pattern"),
     cst_path$0=caml_new_string("path"),
     cst_mpath$0=caml_new_string("mpath"),
     cst_missing_glyph$0=caml_new_string("missing-glyph"),
     cst_metadata$0=caml_new_string("metadata"),
     cst_mask$0=caml_new_string("mask"),
     cst_lineargradient$0=caml_new_string("lineargradient"),
     cst_line$0=caml_new_string("line"),
     cst_image$0=caml_new_string("image"),
     cst_hkern$0=caml_new_string("hkern"),
     cst_glyphref$0=caml_new_string("glyphref"),
     cst_glyph$0=caml_new_string("glyph"),
     cst_g$1=caml_new_string("g"),
     cst_foreignobject$0=caml_new_string("foreignobject"),
     cst_font_face_uri$0=caml_new_string("font-face-uri"),
     cst_font_face_src$0=caml_new_string("font-face-src"),
     cst_font_face_name$0=caml_new_string("font-face-name"),
     cst_font_face_format$0=caml_new_string("font-face-format"),
     cst_font_face$0=caml_new_string("font-face"),
     cst_font$0=caml_new_string("font"),
     cst_filter$0=caml_new_string("filter"),
     cst_ellipse$0=caml_new_string("ellipse"),
     cst_desc$0=caml_new_string("desc"),
     cst_defs$0=caml_new_string("defs"),
     cst_cursor$0=caml_new_string("cursor"),
     cst_clippath$0=caml_new_string("clippath"),
     cst_circle$0=caml_new_string("circle"),
     cst_animatetransform$0=caml_new_string("animatetransform"),
     cst_animatemotion$0=caml_new_string("animatemotion"),
     cst_animatecolor$0=caml_new_string("animatecolor"),
     cst_animate$0=caml_new_string("animate"),
     cst_altglyphitem$0=caml_new_string("altglyphitem"),
     cst_altglyphdef$0=caml_new_string("altglyphdef"),
     cst_altglyph$0=caml_new_string("altglyph"),
     cst_a$3=caml_new_string("a"),
     cst_vkern=caml_new_string("vkern"),
     cst_view=caml_new_string("view"),
     cst_use=caml_new_string("use"),
     cst_tspan=caml_new_string("tspan"),
     cst_tref=caml_new_string("tref"),
     cst_title$2=caml_new_string("title"),
     cst_textpath=caml_new_string("textpath"),
     cst_text$0=caml_new_string("text"),
     cst_symbol=caml_new_string("symbol"),
     cst_switch=caml_new_string("switch"),
     cst_svg=caml_new_string("svg"),
     cst_style$2=caml_new_string("style"),
     cst_stop=caml_new_string("stop"),
     cst_set=caml_new_string("set"),
     cst_script$2=caml_new_string("script"),
     cst_rect=caml_new_string("rect"),
     cst_radialgradient=caml_new_string("radialgradient"),
     cst_polyline=caml_new_string("polyline"),
     cst_polygon=caml_new_string("polygon"),
     cst_pattern=caml_new_string("pattern"),
     cst_path=caml_new_string("path"),
     cst_mpath=caml_new_string("mpath"),
     cst_missing_glyph=caml_new_string("missing-glyph"),
     cst_metadata=caml_new_string("metadata"),
     cst_mask=caml_new_string("mask"),
     cst_lineargradient=caml_new_string("lineargradient"),
     cst_line=caml_new_string("line"),
     cst_image=caml_new_string("image"),
     cst_hkern=caml_new_string("hkern"),
     cst_glyphref=caml_new_string("glyphref"),
     cst_glyph=caml_new_string("glyph"),
     cst_g$0=caml_new_string("g"),
     cst_foreignobject=caml_new_string("foreignobject"),
     cst_font_face_uri=caml_new_string("font-face-uri"),
     cst_font_face_src=caml_new_string("font-face-src"),
     cst_font_face_name=caml_new_string("font-face-name"),
     cst_font_face_format=caml_new_string("font-face-format"),
     cst_font_face=caml_new_string("font-face"),
     cst_font=caml_new_string("font"),
     cst_filter=caml_new_string("filter"),
     cst_ellipse=caml_new_string("ellipse"),
     cst_desc=caml_new_string("desc"),
     cst_defs=caml_new_string("defs"),
     cst_cursor=caml_new_string("cursor"),
     cst_clippath=caml_new_string("clippath"),
     cst_circle=caml_new_string("circle"),
     cst_animatetransform=caml_new_string("animatetransform"),
     cst_animatemotion=caml_new_string("animatemotion"),
     cst_animatecolor=caml_new_string("animatecolor"),
     cst_animate=caml_new_string("animate"),
     cst_altglyphitem=caml_new_string("altglyphitem"),
     cst_altglyphdef=caml_new_string("altglyphdef"),
     cst_altglyph=caml_new_string("altglyph"),
     cst_a$2=caml_new_string("a"),
     cst_Js_of_ocaml_Dom_svg_SVGError=
      caml_new_string("Js_of_ocaml__Dom_svg.SVGError"),
     Stdlib=global_data.Stdlib,
     Stdlib_callback=global_data.Stdlib__callback,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_string=global_data.Stdlib__string,
     Js_of_ocaml=[0];
    caml_register_global(1606,Js_of_ocaml,"Js_of_ocaml__");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t37=undefined,
     _d_=[0,caml_new_string("lib/js_of_ocaml/dom.ml"),343,67],
     _e_=[0,caml_new_string("transparent")],
     _f_=[0,caml_new_string("native")],
     _j_=[0,caml_new_string("lib/js_of_ocaml/dom_html.ml"),2707,58],
     _i_=[0,caml_new_string("lib/js_of_ocaml/dom_html.ml"),2706,61],
     _h_=
      [0,
       [11,
        caml_new_string("getElementById_exn: "),
        [3,0,[11,caml_new_string(" not found"),0]]],
       caml_new_string("getElementById_exn: %S not found")],
     _m_=[0,caml_new_string("lib/js_of_ocaml/form.ml"),174,13],
     _l_=[0,1],
     _n_=[0,caml_new_string("lib/js_of_ocaml/xmlHttpRequest.ml"),128,75],
     _o_=[0,caml_new_string("lib/js_of_ocaml/regexp.ml"),33,64],
     _p_=[0,caml_new_string(""),0],
     _cj_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ck_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cl_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cm_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b7_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b8_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b9_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b__=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b$_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ca_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cb_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cc_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cd_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ce_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cf_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _cg_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ch_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _ci_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b6_=
      caml_list_of_js_array
       ([caml_new_string("aliceblue"),
         caml_new_string("antiquewhite"),
         caml_new_string("aqua"),
         caml_new_string("aquamarine"),
         caml_new_string("azure"),
         caml_new_string("beige"),
         caml_new_string("bisque"),
         caml_new_string("black"),
         caml_new_string("blanchedalmond"),
         caml_new_string("blue"),
         caml_new_string("blueviolet"),
         caml_new_string("brown"),
         caml_new_string("burlywood"),
         caml_new_string("cadetblue"),
         caml_new_string("chartreuse"),
         caml_new_string("chocolate"),
         caml_new_string("coral"),
         caml_new_string("cornflowerblue"),
         caml_new_string("cornsilk"),
         caml_new_string("crimson"),
         caml_new_string("cyan"),
         caml_new_string("darkblue"),
         caml_new_string("darkcyan"),
         caml_new_string("darkgoldenrod"),
         caml_new_string("darkgray"),
         caml_new_string("darkgreen"),
         caml_new_string("darkgrey"),
         caml_new_string("darkkhaki"),
         caml_new_string("darkmagenta"),
         caml_new_string("darkolivegreen"),
         caml_new_string("darkorange"),
         caml_new_string("darkorchid"),
         caml_new_string("darkred"),
         caml_new_string("darksalmon"),
         caml_new_string("darkseagreen"),
         caml_new_string("darkslateblue"),
         caml_new_string("darkslategray"),
         caml_new_string("darkslategrey"),
         caml_new_string("darkturquoise"),
         caml_new_string("darkviolet"),
         caml_new_string("deeppink"),
         caml_new_string("deepskyblue"),
         caml_new_string("dimgray"),
         caml_new_string("dimgrey"),
         caml_new_string("dodgerblue"),
         caml_new_string("firebrick"),
         caml_new_string("floralwhite"),
         caml_new_string("forestgreen"),
         caml_new_string("fuchsia"),
         caml_new_string("gainsboro"),
         caml_new_string("ghostwhite"),
         caml_new_string("gold"),
         caml_new_string("goldenrod"),
         caml_new_string("gray"),
         caml_new_string("green"),
         caml_new_string("greenyellow"),
         caml_new_string("grey"),
         caml_new_string("honeydew"),
         caml_new_string("hotpink"),
         caml_new_string("indianred"),
         caml_new_string("indigo"),
         caml_new_string("ivory"),
         caml_new_string("khaki"),
         caml_new_string("lavender"),
         caml_new_string("lavenderblush"),
         caml_new_string("lawngreen"),
         caml_new_string("lemonchiffon"),
         caml_new_string("lightblue"),
         caml_new_string("lightcoral"),
         caml_new_string("lightcyan"),
         caml_new_string("lightgoldenrodyellow"),
         caml_new_string("lightgray"),
         caml_new_string("lightgreen"),
         caml_new_string("lightgrey"),
         caml_new_string("lightpink"),
         caml_new_string("lightsalmon"),
         caml_new_string("lightseagreen"),
         caml_new_string("lightskyblue"),
         caml_new_string("lightslategray"),
         caml_new_string("lightslategrey"),
         caml_new_string("lightsteelblue"),
         caml_new_string("lightyellow"),
         caml_new_string("lime"),
         caml_new_string("limegreen"),
         caml_new_string("linen"),
         caml_new_string("magenta"),
         caml_new_string("maroon"),
         caml_new_string("mediumaquamarine"),
         caml_new_string("mediumblue"),
         caml_new_string("mediumorchid"),
         caml_new_string("mediumpurple"),
         caml_new_string("mediumseagreen"),
         caml_new_string("mediumslateblue"),
         caml_new_string("mediumspringgreen"),
         caml_new_string("mediumturquoise"),
         caml_new_string("mediumvioletred"),
         caml_new_string("midnightblue"),
         caml_new_string("mintcream"),
         caml_new_string("mistyrose"),
         caml_new_string("moccasin"),
         caml_new_string("navajowhite"),
         caml_new_string("navy"),
         caml_new_string("oldlace"),
         caml_new_string("olive"),
         caml_new_string("olivedrab"),
         caml_new_string("orange"),
         caml_new_string("orangered"),
         caml_new_string("orchid"),
         caml_new_string("palegoldenrod"),
         caml_new_string("palegreen"),
         caml_new_string("paleturquoise"),
         caml_new_string("palevioletred"),
         caml_new_string("papayawhip"),
         caml_new_string("peachpuff"),
         caml_new_string("peru"),
         caml_new_string("pink"),
         caml_new_string("plum"),
         caml_new_string("powderblue"),
         caml_new_string("purple"),
         caml_new_string("red"),
         caml_new_string("rosybrown"),
         caml_new_string("royalblue"),
         caml_new_string("saddlebrown"),
         caml_new_string("salmon"),
         caml_new_string("sandybrown"),
         caml_new_string("seagreen"),
         caml_new_string("seashell"),
         caml_new_string("sienna"),
         caml_new_string("silver"),
         caml_new_string("skyblue"),
         caml_new_string("slateblue"),
         caml_new_string("slategray"),
         caml_new_string("slategrey"),
         caml_new_string("snow"),
         caml_new_string("springgreen"),
         caml_new_string("steelblue"),
         caml_new_string("tan"),
         caml_new_string("teal"),
         caml_new_string("thistle"),
         caml_new_string("tomato"),
         caml_new_string("turquoise"),
         caml_new_string("violet"),
         caml_new_string("wheat"),
         caml_new_string("white"),
         caml_new_string("whitesmoke"),
         caml_new_string("yellow"),
         caml_new_string("yellowgreen")]),
     _b5_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_new_string("#%02X%02X%02X")],
     _bZ_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_new_string("rgb(%d,%d,%d)")],
     _b0_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_new_string("rgb(%d%%,%d%%,%d%%)")],
     _b1_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,0,0,0,[12,41,0]]]]]]]]],
       caml_new_string("rgba(%d,%d,%d,%f)")],
     _b2_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_new_string("rgba(%d%%,%d%%,%d%%,%f)")],
     _b3_=
      [0,
       [11,
        caml_new_string("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_new_string("hsl(%d,%d%%,%d%%)")],
     _b4_=
      [0,
       [11,
        caml_new_string("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[8,0,0,0,partial$0]]]]]]]]]],
       caml_new_string("hsla(%d,%d%%,%d%%,%f)")],
     _w_=[0,240,248,255],
     _x_=[0,250,235,215],
     _y_=[0,0,255,255],
     _z_=[0,127,255,212],
     _A_=[0,240,255,255],
     _B_=[0,245,245,220],
     _C_=[0,255,228,196],
     _D_=[0,0,0,0],
     _E_=[0,255,235,205],
     _F_=[0,0,0,255],
     _G_=[0,138,43,226],
     _H_=[0,165,42,42],
     _I_=[0,222,184,135],
     _J_=[0,95,158,160],
     _K_=[0,127,255,0],
     _L_=[0,210,105,30],
     _M_=[0,255,127,80],
     _N_=[0,100,149,237],
     _O_=[0,255,248,220],
     _P_=[0,220,20,60],
     _Q_=[0,0,255,255],
     _R_=[0,0,0,139],
     _S_=[0,0,139,139],
     _T_=[0,184,134,11],
     _U_=[0,169,169,169],
     _V_=[0,0,100,0],
     _W_=[0,169,169,169],
     _X_=[0,189,183,107],
     _Y_=[0,139,0,139],
     _Z_=[0,85,107,47],
     ___=[0,255,140,0],
     _$_=[0,153,50,204],
     _aa_=[0,139,0,0],
     _ab_=[0,233,150,122],
     _ac_=[0,143,188,143],
     _ad_=[0,72,61,139],
     _ae_=[0,47,79,79],
     _af_=[0,47,79,79],
     _ag_=[0,0,206,209],
     _ah_=[0,148,0,211],
     _ai_=[0,255,20,147],
     _aj_=[0,0,191,255],
     _ak_=[0,105,105,105],
     _al_=[0,105,105,105],
     _am_=[0,30,144,255],
     _an_=[0,178,34,34],
     _ao_=[0,255,250,240],
     _ap_=[0,34,139,34],
     _aq_=[0,255,0,255],
     _ar_=[0,220,220,220],
     _as_=[0,248,248,255],
     _at_=[0,255,215,0],
     _au_=[0,218,165,32],
     _av_=[0,128,128,128],
     _aw_=[0,128,128,128],
     _ax_=[0,0,128,0],
     _ay_=[0,173,255,47],
     _az_=[0,240,255,240],
     _aA_=[0,255,105,180],
     _aB_=[0,205,92,92],
     _aC_=[0,75,0,130],
     _aD_=[0,255,255,240],
     _aE_=[0,240,230,140],
     _aF_=[0,230,230,250],
     _aG_=[0,255,240,245],
     _aH_=[0,124,252,0],
     _aI_=[0,255,250,205],
     _aJ_=[0,173,216,230],
     _aK_=[0,240,128,128],
     _aL_=[0,224,255,255],
     _aM_=[0,250,250,210],
     _aN_=[0,211,211,211],
     _aO_=[0,144,238,144],
     _aP_=[0,211,211,211],
     _aQ_=[0,255,182,193],
     _aR_=[0,255,160,122],
     _aS_=[0,32,178,170],
     _aT_=[0,135,206,250],
     _aU_=[0,119,136,153],
     _aV_=[0,119,136,153],
     _aW_=[0,176,196,222],
     _aX_=[0,255,255,224],
     _aY_=[0,0,255,0],
     _aZ_=[0,50,205,50],
     _a0_=[0,250,240,230],
     _a1_=[0,255,0,255],
     _a2_=[0,128,0,0],
     _a3_=[0,102,205,170],
     _a4_=[0,0,0,205],
     _a5_=[0,186,85,211],
     _a6_=[0,147,112,219],
     _a7_=[0,60,179,113],
     _a8_=[0,123,104,238],
     _a9_=[0,0,250,154],
     _a__=[0,72,209,204],
     _a$_=[0,199,21,133],
     _ba_=[0,25,25,112],
     _bb_=[0,245,255,250],
     _bc_=[0,255,228,225],
     _bd_=[0,255,228,181],
     _be_=[0,255,222,173],
     _bf_=[0,0,0,128],
     _bg_=[0,253,245,230],
     _bh_=[0,128,128,0],
     _bi_=[0,107,142,35],
     _bj_=[0,255,165,0],
     _bk_=[0,255,69,0],
     _bl_=[0,218,112,214],
     _bm_=[0,238,232,170],
     _bn_=[0,152,251,152],
     _bo_=[0,175,238,238],
     _bp_=[0,219,112,147],
     _bq_=[0,255,239,213],
     _br_=[0,255,218,185],
     _bs_=[0,205,133,63],
     _bt_=[0,255,192,203],
     _bu_=[0,221,160,221],
     _bv_=[0,176,224,230],
     _bw_=[0,128,0,128],
     _bx_=[0,255,0,0],
     _by_=[0,188,143,143],
     _bz_=[0,65,105,225],
     _bA_=[0,139,69,19],
     _bB_=[0,250,128,114],
     _bC_=[0,244,164,96],
     _bD_=[0,46,139,87],
     _bE_=[0,255,245,238],
     _bF_=[0,160,82,45],
     _bG_=[0,192,192,192],
     _bH_=[0,135,206,235],
     _bI_=[0,106,90,205],
     _bJ_=[0,112,128,144],
     _bK_=[0,112,128,144],
     _bL_=[0,255,250,250],
     _bM_=[0,0,255,127],
     _bN_=[0,70,130,180],
     _bO_=[0,210,180,140],
     _bP_=[0,0,128,128],
     _bQ_=[0,216,191,216],
     _bR_=[0,255,99,71],
     _bS_=[0,64,224,208],
     _bT_=[0,238,130,238],
     _bU_=[0,245,222,179],
     _bV_=[0,255,255,255],
     _bW_=[0,245,245,245],
     _bX_=[0,255,255,0],
     _bY_=[0,154,205,50];
    function return$0(_gQ_){return _gQ_}
    function map(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter(x,f)
     {var _gP_=1 - (x == no_handler?1:0);return _gP_?caml_call1(f,x):_gP_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gO_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gO_)}
    var
     Opt=
      [0,no_handler,return$0,map,bind,test,iter,case$0,get,option,to_option];
    function return$1(_gN_){return _gN_}
    function map$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function bind$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function test$0(x){return x !== t37?1:0}
    function iter$0(x,f)
     {var _gM_=x !== t37?1:0;return _gM_?caml_call1(f,x):_gM_}
    function case$1(x,f,g){return x === t37?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t37?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t37}
    function to_option$0(x)
     {function _gL_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gL_)}
    var
     Optdef=
      [0,
       t37,
       return$1,
       map$0,
       bind$0,
       test$0,
       iter$0,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gJ_(param){return caml_call1(g,x)}
      var _gK_=caml_call1(f,x);
      return caml_call2(Opt[8],_gK_,_gJ_)}
    function coerce_opt(x,f,g)
     {function _gH_(param){return caml_call1(g,x)}
      var _gI_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gI_,_gH_)}
    var
     true$0=true,
     false$0=false,
     string_constr=Unsafe[1].String,
     regExp_withFlags=Unsafe[1].RegExp,
     object_constructor=Unsafe[1].Object;
    function object_keys(o){return object_constructor.keys(o)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gG_){return _gG_}
    function match_result(_gF_){return _gF_}
    var
     date_ms=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Stdlib_callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_js_to_string(e.toString())]}
      return 0}
    caml_call1(Stdlib_printexc[8],_a_);
    function _b_(e)
     {return e instanceof array_length?0:[0,caml_js_to_string(e.toString())]}
    caml_call1(Stdlib_printexc[8],_b_);
    function string_of_error(e){return caml_js_to_string(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x){return export_js(field.toString(),x)}
    function export_all(obj)
     {var keys=object_keys(obj);
      return keys.forEach
              (caml_js_wrap_callback
                (function(key,param,_gE_){return export_js(key,obj[key])}))}
    function _c_(_gD_){return _gD_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gC_){return _gC_},
       t37,
       _c_,
       Opt,
       Optdef,
       true$0,
       false$0,
       string_constr,
       regExp_withFlags,
       regExp_withFlags,
       regExp_withFlags,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1610,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(i < length)
         {var _gB_=nodeList.item(i),match=caml_call1(Opt[10],_gB_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_list[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return (t & mask) === mask?1:0}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(0 !== match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType)if(4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _gy_(param)
       {function _gA_(param){throw Stdlib[8]}
        return caml_call2(Opt[8],e.srcElement,_gA_)}
      var target=caml_call2(Opt[8],e.target,_gy_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gz_=function(param){throw [0,Assert_failure,_d_]};
          return caml_call2(Opt[8],target.parentNode,_gz_)}
        return target}
      return target}
    var make=caml_js_from_string,Event=[0,make];
    function addEventListener(e,typ,h,capt)
     {if(e.addEventListener === t37)
       {var
         ev="on".concat(typ),
         callback=
          function(e)
           {var _gv_=[0,h,e,[0]];
            return function(_gw_,_gx_)
             {return runtime.caml_js_call(_gv_,_gw_,_gx_)}};
        e.attachEvent(ev,callback);
        return function(param){return e.detachEvent(ev,callback)}}
      e.addEventListener(typ,h,capt);
      return function(param){return e.removeEventListener(typ,h,capt)}}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListener,
       removeEventListener,
       preventDefault];
    caml_register_global(1613,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     uint8Array_fromBuffer=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set,
     get$1=caml_js_get,
     unsafe_get=caml_js_get,
     dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new uint8Array_fromBuffer(ab);
      return runtime.caml_string_of_array(uint8)}
    var
     String=[0,of_arrayBuffer],
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,runtime.bigstring_to_array_buffer,runtime.bigstring_of_array_buffer],
       String];
    caml_register_global
     (1614,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var blob_constr=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gr_=0;
      if(endings)
       var _gs_=116179762 <= endings[1]?_e_:_f_,_gt_=_gs_;
      else
       var _gt_=0;
      var
       _gu_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gt_],_gr_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v){var v$0=v[1];return [0,[0,name,v$0.toString()]]}
            return 0},
          _gu_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_array[12],options))
         :t37;
      return new blob_constr(caml_js_from_array(a),options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,s.toString()])}
    function blob_from_any(contentType,endings,l)
     {function _gp_(param)
       {var _gq_=param[1];
        if(155580615 === _gq_){var s=param[2];return s}
        if(486041214 <= _gq_)
         {if(1037850489 <= _gq_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gq_){var s$0=param[2];return s$0.toString()}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_list[17],_gp_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1
              (Stdlib[2],cst_can_t_retrieve_file_name_not_implemented)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof blob_constr?e:no_handler}
    function string(e)
     {return runtime.caml_equal(typeof e,"string")?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_go_){return _go_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1616,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$0=Event[1],
     Event$0=
      [0,
       click,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       pause,
       play,
       playing,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$0],
     d="2d";
    function location_origin(loc)
     {function _gm_(o){return o}
      function _gn_(param)
       {var protocol=loc.protocol,hostname=loc.hostname,port=loc.port;
        if(0 === protocol.length)if(0 === hostname.length)return "";
        var origin=protocol.concat("//",hostname);
        return 0 < port.length?origin.concat(":",loc.port):origin}
      return caml_call3(Optdef[7],loc.origin,_gn_,_gm_)}
    var _g_=Unsafe[1],document$0=_g_.document;
    function getElementById(id)
     {function _gj_(pnode){return pnode}
      function _gk_(param){throw Stdlib[8]}
      var _gl_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_gl_,_gk_,_gj_)}
    function getElementById_exn(id)
     {function _gf_(pnode){return pnode}
      function _gg_(param)
       {var _gi_=caml_call2(Stdlib_printf[4],_h_,id);
        return caml_call1(Stdlib[2],_gi_)}
      var _gh_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_gh_,_gg_,_gf_)}
    function getElementById_opt(id)
     {var _ge_=document$0.getElementById(id.toString());
      return caml_call1(Opt[10],_ge_)}
    function getElementById_coerce(id,coerce)
     {function _ga_(e)
       {var _gd_=caml_call1(coerce,e);return caml_call1(Opt[10],_gd_)}
      function _gb_(param){return 0}
      var _gc_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_gc_,_gb_,_ga_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(doc,name)
     {return doc.createElement(name.toString())}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type)if(0 === name)return createElement(doc,elt);
        var _f6_=createElementSyntax[1];
        if(785140586 === _f6_)
         {try
           {var
             el=document$0.createElement('<input name="x">'),
             _f9_=el.tagName.toLowerCase() === "input"?1:0,
             _f__=_f9_?el.name === "x"?1:0:_f9_,
             _f7_=_f__}
          catch(_f$_){var _f7_=0}
          var _f8_=_f7_?982028505:-1003883683;
          createElementSyntax[1] = _f8_;
          continue}
        if(982028505 <= _f6_)
         {var a=new array_length();
          a.push("<",elt.toString());
          opt_iter
           (type,
            function(t){a.push(' type="',caml_js_html_escape(t),'"');return 0});
          opt_iter
           (name,
            function(n){a.push(' name="',caml_js_html_escape(n),'"');return 0});
          a.push(">");
          return doc.createElement(a.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canvas_not_available,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t37
       ?function(e){return e.innerHTML === t37?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var _f5_=tag.toString();
      return e.tagName.toLowerCase() === _f5_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$1(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t37)if(ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _f2_(param)
       {var match=caml_js_to_string(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _f3_=function(param){throw [0,Assert_failure,_i_]};
          return caml_call2(Optdef[8],e.fromElement,_f3_)}
        function _f4_(param){throw [0,Assert_failure,_j_]}
        return caml_call2(Optdef[8],e.toElement,_f4_)}
      return caml_call2(Optdef[8],e.relatedTarget,_f2_)}
    function eventAbsolutePosition(e)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fY_(x)
       {function _f0_(y){return [0,x,y]}
        function _f1_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_f1_,_f0_)}
      function _fZ_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fZ_,_fY_)}
    function elementClientPosition(e)
     {var
       r=e.getBoundingClientRect(),
       body=document$0.body,
       html=document$0.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fW_(x){return x}
      function _fX_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fX_,_fW_)}
    function addMousewheelEventListener(e,h,capt)
     {var d=createDiv(document$0);
      d.setAttribute("onmousewheel","return;");
      if(typeof d.onmousewheel === "function")
       {var
         _fS_=
          handler
           (function(e)
             {function _fU_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fU_) | 0) / 40 | 0;
              function _fV_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fV_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListener(e,Event$0[11],_fS_,capt)}
      var
       _fT_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListener(e,Event$0[12],_fT_,capt)}
    function f(v)
     {var
       match=caml_js_to_string(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fR_=switcher;
        if(67 <= _fR_)
         switch(_fR_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fR_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return 0 === v?caml_call1(f,value):v}
    function _k_(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fK_=evt.keyCode;
      function _fL_(_fQ_){return run_next(_fK_,try_key_code_normal,_fQ_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fM_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fH_=evt.keyCode,
           _fM_=function(_fO_){return run_next(_fH_,try_key_code_left,_fO_)};
          break;
         case 1:
          var
           _fI_=evt.keyCode,
           _fM_=function(_fN_){return run_next(_fI_,try_key_code_right,_fN_)};
          break;
         default:
          var
           _fJ_=evt.keyCode,
           _fM_=function(_fP_){return run_next(_fJ_,try_key_code_numpad,_fP_)}}
      var value=evt.code;
      return _k_
              (_k_
                (_k_
                  (0,
                   function(v)
                    {return 0 === v
                             ?caml_call3(Optdef[7],value,make_unidentified,f)
                             :v}),
                 _fM_),
               _fL_)}
    function char_of_int(value)
     {if(0 < value)
       try
        {var _fF_=[0,caml_call1(Stdlib_uchar[8],value)];return _fF_}
       catch(_fG_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var key=caml_call2(Optdef[8],evt.key,empty_string),match=key.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(key.charCodeAt(0) | 0):0}
    function element$1(_fE_){return _fE_}
    function tagged(e)
     {var tag=caml_js_to_byte_string(e.tagName.toLowerCase());
      if(0 === caml_ml_string_length(tag))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _fC_(e){return [0,tagged(e)]}
      function _fD_(param){return 0}
      return caml_call3(Opt[7],e,_fD_,_fC_)}
    function taggedEvent(ev)
     {function _fn_(ev){return [0,ev]}
      function _fo_(param)
       {function _fq_(ev){return [1,ev]}
        function _fr_(param)
         {function _ft_(ev){return [2,ev]}
          function _fu_(param)
           {function _fw_(ev){return [3,ev]}
            function _fx_(param)
             {function _fz_(ev){return [4,ev]}
              function _fA_(param){return [5,ev]}
              var _fB_=popStateEvent(ev);
              return caml_call3(Opt[7],_fB_,_fA_,_fz_)}
            var _fy_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fy_,_fx_,_fw_)}
          var _fv_=wheelEvent(ev);
          return caml_call3(Opt[7],_fv_,_fu_,_ft_)}
        var _fs_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fs_,_fr_,_fq_)}
      var _fp_=mouseEvent(ev);
      return caml_call3(Opt[7],_fp_,_fo_,_fn_)}
    function opt_taggedEvent(ev)
     {function _fl_(ev){return [0,taggedEvent(ev)]}
      function _fm_(param){return 0}
      return caml_call3(Opt[7],ev,_fm_,_fl_)}
    function stopPropagation(ev)
     {function _fj_(param){return ev.stopPropagation()}
      function _fk_(param){return ev.cancelBubble = true$0}
      return caml_call3(Optdef[7],ev.stopPropagation,_fk_,_fj_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _g_.requestAnimationFrame,
             [0,
              _g_.mozRequestAnimationFrame,
              [0,
               _g_.webkitRequestAnimationFrame,
               [0,
                _g_.oRequestAnimationFrame,
                [0,_g_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _fg_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_list[34],_fg_,l),
             _fh_=function(callback){return req(callback)};
            return _fh_}
          catch(_fi_)
           {_fi_ = caml_wrap_exception(_fi_);
            if(_fi_ === Stdlib[8])
             {var
               now=function(param){return new date_ms().getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _g_.setTimeout(callback,dt$0);
                return 0}}
            throw _fi_}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_g_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var step$0=overflow_limit,remain=step - 2147483000.;
        else
         var step$0=step,remain=0.;
        var cb=remain == 0.?callback:function(_ff_){return loop(remain,_ff_)};
        id[1] = [0,_g_.setTimeout(caml_js_wrap_callback(cb),step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _fe_=id[1];
      if(_fe_){var x=_fe_[1];id[1] = 0;return _g_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       document$0,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _g_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListener,
       removeEventListener,
       addMousewheelEventListener,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$1,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1619,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var _fc_=0 < elt.name.length?1:0,_fd_=_fc_?1 - (elt.disabled | 0):_fc_;
      return _fd_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _e2_(i)
       {var _fb_=form.elements.item(i);return caml_call1(Opt[10],_fb_)}
      var
       _e3_=caml_call2(Stdlib_array[2],length,_e2_),
       elements=caml_call1(Stdlib_array[11],_e3_);
      function _e4_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_js_to_string(v$0.name),
                value=v$0.value,
                match=caml_js_to_byte_string(v$0.type.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(0 === list.length)
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1)
                      if(0 !== match$1[1])
                       {var
                         _e9_=function(i){return list.item(i)},
                         _e__=caml_call2(Stdlib_array[2],list.length,_e9_),
                         _e$_=caml_call1(Stdlib_array[11],_e__);
                        return filter_map$0
                                (function(f)
                                  {var match=caml_call1(Opt[10],f);
                                   if(match)
                                    {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                   return 0},
                                 _e$_)}
                     var _e8_=list.item(0),match$2=caml_call1(Opt[10],_e8_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 if(caml_string_notequal(match,cst_password))
                  if(caml_string_notequal(match,cst_radio))
                   {if(caml_string_notequal(match,cst_reset))
                     if(caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       var switch$0=1,switch$1=0}
                     else
                      var switch$1=1;
                    else
                     var switch$1=1;
                    if(switch$1)return 0}
                  else
                   var switch$0=0;
                 else
                  var switch$0=1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_js_to_string(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _e6_=
                   function(i)
                    {var _fa_=v$1.options.item(i);
                     return caml_call1(Opt[10],_fa_)},
                  options=caml_call2(Stdlib_array[2],v$1.options.length,_e6_),
                  _e7_=caml_call1(Stdlib_array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _e7_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_js_to_string(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _e5_=caml_call2(Stdlib_list[17],_e4_,elements),
       contents=caml_call1(Stdlib_list[14],_e5_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_e0_=form_elt[2],_e1_=form_elt[1];
      if(781515420 <= _e0_[1])
       {var file=_e0_[2];return f.append(_e1_.toString(),file)}
      var s=_e0_[2];
      return f.append(_e1_.toString(),s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eX_=form_elements(0,form);
      function _eY_(_eZ_){return append(contents,_eZ_)}
      caml_call2(Stdlib_list[15],_eY_,_eX_);
      return contents}
    function get_form_contents(form)
     {var _eT_=form_elements(_l_,form);
      function _eU_(param)
       {var _eV_=param[2],_eW_=param[1];
        if(typeof _eV_ !== "number")
         if(-976970511 === _eV_[1])
          {var s=_eV_[2];return [0,_eW_,caml_js_to_string(s)]}
        throw [0,Assert_failure,_m_]}
      return caml_call2(Stdlib_list[17],_eU_,_eT_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1620,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0];
    function create(param)
     {var
       xmlHttpRequest=Unsafe[1].XMLHttpRequest,
       activeXObject=Unsafe[1].activeXObject;
      try
       {var _eO_=new xmlHttpRequest();return _eO_}
      catch(_eP_)
       {try
         {var _eN_=new activeXObject("Msxml2.XMLHTTP");return _eN_}
        catch(_eQ_)
         {try
           {var _eM_=new activeXObject("Msxml3.XMLHTTP");return _eM_}
          catch(_eR_)
           {try
             {var _eL_=new activeXObject("Microsoft.XMLHTTP");return _eL_}
            catch(_eS_){throw [0,Assert_failure,_n_]}}}}}
    var Js_of_ocaml_XmlHttpRequest=[0,create,Event$1];
    caml_register_global
     (1621,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var worker=Unsafe[1].Worker;
    function create$0(script){return new worker(script.toString())}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t37)
       caml_call1(Stdlib[1],cst_Worker_import_scripts_is_undefined);
      var
       _eJ_=caml_call1(Stdlib_array[12],scripts),
       _eK_=caml_call2(Stdlib_array[15],caml_js_from_string,_eJ_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eK_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t37)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefined);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(msg)
     {if(Unsafe[1].postMessage === t37)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefined$0);
      return Unsafe[1].postMessage(msg)}
    var
     Js_of_ocaml_Worker=
      [0,create$0,import_scripts,set_onmessage,post_message];
    caml_register_global(1622,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1623,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":true$0,
       "depth":true$0,
       "stencil":false$0,
       "antialias":true$0,
       "premultipliedAlpha":false$0,
       "preserveDrawingBuffer":false$0,
       "preferLowPowerToHighPerformance":false$0,
       "failIfMajorPerformanceCaveat":false$0},
     webglcontextlost=caml_call1(Event$0[73],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[73],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[73],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(c)
     {var ctx=c.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:c.getContext("experimental-webgl")}
    function getContextWithAttributes(c,attribs)
     {var ctx=c.getContext("webgl",attribs);
      return caml_call1(Opt[5],ctx)
              ?ctx
              :c.getContext("experimental-webgl",attribs)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1624,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"g")}
    function regexp_case_fold(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"gi")}
    function regexp_with_flag(s,f)
     {var _eI_=caml_call2(Stdlib[28],cst_g,f).toString();
      return new regExp_withFlags(caml_jsbytes_of_string(s),_eI_)}
    function blunt_str_array_get(a,i)
     {function _eH_(param){throw [0,Assert_failure,_o_]}
      return caml_js_to_byte_string(caml_call2(Optdef[8],a[i],_eH_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       _eF_=r.exec(caml_jsbytes_of_string(s)),
       _eG_=caml_call2(Opt[3],_eF_,match_result);
      return caml_call1(Opt[10],_eG_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      function _eC_(res){return [0,res.index,res]}
      var
       _eD_=r.exec(caml_jsbytes_of_string(s)),
       _eE_=caml_call2(Opt[3],_eD_,_eC_);
      return caml_call1(Opt[10],_eE_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _eB_=caml_call2(Optdef[3],r[i],caml_js_to_byte_string);
      return caml_call1(Optdef[10],_eB_)}
    var quote_repl_re=new regExp_withFlags("[$]","g");
    function quote_repl(s)
     {return caml_jsbytes_of_string(s).replace(quote_repl_re,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var _eA_=quote_repl(s_by);
      return caml_js_to_byte_string(caml_jsbytes_of_string(s).replace(r,_eA_))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=0 === match?0 === match$0?"":"m":0 === match$0?"i":"mi",
       r$0=new regExp_withFlags(r.source,flags),
       _ez_=quote_repl(s_by);
      return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(r$0,_ez_))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(0 <= idx)
         {var
           idx$0=idx - 1 | 0,
           accu$0=[0,blunt_str_array_get(a,idx),accu],
           accu=accu$0,
           idx=idx$0;
          continue}
        return accu}}
    function split(r,s)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r,i))}
    var quote_re=regexp(cst);
    function quote(s)
     {return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(quote_re,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1625,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var
     plus_re=regexp_string(cst$0),
     plus_re_js_string=new regExp_withFlags("\\+","g");
    function urldecode_js_string_string(s)
     {plus_re_js_string.lastIndex = 0;
      return caml_js_to_byte_string
              (unescape(s.replace(plus_re_js_string," ")))}
    function urldecode(s)
     {return caml_js_to_byte_string
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_http_protocol,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _ex_=caml_call3(Stdlib_string[18],s,i,47),j=_ex_}
        catch(_ey_)
         {_ey_ = caml_wrap_exception(_ey_);
          if(_ey_ !== Stdlib[8])throw _ey_;
          var j=l}
        var word=caml_call3(Stdlib_string[4],s,i,j - i | 0);
        return l <= j?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a)
       if(! caml_string_notequal(a[1],cst$2))
        {var _ew_=a[2];
         if(! _ew_)return 0;
         if(! caml_string_notequal(_ew_[1],cst$3))if(! _ew_[2])return _p_}
      return a}
    function encode_arguments(l)
     {function _er_(param)
       {var
         v=param[2],
         n=param[1],
         _et_=urlencode(0,v),
         _eu_=caml_call2(Stdlib[28],cst$4,_et_),
         _ev_=urlencode(0,n);
        return caml_call2(Stdlib[28],_ev_,_eu_)}
      var _es_=caml_call2(Stdlib_list[17],_er_,l);
      return caml_call2(Stdlib_string[7],cst$5,_es_)}
    function decode_arguments_js_string(s)
     {var
       arr=s.split(caml_call2(Stdlib_string[1],1,38).toString()),
       len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(0 <= idx$0)
           try
            {var
              _ej_=idx$0 - 1 | 0,
              _ek_=
               function(s)
                {function _ep_(param)
                  {var
                    y=param[2],
                    x=param[1],
                    _eq_=urldecode_js_string_string(y);
                   return [0,urldecode_js_string_string(x),_eq_]}
                 var
                  index=
                   s.indexOf(caml_call2(Stdlib_string[1],1,61).toString());
                 if(0 <= index)
                  var
                   _en_=s.slice(index + 1 | 0),
                   _eo_=[0,s.slice(0,index),_en_];
                 else
                  var _eo_=t37;
                 return caml_call3(Optdef[7],_eo_,interrupt,_ep_)},
              _el_=
               aux
                ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_ek_),acc],_ej_);
             return _el_}
           catch(_em_)
            {_em_ = caml_wrap_exception(_em_);
             if(_em_ === Local_exn)
              {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
             throw _em_}
          return acc}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     url_re=
      new
       regExp_withFlags
       (caml_jsbytes_of_string
         (cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9)),
     file_re=new regExp_withFlags(caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee));
    function url_of_js_string(s)
     {function _d2_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_js_to_byte_string(prot_string.toLowerCase());
        if(caml_string_notequal(match,cst_file$0))
         if(caml_string_notequal(match,cst_file$1))
          {if(caml_string_notequal(match,cst_http))
            if(caml_string_notequal(match,cst_http$0))
             {if(caml_string_notequal(match,cst_https))
               if(caml_string_notequal(match,cst_https$0))
                var switch$0=1,switch$1=0;
               else
                var switch$1=1;
              else
               var switch$1=1;
              if(switch$1)var ssl=1,switch$0=2}
            else
             var switch$0=0;
           else
            var switch$0=0;
           switch(switch$0)
            {case 0:var ssl=0,switch$2=1;break;
             case 1:var switch$2=0;break;
             default:var switch$2=1}
           if(switch$2)
            {var
              _ea_=function(param){return caml_jsbytes_of_string(cst$7)},
              path_str=
               urldecode_js_string_string(caml_call2(Optdef[8],res[6],_ea_)),
              _eb_=function(param){return caml_jsbytes_of_string(cst$8)},
              _ec_=
               urldecode_js_string_string(caml_call2(Optdef[8],res[10],_eb_)),
              _ed_=function(param){return caml_jsbytes_of_string(cst$9)},
              _ee_=
               decode_arguments_js_string(caml_call2(Optdef[8],res[8],_ed_)),
              _ef_=path_of_path_string(path_str),
              _eg_=function(param){return caml_jsbytes_of_string(cst$10)},
              s=caml_js_to_byte_string(caml_call2(Optdef[8],res[4],_eg_)),
              _eh_=
               caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
              url=
               [0,
                urldecode_js_string_string
                 (caml_call2(Optdef[8],res[2],interrupt)),
                _eh_,
                _ef_,
                path_str,
                _ee_,
                _ec_],
              _ei_=ssl?[1,url]:[0,url];
             return [0,_ei_]}}
        throw Not_an_http_protocol}
      function _d3_(param)
       {function _d5_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _d8_(param){return caml_jsbytes_of_string(cst$11)}
          var _d9_=caml_js_to_byte_string(caml_call2(Optdef[8],res[6],_d8_));
          function _d__(param){return caml_jsbytes_of_string(cst$12)}
          var
           _d$_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_d__));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_d$_,_d9_]]]}
        function _d6_(param){return 0}
        var _d7_=file_re.exec(s);
        return caml_call3(Opt[7],_d7_,_d6_,_d5_)}
      var _d4_=url_re.exec(s);
      return caml_call3(Opt[7],_d4_,_d3_,_d2_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _dp_=urlencode(0,frag),_dq_=caml_call2(Stdlib[28],cst$14,_dp_);
         else
          var _dq_=cst$21;
         if(args)
          var
           _dr_=encode_arguments(args),
           _ds_=caml_call2(Stdlib[28],cst$15,_dr_);
         else
          var _ds_=cst$20;
         var
          _dt_=caml_call2(Stdlib[28],_ds_,_dq_),
          _du_=function(x){return urlencode(0,x)},
          _dv_=caml_call2(Stdlib_list[17],_du_,path),
          _dw_=caml_call2(Stdlib_string[7],cst$16,_dv_),
          _dx_=caml_call2(Stdlib[28],_dw_,_dt_),
          _dy_=caml_call2(Stdlib[28],cst$17,_dx_);
         if(80 === port)
          var _dz_=cst$18;
         else
          var
           _dD_=caml_call1(Stdlib[33],port),
           _dz_=caml_call2(Stdlib[28],cst$19,_dD_);
         var
          _dA_=caml_call2(Stdlib[28],_dz_,_dy_),
          _dB_=urlencode(0,host),
          _dC_=caml_call2(Stdlib[28],_dB_,_dA_);
         return caml_call2(Stdlib[28],cst_http$1,_dC_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _dE_=urlencode(0,frag$0),
           _dF_=caml_call2(Stdlib[28],cst$23,_dE_);
         else
          var _dF_=cst$30;
         if(args$0)
          var
           _dG_=encode_arguments(args$0),
           _dH_=caml_call2(Stdlib[28],cst$24,_dG_);
         else
          var _dH_=cst$29;
         var
          _dI_=caml_call2(Stdlib[28],_dH_,_dF_),
          _dJ_=function(x){return urlencode(0,x)},
          _dK_=caml_call2(Stdlib_list[17],_dJ_,path$0),
          _dL_=caml_call2(Stdlib_string[7],cst$25,_dK_),
          _dM_=caml_call2(Stdlib[28],_dL_,_dI_),
          _dN_=caml_call2(Stdlib[28],cst$26,_dM_);
         if(443 === port$0)
          var _dO_=cst$27;
         else
          var
           _dS_=caml_call1(Stdlib[33],port$0),
           _dO_=caml_call2(Stdlib[28],cst$28,_dS_);
         var
          _dP_=caml_call2(Stdlib[28],_dO_,_dN_),
          _dQ_=urlencode(0,host$0),
          _dR_=caml_call2(Stdlib[28],_dQ_,_dP_);
         return caml_call2(Stdlib[28],cst_https$1,_dR_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dT_=urlencode(0,frag$1),
           _dU_=caml_call2(Stdlib[28],cst$32,_dT_);
         else
          var _dU_=cst$36;
         if(args$1)
          var
           _dV_=encode_arguments(args$1),
           _dW_=caml_call2(Stdlib[28],cst$33,_dV_);
         else
          var _dW_=cst$35;
         var
          _dX_=caml_call2(Stdlib[28],_dW_,_dU_),
          _dY_=function(x){return urlencode(0,x)},
          _dZ_=caml_call2(Stdlib_list[17],_dY_,path$1),
          _d0_=caml_call2(Stdlib_string[7],cst$34,_dZ_),
          _d1_=caml_call2(Stdlib[28],_d0_,_dX_);
         return caml_call2(Stdlib[28],cst_file$2,_d1_)}}
    var _q_=caml_call1(Optdef[2],_g_.location);
    if(caml_call1(Optdef[5],_q_))
     var _r_=_g_.location;
    else
     var
      t29="",
      t40=function(param,_do_){return 0},
      t39=function(param,_dn_){return 0},
      t38=function(param){return 0},
      _r_=
       {"href":t29,
        "protocol":t29,
        "host":t29,
        "hostname":t29,
        "port":t29,
        "pathname":t29,
        "search":t29,
        "hash":t29,
        "origin":t37,
        "reload":caml_js_wrap_meth_callback(t38),
        "replace":caml_js_wrap_meth_callback(t39),
        "assign":caml_js_wrap_meth_callback(t40)};
    var
     host=urldecode_js_string_string(_r_.hostname),
     protocol=urldecode_js_string_string(_r_.protocol),
     _s_=0,
     port=
      function(param)
        {try
          {var _dl_=[0,caml_int_of_string(caml_js_to_byte_string(_r_.port))];
           return _dl_}
         catch(_dm_)
          {_dm_ = caml_wrap_exception(_dm_);
           if(_dm_[1] === Stdlib[7])return 0;
           throw _dm_}}
       (_s_),
     path_string=urldecode_js_string_string(_r_.pathname),
     path=path_of_path_string(path_string),
     _t_=_r_.search.charAt(0) === "?"?_r_.search.slice(1):_r_.search,
     arguments$0=decode_arguments_js_string(_t_);
    function get_fragment(param)
     {function _dh_(res){return caml_js_to_string(res[1])}
      function _di_(param){return cst$37}
      var _dj_=new regExp_withFlags("#(.*)"),_dk_=_r_.href.match(_dj_);
      return caml_call3(Opt[7],_dk_,_di_,_dh_)}
    function set_fragment(s)
     {return _r_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_r_.href)}
    function set$0(u)
     {return _r_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_r_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1628,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,js_of_ocaml_version,git_version];
    caml_register_global
     (1629,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[60],name);
      caml_call2(Stdlib[66],oc,content);
      return caml_call1(Stdlib[76],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_js_to_byte_string(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    var
     unmount=runtime.caml_unmount,
     _u_=runtime.caml_create_file,
     _v_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_dg_){return runtime.caml_list_mount_point(_dg_)},
       unmount,
       mount,
       _v_,
       _u_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1630,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_mutation_observer_init(param){return {}}
    var mutationObserver=Unsafe[1].MutationObserver;
    function is_supported$0(param)
     {return caml_call1(Optdef[5],mutationObserver)}
    function observe
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var obs=new mutationObserver(caml_js_wrap_callback(f)),cfg={};
      opt_iter(child_list,function(v){return cfg.childList = v});
      opt_iter(attributes,function(v){return cfg.attributes = v});
      opt_iter(character_data,function(v){return cfg.characterData = v});
      opt_iter(subtree,function(v){return cfg.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return cfg.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return cfg.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return cfg.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Stdlib_array[12],l))});
      obs.observe(node,cfg);
      return obs}
    var
     Js_of_ocaml_MutationObserver=
      [0,empty_mutation_observer_init,mutationObserver,is_supported$0,observe];
    caml_register_global
     (1631,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var obj=Unsafe[1].Object;
    function create$1(param){return new obj()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       key_array=Unsafe[1].Object.keys(t),
       res=[0,0],
       _dc_=key_array.length - 1 | 0,
       _db_=0;
      if(! (_dc_ < 0))
       {var i=_db_;
        for(;;)
         {var
           _dd_=function(param){return caml_call1(Stdlib[2],cst_Jstable_keys)},
           key=caml_call2(Optdef[8],key_array[i],_dd_),
           _de_=res[1];
          res[1] = [0,key.substring(0,key.length - 1 | 0),_de_];
          var _df_=i + 1 | 0;
          if(_dc_ !== i){var i=_df_;continue}
          break}}
      return caml_call1(Stdlib_list[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$1,add$0,remove,find,keys];
    caml_register_global(1632,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var json=runtime.caml_json(0);
    function reviver(this$0,key,value)
     {return typeof value == typeof "foo"?caml_js_to_byte_string(value):value}
    var input_reviver=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(s){return json.parse(s,input_reviver)}
    var mlString_constr=dummy_string.constructor;
    function output_reviver(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value}
    function output(obj){return json.stringify(obj,output_reviver)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1633,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _da_=param;
      if(74 <= _da_)
       {if(111 <= _da_)
         switch(_da_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_da_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _da_)
       switch(_da_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_da_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      var _c$_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color_name);
      throw [0,Stdlib[6],_c$_]}
    function rgb_of_name(param)
     {var _c__=param;
      if(74 <= _c__)
       {if(111 <= _c__)
         switch(_c__)
          {case 111:return _bp_;
           case 112:return _bq_;
           case 113:return _br_;
           case 114:return _bs_;
           case 115:return _bt_;
           case 116:return _bu_;
           case 117:return _bv_;
           case 118:return _bw_;
           case 119:return _bx_;
           case 120:return _by_;
           case 121:return _bz_;
           case 122:return _bA_;
           case 123:return _bB_;
           case 124:return _bC_;
           case 125:return _bD_;
           case 126:return _bE_;
           case 127:return _bF_;
           case 128:return _bG_;
           case 129:return _bH_;
           case 130:return _bI_;
           case 131:return _bJ_;
           case 132:return _bK_;
           case 133:return _bL_;
           case 134:return _bM_;
           case 135:return _bN_;
           case 136:return _bO_;
           case 137:return _bP_;
           case 138:return _bQ_;
           case 139:return _bR_;
           case 140:return _bS_;
           case 141:return _bT_;
           case 142:return _bU_;
           case 143:return _bV_;
           case 144:return _bW_;
           case 145:return _bX_;
           default:return _bY_}
        switch(_c__)
         {case 74:return _aQ_;
          case 75:return _aR_;
          case 76:return _aS_;
          case 77:return _aT_;
          case 78:return _aU_;
          case 79:return _aV_;
          case 80:return _aW_;
          case 81:return _aX_;
          case 82:return _aY_;
          case 83:return _aZ_;
          case 84:return _a0_;
          case 85:return _a1_;
          case 86:return _a2_;
          case 87:return _a3_;
          case 88:return _a4_;
          case 89:return _a5_;
          case 90:return _a6_;
          case 91:return _a7_;
          case 92:return _a8_;
          case 93:return _a9_;
          case 94:return _a__;
          case 95:return _a$_;
          case 96:return _ba_;
          case 97:return _bb_;
          case 98:return _bc_;
          case 99:return _bd_;
          case 100:return _be_;
          case 101:return _bf_;
          case 102:return _bg_;
          case 103:return _bh_;
          case 104:return _bi_;
          case 105:return _bj_;
          case 106:return _bk_;
          case 107:return _bl_;
          case 108:return _bm_;
          case 109:return _bn_;
          default:return _bo_}}
      if(37 <= _c__)
       switch(_c__)
        {case 37:return _af_;
         case 38:return _ag_;
         case 39:return _ah_;
         case 40:return _ai_;
         case 41:return _aj_;
         case 42:return _ak_;
         case 43:return _al_;
         case 44:return _am_;
         case 45:return _an_;
         case 46:return _ao_;
         case 47:return _ap_;
         case 48:return _aq_;
         case 49:return _ar_;
         case 50:return _as_;
         case 51:return _at_;
         case 52:return _au_;
         case 53:return _av_;
         case 54:return _aw_;
         case 55:return _ax_;
         case 56:return _ay_;
         case 57:return _az_;
         case 58:return _aA_;
         case 59:return _aB_;
         case 60:return _aC_;
         case 61:return _aD_;
         case 62:return _aE_;
         case 63:return _aF_;
         case 64:return _aG_;
         case 65:return _aH_;
         case 66:return _aI_;
         case 67:return _aJ_;
         case 68:return _aK_;
         case 69:return _aL_;
         case 70:return _aM_;
         case 71:return _aN_;
         case 72:return _aO_;
         default:return _aP_}
      switch(_c__)
       {case 0:return _w_;
        case 1:return _x_;
        case 2:return _y_;
        case 3:return _z_;
        case 4:return _A_;
        case 5:return _B_;
        case 6:return _C_;
        case 7:return _D_;
        case 8:return _E_;
        case 9:return _F_;
        case 10:return _G_;
        case 11:return _H_;
        case 12:return _I_;
        case 13:return _J_;
        case 14:return _K_;
        case 15:return _L_;
        case 16:return _M_;
        case 17:return _N_;
        case 18:return _O_;
        case 19:return _P_;
        case 20:return _Q_;
        case 21:return _R_;
        case 22:return _S_;
        case 23:return _T_;
        case 24:return _U_;
        case 25:return _V_;
        case 26:return _W_;
        case 27:return _X_;
        case 28:return _Y_;
        case 29:return _Z_;
        case 30:return ___;
        case 31:return _$_;
        case 32:return _aa_;
        case 33:return _ab_;
        case 34:return _ac_;
        case 35:return _ad_;
        default:return _ae_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_printf[4],_bZ_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_printf[4],_b0_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_printf[4],_b1_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_printf[4],_b2_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_printf[4],_b3_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_printf[4],_b4_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var _c6_=i < 0?1:0,_c7_=_c6_ || (255 < i?1:0);
        if(_c7_)
         {var
           _c8_=caml_call1(Stdlib[33],i),
           _c9_=caml_call2(Stdlib[28],_c8_,cst_is_out_of_valid_range);
          throw [0,Stdlib[6],_c9_]}
        return _c7_}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_printf[4],_b5_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       rgb_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d)),
       rgb_pct_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0)),
       rgba_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d)),
       rgba_pct_re=
        new
         regExp_withFlags
         (caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0)),
       hsl_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d)),
       hsla_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d));
      if(! (rgb_re.test(s) | 0))
       if(! (rgba_re.test(s) | 0))
        if(! (rgb_pct_re.test(s) | 0))
         if(! (rgba_pct_re.test(s) | 0))
          if(! (hsl_re.test(s) | 0))
           if(! (hsla_re.test(s) | 0))
            {if(caml_call2(Stdlib_list[32],caml_js_to_string(s),_b6_))
              return s;
             var
              _c5_=
               caml_call2
                (Stdlib[28],caml_js_to_string(s),cst_is_not_a_valid_color);
             throw [0,Stdlib[6],_c5_]}
      return s}
    function js(c)
     {if(0 === c[0]){var n=c[1];return string_of_name(n).toString()}
      return string_of_t(c).toString()}
    function ml(c)
     {var s=caml_js_to_string(c);
      try
       {var _cS_=[0,name_of_string(s)];return _cS_}
      catch(_cT_)
       {_cT_ = caml_wrap_exception(_cT_);
        if(_cT_[1] === Stdlib[6])
         {var
           fail=
            function(param)
             {var _c4_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color$0);
              throw [0,Stdlib[6],_c4_]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _c2_=caml_int_of_string(i);return _c2_}
                catch(_c3_)
                 {_c3_ = caml_wrap_exception(_c3_);
                  if(_c3_[1] === Stdlib[6])
                   var s=_c3_[2];
                  else
                   {if(_c3_[1] !== Stdlib[7])throw _c3_;var s=_c3_[2]}
                  var
                   _cZ_=caml_call2(Stdlib[28],cst$38,s),
                   _c0_=caml_call2(Stdlib[28],i,_cZ_),
                   _c1_=caml_call2(Stdlib[28],cst_color_conversion_error,_c0_);
                  throw [0,Stdlib[6],_c1_]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cX_=caml_float_of_string(f);return _cX_}
              catch(_cY_)
               {_cY_ = caml_wrap_exception(_cY_);
                if(_cY_[1] === Stdlib[6])
                 var s=_cY_[2];
                else
                 {if(_cY_[1] !== Stdlib[7])throw _cY_;var s=_cY_[2]}
                var
                 _cU_=caml_call2(Stdlib[28],cst$39,s),
                 _cV_=caml_call2(Stdlib[28],f,_cU_),
                 _cW_=caml_call2(Stdlib[28],cst_color_conversion_error$0,_cV_);
                throw [0,Stdlib[6],_cW_]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cA_=match$0[1];
              if(! caml_string_notequal(_cA_,cst_rgb))
               {if(alpha)return fail(0);
                var _cE_=i_of_s_o(blue),_cF_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cF_,_cE_]]}
              if(! caml_string_notequal(_cA_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cB_=f_of_s(a),
                   _cC_=i_of_s_o(blue),
                   _cD_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cD_,_cC_,_cB_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cG_=match$2[1];
              if(! caml_string_notequal(_cG_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cK_=i_of_s_o(blue$0),_cL_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cL_,_cK_]]}
              if(! caml_string_notequal(_cG_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cH_=f_of_s(a$0),
                   _cI_=i_of_s_o(blue$0),
                   _cJ_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cJ_,_cI_,_cH_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cM_=match$4[1];
              if(! caml_string_notequal(_cM_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cQ_=i_of_s_o(blue$1),_cR_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cR_,_cQ_]]}
              if(! caml_string_notequal(_cM_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cN_=f_of_s(a$1),
                   _cO_=i_of_s_o(blue$1),
                   _cP_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cP_,_cO_,_cN_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cT_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_printf[4],_b7_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_printf[4],_b8_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_printf[4],_b9_,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_printf[4],_b__,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_printf[4],_b$_,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_printf[4],_ca_,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_printf[4],_cb_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_printf[4],_cc_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_printf[4],_cd_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_printf[4],_ce_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_printf[4],_cf_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_printf[4],_cg_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_printf[4],_ch_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_printf[4],_ci_,f$12,cst_pc)}}
    function js$0(t){return string_of_t$0(t).toString()}
    function ml$0(t)
     {var s=caml_js_to_string(t);
      if(runtime.caml_string_equal(s,cst_0$0))return 0;
      function fail(param)
       {var _cz_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length);
        throw [0,Stdlib[6],_cz_]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cx_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cw_=caml_call2(Stdlib[28],cst_length_conversion_error,s$0);
              throw [0,Stdlib[6],_cw_]}
            throw exn}
          var f$0=_cx_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cy_=match$1[1],switch$0=caml_string_compare(_cy_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cy_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cy_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cy_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cy_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cy_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cy_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cy_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cy_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cy_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cy_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cy_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cy_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cy_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_printf[4],_cj_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_printf[4],_ck_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_printf[4],_cl_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_printf[4],_cm_,f$2,cst_turns)}}
    function js$1(t){return string_of_t$1(t).toString()}
    function ml$1(j)
     {var s=caml_js_to_string(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {var _cv_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length$0);
        throw [0,Stdlib[6],_cv_]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _ct_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cs_=caml_call2(Stdlib[28],cst_length_conversion_error$0,s$0);
              throw [0,Stdlib[6],_cs_]}
            throw exn}
          var f$0=_ct_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cu_=match$1[1];
          if(! caml_string_notequal(_cu_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_cu_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_cu_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_cu_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1634,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cr_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cr_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1635,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     xmlns="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGError,caml_fresh_oo_id(0)];
    function createElement$0(doc,name)
     {return doc.createElementNS(xmlns,name.toString())}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignobject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$1=Unsafe[1].document;
    function getElementById$0(id)
     {function _co_(e){if(e instanceof svg_element)return e;throw Stdlib[8]}
      function _cp_(param){throw Stdlib[8]}
      var _cq_=Unsafe[1].document.getElementById(id.toString());
      return caml_call3(Opt[7],_cq_,_cp_,_co_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var _cn_=tag.toString();
      return e.tagName.toLowerCase() === _cn_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject$0)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       xmlns,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$1,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1636,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1637,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1638,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$1(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$1];
    caml_register_global
     (1639,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":false$0,
              "numeric":false$0,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t37,
              "hour12":t37,
              "hourCycle":t37,
              "formatMatcher":"best fit",
              "weekday":t37,
              "era":t37,
              "year":t37,
              "month":t37,
              "day":t37,
              "hour":t37,
              "minute":t37,
              "second":t37,
              "timeZoneName":t37}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t37,
              "currencyDisplay":t37,
              "useGrouping":true$0,
              "minimumIntegerDigits":t37,
              "minimumFractionDigits":t37,
              "maximumFractionDigits":t37,
              "minimumSignificantDigits":t37,
              "maximumSignificantDigits":t37}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$2(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$2];
    caml_register_global(1640,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0];
    caml_register_global(1641,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 "../.js/result/result.cma.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime,Result=[0];
    runtime.caml_register_global(0,Result,"Result");
    return}
  (function(){return this}()));


//# 1 "../.js/ppx_deriving.runtime/ppx_deriving_runtime.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     global_data=runtime.caml_get_global_data(),
     Stdlib=global_data.Stdlib,
     invalid_arg=Stdlib[1],
     failwith=Stdlib[2],
     Exit=Stdlib[3],
     Match_failure=Stdlib[4],
     Assert_failure=Stdlib[5],
     Invalid_argument=Stdlib[6],
     Failure=Stdlib[7],
     Not_found=Stdlib[8],
     Out_of_memory=Stdlib[9],
     Stack_overflow=Stdlib[10],
     Sys_error=Stdlib[11],
     End_of_file=Stdlib[12],
     Division_by_zero=Stdlib[13],
     Sys_blocked_io=Stdlib[14],
     Undefined_recursive_module=Stdlib[15],
     min=Stdlib[16],
     max=Stdlib[17],
     abs=Stdlib[18],
     max_int=Stdlib[19],
     min_int=Stdlib[20],
     lnot=Stdlib[21],
     infinity=Stdlib[22],
     neg_infinity=Stdlib[23],
     nan=Stdlib[24],
     max_float=Stdlib[25],
     min_float=Stdlib[26],
     epsilon_float=Stdlib[27],
     char_of_int=Stdlib[29],
     string_of_bool=Stdlib[30],
     bool_of_string_opt=Stdlib[31],
     bool_of_string=Stdlib[32],
     string_of_int=Stdlib[33],
     int_of_string_opt=Stdlib[34],
     string_of_float=Stdlib[35],
     float_of_string_opt=Stdlib[36],
     stdin=Stdlib[38],
     stdout=Stdlib[39],
     stderr=Stdlib[40],
     print_char=Stdlib[41],
     print_string=Stdlib[42],
     print_bytes=Stdlib[43],
     print_int=Stdlib[44],
     print_float=Stdlib[45],
     print_endline=Stdlib[46],
     print_newline=Stdlib[47],
     prerr_char=Stdlib[48],
     prerr_string=Stdlib[49],
     prerr_bytes=Stdlib[50],
     prerr_int=Stdlib[51],
     prerr_float=Stdlib[52],
     prerr_endline=Stdlib[53],
     prerr_newline=Stdlib[54],
     read_line=Stdlib[55],
     read_int_opt=Stdlib[56],
     read_int=Stdlib[57],
     read_float_opt=Stdlib[58],
     read_float=Stdlib[59],
     open_out=Stdlib[60],
     open_out_bin=Stdlib[61],
     open_out_gen=Stdlib[62],
     flush=Stdlib[63],
     flush_all=Stdlib[64],
     output_char=Stdlib[65],
     output_string=Stdlib[66],
     output_bytes=Stdlib[67],
     output=Stdlib[68],
     output_substring=Stdlib[69],
     output_byte=Stdlib[70],
     output_binary_int=Stdlib[71],
     output_value=Stdlib[72],
     seek_out=Stdlib[73],
     pos_out=Stdlib[74],
     out_channel_length=Stdlib[75],
     close_out=Stdlib[76],
     close_out_noerr=Stdlib[77],
     set_binary_mode_out=Stdlib[78],
     open_in=Stdlib[79],
     open_in_bin=Stdlib[80],
     open_in_gen=Stdlib[81],
     input_char=Stdlib[82],
     input_line=Stdlib[83],
     input=Stdlib[84],
     really_input=Stdlib[85],
     really_input_string=Stdlib[86],
     input_byte=Stdlib[87],
     input_binary_int=Stdlib[88],
     input_value=Stdlib[89],
     seek_in=Stdlib[90],
     pos_in=Stdlib[91],
     in_channel_length=Stdlib[92],
     close_in=Stdlib[93],
     close_in_noerr=Stdlib[94],
     set_binary_mode_in=Stdlib[95],
     LargeFile=Stdlib[96],
     string_of_format=Stdlib[97],
     exit=Stdlib[99],
     at_exit=Stdlib[100],
     valid_float_lexem=Stdlib[101],
     unsafe_really_input=Stdlib[102],
     do_at_exit=Stdlib[103],
     Result=[0],
     Ppx_deriving_runtime=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       Stdlib[28],
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       Stdlib[37],
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       LargeFile,
       string_of_format,
       Stdlib[98],
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Result];
    runtime.caml_register_global
     (1,Ppx_deriving_runtime,"Ppx_deriving_runtime");
    return}
  (function(){return this}()));


//# 1 "../.js/menhirLib/menhirLib.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_make_vect=runtime.caml_make_vect,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_new_string(""),
     cst_force_reduction_this_reduction_is_not_permitted_in_this_state=
      caml_new_string
       ("force_reduction: this reduction is not permitted in this state"),
     cst_resume_expects_HandlingError_Shifting_AboutToReduce=
      caml_new_string
       ("resume expects HandlingError | Shifting | AboutToReduce"),
     cst_offer_expects_InputNeeded=
      caml_new_string("offer expects InputNeeded"),
     cst_Current_LR_1_state=caml_new_string("Current LR(1) state: "),
     cst_some_initial_state=caml_new_string("<some initial state>"),
     arrow=caml_new_string(" -> "),
     dot=caml_new_string("."),
     space=caml_new_string(" "),
     newline=caml_new_string("\n"),
     cst_feed_outgoing_transition_does_not_exist=
      caml_new_string("feed: outgoing transition does not exist"),
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_lexing=global_data.Stdlib__lexing,
     Assert_failure=global_data.Assert_failure,
     Stdlib=global_data.Stdlib,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib_sys=global_data.Stdlib__sys,
     _a_=[0,caml_new_string("Engine.ml"),299,4],
     _b_=[0,caml_new_string("Engine.ml"),318,4],
     _d_=[0,caml_new_string("Engine.ml"),616,8],
     _e_=[0,caml_new_string("Engine.ml"),804,6],
     _c_=[0,caml_new_string("Engine.ml"),591,4],
     _i_=[0,caml_new_string("ErrorReports.ml"),61,6],
     _f_=[0,caml_new_string("ErrorReports.ml"),45,6],
     _g_=
      [0,
       [11,caml_new_string("before '"),[2,0,[12,39,0]]],
       caml_new_string("before '%s'")],
     _h_=
      [0,
       [11,
        caml_new_string("after '"),
        [2,0,[11,caml_new_string("' and before '"),[2,0,[12,39,0]]]]],
       caml_new_string("after '%s' and before '%s'")],
     _j_=[0,caml_new_string("InfiniteArray.ml"),39,2],
     _m_=[0,caml_new_string("PackedIntArray.ml"),195,6],
     _l_=[0,caml_new_string("PackedIntArray.ml"),77,4],
     _k_=[0,caml_new_string("PackedIntArray.ml"),126,4],
     _r_=[0,caml_new_string("RowDisplacement.ml"),245,2],
     _q_=[0,caml_new_string("RowDisplacement.ml"),247,2],
     _n_=[0,caml_new_string("RowDisplacement.ml"),163,10],
     _p_=[0,caml_new_string("RowDisplacement.ml"),82,2],
     _o_=[0,caml_new_string("RowDisplacement.ml"),85,6],
     _v_=[0,caml_new_string("LinearizedArray.ml"),66,2],
     _u_=[0,caml_new_string("LinearizedArray.ml"),62,2],
     _t_=[0,caml_new_string("LinearizedArray.ml"),58,2],
     _s_=[0,caml_new_string("LinearizedArray.ml"),33,2],
     _z_=[0,caml_new_string("InspectionTableInterpreter.ml"),185,4],
     _y_=[0,caml_new_string("InspectionTableInterpreter.ml"),104,4],
     _x_=[0,caml_new_string("InspectionTableInterpreter.ml"),98,4],
     _w_=[0,caml_new_string("InspectionTableInterpreter.ml"),79,4],
     _J_=
      [0,
       [11,
        caml_new_string("Handling error in state "),
        [4,0,0,0,[12,10,[10,0]]]],
       caml_new_string("Handling error in state %d\n%!")],
     _I_=
      [0,
       [11,caml_new_string("Resuming error handling\n"),[10,0]],
       caml_new_string("Resuming error handling\n%!")],
     _H_=
      [0,
       [11,caml_new_string("Initiating error handling\n"),[10,0]],
       caml_new_string("Initiating error handling\n%!")],
     _G_=
      [0,
       [11,
        caml_new_string("Lookahead token is now "),
        [2,
         0,
         [11,
          caml_new_string(" ("),
          [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(")\n"),[10,0]]]]]]]],
       caml_new_string("Lookahead token is now %s (%d-%d)\n%!")],
     _F_=[0,[2,0,[12,10,[10,0]]],caml_new_string("%s\n%!")],
     _E_=
      [0,
       [11,
        caml_new_string("Shifting ("),
        [2,0,[11,caml_new_string(") to state "),[4,0,0,0,[12,10,[10,0]]]]]],
       caml_new_string("Shifting (%s) to state %d\n%!")],
     _D_=
      [0,
       [11,
        caml_new_string("State "),
        [4,0,0,0,[11,caml_new_string(":\n"),[10,0]]]],
       caml_new_string("State %d:\n%!")],
     _C_=[0,caml_new_string("TableInterpreter.ml"),132,4],
     _B_=[0,caml_new_string("TableInterpreter.ml"),117,8],
     _A_=[0,caml_new_string("TableInterpreter.ml"),71,4];
    function take(n,input)
     {if(0 !== n)
       if(input)
        {var xs=input[2],x=input[1],xs$0=take(n - 1 | 0,xs);
         return xs === xs$0?input:[0,x,xs$0]}
      return 0}
    function drop(n,xs)
     {var n$0=n,xs$0=xs;
      for(;;)
       {if(0 === n$0)return xs$0;
        if(xs$0){var xs$1=xs$0[2],n$1=n$0 - 1 | 0,n$0=n$1,xs$0=xs$1;continue}
        return 0}}
    function uniq1(cmp,x,ys)
     {var cmp$0=cmp,ys$0=ys;
      for(;;)
       {if(ys$0)
         {var ys$1=ys$0[2],y=ys$0[1];
          if(0 === caml_call2(cmp$0,x,y))
           {var cmp$1=runtime.caml_compare,cmp$0=cmp$1,ys$0=ys$1;continue}
          return [0,y,uniq1(cmp$0,y,ys$1)]}
        return 0}}
    function uniq(cmp,xs)
     {if(xs){var xs$0=xs[2],x=xs[1];return [0,x,uniq1(cmp,x,xs$0)]}return 0}
    function weed(cmp,xs){return uniq(cmp,caml_call2(Stdlib_list[49],cmp,xs))}
    function length(xs)
     {var
       _bQ_=caml_obj_tag(xs),
       _bR_=
        250 === _bQ_?xs[1]:246 === _bQ_?caml_call1(CamlinternalLazy[2],xs):xs;
      if(_bR_){var xs$0=_bR_[2];return 1 + length(xs$0) | 0}
      return 0}
    function foldr(f,xs,accu)
     {var
       _bO_=caml_obj_tag(xs),
       _bP_=
        250 === _bO_?xs[1]:246 === _bO_?caml_call1(CamlinternalLazy[2],xs):xs;
      if(_bP_)
       {var xs$0=_bP_[2],x=_bP_[1];return caml_call2(f,x,foldr(f,xs$0,accu))}
      return accu}
    var MenhirLib_General=[0,take,drop,uniq,weed,length,foldr];
    caml_register_global(50,MenhirLib_General,"MenhirLib.General");
    function traditional2revised
     (get_raw_token,get_startp,get_endp,parser,lexer)
     {var lexbuf=caml_call2(Stdlib_lexing[3],0,cst);
      function lexer$0(lexbuf)
       {var token=caml_call1(lexer,0);
        lexbuf[11] = caml_call1(get_startp,token);
        lexbuf[12] = caml_call1(get_endp,token);
        return caml_call1(get_raw_token,token)}
      return caml_call2(parser,lexer$0,lexbuf)}
    function revised2traditional(make_token,parser,lexer,lexbuf)
     {function lexer$0(param)
       {var token=caml_call1(lexer,lexbuf);
        return caml_call3(make_token,token,lexbuf[11],lexbuf[12])}
      return caml_call1(parser,lexer$0)}
    function traditional2revised$0(parser)
     {function _bK_(param){var endp=param[3];return endp}
      function _bL_(param){var startp=param[2];return startp}
      function _bM_(param){var token=param[1];return token}
      return function(_bN_)
       {return traditional2revised(_bM_,_bL_,_bK_,parser,_bN_)}}
    function revised2traditional$0(parser)
     {function _bH_(token,startp,endp){return [0,token,startp,endp]}
      return function(_bI_,_bJ_)
       {return revised2traditional(_bH_,parser,_bI_,_bJ_)}}
    var
     Simplified=[0,traditional2revised$0,revised2traditional$0],
     MenhirLib_Convert=[0,traditional2revised,revised2traditional,Simplified];
    caml_register_global(52,MenhirLib_Convert,"MenhirLib.Convert");
    var MenhirLib_IncrementalEngine=[0];
    caml_register_global
     (53,MenhirLib_IncrementalEngine,"MenhirLib.IncrementalEngine");
    var MenhirLib_EngineTypes=[0];
    caml_register_global(54,MenhirLib_EngineTypes,"MenhirLib.EngineTypes");
    var
     MenhirLib_Engine=
      [0,
       function(T)
        {var
          number=T[1],
          production_index=T[7],
          find_production=T[8],
          Error=T[15],
          log=T[18],
          Log=T[19];
         function check_for_default_reduction(env)
          {return caml_call4
                   (T[9],env[4],announce_reduce,check_for_error_token,env)}
         function run(env,please_discard)
          {if(log)caml_call1(Log[1],env[4]);
           return please_discard?[0,env]:check_for_default_reduction(env)}
         function check_for_error_token(env)
          {if(env[1]){if(log)caml_call1(Log[6],0);return [3,env]}
           var
            match=env[2],
            token=match[1],
            _bF_=caml_call1(T[3],token),
            _bG_=caml_call1(T[2],token);
           return caml_call7
                   (T[10],env[4],_bG_,_bF_,shift,announce_reduce,initiate,env)}
         function shift(env,please_discard,terminal,value,s)
          {if(log)caml_call2(Log[2],terminal,s);
           var
            match=env[2],
            endp=match[3],
            startp=match[2],
            stack=[0,env[4],value,startp,endp,env[3]],
            new_env=[0,env[1],env[2],stack,s];
           return [1,env,new_env,please_discard]}
         function announce_reduce(env,prod)
          {if(caml_call1(T[14],prod))
            {if(log)caml_call1(Log[3],prod);var v=env[3][2];return [4,v]}
           return [2,env,prod]}
         function initiate(env)
          {if(log)caml_call1(Log[5],0);
           var env$0=[0,1,env[2],env[3],env[4]];
           return [3,env$0]}
         function reduce(env,prod)
          {if(log)caml_call1(Log[3],prod);
           try
            {var stack=caml_call2(T[16],prod,env)}
           catch(_bE_)
            {_bE_ = caml_wrap_exception(_bE_);
             if(_bE_ === Error)return initiate(env);
             throw _bE_}
           var
            current=caml_call2(T[12],stack[1],prod),
            env$0=[0,env[1],env[2],stack,current];
           return run(env$0,0)}
         function error_shift(env,please_discard,terminal,value,s)
          {if(caml_equal(terminal,T[4]))
            if(caml_equal(value,T[5]))
             {if(log)caml_call1(Log[7],env[4]);
              return shift(env,please_discard,terminal,value,s)}
           throw [0,Assert_failure,_b_]}
         function error_reduce(env,prod)
          {if(log)caml_call1(Log[7],env[4]);return reduce(env,prod)}
         function error_fail(env)
          {var cell=env[3],next=cell[5];
           if(next === cell)return 0;
           var env$0=[0,env[1],env[2],next,cell[1]];
           return [3,env$0]}
         function start(s,initial)
          {var empty=[];
           runtime.caml_update_dummy(empty,[0,s,T[5],initial,initial,empty]);
           var env=[0,0,[0,0,initial,initial],empty,s];
           return run(env,1)}
         function offer(param)
          {if(typeof param !== "number" && 0 === param[0])
            {var env=param[1];
             return function(triple)
              {if(log)
                {var
                  endp=triple[3],
                  startp=triple[2],
                  token=triple[1],
                  _bD_=caml_call1(T[2],token);
                 caml_call3(Log[4],_bD_,startp,endp)}
               var env$0=[0,0,triple,env[3],env[4]];
               return check_for_default_reduction(env$0)}}
           return caml_call1(Stdlib[1],cst_offer_expects_InputNeeded)}
         function resume(param)
          {if(typeof param !== "number")
            switch(param[0])
             {case 1:
               var please_discard=param[3],env=param[2];
               return run(env,please_discard);
              case 2:
               var prod=param[2],env$0=param[1];return reduce(env$0,prod);
              case 3:
               var env$1=param[1];
               if(env$1[1])
                return caml_call7
                        (T[10],
                         env$1[4],
                         T[4],
                         T[5],
                         error_shift,
                         error_reduce,
                         error_fail,
                         env$1);
               throw [0,Assert_failure,_a_]
              }
           return caml_call1
                   (Stdlib[1],
                    cst_resume_expects_HandlingError_Shifting_AboutToReduce)}
         function lexer_lexbuf_to_supplier(lexer,lexbuf,param)
          {var
            token=caml_call1(lexer,lexbuf),
            startp=lexbuf[11],
            endp=lexbuf[12];
           return [0,token,startp,endp]}
         function loop(read,checkpoint)
          {var checkpoint$0=checkpoint;
           for(;;)
            if(typeof checkpoint$0 === "number")
             throw Error;
            else
             switch(checkpoint$0[0])
              {case 0:
                var
                 triple=caml_call1(read,0),
                 checkpoint$1=caml_call1(offer(checkpoint$0),triple),
                 checkpoint$0=checkpoint$1;
                continue;
               case 4:var v=checkpoint$0[1];return v;
               default:
                var
                 checkpoint$2=resume(checkpoint$0),
                 checkpoint$0=checkpoint$2;
                continue}}
         function entry(s,lexer,lexbuf)
          {var initial=lexbuf[12],_bB_=start(s,initial);
           return loop
                   (function(_bC_)
                     {return lexer_lexbuf_to_supplier(lexer,lexbuf,_bC_)},
                    _bB_)}
         function loop_handle(succeed,fail,read,checkpoint)
          {var checkpoint$0=checkpoint;
           for(;;)
            {if(typeof checkpoint$0 !== "number")
              switch(checkpoint$0[0])
               {case 0:
                 var
                  triple=caml_call1(read,0),
                  checkpoint$1=caml_call1(offer(checkpoint$0),triple),
                  checkpoint$0=checkpoint$1;
                 continue;
                case 4:var v=checkpoint$0[1];return caml_call1(succeed,v);
                case 3:break;
                default:
                 var
                  checkpoint$2=resume(checkpoint$0),
                  checkpoint$0=checkpoint$2;
                 continue}
             return caml_call1(fail,checkpoint$0)}}
         function loop_handle_undo(succeed,fail,read,checkpoint$2)
          {if(typeof checkpoint$2 === "number")
            var switch$0=0;
           else
            if(0 === checkpoint$2[0])
             var _bA_=1,switch$0=1;
            else
             var switch$0=0;
           if(! switch$0)var _bA_=0;
           if(_bA_)
            {var param$2=[0,checkpoint$2,checkpoint$2],param=param$2;
             for(;;)
              {var checkpoint=param[2],inputneeded=param[1];
               if(typeof checkpoint !== "number")
                switch(checkpoint[0])
                 {case 0:
                   var
                    triple=caml_call1(read,0),
                    checkpoint$0=caml_call1(offer(checkpoint),triple),
                    param$0=[0,checkpoint,checkpoint$0],
                    param=param$0;
                   continue;
                  case 4:var v=checkpoint[1];return caml_call1(succeed,v);
                  case 3:break;
                  default:
                   var
                    checkpoint$1=resume(checkpoint),
                    param$1=[0,inputneeded,checkpoint$1],
                    param=param$1;
                   continue}
               return caml_call2(fail,inputneeded,checkpoint)}}
           throw [0,Assert_failure,_c_]}
         function shifts(checkpoint)
          {var checkpoint$0=checkpoint;
           for(;;)
            {if(typeof checkpoint$0 !== "number")
              switch(checkpoint$0[0])
               {case 1:var env=checkpoint$0[1];return [0,env];
                case 2:
                 var
                  checkpoint$1=resume(checkpoint$0),
                  checkpoint$0=checkpoint$1;
                 continue;
                case 3:return 0
                }
             throw [0,Assert_failure,_d_]}}
         function acceptable(checkpoint,token,pos)
          {var
            triple=[0,token,pos,pos],
            checkpoint$0=caml_call1(offer(checkpoint),triple),
            match=shifts(checkpoint$0);
           return match?1:0}
         function _bt_(cell,current)
          {return [246,
                   function(param)
                    {var next=cell[5];
                     if(next === cell)return 0;
                     var element=[0,current,cell[2],cell[3],cell[4]];
                     return [0,element,_bt_(next,cell[1])]}]}
         function stack(env){return _bt_(env[3],env[4])}
         function top(env)
          {var cell=env[3],next=cell[5];
           return next === cell?0:[0,[0,env[4],cell[2],cell[3],cell[4]]]}
         function equal(env1,env2)
          {var _bx_=env1[3] === env2[3]?1:0;
           if(_bx_)
            var
             _by_=caml_call1(number,env2[4]),
             _bz_=caml_call1(number,env1[4]) === _by_?1:0;
           else
            var _bz_=_bx_;
           return _bz_}
         function current_state_number(env){return caml_call1(number,env[4])}
         function positions(param)
          {var match=param[2],endp=match[3],startp=match[2];
           return [0,startp,endp]}
         function state_has_default_reduction(state)
          {var _bu_=0;
           function _bv_(env){return 0}
           function _bw_(env,prod){return 1}
           return caml_call4(T[9],state,_bw_,_bv_,_bu_)}
         function env_has_default_reduction(env)
          {return state_has_default_reduction(env[4])}
         function pop(env)
          {var cell=env[3],next=cell[5];
           return next === cell?0:[0,[0,env[1],env[2],next,cell[1]]]}
         function force_reduction(prod,env)
          {if(caml_call2(T[17],env[4],prod))
            {if(caml_call1(T[14],prod))throw [0,Assert_failure,_e_];
             var
              stack=caml_call2(T[16],prod,env),
              current=caml_call2(T[12],stack[1],prod);
             return [0,env[1],env[2],stack,current]}
           return caml_call1
                   (Stdlib[1],
                    cst_force_reduction_this_reduction_is_not_permitted_in_this_state)}
         function input_needed(env){return [0,env]}
         function pop_many(i,env)
          {var i$0=i,env$0=env;
           for(;;)
            {if(0 === i$0)return [0,env$0];
             var match=pop(env$0);
             if(match)
              {var env$1=match[1],i$1=i$0 - 1 | 0,i$0=i$1,env$0=env$1;
               continue}
             return 0}}
         function get(i,env)
          {var match=pop_many(i,env);
           if(match){var env$0=match[1];return top(env$0)}
           return 0}
         return [0,
                 Error,
                 entry,
                 offer,
                 resume,
                 lexer_lexbuf_to_supplier,
                 loop,
                 loop_handle,
                 loop_handle_undo,
                 shifts,
                 acceptable,
                 number,
                 production_index,
                 find_production,
                 stack,
                 top,
                 pop_many,
                 get,
                 current_state_number,
                 equal,
                 positions,
                 env_has_default_reduction,
                 state_has_default_reduction,
                 pop,
                 force_reduction,
                 input_needed,
                 start]}];
    caml_register_global(57,MenhirLib_Engine,"MenhirLib.Engine");
    function show(f,buffer)
     {var _bp_=buffer[1];
      if(typeof _bp_ === "number")
       throw [0,Assert_failure,_f_];
      else
       {if(0 === _bp_[0])
         {var invalid=_bp_[1],_bq_=caml_call1(f,invalid);
          return caml_call2(Stdlib_printf[4],_g_,_bq_)}
        var
         invalid$0=_bp_[2],
         valid=_bp_[1],
         _br_=caml_call1(f,invalid$0),
         _bs_=caml_call1(f,valid);
        return caml_call3(Stdlib_printf[4],_h_,_bs_,_br_)}}
    function last(buffer)
     {var _bo_=buffer[1];
      if(typeof _bo_ === "number")
       throw [0,Assert_failure,_i_];
      else
       var invalid=0 === _bo_[0]?_bo_[1]:_bo_[2];
      return invalid}
    function wrap(lexer)
     {var buffer=[0,0];
      return [0,
              buffer,
              function(lexbuf)
               {var
                 token=caml_call1(lexer,lexbuf),
                 x=[0,lexbuf[11],lexbuf[12]],
                 _bm_=buffer[1];
                if(typeof _bm_ === "number")
                 var _bn_=[0,x],switch$0=1;
                else
                 if(0 === _bm_[0])
                  var x1=_bm_[1],switch$0=0;
                 else
                  var x1=_bm_[2],switch$0=0;
                if(! switch$0)var _bn_=[1,x1,x];
                buffer[1] = _bn_;
                return token}]}
    var MenhirLib_ErrorReports=[0,wrap,show,last];
    caml_register_global(59,MenhirLib_ErrorReports,"MenhirLib.ErrorReports");
    var
     MenhirLib_Printers=
      [0,
       function(I,User)
        {function print_symbols(i,symbols)
          {var i$0=i,symbols$0=symbols;
           for(;;)
            {if(0 === i$0)
              {caml_call1(User[1],dot);
               caml_call1(User[1],space);
               var i$0=-1;
               continue}
             if(symbols$0)
              {var symbols$1=symbols$0[2],symbol=symbols$0[1];
               caml_call1(User[2],symbol);
               caml_call1(User[1],space);
               var i$1=i$0 - 1 | 0,i$0=i$1,symbols$0=symbols$1;
               continue}
             return 0}}
         function print_element_as_symbol(element)
          {var s=element[1],_bl_=[0,caml_call1(I[29],s)];
           return caml_call1(User[2],_bl_)}
         var _bf_=User[3];
         if(_bf_)
          var print_element=_bf_[1],print_element$0=print_element;
         else
          var print_element$0=print_element_as_symbol;
         function _bg_(env)
          {var match=caml_call1(I[13],env),match$0=caml_call1(I[21],env);
           if(match)
            if(match$0)
             {var env$0=match$0[1],element=match[1];
              _bg_(env$0);
              caml_call1(User[1],space);
              return caml_call1(print_element$0,element)}
           return 0}
         function print_stack(env)
          {_bg_(env);return caml_call1(User[1],newline)}
         function print_item(param)
          {var i=param[2],prod=param[1],_bk_=caml_call1(I[31],prod);
           caml_call1(User[2],_bk_);
           caml_call1(User[1],arrow);
           print_symbols(i,caml_call1(I[32],prod));
           return caml_call1(User[1],newline)}
         function print_symbols$0(symbols){return print_symbols(-1,symbols)}
         function print_production(prod){return print_item([0,prod,-1])}
         function print_current_state(env)
          {caml_call1(User[1],cst_Current_LR_1_state);
           var match=caml_call1(I[13],env);
           if(match)
            {var
              match$0=match[1],
              current=match$0[1],
              _bh_=caml_call1(I[9],current),
              _bi_=caml_call1(Stdlib[33],_bh_);
             caml_call1(User[1],_bi_);
             caml_call1(User[1],newline);
             var _bj_=caml_call1(I[30],current);
             return caml_call2(Stdlib_list[15],print_item,_bj_)}
           caml_call1(User[1],cst_some_initial_state);
           return caml_call1(User[1],newline)}
         function print_env(env)
          {print_stack(env);
           print_current_state(env);
           return caml_call1(User[1],newline)}
         return [0,
                 print_symbols$0,
                 print_element_as_symbol,
                 print_stack,
                 print_item,
                 print_production,
                 print_current_state,
                 print_env]}];
    caml_register_global(60,MenhirLib_Printers,"MenhirLib.Printers");
    function make(x){return [0,x,caml_make_vect(16384,x),0]}
    function ensure(a,i)
     {if(0 <= i)
       {var table=a[2],length$1=table.length - 1,_bc_=length$1 <= i?1:0;
        if(_bc_)
         {var length$2=2 * length$1 | 0,length=length$2,_bd_=a[1];
          for(;;)
           {if(! (i < length))
             {var length$0=2 * length | 0,length=length$0;continue}
            var table$0=caml_make_vect(length,_bd_);
            caml_call5(Stdlib_array[10],table,0,table$0,0,length$1);
            a[2] = table$0;
            var _be_=0;
            break}}
        else
         var _be_=_bc_;
        return _be_}
      throw [0,Assert_failure,_j_]}
    function get(a,i){ensure(a,i);return a[2][i + 1]}
    function set(a,i,x)
     {ensure(a,i);
      a[2][i + 1] = x;
      var _ba_=a[3] <= i?1:0,_bb_=_ba_?(a[3] = i + 1 | 0,0):_ba_;
      return _bb_}
    function extent(a){return a[3]}
    function domain(a){return caml_call3(Stdlib_array[7],a[2],0,a[3])}
    var MenhirLib_InfiniteArray=[0,make,get,set,extent,domain];
    caml_register_global(62,MenhirLib_InfiniteArray,"MenhirLib.InfiniteArray");
    function pack(a)
     {var m=a.length - 1,_aY_=1;
      function _aZ_(k$1,v)
       {if(0 <= v)
         {var k=1,max=2;
          for(;;)
           {if(0 < max)
             if(! (v < max))
              {var max$0=caml_mul(max,max),k$0=2 * k | 0,k=k$0,max=max$0;
               continue}
            var _a$_=k;
            break}}
        else
         var _a$_=Stdlib_sys[10];
        return caml_call2(Stdlib[17],k$1,_a$_)}
      var k=caml_call3(Stdlib_array[17],_aZ_,_aY_,a);
      if(8 < k)
       {if(0 === (k % 8 | 0))
         {var
           w=k / 8 | 0,
           n=caml_mul(m,w),
           s=caml_create_bytes(n),
           _a1_=m - 1 | 0,
           _a0_=0;
          if(! (_a1_ < 0))
           {var i=_a0_;
            for(;;)
             {var v=[0,caml_check_bound(a,i)[i + 1]],_a2_=1;
              if(! (w < 1))
               {var x=_a2_;
                for(;;)
                 {caml_bytes_set
                   (s,
                    caml_mul(i + 1 | 0,w) - x | 0,
                    caml_call1(Stdlib_char[1],v[1] & 255));
                  v[1] = v[1] >>> 8 | 0;
                  var _a4_=x + 1 | 0;
                  if(w !== x){var x=_a4_;continue}
                  break}}
              var _a3_=i + 1 | 0;
              if(_a1_ !== i){var i=_a3_;continue}
              break}}
          return [0,k,caml_call1(Stdlib_bytes[42],s)]}
        throw [0,Assert_failure,_k_]}
      if(0 === caml_mod(8,k))
       {var
         w$0=caml_div(8,k),
         n$0=0 === caml_mod(m,w$0)?caml_div(m,w$0):caml_div(m,w$0) + 1 | 0,
         s$0=caml_create_bytes(n$0),
         i$0=[0,0],
         _a6_=n$0 - 1 | 0,
         _a5_=0;
        if(! (_a6_ < 0))
         {var j=_a5_;
          for(;;)
           {var c=[0,0],_a7_=1;
            if(! (w$0 < 1))
             {var x$0=_a7_;
              for(;;)
               {var ii=i$0[1];
                if(ii === m)
                 var _a9_=0;
                else
                 {var v$0=caml_check_bound(a,ii)[ii + 1];
                  i$0[1] = ii + 1 | 0;
                  var _a9_=v$0}
                c[1] = c[1] << k | _a9_;
                var _a__=x$0 + 1 | 0;
                if(w$0 !== x$0){var x$0=_a__;continue}
                break}}
            caml_bytes_set(s$0,j,caml_call1(Stdlib_char[1],c[1]));
            var _a8_=j + 1 | 0;
            if(_a6_ !== j){var j=_a8_;continue}
            break}}
        return [0,k,caml_call1(Stdlib_bytes[42],s$0)]}
      throw [0,Assert_failure,_l_]}
    function get1(s,i)
     {var
       c=caml_string_unsafe_get(s,i >>> 3 | 0),
       c$0=c >>> (caml_call1(Stdlib[21],i) & 7) | 0,
       c$1=c$0 & 1;
      return c$1}
    function get$0(param,i)
     {var s=param[2],k=param[1],switcher=k - 1 | 0;
      if(! (15 < switcher >>> 0))
       switch(switcher)
        {case 0:return get1(s,i);
         case 1:
          var
           c=caml_string_unsafe_get(s,i >>> 2 | 0),
           c$0=c >>> (2 * (caml_call1(Stdlib[21],i) & 3) | 0) | 0,
           c$1=c$0 & 3;
          return c$1;
         case 3:
          var
           c$2=caml_string_unsafe_get(s,i >>> 1 | 0),
           c$3=c$2 >>> (4 * (caml_call1(Stdlib[21],i) & 1) | 0) | 0,
           c$4=c$3 & 15;
          return c$4;
         case 7:return caml_string_unsafe_get(s,i);
         case 15:
          var j$0=2 * i | 0;
          return (caml_string_unsafe_get(s,j$0) << 8)
                 +
                 caml_string_unsafe_get(s,j$0 + 1 | 0)
                 |
                 0
         }
      if(32 === k)
       {var j=4 * i | 0;
        return (((((caml_string_unsafe_get(s,j) << 8)
                   +
                   caml_string_unsafe_get(s,j + 1 | 0)
                   |
                   0)
                  <<
                  8)
                 +
                 caml_string_unsafe_get(s,j + 2 | 0)
                 |
                 0)
                <<
                8)
               +
               caml_string_unsafe_get(s,j + 3 | 0)
               |
               0}
      throw [0,Assert_failure,_m_]}
    function unflatten1(param,i,j)
     {var data=param[2],n=param[1];return get1(data,caml_mul(n,i) + j | 0)}
    var MenhirLib_PackedIntArray=[0,pack,get$0,get1,unflatten1];
    caml_register_global
     (66,MenhirLib_PackedIntArray,"MenhirLib.PackedIntArray");
    function decode(displacement)
     {return 0 === (displacement & 1)
              ?displacement >>> 1 | 0
              :- (displacement >>> 1 | 0) | 0}
    function compress(equal,insignificant,dummy,m,n,t)
     {if(t.length - 1 === m)
       {var _aR_=m - 1 | 0,_aQ_=0;
        if(! (_aR_ < 0))
         {var i=_aQ_;
          for(;;)
           {if(caml_check_bound(t,i)[i + 1].length - 1 !== n)
             throw [0,Assert_failure,_o_];
            var _aU_=i + 1 | 0;
            if(_aR_ !== i){var i=_aU_;continue}
            break}}
        var
         sparse=
          function(i,line)
           {var j$2=n - 1 | 0,j=j$2,rank=0,row=0;
            for(;;)
             {if(0 <= j)
               {var x=caml_check_bound(line,j)[j + 1];
                if(caml_call1(insignificant,x))
                 {var j$0=j - 1 | 0,j=j$0;continue}
                var
                 row$0=[0,[0,j,x],row],
                 rank$0=1 + rank | 0,
                 j$1=j - 1 | 0,
                 j=j$1,
                 rank=rank$0,
                 row=row$0;
                continue}
              return [0,i,rank,row]}},
         rows=caml_call2(Stdlib_array[16],sparse,t),
         _aS_=
          function(param,_aX_)
           {var rank2=_aX_[2],rank1=param[2];
            return runtime.caml_int_compare(rank2,rank1)};
        caml_call2(Stdlib_array[27],_aS_,rows);
        var
         displacement=caml_make_vect(m,0),
         data=caml_call1(MenhirLib_InfiniteArray[1],dummy),
         _aT_=
          function(param$1)
           {var row$1=param$1[3],i=param$1[1];
            if(row$1)
             {var match$0=row$1[1],j$0=match$0[1],k$1=- j$0 | 0,k=k$1;
              a:
              for(;;)
               {var d=caml_call1(MenhirLib_InfiniteArray[4],data),param=row$1;
                for(;;)
                 {if(param)
                   {var row=param[2],match=param[1],x=match[2],j=match[1];
                    if(! (0 <= (k + j | 0)))throw [0,Assert_failure,_n_];
                    if(d <= (k + j | 0))
                     var _aV_=1;
                    else
                     {var
                       y=
                        caml_call2(MenhirLib_InfiniteArray[2],data,k + j | 0);
                      if(caml_call1(insignificant,y))
                       var switch$0=0;
                      else
                       if(caml_call2(equal,x,y))
                        var switch$0=0;
                       else
                        var _aV_=0,switch$0=1;
                      if(! switch$0){var param=row;continue}}}
                  else
                   var _aV_=1;
                  if(! _aV_){var k$0=k + 1 | 0,k=k$0;continue a}
                  var k$2=k;
                  break}
                break}}
            else
             var k$2=0;
            var param$0=row$1;
            for(;;)
             {if(param$0)
               {var
                 row$0=param$0[2],
                 match$1=param$0[1],
                 x$0=match$1[2],
                 j$1=match$1[1];
                caml_call3(MenhirLib_InfiniteArray[3],data,k$2 + j$1 | 0,x$0);
                var param$0=row$0;
                continue}
              var _aW_=0 <= k$2?k$2 << 1:((- k$2 | 0) << 1) + 1 | 0;
              return caml_check_bound(displacement,i)[i + 1] = _aW_}};
        caml_call2(Stdlib_array[13],_aT_,rows);
        return [0,displacement,caml_call1(MenhirLib_InfiniteArray[5],data)]}
      throw [0,Assert_failure,_p_]}
    function get$1(param,i,j)
     {var data=param[2],displacement=param[1];
      if(0 <= i)
       if(i < displacement.length - 1)
        {var k=decode(caml_check_bound(displacement,i)[i + 1]);
         if(0 <= (k + j | 0))
          if((k + j | 0) < data.length - 1)
           {var _aP_=k + j | 0;return caml_check_bound(data,_aP_)[_aP_ + 1]}
         throw [0,Assert_failure,_q_]}
      throw [0,Assert_failure,_r_]}
    function getget(get_displacement,get_data,param,i,j)
     {var
       data=param[2],
       displacement=param[1],
       k=decode(caml_call2(get_displacement,displacement,i));
      return caml_call2(get_data,data,k + j | 0)}
    var MenhirLib_RowDisplacement=[0,compress,get$1,getget];
    caml_register_global
     (67,MenhirLib_RowDisplacement,"MenhirLib.RowDisplacement");
    function make$0(a)
     {var n=a.length - 1,size=[0,0];
      function _aI_(i)
       {var s=size[1];
        if(i < n)size[1] = s + (caml_check_bound(a,i)[i + 1].length - 1) | 0;
        return s}
      var entry=caml_call2(Stdlib_array[2],n + 1 | 0,_aI_),_aJ_=size[1];
      if(caml_check_bound(entry,n)[n + 1] === _aJ_)
       {var
         i=[0,0],
         j=[0,0],
         _aK_=
          function(param)
           {for(;;)
             {var
               _aL_=i[1],
               _aM_=caml_check_bound(a,_aL_)[_aL_ + 1].length - 1;
              if(j[1] === _aM_){i[1] = i[1] + 1 | 0;j[1] = 0;continue}
              var
               _aN_=j[1],
               _aO_=i[1],
               x=
                caml_check_bound(caml_check_bound(a,_aO_)[_aO_ + 1],_aN_)
                 [_aN_ + 1];
              j[1] = j[1] + 1 | 0;
              return x}},
         data=caml_call2(Stdlib_array[2],size[1],_aK_);
        return [0,data,entry]}
      throw [0,Assert_failure,_s_]}
    function length$0(param){var entry=param[2];return entry.length - 1}
    function row_length(param,i)
     {var entry=param[2],_aH_=i + 1 | 0,_aG_=caml_check_bound(entry,i)[i + 1];
      return caml_check_bound(entry,_aH_)[_aH_ + 1] - _aG_ | 0}
    function row_length_via(get_entry,i)
     {var _aF_=caml_call1(get_entry,i);
      return caml_call1(get_entry,i + 1 | 0) - _aF_ | 0}
    function read(la,i,j)
     {var entry=la[2],data=la[1];
      if(0 <= j)
       if(j < row_length(la,i))
        {var _aE_=caml_check_bound(entry,i)[i + 1] + j | 0;
         return caml_check_bound(data,_aE_)[_aE_ + 1]}
      throw [0,Assert_failure,_t_]}
    function read_via(get_data,get_entry,i,j)
     {if(0 <= j)
       if(j < row_length_via(get_entry,i))
        return caml_call1(get_data,caml_call1(get_entry,i) + j | 0);
      throw [0,Assert_failure,_u_]}
    function write(la,i,j,v)
     {var entry=la[2],data=la[1];
      if(0 <= j)
       if(j < row_length(la,i))
        {var _aD_=caml_check_bound(entry,i)[i + 1] + j | 0;
         return caml_check_bound(data,_aD_)[_aD_ + 1] = v}
      throw [0,Assert_failure,_v_]}
    function read_interval_via(get_data,i,j)
     {if(i === j)return 0;
      var _aC_=read_interval_via(get_data,i + 1 | 0,j);
      return [0,caml_call1(get_data,i),_aC_]}
    function read_row_via(get_data,get_entry,i)
     {var _aB_=caml_call1(get_entry,i + 1 | 0);
      return read_interval_via(get_data,caml_call1(get_entry,i),_aB_)}
    function read_row(param,i)
     {var entry=param[2],data=param[1];
      function _ay_(_aA_){return caml_check_bound(entry,_aA_)[_aA_ + 1]}
      return read_row_via
              (function(_az_){return caml_check_bound(data,_az_)[_az_ + 1]},
               _ay_,
               i)}
    var
     MenhirLib_LinearizedArray=
      [0,
       make$0,
       read,
       write,
       length$0,
       row_length,
       read_row,
       row_length_via,
       read_via,
       read_row_via];
    caml_register_global
     (68,MenhirLib_LinearizedArray,"MenhirLib.LinearizedArray");
    var MenhirLib_TableFormat=[0];
    caml_register_global(69,MenhirLib_TableFormat,"MenhirLib.TableFormat");
    var MenhirLib_InspectionTableFormat=[0];
    caml_register_global
     (70,MenhirLib_InspectionTableFormat,"MenhirLib.InspectionTableFormat");
    function Symbols(T){return [0]}
    var
     MenhirLib_InspectionTableInterpreter=
      [0,
       Symbols,
       function(TT,IT,ET,_af_)
        {function read_packed_linearized(param,i)
          {var
            entry=param[2],
            data=param[1],
            _aw_=caml_call1(MenhirLib_PackedIntArray[2],entry),
            _ax_=caml_call1(MenhirLib_PackedIntArray[2],data);
           return caml_call3(MenhirLib_LinearizedArray[9],_ax_,_aw_,i)}
         function decode_symbol(symbol)
          {if(0 < symbol)
            {var kind=symbol & 1,symbol$0=symbol >>> 1 | 0;
             return 0 === kind
                     ?caml_call1(IT[1],symbol$0 - 1 | 0)
                     :caml_call1(IT[2],symbol$0)}
           throw [0,Assert_failure,_w_]}
         function n2i(nt)
          {var answer=TT[9] + nt | 0;
           if(caml_equal(caml_call1(IT[2],answer),[0,[1,nt]]))return answer;
           throw [0,Assert_failure,_x_]}
         function t2i(answer)
          {if(caml_equal(caml_call1(IT[1],answer),[0,[0,answer]]))
            return answer;
           throw [0,Assert_failure,_y_]}
         function compare_terminals(t1,t2)
          {var _av_=t2i(t2);return t2i(t1) - _av_ | 0}
         function compare_nonterminals(nt1,nt2)
          {var _au_=n2i(nt2);return n2i(nt1) - _au_ | 0}
         function compare_symbols(symbol1,symbol2)
          {var _ap_=symbol1[1];
           if(0 === _ap_[0])
            {var _aq_=symbol2[1],_ar_=_ap_[1];
             if(0 === _aq_[0])
              {var t2=_aq_[1];return compare_terminals(_ar_,t2)}
             return -1}
           var _as_=symbol2[1],_at_=_ap_[1];
           if(0 === _as_[0])return 1;
           var nt2=_as_[1];
           return compare_nonterminals(_at_,nt2)}
         function compare_productions(prod1,prod2){return prod1 - prod2 | 0}
         function compare_items(param,_ao_)
          {var
            index2=_ao_[2],
            prod2=_ao_[1],
            index1=param[2],
            prod1=param[1],
            c=prod1 - prod2 | 0;
           return 0 === c?index1 - index2 | 0:c}
         function incoming_symbol(s)
          {var
            core=caml_call2(MenhirLib_PackedIntArray[2],IT[4],s),
            symbol=
             decode_symbol(caml_call2(MenhirLib_PackedIntArray[2],IT[6],core)),
            symbol$0=symbol[1];
           return symbol$0}
         function lhs(prod)
          {var _an_=caml_call2(MenhirLib_PackedIntArray[2],TT[7],prod);
           return caml_call1(IT[2],_an_)}
         function rhs(prod)
          {var _am_=read_packed_linearized(IT[3],prod);
           return caml_call2(Stdlib_list[17],decode_symbol,_am_)}
         function export$0(t){return [0,t >>> 7 | 0,t % 128 | 0]}
         function items(s)
          {var
            core=caml_call2(MenhirLib_PackedIntArray[2],IT[4],s),
            _al_=read_packed_linearized(IT[5],core);
           return caml_call2(Stdlib_list[17],export$0,_al_)}
         function decode_bool(i)
          {if(0 !== i)if(1 !== i)throw [0,Assert_failure,_z_];
           return 1 === i?1:0}
         function nullable(nt)
          {var _ak_=n2i(nt);
           return decode_bool
                   (caml_call2(MenhirLib_PackedIntArray[3],IT[7],_ak_))}
         function first(nt,t)
          {var _ai_=t2i(t),_aj_=n2i(nt);
           return decode_bool
                   (caml_call3(MenhirLib_PackedIntArray[4],IT[8],_aj_,_ai_))}
         function xfirst(symbol,t)
          {var _ah_=symbol[1];
           if(0 === _ah_[0])
            {var t$0=_ah_[1];return 0 === compare_terminals(t,t$0)?1:0}
           var nt=_ah_[1];
           return first(nt,t)}
         function foldij(i,j,f,accu)
          {var i$0=i,accu$0=accu;
           for(;;)
            {if(i$0 === j)return accu$0;
             var
              accu$1=caml_call2(f,i$0,accu$0),
              i$1=i$0 + 1 | 0,
              i$0=i$1,
              accu$0=accu$1;
             continue}}
         function foreach_terminal(f,accu)
          {var match=TT[5],n=match[1];
           return foldij
                   (0,
                    n,
                    function(i,accu)
                     {return caml_call2(f,caml_call1(IT[1],i),accu)},
                    accu)}
         function foreach_terminal_but_error(f,accu)
          {var match=TT[5],n=match[1];
           return foldij
                   (0,
                    n,
                    function(i,accu)
                     {return i === TT[2]
                              ?accu
                              :caml_call2(f,caml_call1(IT[1],i),accu)},
                    accu)}
         function feed_failure(param)
          {return caml_call1
                   (Stdlib[1],cst_feed_outgoing_transition_does_not_exist)}
         function reduce(env,prod){return feed_failure(0)}
         function initiate(env){return feed_failure(0)}
         function feed(symbol,startp,semv,endp,env)
          {if(0 === symbol[0])
            {var
              terminal=symbol[1],
              terminal$0=t2i(terminal),
              source$0=env[4],
              _ag_=
               function(env,please_discard,terminal,semv,target)
                {var stack=[0,source$0,semv,startp,endp,env[3]];
                 return [0,env[1],env[2],stack,target]};
             return caml_call7
                     (ET[10],source$0,terminal$0,semv,_ag_,reduce,initiate,env)}
           var
            nt=symbol[1],
            nt$0=n2i(nt),
            source=env[4],
            match=caml_call2(ET[13],source,nt$0);
           if(match)
            {var target=match[1],stack=[0,source,semv,startp,endp,env[3]];
             return [0,env[1],env[2],stack,target]}
           return feed_failure(0)}
         return [0,
                 compare_terminals,
                 compare_nonterminals,
                 compare_symbols,
                 compare_productions,
                 compare_items,
                 incoming_symbol,
                 items,
                 lhs,
                 rhs,
                 nullable,
                 first,
                 xfirst,
                 foreach_terminal,
                 foreach_terminal_but_error,
                 feed]}];
    caml_register_global
     (71,
      MenhirLib_InspectionTableInterpreter,
      "MenhirLib.InspectionTableInterpreter");
    var
     MenhirLib_TableInterpreter=
      [0,
       function(T)
        {function number(s){return s}
         var _K_=T[1],_L_=T[3],_M_=T[2],error_value=0;
         function foreach_terminal(f,accu$0)
          {var match=T[5],n=match[1],i=0,accu=accu$0;
           for(;;)
            {if(i === n)return accu;
             var accu$1=caml_call2(f,i,accu),i$0=i + 1 | 0,i=i$0,accu=accu$1;
             continue}}
         function non_start_production(i)
          {if(T[9] <= i)if((i - T[9] | 0) < T[10].length - 1)return 0;
           throw [0,Assert_failure,_A_]}
         function production_index(i){non_start_production(i);return i}
         function find_production(i){non_start_production(i);return i}
         function default_reduction(state,defred,nodefred,env)
          {var code=caml_call2(MenhirLib_PackedIntArray[2],T[4],state);
           return 0 === code
                   ?caml_call1(nodefred,env)
                   :caml_call2(defred,env,code - 1 | 0)}
         function is_start(prod){return prod < T[9]?1:0}
         function unmarshal2(table,i,j)
          {return caml_call5
                   (MenhirLib_RowDisplacement[3],
                    MenhirLib_PackedIntArray[2],
                    MenhirLib_PackedIntArray[2],
                    table,
                    i,
                    j)}
         function action(state,terminal,value,shift,reduce,fail,env)
          {var c=caml_call3(MenhirLib_PackedIntArray[4],T[5],state,terminal);
           if(1 === c)
            {var
              action=unmarshal2(T[6],state,terminal),
              opcode=action & 3,
              param=action >>> 2 | 0;
             if(2 <= opcode)
              {var please_discard=2 === opcode?1:0;
               return caml_call5
                       (shift,env,please_discard,terminal,value,param)}
             return caml_call2(reduce,env,param)}
           if(0 === c)return caml_call1(fail,env);
           throw [0,Assert_failure,_B_]}
         function goto_nt(state,nt)
          {var code=unmarshal2(T[8],state,nt);return code - 1 | 0}
         function goto_prod(state,prod)
          {return goto_nt
                   (state,caml_call2(MenhirLib_PackedIntArray[2],T[7],prod))}
         function maybe_goto_nt(state,nt)
          {var code=unmarshal2(T[8],state,nt);
           if(0 <= code)return 0 === code?0:[0,code - 1 | 0];
           throw [0,Assert_failure,_C_]}
         var _N_=T[11];
         function semantic_action(prod)
          {var _ae_=prod - T[9] | 0;
           return caml_check_bound(T[10],_ae_)[_ae_ + 1]}
         function may_reduce(state,prod)
          {var _W_=0;
           function _X_(param)
            {var _Y_=0;
             return foreach_terminal
                     (function(t,accu)
                       {if(accu)return accu;
                        var _Z_=0;
                        function ___(param){return 0}
                        function _$_(param,prod$0){return prod === prod$0?1:0}
                        return action
                                (state,
                                 t,
                                 0,
                                 function(param,_ad_,_ac_,_ab_,_aa_){return 0},
                                 _$_,
                                 ___,
                                 _Z_)},
                      _Y_)}
           return default_reduction
                   (state,
                    function(param,prod$0){return prod === prod$0?1:0},
                    _X_,
                    _W_)}
         var log=T[12]?1:0;
         function state(state)
          {return T[12]?caml_call3(Stdlib_printf[1],Stdlib[40],_D_,state):0}
         function shift(terminal,state)
          {var _U_=T[12];
           if(_U_)
            {var
              match=_U_[1],
              terminals=match[1],
              _V_=caml_check_bound(terminals,terminal)[terminal + 1];
             return caml_call4(Stdlib_printf[1],Stdlib[40],_E_,_V_,state)}
           return 0}
         function reduce_or_accept(prod)
          {var _S_=T[12];
           if(_S_)
            {var
              match=_S_[1],
              productions=match[2],
              _T_=caml_check_bound(productions,prod)[prod + 1];
             return caml_call3(Stdlib_printf[1],Stdlib[40],_F_,_T_)}
           return 0}
         function lookahead_token(token,startp,endp)
          {var _O_=T[12];
           if(_O_)
            {var
              match=_O_[1],
              terminals=match[1],
              _P_=endp[4],
              _Q_=startp[4],
              _R_=caml_check_bound(terminals,token)[token + 1];
             return caml_call5(Stdlib_printf[1],Stdlib[40],_G_,_R_,_Q_,_P_)}
           return 0}
         function initiating_error_handling(param)
          {return T[12]?caml_call2(Stdlib_printf[1],Stdlib[40],_H_):0}
         function resuming_error_handling(param)
          {return T[12]?caml_call2(Stdlib_printf[1],Stdlib[40],_I_):0}
         function handling_error(state)
          {return T[12]?caml_call3(Stdlib_printf[1],Stdlib[40],_J_,state):0}
         var
          Log=
           [0,
            state,
            shift,
            reduce_or_accept,
            lookahead_token,
            initiating_error_handling,
            resuming_error_handling,
            handling_error];
         return [0,
                 number,
                 _K_,
                 _L_,
                 _M_,
                 error_value,
                 foreach_terminal,
                 production_index,
                 find_production,
                 default_reduction,
                 action,
                 goto_nt,
                 goto_prod,
                 maybe_goto_nt,
                 is_start,
                 _N_,
                 semantic_action,
                 may_reduce,
                 log,
                 Log]}];
    caml_register_global
     (72,MenhirLib_TableInterpreter,"MenhirLib.TableInterpreter");
    var MenhirLib_StaticVersion=[0,0];
    caml_register_global(73,MenhirLib_StaticVersion,"MenhirLib.StaticVersion");
    var
     MenhirLib=
      [0,
       MenhirLib_General,
       MenhirLib_Convert,
       MenhirLib_IncrementalEngine,
       MenhirLib_EngineTypes,
       MenhirLib_Engine,
       MenhirLib_ErrorReports,
       MenhirLib_Printers,
       MenhirLib_InfiniteArray,
       MenhirLib_PackedIntArray,
       MenhirLib_RowDisplacement,
       MenhirLib_LinearizedArray,
       MenhirLib_TableFormat,
       MenhirLib_InspectionTableFormat,
       MenhirLib_InspectionTableInterpreter,
       MenhirLib_TableInterpreter,
       MenhirLib_StaticVersion];
    caml_register_global(74,MenhirLib,"MenhirLib");
    return}
  (function(){return this}()));


//# 1 "../.js/pprint/PPrintLib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$1=caml_new_string(""),
     cst$0=caml_new_string(""),
     cst=caml_new_string(""),
     _a_=[0,caml_new_string("substring"),caml_new_string("char")],
     shared=[0,caml_new_string("char"),caml_new_string("substring")],
     cst_contents=caml_new_string("contents"),
     cst_ref=caml_new_string("ref"),
     cst_nan=caml_new_string("nan"),
     cst_neg_infinity=caml_new_string("neg_infinity"),
     cst_infinity=caml_new_string("infinity"),
     cst$2=caml_new_string("."),
     cst_Some=caml_new_string("Some"),
     cst_None=caml_new_string("None"),
     cst$3=caml_new_string("[|"),
     cst$4=caml_new_string("|]"),
     Assert_failure=global_data.Assert_failure,
     Stdlib=global_data.Stdlib,
     CamlinternalOO=global_data.CamlinternalOO,
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_printf=global_data.Stdlib__printf,
     PPrintRenderer=[0];
    caml_register_global(32,PPrintRenderer,"PPrintRenderer");
    var
     _b_=Stdlib[19],
     _l_=[0,caml_new_string("PPrintEngine.ml"),522,6],
     _m_=[0,caml_new_string("PPrintEngine.ml"),574,6],
     _j_=[0,caml_new_string("PPrintEngine.ml"),422,2],
     _i_=[0,caml_new_string("PPrintEngine.ml"),403,2],
     _g_=[0,caml_new_string("PPrintEngine.ml"),317,2],
     _G_=
      [0,
       [11,caml_new_string("<abstr:"),[2,0,[12,62,0]]],
       caml_new_string("<abstr:%s>")],
     _s_=[0,[8,9,0,[0,12],0],caml_new_string("%.12g")],
     _t_=[0,[8,9,0,[0,15],0],caml_new_string("%.15g")],
     _u_=[0,[8,9,0,[0,18],0],caml_new_string("%.18g")],
     _z_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _A_=[0,[5,0,0,0,0],caml_new_string("%ld")],
     _B_=[0,[7,0,0,0,0],caml_new_string("%Ld")],
     _C_=[0,[6,0,0,0,0],caml_new_string("%nd")],
     _D_=[0,[1,0],caml_new_string("%C")],
     _E_=[0,[9,0,0],caml_new_string("%B")],
     _F_=[0,[3,0,0],caml_new_string("%S")];
    function _c_(x,y){if(x !== _b_)if(y !== _b_)return x + y | 0;return _b_}
    function _d_(_aT_)
     {var
       _aU_=caml_call2(CamlinternalOO[3],_aT_,cst),
       _aV_=caml_call2(CamlinternalOO[8],_aT_,_a_),
       _aW_=_aV_[1],
       _aX_=_aV_[2];
      function _aY_(self_1){return caml_call1(Stdlib[69],self_1[_aU_ + 1])}
      var
       _aZ_=
        [0,
         _aX_,
         function(self_1){return caml_call1(Stdlib[65],self_1[_aU_ + 1])},
         _aW_,
         _aY_];
      caml_call2(CamlinternalOO[11],_aT_,_aZ_);
      return function(_a2_,_a1_,_a0_)
       {var _a3_=caml_call2(CamlinternalOO[24],_a1_,_aT_);
        _a3_[_aU_ + 1] = _a0_;
        return _a3_}}
    var channel_output=caml_call2(CamlinternalOO[19],shared,_d_);
    function _e_(_aI_)
     {var
       _aJ_=caml_call2(CamlinternalOO[3],_aI_,cst$0),
       _aK_=caml_call2(CamlinternalOO[8],_aI_,_a_),
       _aL_=_aK_[1],
       _aM_=_aK_[2];
      function _aN_(self_2)
       {return caml_call1(Stdlib_buffer[16],self_2[_aJ_ + 1])}
      var
       _aO_=
        [0,
         _aM_,
         function(self_2)
          {return caml_call1(Stdlib_buffer[10],self_2[_aJ_ + 1])},
         _aL_,
         _aN_];
      caml_call2(CamlinternalOO[11],_aI_,_aO_);
      return function(_aR_,_aQ_,_aP_)
       {var _aS_=caml_call2(CamlinternalOO[24],_aQ_,_aI_);
        _aS_[_aJ_ + 1] = _aP_;
        return _aS_}}
    var buffer_output=caml_call2(CamlinternalOO[19],shared,_e_);
    function _f_(_ax_)
     {var
       _ay_=caml_call2(CamlinternalOO[3],_ax_,cst$1),
       _az_=caml_call2(CamlinternalOO[8],_ax_,_a_),
       _aA_=_az_[1],
       _aB_=_az_[2];
      function _aC_(self_3)
       {return caml_call2(Stdlib_format[94],self_3[_ay_ + 1],0)[1]}
      var
       _aD_=
        [0,
         _aB_,
         function(self_3)
          {return caml_call1(Stdlib_format[21],self_3[_ay_ + 1])},
         _aA_,
         _aC_];
      caml_call2(CamlinternalOO[11],_ax_,_aD_);
      return function(_aG_,_aF_,_aE_)
       {var _aH_=caml_call2(CamlinternalOO[24],_aF_,_ax_);
        _aH_[_ay_ + 1] = _aE_;
        return _aH_}}
    var formatter_output=caml_call2(CamlinternalOO[19],shared,_f_);
    function requirement(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")
         return 0 === param$0?0:_b_;
        else
         switch(param$0[0])
          {case 0:return 1;
           case 1:var s=param$0[1];return caml_ml_string_length(s);
           case 2:var len=param$0[4];break;
           case 3:var len=param$0[1];break;
           case 4:var param$1=param$0[1],param$0=param$1;continue;
           case 10:
            var c=param$0[1];
            return caml_call1(caml_get_public_method(c,333005699,1),c);
           default:var req=param$0[1];return req}
        return len}}
    var accu=0;
    function char$0(c){if(10 === c)throw [0,Assert_failure,_g_];return [0,c]}
    var space=char$0(32);
    function string(s){return [1,s]}
    function fancysubstring(s,ofs,len,apparent_length)
     {return 0 === len?accu:[2,s,ofs,len,apparent_length]}
    function substring(s,ofs,len){return fancysubstring(s,ofs,len,len)}
    function fancystring(s,apparent_length)
     {return fancysubstring(s,0,caml_ml_string_length(s),apparent_length)}
    function utf8string(s)
     {var c=0,i=0;
      for(;;)
       {if(caml_ml_string_length(s) <= i)return fancystring(s,c);
        var
         n=runtime.caml_string_unsafe_get(s,i),
         k=128 <= n?224 <= n?240 <= n?4:3:2:1,
         i$0=i + k | 0,
         c$0=c + 1 | 0,
         c=c$0,
         i=i$0;
        continue}}
    var hardline=1;
    function blank(n){return 0 === n?accu:1 === n?space:[3,n]}
    function ifflat(doc1,doc2)
     {if(typeof doc1 === "number")
       var switch$0=0;
      else
       if(4 === doc1[0])var doc1$0=doc1[1],switch$0=1;else var switch$0=0;
      if(! switch$0)var doc1$0=doc1;
      return [4,doc1$0,doc2]}
    function internal_break(i){return ifflat(blank(i),hardline)}
    var break0=internal_break(0),break1=internal_break(1);
    function break$0(i)
     {return 0 === i?break0:1 === i?break1:internal_break(i)}
    function _h_(x,y)
     {if(typeof x === "number")if(0 === x)return y;
      if(typeof y === "number")if(0 === y)return x;
      var _aw_=requirement(y);
      return [5,_c_(requirement(x),_aw_),x,y]}
    function nest(i,x)
     {if(0 <= i)return [6,requirement(x),i,x];throw [0,Assert_failure,_i_]}
    function group(x){var req=requirement(x);return req === _b_?x:[7,req,x]}
    function align(x){return [8,requirement(x),x]}
    function range(hook,x){return [9,requirement(x),hook,x]}
    function custom(c)
     {if(0 <= caml_call1(caml_get_public_method(c,333005699,2),c))
       return [10,c];
      throw [0,Assert_failure,_j_]}
    var blank_buffer=caml_call2(Stdlib_string[1],80,32),blank_length=80;
    function blanks(output,n)
     {var n$0=n;
      for(;;)
       {if(0 < n$0)
         {if(n$0 <= 80)
           return caml_call4
                   (caml_get_public_method(output,-488115631,3),
                    output,
                    blank_buffer,
                    0,
                    n$0);
          caml_call4
           (caml_get_public_method(output,-488115631,4),
            output,
            blank_buffer,
            0,
            blank_length);
          var n$1=n$0 - 80 | 0,n$0=n$1;
          continue}
        return 0}}
    function _J_(counter,output,state,indent,flatten,doc,cont)
     {var indent$0=indent,flatten$0=flatten,doc$0=doc,cont$0=cont;
      for(;;)
       if(typeof doc$0 === "number")
        {if(0 === doc$0)
          {if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return _I_(counter$0,output,state,cont$0)}
           return caml_trampoline_return(_I_,[0,output,state,cont$0])}
         if(flatten$0)throw [0,Assert_failure,_l_];
         caml_call2(caml_get_public_method(output,-1044422954,5),output,10);
         blanks(output,indent$0);
         state[4] = state[4] + 1 | 0;
         state[5] = indent$0;
         state[3] = indent$0;
         if(counter < 50)
          {var counter$1=counter + 1 | 0;
           return _I_(counter$1,output,state,cont$0)}
         return caml_trampoline_return(_I_,[0,output,state,cont$0])}
       else
        switch(doc$0[0])
         {case 0:
           var c=doc$0[1];
           caml_call2(caml_get_public_method(output,-1044422954,6),output,c);
           state[5] = state[5] + 1 | 0;
           if(counter < 50)
            {var counter$2=counter + 1 | 0;
             return _I_(counter$2,output,state,cont$0)}
           return caml_trampoline_return(_I_,[0,output,state,cont$0]);
          case 1:
           var s=doc$0[1],len=caml_ml_string_length(s);
           caml_call4
            (caml_get_public_method(output,-488115631,7),output,s,0,len);
           state[5] = state[5] + len | 0;
           if(counter < 50)
            {var counter$3=counter + 1 | 0;
             return _I_(counter$3,output,state,cont$0)}
           return caml_trampoline_return(_I_,[0,output,state,cont$0]);
          case 2:
           var
            apparent_length=doc$0[4],
            len$0=doc$0[3],
            ofs=doc$0[2],
            s$0=doc$0[1];
           caml_call4
            (caml_get_public_method(output,-488115631,8),output,s$0,ofs,len$0);
           state[5] = state[5] + apparent_length | 0;
           if(counter < 50)
            {var counter$4=counter + 1 | 0;
             return _I_(counter$4,output,state,cont$0)}
           return caml_trampoline_return(_I_,[0,output,state,cont$0]);
          case 3:
           var n=doc$0[1];
           blanks(output,n);
           state[5] = state[5] + n | 0;
           if(counter < 50)
            {var counter$5=counter + 1 | 0;
             return _I_(counter$5,output,state,cont$0)}
           return caml_trampoline_return(_I_,[0,output,state,cont$0]);
          case 4:
           var
            doc2=doc$0[2],
            doc1=doc$0[1],
            doc$1=flatten$0?doc1:doc2,
            doc$0=doc$1;
           continue;
          case 5:
           var
            doc2$0=doc$0[3],
            doc$2=doc$0[2],
            cont$1=[0,indent$0,flatten$0,doc2$0,cont$0],
            doc$0=doc$2,
            cont$0=cont$1;
           continue;
          case 6:
           var
            doc$3=doc$0[3],
            j=doc$0[2],
            indent$1=indent$0 + j | 0,
            indent$0=indent$1,
            doc$0=doc$3;
           continue;
          case 7:
           var doc$4=doc$0[2],req=doc$0[1];
           if(flatten$0)
            var flatten$1=flatten$0;
           else
            var
             column=_c_(state[5],req),
             _au_=column <= state[1]?1:0,
             _av_=_au_?column <= (state[3] + state[2] | 0)?1:0:_au_,
             flatten$1=_av_;
           var flatten$0=flatten$1,doc$0=doc$4;
           continue;
          case 8:
           var doc$5=doc$0[2],indent$2=state[5],indent$0=indent$2,doc$0=doc$5;
           continue;
          case 9:
           var
            doc$6=doc$0[3],
            hook=doc$0[2],
            start=[0,state[4],state[5]],
            cont$2=[1,hook,start,cont$0],
            doc$0=doc$6,
            cont$0=cont$2;
           continue;
          default:
           var c$0=doc$0[1];
           caml_call5
            (caml_get_public_method(c$0,784433846,9),
             c$0,
             output,
             state,
             indent$0,
             flatten$0);
           var _ar_=1 - flatten$0;
           if(_ar_)
            var _as_=_ar_;
           else
            var
             _at_=state[5] <= state[1]?1:0,
             _as_=_at_?state[5] <= (state[3] + state[2] | 0)?1:0:_at_;
           if(_as_)
            {if(counter < 50)
              {var counter$6=counter + 1 | 0;
               return _I_(counter$6,output,state,cont$0)}
             return caml_trampoline_return(_I_,[0,output,state,cont$0])}
           throw [0,Assert_failure,_m_]}}
    function _I_(counter,output,state,param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        return 0;
       else
        {if(0 === param$0[0])
          {var
            cont=param$0[4],
            doc=param$0[3],
            flatten=param$0[2],
            indent=param$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return _J_(counter$0,output,state,indent,flatten,doc,cont)}
           return caml_trampoline_return
                   (_J_,[0,output,state,indent,flatten,doc,cont])}
         var
          cont$0=param$0[3],
          start=param$0[2],
          hook=param$0[1],
          finish=[0,state[4],state[5]];
         caml_call1(hook,[0,start,finish]);
         var param$0=cont$0;
         continue}}
    function _k_(output,state,indent,flatten,doc,cont)
     {return caml_trampoline(_J_(0,output,state,indent,flatten,doc,cont))}
    function pretty(output,state,indent,flatten,doc)
     {return _k_(output,state,indent,flatten,doc,0)}
    function _H_(counter,output,doc,cont)
     {var doc$0=doc,cont$0=cont;
      for(;;)
       {if(typeof doc$0 === "number")
         {if(0 === doc$0)
           {if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return continue$0(counter$0,output,cont$0)}
            return caml_trampoline_return(continue$0,[0,output,cont$0])}
          caml_call2(caml_get_public_method(output,-1044422954,10),output,10);
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return continue$0(counter$1,output,cont$0)}
          return caml_trampoline_return(continue$0,[0,output,cont$0])}
        else
         switch(doc$0[0])
          {case 0:
            var c=doc$0[1];
            caml_call2(caml_get_public_method(output,-1044422954,11),output,c);
            if(counter < 50)
             {var counter$2=counter + 1 | 0;
              return continue$0(counter$2,output,cont$0)}
            return caml_trampoline_return(continue$0,[0,output,cont$0]);
           case 1:
            var s=doc$0[1],len=caml_ml_string_length(s);
            caml_call4
             (caml_get_public_method(output,-488115631,12),output,s,0,len);
            if(counter < 50)
             {var counter$3=counter + 1 | 0;
              return continue$0(counter$3,output,cont$0)}
            return caml_trampoline_return(continue$0,[0,output,cont$0]);
           case 2:
            var len$0=doc$0[3],ofs=doc$0[2],s$0=doc$0[1];
            caml_call4
             (caml_get_public_method(output,-488115631,13),
              output,
              s$0,
              ofs,
              len$0);
            if(counter < 50)
             {var counter$4=counter + 1 | 0;
              return continue$0(counter$4,output,cont$0)}
            return caml_trampoline_return(continue$0,[0,output,cont$0]);
           case 3:
            var n=doc$0[1];
            blanks(output,n);
            if(counter < 50)
             {var counter$5=counter + 1 | 0;
              return continue$0(counter$5,output,cont$0)}
            return caml_trampoline_return(continue$0,[0,output,cont$0]);
           case 4:var doc$1=doc$0[1];break;
           case 5:
            var
             doc2=doc$0[3],
             doc$2=doc$0[2],
             cont$1=[0,doc2,cont$0],
             doc$0=doc$2,
             cont$0=cont$1;
            continue;
           case 10:
            var c$0=doc$0[1];
            caml_call2(caml_get_public_method(c$0,57215907,14),c$0,output);
            if(counter < 50)
             {var counter$6=counter + 1 | 0;
              return continue$0(counter$6,output,cont$0)}
            return caml_trampoline_return(continue$0,[0,output,cont$0]);
           case 6:
           case 9:var doc$1=doc$0[3];break;
           default:var doc$1=doc$0[2]}
        var doc$0=doc$1;
        continue}}
    function continue$0(counter,output,cont)
     {if(cont)
       {var cont$0=cont[2],doc=cont[1];
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return _H_(counter$0,output,doc,cont$0)}
        return caml_trampoline_return(_H_,[0,output,doc,cont$0])}
      return 0}
    function _n_(output,doc,cont)
     {return caml_trampoline(_H_(0,output,doc,cont))}
    function compact(output,doc){return _n_(output,doc,0)}
    function MakeRenderer(X)
     {function pretty$0(rfrac,width,channel,doc)
       {var
         _ap_=caml_call2(Stdlib[16],width,width * rfrac | 0),
         _aq_=[0,width,caml_call2(Stdlib[17],0,_ap_),0,0,0];
        return pretty(caml_call1(X[1],channel),_aq_,0,0,doc)}
      function compact$0(channel,doc)
       {return compact(caml_call1(X[1],channel),doc)}
      return [0,pretty$0,compact$0]}
    var
     output=caml_call1(channel_output[1],0),
     ToChannel=MakeRenderer([0,output]),
     output$0=caml_call1(buffer_output[1],0),
     ToBuffer=MakeRenderer([0,output$0]),
     output$1=caml_call1(formatter_output[1],0),
     ToFormatter=MakeRenderer([0,output$1]),
     PPrintEngine=
      [0,
       accu,
       char$0,
       string,
       substring,
       fancystring,
       fancysubstring,
       utf8string,
       hardline,
       blank,
       break$0,
       _h_,
       nest,
       group,
       ifflat,
       align,
       range,
       ToChannel,
       ToBuffer,
       ToFormatter,
       _b_,
       custom,
       requirement,
       pretty,
       compact];
    caml_register_global(39,PPrintEngine,"PPrintEngine");
    var
     opening=char$0(40),
     closing=char$0(41),
     langle=char$0(60),
     rangle=char$0(62),
     lbrace=char$0(123),
     rbrace=char$0(125),
     lbracket=char$0(91),
     rbracket=char$0(93),
     squote=char$0(39),
     dquote=char$0(34),
     bquote=char$0(96),
     semi=char$0(59),
     colon=char$0(58),
     separator=char$0(44),
     space$0=char$0(32),
     dot=char$0(46),
     sharp=char$0(35),
     slash=char$0(47),
     backslash=char$0(92),
     equals=char$0(61),
     qmark=char$0(63),
     tilde=char$0(126),
     at=char$0(64),
     percent=char$0(37),
     dollar=char$0(36),
     caret=char$0(94),
     ampersand=char$0(38),
     star=char$0(42),
     plus=char$0(43),
     minus=char$0(45),
     underscore=char$0(95),
     bang=char$0(33),
     bar=char$0(124);
    function twice(doc){return _h_(doc,doc)}
    function repeat(n,doc)
     {var n$0=n,accu$0=accu;
      for(;;)
       {if(0 === n$0)return accu$0;
        var accu$1=_h_(doc,accu$0),n$1=n$0 - 1 | 0,n$0=n$1,accu$0=accu$1;
        continue}}
    function precede(l,x){return _h_(l,x)}
    function terminate(r,x){return _h_(x,r)}
    function enclose(l,r,x){return _h_(l,_h_(x,r))}
    function squotes(_ao_){return enclose(squote,squote,_ao_)}
    function dquotes(_an_){return enclose(dquote,dquote,_an_)}
    function bquotes(_am_){return enclose(bquote,bquote,_am_)}
    function braces(_al_){return enclose(lbrace,rbrace,_al_)}
    function parens(_ak_){return enclose(opening,closing,_ak_)}
    function angles(_aj_){return enclose(langle,rangle,_aj_)}
    function brackets(_ai_){return enclose(lbracket,rbracket,_ai_)}
    function foldli(f,accu,xs)
     {var r=[0,0];
      function _ah_(accu,x)
       {var i=r[1];r[1] = i + 1 | 0;return caml_call3(f,i,accu,x)}
      return caml_call3(Stdlib_list[21],_ah_,accu,xs)}
    function concat(docs){return caml_call3(Stdlib_list[21],_h_,accu,docs)}
    function separate(sep,docs)
     {return foldli
              (function(i,accu,doc){return 0 === i?doc:_h_(accu,_h_(sep,doc))},
               accu,
               docs)}
    function concat_map(f,xs)
     {function _ag_(accu,x){return _h_(accu,caml_call1(f,x))}
      return caml_call3(Stdlib_list[21],_ag_,accu,xs)}
    function separate_map(sep,f,xs)
     {return foldli
              (function(i,accu,x)
                {return 0 === i
                         ?caml_call1(f,x)
                         :_h_(accu,_h_(sep,caml_call1(f,x)))},
               accu,
               xs)}
    function separate2(sep,last_sep,docs)
     {var n=caml_call1(Stdlib_list[1],docs);
      return foldli
              (function(i,accu,doc)
                {if(0 === i)return doc;
                 var sep$0=i < (n - 1 | 0)?sep:last_sep;
                 return _h_(accu,_h_(sep$0,doc))},
               accu,
               docs)}
    function optional(f,param)
     {if(param){var x=param[1];return caml_call1(f,x)}return accu}
    function index_from(s,i,c)
     {try
       {var _ae_=[0,caml_call3(Stdlib_string[18],s,i,c)];return _ae_}
      catch(_af_)
       {_af_ = caml_wrap_exception(_af_);
        if(_af_ === Stdlib[8])return 0;
        throw _af_}}
    function lines(s)
     {var accu=0,i=0;
      for(;;)
       {var match=index_from(s,i,10);
        if(match)
         {var
           j=match[1],
           accu$0=[0,substring(s,i,j - i | 0),accu],
           i$0=j + 1 | 0,
           accu=accu$0,
           i=i$0;
          continue}
        var _ad_=[0,substring(s,i,caml_ml_string_length(s) - i | 0),accu];
        return caml_call1(Stdlib_list[9],_ad_)}}
    function arbitrary_string(s)
     {var _ac_=lines(s);return separate(break$0(1),_ac_)}
    function split(ok,s)
     {var n=caml_ml_string_length(s),accu=0,i$1=0;
      a:
      for(;;)
       {var i=i$1;
        for(;;)
         {if(i === n)
           var match=0;
          else
           {if(! caml_call1(ok,caml_string_get(s,i)))
             {var i$0=i + 1 | 0,i=i$0;continue}
            var match=[0,i]}
          if(match)
           {var
             j=match[1],
             accu$0=[0,substring(s,i$1,j - i$1 | 0),accu],
             accu$1=[0,char$0(caml_string_get(s,j)),accu$0],
             i$2=j + 1 | 0,
             accu=accu$1,
             i$1=i$2;
            continue a}
          var
           _ab_=
            [0,substring(s,i$1,caml_ml_string_length(s) - i$1 | 0),accu];
          return caml_call1(Stdlib_list[9],_ab_)}}}
    function words(s)
     {var n=caml_ml_string_length(s),accu=0,i=0;
      a:
      for(;;)
       {if(i === n)
         var _aa_=accu;
        else
         {var
           match=caml_string_get(s,i),
           ___=match - 9 | 0,
           switch$0=4 < ___ >>> 0?23 === ___?1:0:1 < (___ - 2 | 0) >>> 0?1:0;
          if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
          var j=i + 1 | 0,j$0=j;
          for(;;)
           {if(j$0 !== n)
             {var
               match$0=caml_string_get(s,j$0),
               _$_=match$0 - 9 | 0,
               switch$1=
                4 < _$_ >>> 0?23 === _$_?1:0:1 < (_$_ - 2 | 0) >>> 0?1:0;
              if(switch$1)
               {var
                 accu$0=[0,substring(s,i,j$0 - i | 0),accu],
                 i$1=j$0 + 1 | 0,
                 accu=accu$0,
                 i=i$1;
                continue a}
              var j$1=j$0 + 1 | 0,j$0=j$1;
              continue}
            var _aa_=[0,substring(s,i,j$0 - i | 0),accu];
            break}}
        return caml_call1(Stdlib_list[9],_aa_)}}
    function flow_map(sep,f,docs)
     {return foldli
              (function(i,accu,doc)
                {return 0 === i
                         ?caml_call1(f,doc)
                         :_h_(accu,group(_h_(sep,caml_call1(f,doc))))},
               accu,
               docs)}
    function flow(sep,docs){return flow_map(sep,function(x){return x},docs)}
    function url(s)
     {var
       _Z_=
        split
         (function(param)
           {var switcher=param - 46 | 0;return 1 < switcher >>> 0?0:1},
          s);
      return flow(break$0(0),_Z_)}
    function hang(i,d){return align(nest(i,d))}
    function _o_(x,y){return _h_(x,_h_(break$0(1),y))}
    function prefix(n,b,x,y){return group(_h_(x,nest(n,_h_(break$0(b),y))))}
    var _p_=1,_q_=2;
    function _r_(_X_,_Y_){return prefix(_q_,_p_,_X_,_Y_)}
    function jump(n,b,y){return group(nest(n,_h_(break$0(b),y)))}
    function infix(n,b,op,x,y){return prefix(n,b,_h_(x,_h_(blank(b),op)),y)}
    function surround(n,b,opening,contents,closing)
     {var _W_=_h_(break$0(b),closing);
      return group(_h_(opening,_h_(nest(n,_h_(break$0(b),contents)),_W_)))}
    function soft_surround(n,b,opening,contents,closing)
     {var _V_=group(_h_(break$0(b),closing));
      return group
              (_h_(opening,_h_(nest(n,_h_(group(break$0(b)),contents)),_V_)))}
    function surround_separate(n,b,void$0,opening,sep,closing,docs)
     {return docs?surround(n,b,opening,separate(sep,docs),closing):void$0}
    function surround_separate_map(n,b,void$0,opening,sep,closing,f,xs)
     {return xs?surround(n,b,opening,separate_map(sep,f,xs),closing):void$0}
    var
     include=
      [0,
       opening,
       closing,
       langle,
       rangle,
       lbrace,
       rbrace,
       lbracket,
       rbracket,
       squote,
       dquote,
       bquote,
       semi,
       colon,
       separator,
       space$0,
       dot,
       sharp,
       slash,
       backslash,
       equals,
       qmark,
       tilde,
       at,
       percent,
       dollar,
       caret,
       ampersand,
       star,
       plus,
       minus,
       underscore,
       bang,
       bar,
       precede,
       terminate,
       enclose,
       squotes,
       dquotes,
       bquotes,
       braces,
       parens,
       angles,
       brackets,
       twice,
       repeat,
       concat,
       separate,
       concat_map,
       separate_map,
       separate2,
       optional,
       lines,
       arbitrary_string,
       words,
       split,
       flow,
       flow_map,
       url,
       hang,
       prefix,
       jump,
       infix,
       surround,
       soft_surround,
       surround_separate,
       surround_separate_map,
       string,
       _o_,
       _r_];
    caml_register_global(41,include,"PPrintCombinators");
    function dsprintf(format)
     {return caml_call2(Stdlib_printf[9],string,format)}
    function valid_float_lexeme(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return caml_call2(Stdlib[28],s,cst$2);
        var
         match=caml_string_get(s,i),
         switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    var
     some=[1,cst_Some],
     none=[1,cst_None],
     lbracketbar=[1,cst$3],
     rbracketbar=[1,cst$4];
    function seq2(opening,separator,closing)
     {var _P_=_h_(separator,break$0(1)),_Q_=_h_(opening,closing),_R_=1,_S_=2;
      return function(_T_,_U_)
       {return surround_separate_map(_S_,_R_,_Q_,opening,_P_,closing,_T_,_U_)}}
    var _v_=_h_(separator,break$0(1)),_w_=_h_(opening,closing),_x_=0,_y_=2;
    function tuple(_O_)
     {return surround_separate(_y_,_x_,_w_,opening,_v_,closing,_O_)}
    function variant(param,cons,_N_,args)
     {return args?_h_([1,cons],tuple(args)):[1,cons]}
    function record(param,fields)
     {function _M_(param)
       {var v=param[2],k=param[1];return infix(2,1,equals,[1,k],v)}
      return caml_call2(seq2(lbrace,semi,rbrace),_M_,fields)}
    function option(f,param)
     {if(param){var x=param[1];return _h_(some,tuple([0,caml_call1(f,x),0]))}
      return none}
    function list(f,xs){return caml_call2(seq2(lbracket,semi,rbracket),f,xs)}
    function array(f,xs)
     {var _L_=caml_call1(Stdlib_array[11],xs);
      return caml_call2(seq2(lbracketbar,semi,rbracketbar),f,_L_)}
    function ref(f,x)
     {return record(cst_ref,[0,[0,cst_contents,caml_call1(f,x[1])],0])}
    function float$0(f)
     {var match=runtime.caml_classify_float(f);
      if(3 === match)
       var _K_=f < 0.?cst_neg_infinity:cst_infinity;
      else
       if(4 <= match)
        var _K_=cst_nan;
       else
        {var s=caml_call2(Stdlib_printf[4],_s_,f);
         if(f == caml_float_of_string(s))
          var _K_=valid_float_lexeme(s);
         else
          var
           s$0=caml_call2(Stdlib_printf[4],_t_,f),
           _K_=
            f == caml_float_of_string(s$0)
             ?valid_float_lexeme(s$0)
             :caml_call2(Stdlib_printf[4],_u_,f)}
      return [1,_K_]}
    var
     int$0=dsprintf(_z_),
     int32=dsprintf(_A_),
     int64=dsprintf(_B_),
     nativeint=dsprintf(_C_),
     char$1=dsprintf(_D_),
     bool=dsprintf(_E_),
     string$0=dsprintf(_F_);
    function unknown(tyname,param){return caml_call1(dsprintf(_G_),tyname)}
    var
     PPrintOCaml=
      [0,
       variant,
       record,
       tuple,
       string$0,
       int$0,
       int32,
       int64,
       nativeint,
       float$0,
       char$1,
       bool,
       option,
       list,
       array,
       ref,
       unknown];
    caml_register_global(44,PPrintOCaml,"PPrintOCaml");
    var
     PPrint=
      [0,
       accu,
       char$0,
       string,
       substring,
       fancystring,
       fancysubstring,
       utf8string,
       hardline,
       blank,
       break$0,
       _h_,
       nest,
       group,
       ifflat,
       align,
       range,
       ToChannel,
       ToBuffer,
       ToFormatter,
       _b_,
       custom,
       requirement,
       pretty,
       compact,
       opening,
       closing,
       langle,
       rangle,
       lbrace,
       rbrace,
       lbracket,
       rbracket,
       squote,
       dquote,
       bquote,
       semi,
       colon,
       separator,
       space$0,
       dot,
       sharp,
       slash,
       backslash,
       equals,
       qmark,
       tilde,
       at,
       percent,
       dollar,
       caret,
       ampersand,
       star,
       plus,
       minus,
       underscore,
       bang,
       bar,
       precede,
       terminate,
       enclose,
       squotes,
       dquotes,
       bquotes,
       braces,
       parens,
       angles,
       brackets,
       twice,
       repeat,
       concat,
       separate,
       concat_map,
       separate_map,
       separate2,
       optional,
       lines,
       arbitrary_string,
       words,
       split,
       flow,
       flow_map,
       url,
       hang,
       prefix,
       jump,
       infix,
       surround,
       soft_surround,
       surround_separate,
       surround_separate_map,
       string,
       _o_,
       _r_];
    caml_register_global(45,PPrint,"PPrint");
    return}
  (function(){return this}()));


//# 1 "../lib/.polyGNew.objs/polyGNew.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_equal=runtime.caml_equal,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_update_dummy=runtime.caml_update_dummy,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_ref=caml_new_string("ref ("),
     cst=caml_new_string(")"),
     cst_fresh=caml_new_string("fresh"),
     cst_Gtypes_DynRefl=caml_new_string("Gtypes.DynRefl"),
     cst_Gtypes_BoolRefl=caml_new_string("Gtypes.BoolRefl"),
     cst_Gtypes_NumRefl=caml_new_string("Gtypes.NumRefl"),
     cst_Gtypes_Dyn=caml_new_string("Gtypes.Dyn"),
     cst_Gtypes_Bool=caml_new_string("Gtypes.Bool"),
     cst_Gtypes_Num=caml_new_string("Gtypes.Num"),
     cst_Gtypes_Booltag=caml_new_string("Gtypes.Booltag"),
     cst_Gtypes_Numtag=caml_new_string("Gtypes.Numtag"),
     cst_Gtypes_Prodtag=caml_new_string("Gtypes.Prodtag"),
     cst_Gtypes_Funtag=caml_new_string("Gtypes.Funtag"),
     cst_Gtypes_Extag=caml_new_string("Gtypes.Extag"),
     cst_Gtypes_Alltag=caml_new_string("Gtypes.Alltag"),
     cst_CC_Down=caml_new_string("CC.Down"),
     cst_CC_Up=caml_new_string("CC.Up"),
     cst_Surf_line=caml_new_string("Surf.line"),
     cst_col=caml_new_string("col"),
     cst_let=caml_new_string("let"),
     cst_seal=caml_new_string("seal"),
     cst_unseal=caml_new_string("unseal"),
     cst_true=caml_new_string("#true"),
     cst_false=caml_new_string("#false"),
     cst_else=caml_new_string("else "),
     cst_then=caml_new_string("then "),
     cst_if=caml_new_string("if "),
     cst_let$0=caml_new_string("let"),
     cst$6=caml_new_string(" =>"),
     cst$7=caml_new_string(" : "),
     cst_fun=caml_new_string("fun "),
     cst$8=caml_new_string(">"),
     cst$9=caml_new_string(","),
     cst$10=caml_new_string(" =~ "),
     cst_pack=caml_new_string("pack<"),
     cst_unpack=caml_new_string("unpack"),
     cst$11=caml_new_string(">"),
     cst$12=caml_new_string(","),
     cst$13=caml_new_string(","),
     cst$14=caml_new_string(" =~ "),
     cst_pack$0=caml_new_string("pack<"),
     cst$15=caml_new_string(" =>"),
     cst_Lambda=caml_new_string("Lambda "),
     cst$16=caml_new_string("=~"),
     cst_in$0=caml_new_string(" in"),
     cst$17=caml_new_string(" =~ "),
     cst_hide=caml_new_string("hide "),
     cst_dinj=caml_new_string("dinj"),
     cst$18=caml_new_string(" + "),
     cst_down=caml_new_string("down"),
     cst_up=caml_new_string("up"),
     cst$3=caml_new_string("?"),
     cst_bool$0=caml_new_string("bool"),
     cst_int$0=caml_new_string("int"),
     cst_tag=caml_new_string("tag"),
     cst$4=caml_new_string(" * "),
     cst$5=caml_new_string("->"),
     cst_exists$0=caml_new_string("exists"),
     cst_forall$0=caml_new_string("forall"),
     cst_bool=caml_new_string("bool"),
     cst_int=caml_new_string("int"),
     cst$1=caml_new_string("*"),
     cst$2=caml_new_string("->"),
     cst_exists=caml_new_string("exists"),
     cst_forall=caml_new_string("forall"),
     cst_column=caml_new_string("column"),
     cst_line=caml_new_string("line"),
     cst_in=caml_new_string("in"),
     cst$0=caml_new_string("="),
     cst_to_an_inconsistent_type=caml_new_string(" to an inconsistent type"),
     cst_Tried_to_cast_from_type=caml_new_string("Tried to cast from type"),
     cst_bound_in_the_kont_of_an_unpack=
      caml_new_string(" bound in the kont of an unpack."),
     cst_Leaked_a_type_variable=caml_new_string("Leaked a type variable "),
     cst_leaked_in_body_of_pack=caml_new_string(" leaked in body of pack"),
     cst_type_variable=caml_new_string("type variable "),
     cst_to_an_arg_of_incompatible_type=
      caml_new_string(" to an arg of incompatible type "),
     cst_Applied_a_function_of_with_domain=
      caml_new_string("Applied a function of with domain "),
     cst_in_function_body=caml_new_string(" in function body"),
     cst_Leaked_type_variable=caml_new_string("Leaked type variable "),
     cst_Tried_to_add_something_of_type=
      caml_new_string("Tried to add something of type "),
     cst_Tried_to_add_something_of_type$0=
      caml_new_string("Tried to add something of type "),
     cst_type_variable_in_output_of_if_one_branch_but_not_another=
      caml_new_string
       ("type variable in output of if one branch but not another: "),
     cst_Branches_of_an_if_were_not_consistent=
      caml_new_string("Branches of an if were not consistent"),
     cst_Tried_to_do_an_if_on_something_inconsistent_with_bool=
      caml_new_string("Tried to do an if on something inconsistent with bool"),
     cst_Tried_to_unseal_a_val_with_incompatible_type=
      caml_new_string("Tried to unseal a val with incompatible type"),
     cst_unbound_or_unknown_type_variable_used_for_unsealing=
      caml_new_string("unbound or unknown type variable used for unsealing: "),
     cst_sealed_as=caml_new_string("sealed as"),
     cst_at_incompatible_type=caml_new_string("at incompatible type"),
     cst_Tried_to_seal_a_val_of_type=
      caml_new_string("Tried to seal a val of type"),
     cst_in_env=caml_new_string("in env"),
     cst_unbound_or_unknown_type_variable_used_for_sealing=
      caml_new_string("unbound or unknown type variable used for sealing:"),
     cst_unbound_variable=caml_new_string("unbound variable:"),
     cst_in_argument_to_function=caml_new_string(" in argument to function"),
     cst_Unbound_type_variable=caml_new_string("Unbound type variable "),
     cst_twice=caml_new_string(" twice."),
     cst_Instantiating_variables_must_be_unique_but_you_used=
      caml_new_string("Instantiating variables must be unique, but you used "),
     cst_tag_check=caml_new_string(" tag-check"),
     cst_Unbound_type_variable$0=caml_new_string("Unbound type variable "),
     cst_occurs_free_in_inferred_type=
      caml_new_string(" occurs free in inferred type "),
     cst_Type_of_a_program_should_be_closed_but=
      caml_new_string("Type of a program should be closed, but "),
     cst_tried_to_instantiate_something_with_type_incompatible_with_universal_quantifier=
      caml_new_string
       ("tried to instantiate something with type incompatible with universal quantifier"),
     cst_tried_to_unpack_something_with_type_incompatible_with_existential_quantifier=
      caml_new_string
       ("tried to unpack something with type incompatible with existential quantifier"),
     cst_tried_to_apply_something_that_isn_t_a_function=
      caml_new_string("tried to apply something that isn't a function"),
     cst_tried_a_pair_pattern_match_on_something_with_type_incompatible_with_pair=
      caml_new_string
       ("tried a pair pattern-match on something with type incompatible with pair"),
     cst$21=caml_new_string(","),
     cst$22=caml_new_string("(/)"),
     cst$19=caml_new_string(" : "),
     cst$20=caml_new_string(" =~ "),
     cst_PolyGNew_Parser_MenhirBasics_Error=
      caml_new_string("PolyGNew.Parser.MenhirBasics.Error"),
     default_reduction=
      [0,
       8,
       caml_new_string
        ("\0\r\0\0\x0e\0\0\0\0\"#\0!\0\0\0\0\0\0 \0\0\0\0\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\f\0\0\0\0\0\0\0\0\0\0\x0f\0\0\0\x1b\0\0\0\0\0\x06\0\0\x05\x04\0\0\0\0\0\0\0\0\b\x07\0\0\0\0\0\0\0\0\0\0\x1a\0\0\0\0\x1d\0\0\x1c\0\0\0\0\0\0\0\0\x1e\0\x0b\0\0\x10\0\0\0\x1f\0\x11\0\0\x12\x01")],
     error=
      [0,
       38,
       caml_new_string
        ('t\x81\xe1\xa0\b\0\0\0\0\0\x80\0\0\0\x11\0h\b\0\0\0\0\0\0\0\0 \0\0\x80\0\0\0\0\0\0\x02\0\b\b$P\x10\0\0\0\0\0\0\0\0\0\x02\x02\t\x14\x04\0\0\0\0\0 \0\0\0\0\0 \0\0\x02\x02\t\x14\x04\b\0\0\0\0\0\b\0\0\0\x80\x82E\x01\0\0\0\0\0\x03r\x02\x03\xc4  \x91@@7  <B\x02\t\x14\x04\x03r\x02\x03\xc4\r\xc8\b\x0f\x10$\0\0\0@\0\0\0\0\x02\0\0\0E\xd2\x07\x86\x80 \0\0\x80\0\x02\0\0\0\0\0\0\0\0A\0\0\0\0\0\x01\0\0\0\0\0\0\x01\0t\x81\xe1\xa0\b \0\0\0\x04@\x1a\x02\0\0\0\0\0\0t\x81\xe1\xa0\t\0\0\x80\0\0\0\0\0@\x1d xh\x02t\x81\xe1\xa0\t\0\0\0\0\0\0\0\0\x02\x02\x02\t\x14\x04\x02\x02\0\0\x05\xd2\x07\x86\x80 \0\0\0\0\x02\0\0\0\0\0\x02\0\0\x01\xd2\x07\x86\x80 \0\0\0\0\x11Ul\x88\xf0\0\x04\0\0\x01\x92\x06\x80\x80\0\x80\0\0\0\x11\0h\b\0\0\0\0\0\0 \0\0\0\x04@\x1a\x02\0\0\0\0\0\0\0\0\0\0\0\x05P\b\r\x06H\x1a\x02\0\0U\0\x80\xd0EU\xb2#@ \0\0\0\0\0\0\0\x80\x02\x02\t\x14\x04\x02 \0\0\x04\0\0\0\0\0\0\0\0\0\x11\x01l\b\0\b\0\0\0\0\0\0\0 \0\x80\x82E\x01\0\x88\0\0\x01EU\xb2#A\x15V\xc8\x8d\0\0\0\0\b\x02\x02\t\x14\x04\x03P\x02\x03\xc4\0\0\0\0\0\x10\0\0\0\x1d xh\x02\0\0\0\x01\x01\xd2\x07\x86\x80 \0\0\0\0\0\0\0\x80\0t\x81\xe1\xa0\b\0\0\0\0\x04\0\0\0\0\0\0\0\0\x10@\0\0\0\0\x01\0\0\0\0\0\0\0@\x1d xh\x02\0\0\x02\0\x01\xd2\x07\x86\x80 \0\0\0\0\0\x10\0\0\x10\0\0\0\0\x01\xd2\x07\x86\x80 \x04\0\0\0\0\0\0\0\0EU\xb2#@\0\0\b\0\x07H\x1e\x1a\0\x80\0\0\0\0\0\x10\0\0\0\0\0\0\0\x04U["4\0\0\0\0\x80\0\0\0\0\0\0\0\0\0\0')],
     action=
      [0,
       [0,
        16,
        caml_new_string
         ("\x01Z\0\0\0\x07\0@\0\0\0%\0\x06\0'\0\x02\0\0\0\0\0\x02\0\0\0\x18\0\x12\0\x02\0P\0@\0\x02\0\0\x01Z\0\x02\x01\x9a\0\x02\x01\xb6\x01\xf0\0$\0\0\0\n\x01Z\0R\0~\0H\0\x8c\0|\0^\x01Z\0\x96\0@\0\0\x01Z\0\x04\0j\x01Z\x01Z\0\xa6\0h\0\x02\0V\x01Z\0\0\0\xa8\0\xa0\x01Z\0\0\0\x03\0\xa6\0@\0\xbc\0@\0\0\0\xc0\0@\0\0\0\0\x02>\0@\x02H\0@\0\xc6\0\x9c\0\x02\0V\0\0\0\0\x01Z\0\xce\0\xa2\0\x02\0\\\0v\0\xac\0\x9c\0\x02\x02\b\0\0\0\xd0\x01Z\0\xa4\x01Z\0\0\0\xba\x01Z\0\0\0\xf0\0\xb4\0\xf8\0\xec\0\xca\x01Z\0\xde\x01Z\0\0\x004\0\0\x01Z\0\xfa\0\0\0\xe2\0\xe4\x01Z\0\0\0\xfc\0\0\x01\x18\0\xd8\0\0\0\0")],
       [0,
        16,
        caml_new_string
         ('\0\r\0\x0e\0\x1a\0\xaa\0\r\0&\0I\0\x1e\0I\0"\0I\0V\0\r\0*\0\r\0\r\0:\0\r\0\r\0.\x01z\0I\x002\0>\0V\0\r\x006\0n\0B\0I\0I\0\x05\0I\0\x06\0\xea\x01\xa2\0N\0\x12\0v\0!\0\xf6\0!\0^\0!\0F\0!\0J\0\x16\0\x9e\0V\0\xa2\x01\x16\0V\x01&\0!\0^\x01B\0\xc6\0\xca\x01\xa6\0\x1d\0~\0!\0!\0\x1d\0!\0]\0\x82\0]\0\x86\0]\0\x8a\0\x1d\0\x8e\0\x1d\0\x1d\0\x92\0\x1d\0\x1d\0\x9a\0^\0]\0\xae\0^\0\xba\0\x1d\0\xbe\0\x19\0\xd2\0]\0]\0\x19\0]\0Y\0\xd6\0Y\0\xe6\0Y\0\xee\0\x19\0\xfa\0\x19\0\x19\x01\x1a\0\x19\0\x19\x01\x1e\x016\0Y\x01:\x01N\x01^\0\x19\x01f\0\x11\x01r\0Y\0Y\0\x11\0Y\0Q\x01~\0Q\x01\x82\0Q\x01\x86\0\x11\x01\x8a\0\x11\0\x11\x01\x8e\0\x11\0\x11\x01\x96\x01\xae\0Q\x01\xba\x01\xc6\x01\xd3\0\x11\0\0\0\x15\0\0\0Q\0Q\0\x15\0Q\0U\0\0\0U\0\0\0U\0\0\0\x15\0\0\0\x15\0\x15\0\0\0\x15\0\x15\0\0\0\0\0U\0\0\0\0\0\0\0\x15\0\0\0\0\0\0\0U\0U\0\0\0U\0\x06\0\n\0z\0\0\0\x12\0V\0\x95\0\x96\0\x95\0\x95\0\x95\0\0\0!\0\x95\0\x16\0\x9e\0\xa6\0\xa2\x012\0\0\0\0\0\x95\0\xb2\0\xb6\0\0\0\xca\0\0\0\0\0\0\0\x95\0\x95\0\x95\0\x95\0\0\0\0\0\xce\0^\0V\0\x91\0\0\0\x91\0\x91\0\x91\0\0\0\0\0\x91\0\0\0\0\0\0\0\0\0\0\0\x8d\0\x8d\0\x91\0\x8d\0\x8d\0\x8d\0\0\0\0\0\x8d\0\0\0\x91\0\x91\0\x91\0\x91\0\0\0\0\0\x8d\0^\0\0\0\0\0\0\0\0\0\0\0\0\0\x8d\0\x8d\0\x8d\0\x8d\0\0\0V\0\x9d\0^\0\x9d\0\x9d\0\x9d\0\0\0\0\0\x9d\0\0\0\0\0\0\0V\0M\0\0\0M\0\x9d\0M\0\0\0\0\0\0\0\0\0\0\0\0\0\x9d\0\x9d\0\x9d\0\x9d\0M\0\0\0\0\0^\0\0\0\0\0\0\0\0\0M\0M\0\t\0M\0a\0\0\0a\0^\0a\0%\x01\n\0%\0\0\0%\0\0\x01\n\0\0\0\0\0\0\0a\0\0\0\0\0\0\0\0\0%\0\0\0\0\0a\0a\0\0\0a\0\0\0%\0%\0\0\0%')]],
     lhs=[0,4,caml_new_string('\x07vffUDDDC""""""!\x11\x11\x11\x11')],
     goto$0=
      [0,
       [0,
        8,
        caml_new_string
         ("\x05\0\0\x06\0\0\0\0\x18\0\0$\0\0\x000\0\0<\0\0H\0T\0\0\0\0\0\b\0\0\0\0\0\0\x14\0Z\0 \0\0,8\0\0l\0D\0\0\0P\0\0\0\xac\0r\0\0~\0\0\0\xb2\0\x8a\0\0\x9c\0\0\0\xa2\0\0\xbe\0\0\0\0\xc0\0\0\0\\\0h\0\0t\0\0\0\0\0\0\x80\0\x8c\0\0\0\x98\0\0\0\0\xa4\0\0\0\0\0\0\0")],
       [0,
        8,
        caml_new_string
         ("tv89LSqs89LSn\x1d89LSh\x1b89LS\\\x1a89LSW\x1589LSV\x1789LS7\x1989LSYm89LS[189LS^=89LSe@89LSgK89LSkI89LSpR89LSABEADEPU")]],
     cst_Unexpected_char=caml_new_string("Unexpected char: "),
     cst_PolyGNew_Lexer_LexingError=
      caml_new_string("PolyGNew.Lexer.LexingError"),
     ocaml_lex_tables=
      [0,
       caml_new_string
        ("\0\0\xd8\xff\xd9\xffU\0\xc0\0\x14\x01h\x01\xbc\x01\x10\x02d\x02\xb8\x02\f\x03`\x03\xb4\x03\b\x04\xec\xff\xed\xff\xee\xff\x01\0\0\0\xf3\xff\xf4\xff\xf5\xff\xf6\xff\xf7\xff\xf8\xff\xf9\xff\xfa\xff\xa0\0\xaa\0\x1b\0\xfe\xff\x01\0\x05\0\x1f\0\x11\0\x0f\0+\0\xfd\xff%\0\x1f\0.\0\xfc\xff\xeb\xff\xf2\xff\xef\xff\\\x04\xb0\x04\x04\x05X\x05\xac\x05\0\x06T\x06\xa8\x06\xfc\x06P\x07\xa4\x07\xf8\x07L\b\xa0\b\xf4\bH\t\x9c\t\xf0\tD\n\x98\n\xec\n@\x0b\x94\x0b\xe8\x0b<\f\x90\f\xe4\f8\r\x8c\r\xe0\r4\x0e\x88\x0e\xdc\x0e0\x0f\x84\x0f\xd8\x0f,\x10\x80\x10\xd4\x10(\x11|\x11\xd0\x11$\x12x\x12\xcc\x12 \x13t\x13\xc8\x13\x1c\x14"),
       caml_new_string
        ('\xff\xff\xff\xff\xff\xff%\0$\0$\0$\0$\0%\0$\0$\0$\0$\0$\0$\0\xff\xff\xff\xff\xff\xff\x0f\0\x0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0&\0&\0\xff\xff\x01\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x17\0\x15\0!\0$\0$\0\x16\0$\0$\0$\0\x1c\0$\0$\0\x18\0$\0$\0$\0\x19\0$\0$\0$\0\x1e\0$\0$\0\x1a\0$\0$\0$\0$\0$\0\x1b\0$\0$\0#\0%\0%\0%\0%\0\x1d\0$\0$\0$\0$\0\x1f\0$\0$\0 \0$\0$\0"\0'),
       caml_new_string
        ("\x02\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_new_string
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0\x1f\0\x1f\0\0\0 \0!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0\0\0\0\0\x1e\0\0\0!\0\0\0\0\0\x1a\0\x19\0\x10\0\x1b\0\x14\0\x1d\0\x11\0\0\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x12\0-\0\x16\0\x13\0\x15\0\x0f\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\b\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x06\0\x04\0\x04\0\x0b\0\x07\0\x04\0\x04\0\x0e\0\x04\0\x04\0\r\0\x04\0\x04\0\x04\0\n\0\x04\0\x04\0\x05\0\f\0\t\0\x04\0\x04\0\x04\0\x04\0\x04\0\x18\0\x03\0\x17\0,\0\x03\0'\0\"\0\x03\0$\0%\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0#\0&\0(\0)\0*\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\0\0\0\0\0\0\x04\0+\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\\\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0Y\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0T\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0O\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0F\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0C\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0<\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0;\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\x008\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\x001\0\x04\0\x04\0\x04\x002\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0.\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0/\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\x000\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\x004\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\x003\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\x005\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\x006\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\x007\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\x009\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0:\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0?\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0=\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0>\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0@\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0A\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0B\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0D\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0E\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0H\0\x04\0\x04\0G\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0L\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0I\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0J\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0K\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0M\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0N\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0P\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0\x03\0Q\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0\x03\0\x03\0\x03\0R\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0S\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0U\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0V\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0W\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0X\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0Z\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0[\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0]\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0^\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\x04\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_new_string
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0 \0\xff\xff\0\0!\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff!\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x12\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\0\0\x13\0\x03\0\"\0\x1e\0\x03\0#\0$\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x1e\0%\0'\0(\0)\0\xff\xff\xff\xff\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\xff\xff\xff\xff\xff\xff\x04\0\x1d\0\xff\xff\x04\0\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x05\0\xff\xff\xff\xff\x05\0\xff\xff\xff\xff\x05\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\xff\xff\xff\xff\x06\0\xff\xff\xff\xff\x06\0\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\x07\0\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\b\0\xff\xff\xff\xff\b\0\xff\xff\xff\xff\b\0\xff\xff\xff\xff\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\xff\xff\xff\xff\xff\xff\xff\xff\b\0\xff\xff\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\b\0\t\0\xff\xff\xff\xff\t\0\xff\xff\xff\xff\t\0\xff\xff\xff\xff\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\xff\xff\xff\xff\xff\xff\xff\xff\t\0\xff\xff\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\n\0\xff\xff\xff\xff\n\0\xff\xff\xff\xff\n\0\xff\xff\xff\xff\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\xff\xff\n\0\xff\xff\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\n\0\x0b\0\xff\xff\xff\xff\x0b\0\xff\xff\xff\xff\x0b\0\xff\xff\xff\xff\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\x0b\0\xff\xff\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\f\0\xff\xff\xff\xff\f\0\xff\xff\xff\xff\f\0\xff\xff\xff\xff\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\xff\xff\xff\xff\xff\xff\xff\xff\f\0\xff\xff\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\f\0\r\0\xff\xff\xff\xff\r\0\xff\xff\xff\xff\r\0\xff\xff\xff\xff\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\xff\xff\xff\xff\xff\xff\xff\xff\r\0\xff\xff\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\x0e\0\xff\xff\xff\xff\x0e\0\xff\xff\xff\xff\x0e\0\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\xff\xff\xff\xff\xff\xff\xff\xff\x0e\0\xff\xff\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0\x0e\0.\0\xff\xff\xff\xff.\0\xff\xff\xff\xff.\0\xff\xff\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0/\0\xff\xff\xff\xff/\0\xff\xff\xff\xff/\0\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\0\xff\xff\xff\xff0\0\xff\xff\xff\xff0\0\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\0\xff\xff\xff\xff1\0\xff\xff\xff\xff1\0\xff\xff\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff\xff\xff1\0\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x002\0\xff\xff\xff\xff2\0\xff\xff\xff\xff2\0\xff\xff\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xff\xff\xff\xff\xff\xff\xff\xff2\0\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x003\0\xff\xff\xff\xff3\0\xff\xff\xff\xff3\0\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\0\xff\xff\xff\xff4\0\xff\xff\xff\xff4\0\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\0\xff\xff\xff\xff5\0\xff\xff\xff\xff5\0\xff\xff\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x006\0\xff\xff\xff\xff6\0\xff\xff\xff\xff6\0\xff\xff\xff\xff6\x006\x006\x006\x006\x006\x006\x006\x006\x006\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff6\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\0\xff\xff\xff\xff\xff\xff\xff\xff6\0\xff\xff6\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x007\0\xff\xff\xff\xff7\0\xff\xff\xff\xff7\0\xff\xff\xff\xff7\x007\x007\x007\x007\x007\x007\x007\x007\x007\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff7\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\0\xff\xff\xff\xff\xff\xff\xff\xff7\0\xff\xff7\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x008\0\xff\xff\xff\xff8\0\xff\xff\xff\xff8\0\xff\xff\xff\xff8\x008\x008\x008\x008\x008\x008\x008\x008\x008\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\0\xff\xff\xff\xff\xff\xff\xff\xff8\0\xff\xff8\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x008\x009\0\xff\xff\xff\xff9\0\xff\xff\xff\xff9\0\xff\xff\xff\xff9\x009\x009\x009\x009\x009\x009\x009\x009\x009\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff9\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\0\xff\xff\xff\xff\xff\xff\xff\xff9\0\xff\xff9\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\x009\0:\0\xff\xff\xff\xff:\0\xff\xff\xff\xff:\0\xff\xff\xff\xff:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0\xff\xff\xff\xff\xff\xff\xff\xff:\0\xff\xff:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0:\0;\0\xff\xff\xff\xff;\0\xff\xff\xff\xff;\0\xff\xff\xff\xff;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0\xff\xff\xff\xff\xff\xff\xff\xff;\0\xff\xff;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0;\0<\0\xff\xff\xff\xff<\0\xff\xff\xff\xff<\0\xff\xff\xff\xff<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0\xff\xff\xff\xff\xff\xff\xff\xff<\0\xff\xff<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0=\0\xff\xff\xff\xff=\0\xff\xff\xff\xff=\0\xff\xff\xff\xff=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0\xff\xff\xff\xff\xff\xff\xff\xff=\0\xff\xff=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0=\0>\0\xff\xff\xff\xff>\0\xff\xff\xff\xff>\0\xff\xff\xff\xff>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0\xff\xff\xff\xff\xff\xff\xff\xff>\0\xff\xff>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0>\0?\0\xff\xff\xff\xff?\0\xff\xff\xff\xff?\0\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0@\0\xff\xff\xff\xff@\0\xff\xff\xff\xff@\0\xff\xff\xff\xff@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0A\0\xff\xff\xff\xffA\0\xff\xff\xff\xffA\0\xff\xff\xff\xffA\0A\0A\0A\0A\0A\0A\0A\0A\0A\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffA\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0\xff\xff\xff\xff\xff\xff\xff\xffA\0\xff\xffA\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0B\0\xff\xff\xff\xffB\0\xff\xff\xff\xffB\0\xff\xff\xff\xffB\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffB\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0\xff\xff\xff\xff\xff\xff\xff\xffB\0\xff\xffB\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0C\0\xff\xff\xff\xffC\0\xff\xff\xff\xffC\0\xff\xff\xff\xffC\0C\0C\0C\0C\0C\0C\0C\0C\0C\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffC\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0\xff\xff\xff\xff\xff\xff\xff\xffC\0\xff\xffC\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0C\0D\0\xff\xff\xff\xffD\0\xff\xff\xff\xffD\0\xff\xff\xff\xffD\0D\0D\0D\0D\0D\0D\0D\0D\0D\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffD\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0\xff\xff\xff\xff\xff\xff\xff\xffD\0\xff\xffD\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0D\0E\0\xff\xff\xff\xffE\0\xff\xff\xff\xffE\0\xff\xff\xff\xffE\0E\0E\0E\0E\0E\0E\0E\0E\0E\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffE\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0\xff\xff\xff\xff\xff\xff\xff\xffE\0\xff\xffE\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0E\0F\0\xff\xff\xff\xffF\0\xff\xff\xff\xffF\0\xff\xff\xff\xffF\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffF\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0\xff\xff\xff\xff\xff\xff\xff\xffF\0\xff\xffF\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0F\0G\0\xff\xff\xff\xffG\0\xff\xff\xff\xffG\0\xff\xff\xff\xffG\0G\0G\0G\0G\0G\0G\0G\0G\0G\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffG\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0\xff\xff\xff\xff\xff\xff\xff\xffG\0\xff\xffG\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0H\0\xff\xff\xff\xffH\0\xff\xff\xff\xffH\0\xff\xff\xff\xffH\0H\0H\0H\0H\0H\0H\0H\0H\0H\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0\xff\xff\xff\xff\xff\xff\xff\xffH\0\xff\xffH\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0H\0I\0\xff\xff\xff\xffI\0\xff\xff\xff\xffI\0\xff\xff\xff\xffI\0I\0I\0I\0I\0I\0I\0I\0I\0I\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0\xff\xff\xff\xff\xff\xff\xff\xffI\0\xff\xffI\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0I\0J\0\xff\xff\xff\xffJ\0\xff\xff\xff\xffJ\0\xff\xff\xff\xffJ\0J\0J\0J\0J\0J\0J\0J\0J\0J\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffJ\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0\xff\xff\xff\xff\xff\xff\xff\xffJ\0\xff\xffJ\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0J\0K\0\xff\xff\xff\xffK\0\xff\xff\xff\xffK\0\xff\xff\xff\xffK\0K\0K\0K\0K\0K\0K\0K\0K\0K\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffK\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0\xff\xff\xff\xff\xff\xff\xff\xffK\0\xff\xffK\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0K\0L\0\xff\xff\xff\xffL\0\xff\xff\xff\xffL\0\xff\xff\xff\xffL\0L\0L\0L\0L\0L\0L\0L\0L\0L\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffL\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0\xff\xff\xff\xff\xff\xff\xff\xffL\0\xff\xffL\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0L\0M\0\xff\xff\xff\xffM\0\xff\xff\xff\xffM\0\xff\xff\xff\xffM\0M\0M\0M\0M\0M\0M\0M\0M\0M\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffM\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0\xff\xff\xff\xff\xff\xff\xff\xffM\0\xff\xffM\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0N\0\xff\xff\xff\xffN\0\xff\xff\xff\xffN\0\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0N\0N\0N\0N\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffN\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0\xff\xff\xff\xff\xff\xff\xff\xffN\0\xff\xffN\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0O\0\xff\xff\xff\xffO\0\xff\xff\xff\xffO\0\xff\xff\xff\xffO\0O\0O\0O\0O\0O\0O\0O\0O\0O\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffO\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0\xff\xff\xff\xff\xff\xff\xff\xffO\0\xff\xffO\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0P\0\xff\xff\xff\xffP\0\xff\xff\xff\xffP\0\xff\xff\xff\xffP\0P\0P\0P\0P\0P\0P\0P\0P\0P\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffP\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0\xff\xff\xff\xff\xff\xff\xff\xffP\0\xff\xffP\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0Q\0\xff\xff\xff\xffQ\0\xff\xff\xff\xffQ\0\xff\xff\xff\xffQ\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffQ\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0\xff\xff\xff\xff\xff\xff\xff\xffQ\0\xff\xffQ\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0R\0\xff\xff\xff\xffR\0\xff\xff\xff\xffR\0\xff\xff\xff\xffR\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\xff\xff\xff\xff\xff\xff\xff\xffR\0\xff\xffR\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0S\0\xff\xff\xff\xffS\0\xff\xff\xff\xffS\0\xff\xff\xff\xffS\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffS\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xff\xff\xff\xff\xff\xff\xff\xffS\0\xff\xffS\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0T\0\xff\xff\xff\xffT\0\xff\xff\xff\xffT\0\xff\xff\xff\xffT\0T\0T\0T\0T\0T\0T\0T\0T\0T\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffT\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0\xff\xff\xff\xff\xff\xff\xff\xffT\0\xff\xffT\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0U\0\xff\xff\xff\xffU\0\xff\xff\xff\xffU\0\xff\xff\xff\xffU\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffU\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\xff\xff\xff\xff\xff\xff\xff\xffU\0\xff\xffU\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0V\0\xff\xff\xff\xffV\0\xff\xff\xff\xffV\0\xff\xff\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\xff\xff\xff\xff\xff\xff\xff\xffV\0\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0W\0\xff\xff\xff\xffW\0\xff\xff\xff\xffW\0\xff\xff\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\xff\xff\xff\xff\xff\xff\xff\xffW\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0X\0\xff\xff\xff\xffX\0\xff\xff\xff\xffX\0\xff\xff\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0\xff\xff\xff\xff\xff\xff\xff\xffX\0\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0Y\0\xff\xff\xff\xffY\0\xff\xff\xff\xffY\0\xff\xff\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0\xff\xff\xff\xff\xff\xff\xff\xffY\0\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Z\0\xff\xff\xff\xffZ\0\xff\xff\xff\xffZ\0\xff\xff\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0\xff\xff\xff\xff\xff\xff\xff\xffZ\0\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0[\0\xff\xff\xff\xff[\0\xff\xff\xff\xff[\0\xff\xff\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\xff\xff\xff\xff\xff\xff\xff\xff[\0\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\\\0\xff\xff\xff\xff\\\0\xff\xff\xff\xff\\\0\xff\xff\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\\\0\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0]\0\xff\xff\xff\xff]\0\xff\xff\xff\xff]\0\xff\xff\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff]\0\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0^\0\xff\xff\xff\xff^\0\xff\xff\xff\xff^\0\xff\xff\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff^\0\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string("")],
     cst$23=caml_new_string("\n"),
     cst_current_lexeme=caml_new_string("\ncurrent lexeme: "),
     cst$24=caml_new_string("\n:: "),
     cst$25=caml_new_string(" |-> "),
     cst$26=caml_new_string("{}"),
     cst_unbound_variable$0=caml_new_string("unbound variable: "),
     cst_sealprj_of_non_seal=caml_new_string("sealprj of non-seal"),
     cst_if_of_a_non_bool=caml_new_string("if of a non-bool"),
     cst_pair_pattern_match_on_non_pair=
      caml_new_string("pair pattern match on non-pair"),
     cst_non_function_proxy_in_function_application_position=
      caml_new_string("non-function/proxy in function application position"),
     cst_tried_to_unpack_a_non_pack=
      caml_new_string("tried to unpack a non-pack"),
     cst_free_type_variable=caml_new_string("free type variable: "),
     cst_tried_to_instantiate_a_non_Lambda_proxy=
      caml_new_string("tried to instantiate a non-Lambda/proxy"),
     cst_added_non_ints=caml_new_string("added non ints"),
     cst_has_tag_on_something_that_wasn_t_a_dyn_inj=
      caml_new_string("has-tag on something that wasn't a dyn inj."),
     cst_dyn_downcast_on_non_dyn_value=
      caml_new_string("dyn downcast on non-dyn value"),
     cst_to_a_type_with_tag=caml_new_string("to a type with tag"),
     cst_Tried_to_cast_something_with_tag=
      caml_new_string("Tried to cast something with tag"),
     cst_prod_cast_on_non_pair_value=
      caml_new_string("prod cast on non-pair value"),
     cst_existential_cast_on_non_castpack=
      caml_new_string("existential cast on non-castpack"),
     cst_tried_to_lookup_a_seal_that_wasn_t_allocated=
      caml_new_string("tried to lookup a seal that wasn't allocated"),
     cst_Shouldn_t_happen=caml_new_string("Shouldn't happen:"),
     st=[0,0,0],
     cst_in_let_init_p_p_in_let_flip_read_p_in_read_flip_true_X=
      caml_new_string
       ("in\nlet (init,p') = p in\nlet (flip, read) = p' in\nread (flip (#true :: ? :: X))"),
     cst_let_not_lambda_b_bool_if_b_then_false_else_true_in_unpack_X_p$0=
      caml_new_string
       ("let not = lambda b : bool. if b then #false else #true in\nunpack <X,p> = "),
     cst_in_let_init_p_p_in_let_flip_read_p_in_read_init_read_flip_init=
      caml_new_string
       ("in\nlet (init,p') = p in\nlet (flip, read) = p' in\n(read init, read (flip init))"),
     cst_let_not_lambda_b_bool_if_b_then_false_else_true_in_unpack_X_p=
      caml_new_string
       ("let not = lambda b : bool. if b then #false else #true in\nunpack <X,p> = "),
     cst_X_int_Y_bool_seal_X_42_seal_Y_true_in_unseal_Y_y_unseal_X_x=
      caml_new_string
       (" {X =~ int}{Y =~ bool}(seal X 42, seal Y #true) in\n(unseal Y y, unseal X x)"),
     cst_let_y_x$0=caml_new_string("let (y,x) = "),
     cst_X_bool_Y_int_seal_X_true_seal_Y_42_in_unseal_X_x_unseal_Y_y=
      caml_new_string
       (" {X =~ bool}{Y =~ int}(seal X #true, seal Y 42) in\n(unseal X x, unseal Y y)"),
     cst_let_y_x=caml_new_string("let (y,x) = "),
     cst_X_int_seal_X_5_in_true=
      caml_new_string(" {X =~ int} (seal X 5) in\n#true"),
     cst_let_y=caml_new_string("let y = "),
     cst_X_bool_seal_X_true=caml_new_string(" {X =~ bool} (seal X #true))"),
     cst_unseal_X=caml_new_string("unseal X ("),
     unseeable=
      caml_new_string
       ("unpack <Y, y> = pack<X =~ bool, seal X #true> in y :: ?"),
     cst_bool$1=caml_new_string(" :: bool"),
     bool=caml_new_string("let x = #true in if x then #false else x"),
     pair=
      caml_new_string
       ("let (x,y) = (#true, #false) in (x, if y then x else y)"),
     exist_fun=
      caml_new_string
       ("unpack <Y, y> = pack<X =~ bool, (lambda x : X. unseal X x, seal X #true)> in let (f, b) = y in f b"),
     ex_incompat=
      caml_new_string
       ("let f = lambda b : bool. pack<X =~ bool, seal X b> in\n   unpack <Y, y> = f #true in\n   unpack <Z, z> = f #false in\n   y :: ? :: Z :: ?"),
     fun_cast=
      caml_new_string
       ("let f = (lambda b : bool. (b, b)) :: ? -> ? in f #true"),
     paper_1_noseal=
      caml_new_string("((Lambda X. lambda x : X. x) {X =~ int} 1) + 3"),
     paper_1_seal=
      caml_new_string
       ("unseal X ((Lambda X. lambda x : X. x) {X =~ int} (seal X 1)) + 3"),
     paper_2_noseal=
      caml_new_string("((Lambda X. lambda x : X. x) :: ?) {X =~ int} #true"),
     paper_2_seal=
      caml_new_string
       ("unseal X (((Lambda X. lambda x : X. x) :: ?) {X =~ int} (seal X #true))"),
     paper_3_noseal=
      caml_new_string
       ("((Lambda X. lambda x : X. x) :: forall X. ? -> X) {X =~ int} 5"),
     paper_3_seal=
      caml_new_string
       ("unseal X (((Lambda X. lambda x : X. x) :: forall X. ? -> X) {X =~ int} (seal X 5))"),
     paper_4_noseal=
      caml_new_string
       ("((Lambda X. lambda x : X. #true) :: forall X. ? -> bool) {X =~ int} 5"),
     paper_4_seal=
      caml_new_string
       ("((Lambda X. lambda x : X. #true) :: forall X. ? -> bool) {X =~ int} (seal X 5)"),
     paper_5_noseal=
      caml_new_string
       ("((Lambda X. lambda x : X. #true) :: forall X. ? -> bool) {X =~ bool} 5"),
     paper_5_seal=
      caml_new_string
       ("((Lambda X. lambda x : X. #true) :: forall X. ? -> bool) {X =~ bool} (seal X 5)"),
     paper_6_noseal=
      caml_new_string
       ("((Lambda X. lambda x : ?. #true) :: forall X. ? -> bool) {X =~ bool} 5"),
     paper_6_seal=
      caml_new_string
       ("((Lambda X. lambda x : ?. #true) :: forall X. ? -> bool) {X =~ bool} (seal X 5)"),
     good_id_init=caml_new_string("let id = (Lambda X. lambda x : X. x) in\n"),
     bad_id_init=
      caml_new_string
       ("let bad_id = (Lambda X. lambda x : X. #true :: ? :: X) in\n"),
     cst_id=caml_new_string("id"),
     cst_id$0=caml_new_string("id"),
     cst_bad_id=caml_new_string("bad_id"),
     cst_bad_id$0=caml_new_string("bad_id"),
     good_swap_init=
      caml_new_string
       ("let swap = (Lambda X. Lambda Y. lambda p : X * Y. let (x,y) = p in (y,x)) in\n"),
     bad_swap_init=
      caml_new_string
       ("let bad_swap = (Lambda X. Lambda Y. lambda p : X * Y. let (x, y) = p in (y, y :: ? :: X)) in\n"),
     cst_swap=caml_new_string("swap"),
     cst_swap$0=caml_new_string("swap"),
     cst_bad_swap=caml_new_string("bad_swap"),
     cst_bad_swap$0=caml_new_string("bad_swap"),
     flipper_p_1=
      caml_new_string
       ("pack <X =~ bool, (seal X #true, (lambda x : X. seal X (not (unseal X x)), lambda x : X. unseal X x))>"),
     flipper_p_2=
      caml_new_string
       ("pack <X =~ bool, (seal X #false, (lambda x : X. seal X (not (unseal X x)), lambda x : X. not (unseal X x)))>"),
     Stdlib_format=global_data.Stdlib__format,
     Stdlib=global_data.Stdlib,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_buffer=global_data.Stdlib__buffer,
     PPrint=global_data.PPrint,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_map=global_data.Stdlib__map,
     MenhirLib=global_data.MenhirLib,
     Stdlib_lexing=global_data.Stdlib__lexing,
     Stdlib_printf=global_data.Stdlib__printf,
     PolyGNew=[0];
    caml_register_global(487,PolyGNew,"PolyGNew");
    var
     _a_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _b_=[0,[15,0],caml_new_string("%a")],
     _c_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _d_=[0,[15,0],caml_new_string("%a")],
     _aa_=[0,0,1],
     _ab_=[0,1,2],
     _ac_=[0,[0,1,1,1]],
     _ad_=[0,[0,2,2,2]],
     _$_=[0,[15,0],caml_new_string("%a")],
     _I_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.DynInj ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.DynInj (@,")],
     _J_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _K_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _L_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.NameRefl"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Gtypes.NameRefl@ ")],
     _M_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _N_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.ProdPrec ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.ProdPrec (@,")],
     _O_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _P_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _Q_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.FunPrec ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.FunPrec (@,")],
     _R_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _S_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _T_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.FrexistsPrec ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.FrexistsPrec (@,")],
     _U_=[0,[3,0,0],caml_new_string("%S")],
     _V_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _W_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _X_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.FrforallPrec ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.FrforallPrec (@,")],
     _Y_=[0,[3,0,0],caml_new_string("%S")],
     _Z_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     ___=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _E_=[1,0,0],
     _F_=[2,0,0],
     _G_=[3,caml_new_string("_"),0],
     _H_=[4,caml_new_string("_"),0],
     _D_=[0,[15,0],caml_new_string("%a")],
     _n_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.Name"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Gtypes.Name@ ")],
     _o_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _p_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.Times ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.Times (@,")],
     _q_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _r_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _s_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.Fun ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.Fun (@,")],
     _t_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _u_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _v_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.Frexists ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.Frexists (@,")],
     _w_=[0,[3,0,0],caml_new_string("%S")],
     _x_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _y_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _z_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.Frforall ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Gtypes.Frforall (@,")],
     _A_=[0,[3,0,0],caml_new_string("%S")],
     _B_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _C_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _m_=[0,[15,0],caml_new_string("%a")],
     _k_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.Nametag"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Gtypes.Nametag@ ")],
     _l_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _j_=[0,[15,0],caml_new_string("%a")],
     _e_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.SealName"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Gtypes.SealName@ ")],
     _f_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _g_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Gtypes.VarName"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Gtypes.VarName@ ")],
     _h_=[0,[3,0,0],caml_new_string("%S")],
     _i_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _ae_=[0,[15,0],caml_new_string("%a")],
     _bN_=[0,[15,0],caml_new_string("%a")],
     _bn_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _bo_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bp_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bq_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _bh_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _bi_=[0,[3,0,0],caml_new_string("%S")],
     _bj_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bk_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _a__=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _a$_=[0,[3,0,0],caml_new_string("%S")],
     _ba_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bb_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bc_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _a9_=
      [0,[12,59,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(";@ ")],
     _a8_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
        [12,91,0]],
       caml_new_string("@[<2>[")],
     _bd_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[12,93,[17,0,0]]],
       caml_new_string("@,]@]")],
     _af_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,caml_new_string("CC.TmVar"),[17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>CC.TmVar@ ")],
     _ag_=[0,[3,0,0],caml_new_string("%S")],
     _ah_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _ai_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,caml_new_string("CC.Let ("),[17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Let (@,")],
     _aj_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _ak_=[0,[3,0,0],caml_new_string("%S")],
     _al_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _am_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _an_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Sealinj ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Sealinj (@,")],
     _ao_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _ap_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _aq_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Sealprj ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Sealprj (@,")],
     _ar_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _as_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _at_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Boollit"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>CC.Boollit@ ")],
     _au_=[0,[9,0,0],caml_new_string("%B")],
     _av_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _aw_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,caml_new_string("CC.If ("),[17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.If (@,")],
     _ax_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _ay_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _az_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _aA_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Pair ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Pair (@,")],
     _aB_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aC_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _aD_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.PmPair ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.PmPair (@,")],
     _aE_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aF_=[0,[3,0,0],caml_new_string("%S")],
     _aG_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aH_=[0,[3,0,0],caml_new_string("%S")],
     _aI_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aJ_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _aK_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,caml_new_string("CC.Fun ("),[17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Fun (@,")],
     _aL_=[0,[3,0,0],caml_new_string("%S")],
     _aM_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aN_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aO_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _aP_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.FunApp ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.FunApp (@,")],
     _aQ_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aR_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _aS_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Pack ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Pack (@,")],
     _aT_=[0,[3,0,0],caml_new_string("%S")],
     _aU_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aV_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aW_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _aX_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Unpack ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Unpack (@,")],
     _aY_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _aZ_=[0,[3,0,0],caml_new_string("%S")],
     _a0_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _a1_=[0,[3,0,0],caml_new_string("%S")],
     _a2_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _a3_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _a4_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.CastPack ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.CastPack (@,")],
     _a5_=[0,[3,0,0],caml_new_string("%S")],
     _a6_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _a7_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _be_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bf_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _bg_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.BigLambda"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>CC.BigLambda@ ")],
     _bl_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _bm_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,caml_new_string("CC.Inst"),[17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>CC.Inst@ ")],
     _br_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _bs_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Hide ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Hide (@,")],
     _bt_=[0,[3,0,0],caml_new_string("%S")],
     _bu_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bv_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bw_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _bx_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Cast ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Cast (@,")],
     _by_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bz_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bA_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _bB_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Dinj ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Dinj (@,")],
     _bC_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bD_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _bE_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,caml_new_string("CC.Int"),[17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>CC.Int@ ")],
     _bF_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bG_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _bH_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.Plus ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.Plus (@,")],
     _bI_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bJ_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _bK_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("CC.HasTag ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>CC.HasTag (@,")],
     _bL_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _bM_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _bO_=[0,[3,0,0],caml_new_string("%S")],
     _bP_=[0,[15,0],caml_new_string("%a")],
     _bQ_=[0,[3,0,0],caml_new_string("%S")],
     _bR_=[0,[15,0],caml_new_string("%a")],
     _bS_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
        [11,caml_new_string("{ "),0]],
       caml_new_string("@[<2>{ ")],
     _bT_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [2,0,[11,caml_new_string(" ="),[17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("@[%s =@ ")],
     _bU_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bV_=[0,[17,0,0],caml_new_string("@]")],
     _bW_=
      [0,[12,59,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(";@ ")],
     _bX_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [2,0,[11,caml_new_string(" ="),[17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("@[%s =@ ")],
     _bY_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bZ_=[0,[17,0,0],caml_new_string("@]")],
     _b0_=
      [0,
       [17,[0,caml_new_string("@ "),1,0],[12,125,[17,0,0]]],
       caml_new_string("@ }@]")],
     _b1_=[0,[15,0],caml_new_string("%a")],
     _c9_=[0,[15,0],caml_new_string("%a")],
     _cY_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _cZ_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _c0_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _c1_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _cT_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _cU_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cV_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _b6_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.TmVar"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Surf.TmVar@ ")],
     _b7_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _b8_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Let ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Let (@,")],
     _b9_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _b__=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _b$_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _ca_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Sealinj ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Sealinj (@,")],
     _cb_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cc_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cd_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Sealprj ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Sealprj (@,")],
     _ce_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cf_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cg_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Boollit"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Surf.Boollit@ ")],
     _ch_=[0,[9,0,0],caml_new_string("%B")],
     _ci_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _cj_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.If ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.If (@,")],
     _ck_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cl_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cm_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cn_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,caml_new_string("Surf.Int"),[17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Surf.Int@ ")],
     _co_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _cp_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _cq_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Plus ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Plus (@,")],
     _cr_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cs_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _ct_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Pair ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Pair (@,")],
     _cu_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cv_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cw_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.PmPair ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.PmPair (@,")],
     _cx_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cy_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cz_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cA_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cB_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Fun ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Fun (@,")],
     _cC_=[0,[3,0,0],caml_new_string("%S")],
     _cD_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cE_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cF_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cG_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.FunApp ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.FunApp (@,")],
     _cH_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cI_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cJ_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Pack ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Pack (@,")],
     _cK_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cL_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cM_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cN_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Unpack ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Unpack (@,")],
     _cO_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cP_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cQ_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _cR_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _cS_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.BigLambda"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Surf.BigLambda@ ")],
     _cW_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _cX_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Inst"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>Surf.Inst@ ")],
     _c2_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _c3_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.Ann ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.Ann (@,")],
     _c4_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _c5_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _c6_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("Surf.HasTag ("),
          [17,[0,caml_new_string("@,"),0,0],0]]]],
       caml_new_string("(@[<2>Surf.HasTag (@,")],
     _c7_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _c8_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[11,caml_new_string("))"),[17,0,0]]],
       caml_new_string("@,))@]")],
     _b5_=[0,[15,0],caml_new_string("%a")],
     _b2_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _b3_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _b4_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _c$_=[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]],
     _da_=[0,2,[0,3,0]],
     _db_=[0,2,[0,3,0]],
     _dc_=[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]],
     _dd_=[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]],
     _de_=[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]],
     _df_=[0,2,[0,3,0]],
     _dg_=[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]],
     _dh_=[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]],
     _di_=[0,2,[0,3,[0,4,0]]],
     _dj_=[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]],
     _dk_=[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]],
     _dl_=[0,2,[0,3,[0,4,0]]],
     _dm_=[0,1,[0,2,[0,3,0]]],
     _dn_=[0,2,[0,3,0]],
     _dZ_=[0,0],
     _dY_=[0,0],
     _dX_=[0,[0,caml_new_string("_"),0]],
     _dW_=[0,[0,caml_new_string("_"),0]],
     _dV_=[0,[0,0,0]],
     _dU_=[0,[0,0,0]],
     _dR_=[0,0],
     _dS_=[0,0],
     _dT_=[0,0],
     _dQ_=[0,[15,0],caml_new_string("%a")],
     _dM_=
      [0,[12,59,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(";@ ")],
     _dL_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
        [12,91,0]],
       caml_new_string("@[<2>[")],
     _dN_=
      [0,
       [17,[0,caml_new_string("@,"),0,0],[12,93,[17,0,0]]],
       caml_new_string("@,]@]")],
     _dK_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _dO_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _dP_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _dJ_=[0,[15,0],caml_new_string("%a")],
     _dF_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _dG_=[0,[3,0,0],caml_new_string("%S")],
     _dH_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _dI_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _dE_=[0,[15,0],caml_new_string("%a")],
     _dw_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _dx_=[0,[3,0,0],caml_new_string("%S")],
     _dy_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _dz_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _dq_=
      [0,[12,40,[18,[1,[0,0,caml_new_string("")]],0]],caml_new_string("(@[")],
     _dr_=[0,[3,0,0],caml_new_string("%S")],
     _ds_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _dt_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _dp_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("TcElab.TmVar"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>TcElab.TmVar@ ")],
     _du_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _dv_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("TcElab.KnownTyVar"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>TcElab.KnownTyVar@ ")],
     _dA_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _dB_=
      [0,
       [12,
        40,
        [18,
         [1,[0,[11,caml_new_string("<2>"),0],caml_new_string("<2>")]],
         [11,
          caml_new_string("TcElab.UnknownTyVar"),
          [17,[0,caml_new_string("@ "),1,0],0]]]],
       caml_new_string("(@[<2>TcElab.UnknownTyVar@ ")],
     _dC_=[0,[3,0,0],caml_new_string("%S")],
     _dD_=[0,[17,0,[12,41,0]],caml_new_string("@])")],
     _eq_=[4,1],
     _eo_=[4,0],
     _eC_=
      [0,
       [11,
        caml_new_string("line "),
        [4,0,0,0,[11,caml_new_string(", starting at character "),[4,0,0,0,0]]]],
       caml_new_string("line %d, starting at character %d")],
     _eD_=[4,1],
     _eE_=[4,0];
    function pp_supply(fmt,x)
     {caml_call2(Stdlib_format[13],fmt,cst_ref);
      var _pD_=x[1];
      caml_call1(caml_call2(Stdlib_format[123],fmt,_a_),_pD_);
      return caml_call2(Stdlib_format[13],fmt,cst)}
    function show_supply(x)
     {return caml_call3(Stdlib_format[127],_b_,pp_supply,x)}
    function init_supply(param){return [0,0]}
    function tyVar(supp)
     {var n=supp[1];
      supp[1] = n + 1 | 0;
      var _pC_=caml_call1(Stdlib[33],n);
      return caml_call2(Stdlib[28],cst_fresh,_pC_)}
    var PolyGNew_Fresh=[0,pp_supply,show_supply,init_supply,tyVar];
    caml_register_global(490,PolyGNew_Fresh,"PolyGNew__Fresh");
    function pp_seal(fmt){return caml_call2(Stdlib_format[123],fmt,_c_)}
    function show_seal(x){return caml_call3(Stdlib_format[127],_d_,pp_seal,x)}
    function equal_seal(a,b){return a === b?1:0}
    var
     pp_tyname=function _pB_(_pz_,_pA_){return _pB_.fun(_pz_,_pA_)},
     show_tyname=function _py_(_px_){return _py_.fun(_px_)};
    caml_update_dummy
     (pp_tyname,
      function(fmt,param)
       {if(0 === param[0])
         {var a0=param[1];
          caml_call2(Stdlib_format[123],fmt,_e_);
          caml_call1(pp_seal(fmt),a0);
          return caml_call2(Stdlib_format[123],fmt,_f_)}
        var a0$0=param[1];
        caml_call2(Stdlib_format[123],fmt,_g_);
        caml_call1(caml_call2(Stdlib_format[123],fmt,_h_),a0$0);
        return caml_call2(Stdlib_format[123],fmt,_i_)});
    caml_update_dummy
     (show_tyname,
      function(x){return caml_call3(Stdlib_format[127],_j_,pp_tyname,x)});
    var equal_tyname=function _pw_(_pu_,_pv_){return _pw_.fun(_pu_,_pv_)};
    caml_update_dummy
     (equal_tyname,
      function(lhs,match)
       {if(0 === lhs[0])
         {var _ps_=lhs[1];
          if(0 === match[0]){var rhs0=match[1];return _ps_ === rhs0?1:0}}
        else
         {var _pt_=lhs[1];
          if(0 !== match[0])
           {var rhs0$0=match[1];return caml_string_equal(_pt_,rhs0$0)}}
        return 0});
    var
     pp_tagty=function _pr_(_pp_,_pq_){return _pr_.fun(_pp_,_pq_)},
     show_tagty=function _po_(_pn_){return _po_.fun(_pn_)};
    caml_update_dummy
     (pp_tagty,
      function(fmt,param)
       {if(typeof param === "number")
         switch(param)
          {case 0:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Booltag);
           case 1:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Numtag);
           case 2:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Prodtag);
           case 3:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Funtag);
           case 4:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Extag);
           default:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Alltag)}
        var a0=param[1];
        caml_call2(Stdlib_format[123],fmt,_k_);
        caml_call1(caml_call1(pp_tyname,fmt),a0);
        return caml_call2(Stdlib_format[123],fmt,_l_)});
    caml_update_dummy
     (show_tagty,
      function(x){return caml_call3(Stdlib_format[127],_m_,pp_tagty,x)});
    var equal_tagty=function _pm_(_pk_,_pl_){return _pm_.fun(_pk_,_pl_)};
    caml_update_dummy
     (equal_tagty,
      function(lhs,match)
       {if(typeof lhs === "number")
         switch(lhs)
          {case 0:if(typeof match === "number")if(0 === match)return 1;break;
           case 1:if(typeof match === "number")if(1 === match)return 1;break;
           case 2:if(typeof match === "number")if(2 === match)return 1;break;
           case 3:if(typeof match === "number")if(3 === match)return 1;break;
           case 4:if(typeof match === "number")if(4 === match)return 1;break;
           default:if(typeof match === "number")if(5 <= match)return 1}
        else
         if(typeof match !== "number")
          {var rhs0=match[1],lhs0=lhs[1];
           return caml_call1(caml_call1(equal_tyname,lhs0),rhs0)}
        return 0});
    var
     pp_gtype=function _pj_(_ph_,_pi_){return _pj_.fun(_ph_,_pi_)},
     show_gtype=function _pg_(_pf_){return _pg_.fun(_pf_)};
    caml_update_dummy
     (pp_gtype,
      function(fmt,param)
       {if(typeof param === "number")
         switch(param)
          {case 0:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Dyn);
           case 1:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Bool);
           default:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_Num)}
        else
         switch(param[0])
          {case 0:
            var a0=param[1];
            caml_call2(Stdlib_format[123],fmt,_n_);
            caml_call1(caml_call1(pp_tyname,fmt),a0);
            return caml_call2(Stdlib_format[123],fmt,_o_);
           case 1:
            var a1=param[2],a0$0=param[1];
            caml_call2(Stdlib_format[123],fmt,_p_);
            caml_call1(caml_call1(pp_gtype,fmt),a0$0);
            caml_call2(Stdlib_format[123],fmt,_q_);
            caml_call1(caml_call1(pp_gtype,fmt),a1);
            return caml_call2(Stdlib_format[123],fmt,_r_);
           case 2:
            var a1$0=param[2],a0$1=param[1];
            caml_call2(Stdlib_format[123],fmt,_s_);
            caml_call1(caml_call1(pp_gtype,fmt),a0$1);
            caml_call2(Stdlib_format[123],fmt,_t_);
            caml_call1(caml_call1(pp_gtype,fmt),a1$0);
            return caml_call2(Stdlib_format[123],fmt,_u_);
           case 3:
            var a1$1=param[2],a0$2=param[1];
            caml_call2(Stdlib_format[123],fmt,_v_);
            caml_call1(caml_call2(Stdlib_format[123],fmt,_w_),a0$2);
            caml_call2(Stdlib_format[123],fmt,_x_);
            caml_call1(caml_call1(pp_gtype,fmt),a1$1);
            return caml_call2(Stdlib_format[123],fmt,_y_);
           default:
            var a1$2=param[2],a0$3=param[1];
            caml_call2(Stdlib_format[123],fmt,_z_);
            caml_call1(caml_call2(Stdlib_format[123],fmt,_A_),a0$3);
            caml_call2(Stdlib_format[123],fmt,_B_);
            caml_call1(caml_call1(pp_gtype,fmt),a1$2);
            return caml_call2(Stdlib_format[123],fmt,_C_)}});
    caml_update_dummy
     (show_gtype,
      function(x){return caml_call3(Stdlib_format[127],_D_,pp_gtype,x)});
    var equal_gtype=function _pe_(_pc_,_pd_){return _pe_.fun(_pc_,_pd_)};
    caml_update_dummy
     (equal_gtype,
      function(lhs,match)
       {if(typeof lhs === "number")
         switch(lhs)
          {case 0:if(typeof match === "number")if(0 === match)return 1;break;
           case 1:if(typeof match === "number")if(1 === match)return 1;break;
           default:if(typeof match === "number")if(2 <= match)return 1}
        else
         switch(lhs[0])
          {case 0:
            if(typeof match !== "number" && 0 === match[0])
             {var rhs0=match[1],lhs0=lhs[1];
              return caml_call1(caml_call1(equal_tyname,lhs0),rhs0)}
            break;
           case 1:
            if(typeof match !== "number" && 1 === match[0])
             {var
               rhs1=match[2],
               rhs0$0=match[1],
               lhs1=lhs[2],
               lhs0$0=lhs[1],
               _o__=caml_call1(caml_call1(equal_gtype,lhs0$0),rhs0$0);
              return _o__?caml_call1(caml_call1(equal_gtype,lhs1),rhs1):_o__}
            break;
           case 2:
            if(typeof match !== "number" && 2 === match[0])
             {var
               rhs1$0=match[2],
               rhs0$1=match[1],
               lhs1$0=lhs[2],
               lhs0$1=lhs[1],
               _o$_=caml_call1(caml_call1(equal_gtype,lhs0$1),rhs0$1);
              return _o$_
                      ?caml_call1(caml_call1(equal_gtype,lhs1$0),rhs1$0)
                      :_o$_}
            break;
           case 3:
            if(typeof match !== "number" && 3 === match[0])
             {var
               rhs1$1=match[2],
               rhs0$2=match[1],
               lhs1$1=lhs[2],
               lhs0$2=lhs[1],
               _pa_=caml_string_equal(lhs0$2,rhs0$2);
              return _pa_
                      ?caml_call1(caml_call1(equal_gtype,lhs1$1),rhs1$1)
                      :_pa_}
            break;
           default:
            if(typeof match !== "number" && 4 === match[0])
             {var
               rhs1$2=match[2],
               rhs0$3=match[1],
               lhs1$2=lhs[2],
               lhs0$3=lhs[1],
               _pb_=caml_string_equal(lhs0$3,rhs0$3);
              return _pb_
                      ?caml_call1(caml_call1(equal_gtype,lhs1$2),rhs1$2)
                      :_pb_}}
        return 0});
    function tyvar(x){return [0,[1,x]]}
    function renameTyVar(fromTy,toTy,supp)
     {function f(ty)
       {if(typeof ty !== "number")
         switch(ty[0])
          {case 0:
            var _o7_=ty[1];
            if(0 !== _o7_[0])
             {var tyZ=_o7_[1],toTy$0=caml_string_equal(tyZ,fromTy)?toTy:tyZ;
              return [0,[1,toTy$0]]}
            break;
           case 1:var b=ty[2],a=ty[1],_o8_=f(b);return [1,f(a),_o8_];
           case 2:var b$0=ty[2],a$0=ty[1],_o9_=f(b$0);return [2,f(a$0),_o9_];
           case 3:
            var a$1=ty[2],tyZ$0=ty[1],tyZ$1=tyVar(supp);
            return [3,tyZ$1,f(caml_call1(renameTyVar(tyZ$0,tyZ$1,supp),a$1))];
           default:
            var a$2=ty[2],tyZ$2=ty[1],tyZ$3=tyVar(supp);
            return [4,tyZ$3,f(caml_call1(renameTyVar(tyZ$2,tyZ$3,supp),a$2))]}
        return ty}
      return f}
    function typ_from_tag(param)
     {if(typeof param === "number")
       switch(param)
        {case 0:return 1;
         case 1:return 2;
         case 2:return _E_;
         case 3:return _F_;
         case 4:return _G_;
         default:return _H_}
      var nm=param[1];
      return [0,nm]}
    var
     pp_precision=function _o6_(_o4_,_o5_){return _o6_.fun(_o4_,_o5_)},
     show_precision=function _o3_(_o2_){return _o3_.fun(_o2_)};
    caml_update_dummy
     (pp_precision,
      function(fmt,param)
       {if(typeof param === "number")
         switch(param)
          {case 0:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_DynRefl);
           case 1:
            return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_BoolRefl);
           default:return caml_call2(Stdlib_format[13],fmt,cst_Gtypes_NumRefl)}
        else
         switch(param[0])
          {case 0:
            var a1=param[2],a0=param[1];
            caml_call2(Stdlib_format[123],fmt,_I_);
            caml_call1(caml_call1(pp_tagty,fmt),a0);
            caml_call2(Stdlib_format[123],fmt,_J_);
            caml_call1(caml_call1(pp_precision,fmt),a1);
            return caml_call2(Stdlib_format[123],fmt,_K_);
           case 1:
            var a0$0=param[1];
            caml_call2(Stdlib_format[123],fmt,_L_);
            caml_call1(caml_call1(pp_tyname,fmt),a0$0);
            return caml_call2(Stdlib_format[123],fmt,_M_);
           case 2:
            var a1$0=param[2],a0$1=param[1];
            caml_call2(Stdlib_format[123],fmt,_N_);
            caml_call1(caml_call1(pp_precision,fmt),a0$1);
            caml_call2(Stdlib_format[123],fmt,_O_);
            caml_call1(caml_call1(pp_precision,fmt),a1$0);
            return caml_call2(Stdlib_format[123],fmt,_P_);
           case 3:
            var a1$1=param[2],a0$2=param[1];
            caml_call2(Stdlib_format[123],fmt,_Q_);
            caml_call1(caml_call1(pp_precision,fmt),a0$2);
            caml_call2(Stdlib_format[123],fmt,_R_);
            caml_call1(caml_call1(pp_precision,fmt),a1$1);
            return caml_call2(Stdlib_format[123],fmt,_S_);
           case 4:
            var a1$2=param[2],a0$3=param[1];
            caml_call2(Stdlib_format[123],fmt,_T_);
            caml_call1(caml_call2(Stdlib_format[123],fmt,_U_),a0$3);
            caml_call2(Stdlib_format[123],fmt,_V_);
            caml_call1(caml_call1(pp_precision,fmt),a1$2);
            return caml_call2(Stdlib_format[123],fmt,_W_);
           default:
            var a1$3=param[2],a0$4=param[1];
            caml_call2(Stdlib_format[123],fmt,_X_);
            caml_call1(caml_call2(Stdlib_format[123],fmt,_Y_),a0$4);
            caml_call2(Stdlib_format[123],fmt,_Z_);
            caml_call1(caml_call1(pp_precision,fmt),a1$3);
            return caml_call2(Stdlib_format[123],fmt,___)}});
    caml_update_dummy
     (show_precision,
      function(x){return caml_call3(Stdlib_format[127],_$_,pp_precision,x)});
    var equal_precision=function _o1_(_oZ_,_o0_){return _o1_.fun(_oZ_,_o0_)};
    caml_update_dummy
     (equal_precision,
      function(lhs,match)
       {if(typeof lhs === "number")
         switch(lhs)
          {case 0:if(typeof match === "number")if(0 === match)return 1;break;
           case 1:if(typeof match === "number")if(1 === match)return 1;break;
           default:if(typeof match === "number")if(2 <= match)return 1}
        else
         switch(lhs[0])
          {case 0:
            if(typeof match !== "number" && 0 === match[0])
             {var
               rhs1=match[2],
               rhs0=match[1],
               lhs1=lhs[2],
               lhs0=lhs[1],
               _oU_=caml_call1(caml_call1(equal_tagty,lhs0),rhs0);
              return _oU_
                      ?caml_call1(caml_call1(equal_precision,lhs1),rhs1)
                      :_oU_}
            break;
           case 1:
            if(typeof match !== "number" && 1 === match[0])
             {var rhs0$0=match[1],lhs0$0=lhs[1];
              return caml_call1(caml_call1(equal_tyname,lhs0$0),rhs0$0)}
            break;
           case 2:
            if(typeof match !== "number" && 2 === match[0])
             {var
               rhs1$0=match[2],
               rhs0$1=match[1],
               lhs1$0=lhs[2],
               lhs0$1=lhs[1],
               _oV_=caml_call1(caml_call1(equal_precision,lhs0$1),rhs0$1);
              return _oV_
                      ?caml_call1(caml_call1(equal_precision,lhs1$0),rhs1$0)
                      :_oV_}
            break;
           case 3:
            if(typeof match !== "number" && 3 === match[0])
             {var
               rhs1$1=match[2],
               rhs0$2=match[1],
               lhs1$1=lhs[2],
               lhs0$2=lhs[1],
               _oW_=caml_call1(caml_call1(equal_precision,lhs0$2),rhs0$2);
              return _oW_
                      ?caml_call1(caml_call1(equal_precision,lhs1$1),rhs1$1)
                      :_oW_}
            break;
           case 4:
            if(typeof match !== "number" && 4 === match[0])
             {var
               rhs1$2=match[2],
               rhs0$3=match[1],
               lhs1$2=lhs[2],
               lhs0$3=lhs[1],
               _oX_=caml_string_equal(lhs0$3,rhs0$3);
              return _oX_
                      ?caml_call1(caml_call1(equal_precision,lhs1$2),rhs1$2)
                      :_oX_}
            break;
           default:
            if(typeof match !== "number" && 5 === match[0])
             {var
               rhs1$3=match[2],
               rhs0$4=match[1],
               lhs1$3=lhs[2],
               lhs0$4=lhs[1],
               _oY_=caml_string_equal(lhs0$4,rhs0$4);
              return _oY_
                      ?caml_call1(caml_call1(equal_precision,lhs1$3),rhs1$3)
                      :_oY_}}
        return 0});
    function refl(param)
     {if(typeof param === "number")
       switch(param){case 0:return 0;case 1:return 1;default:return 2}
      else
       switch(param[0])
        {case 0:var nm=param[1];return [1,nm];
         case 1:
          var b=param[2],a=param[1],_oS_=refl(b);return [2,refl(a),_oS_];
         case 2:
          var b$0=param[2],a$0=param[1],_oT_=refl(b$0);
          return [3,refl(a$0),_oT_];
         case 3:var a$1=param[2],x=param[1];return [4,x,refl(a$1)];
         default:var a$2=param[2],x$0=param[1];return [5,x$0,refl(a$2)]}}
    function dynTop(param)
     {if(typeof param === "number")
       switch(param){case 0:return 0;case 1:return _aa_;default:return _ab_}
      else
       switch(param[0])
        {case 0:var nm=param[1];return [0,[0,nm],[1,nm]];
         case 1:
          var b=param[2],a=param[1],_oQ_=dynTop(b);
          return [0,2,[2,dynTop(a),_oQ_]];
         case 2:
          var b$0=param[2],a$0=param[1],_oR_=dynTop(b$0);
          return [0,3,[3,dynTop(a$0),_oR_]];
         case 3:var a$1=param[2],x=param[1];return [0,4,[4,x,dynTop(a$1)]];
         default:
          var a$2=param[2],x$0=param[1];return [0,5,[5,x$0,dynTop(a$2)]]}}
    function obind(m,k){if(m){var x=m[1];return caml_call1(k,x)}return 0}
    function mkMeet(a,match,supp)
     {if(typeof a === "number")
       switch(a)
        {case 0:var _ot_=refl(match);return [0,[0,match,dynTop(match),_ot_]];
         case 1:
          if(typeof match === "number")
           switch(match)
            {case 1:return _ac_;
             case 0:var switch$0=0;break;
             default:var switch$0=1}
          else
           var switch$0=1;
          break;
         default:
          if(typeof match === "number")
           switch(match)
            {case 2:return _ad_;
             case 0:var switch$0=0;break;
             default:var switch$0=1}
          else
           var switch$0=1}
      else
       switch(a[0])
        {case 0:
          var _ov_=a[1];
          if(0 === _ov_[0])
           {var _ow_=_ov_[1];
            if(typeof match === "number")
             if(0 === match)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(0 === match[0])
              {var _ox_=match[1];
               if(0 === _ox_[0])
                {var sl=_ox_[1];
                 if(_ow_ === sl)
                  {var _oy_=refl(a);return [0,[0,a,refl(a),_oy_]]}
                 return 0}
               var switch$0=1,switch$1=0}
             else
              var switch$1=1;
            if(switch$1)var switch$0=1}
          else
           {var _oz_=_ov_[1];
            if(typeof match === "number")
             if(0 === match)var switch$0=0,switch$2=0;else var switch$2=1;
            else
             if(0 === match[0])
              {var _oA_=match[1];
               if(0 !== _oA_[0])
                {var tyY=_oA_[1];
                 if(caml_string_equal(_oz_,tyY))
                  {var _oB_=refl(a);return [0,[0,a,refl(a),_oB_]]}
                 return 0}
               var switch$0=1,switch$2=0}
             else
              var switch$2=1;
            if(switch$2)var switch$0=1}
          break;
         case 1:
          var _oC_=a[2],_oD_=a[1];
          if(typeof match === "number")
           if(0 === match)var switch$0=0,switch$3=0;else var switch$3=1;
          else
           {if(1 === match[0])
             {var
               b2=match[2],
               b1=match[1],
               _oE_=
                function(param)
                 {var p1r=param[3],p1l=param[2],c1=param[1];
                  function _oP_(param)
                   {var p2r=param[3],p2l=param[2],c2=param[1];
                    return [0,[0,[1,c1,c2],[2,p1l,p2l],[2,p1r,p2r]]]}
                  return obind(mkMeet(_oC_,b2,supp),_oP_)};
              return obind(mkMeet(_oD_,b1,supp),_oE_)}
            var switch$3=1}
          if(switch$3)var switch$0=1;
          break;
         case 2:
          var _oF_=a[2],_oG_=a[1];
          if(typeof match === "number")
           if(0 === match)var switch$0=0,switch$4=0;else var switch$4=1;
          else
           {if(2 === match[0])
             {var
               b2$0=match[2],
               b1$0=match[1],
               _oH_=
                function(param)
                 {var p1r=param[3],p1l=param[2],c1=param[1];
                  function _oO_(param)
                   {var p2r=param[3],p2l=param[2],c2=param[1];
                    return [0,[0,[1,c1,c2],[3,p1l,p2l],[3,p1r,p2r]]]}
                  return obind(mkMeet(_oF_,b2$0,supp),_oO_)};
              return obind(mkMeet(_oG_,b1$0,supp),_oH_)}
            var switch$4=1}
          if(switch$4)var switch$0=1;
          break;
         case 3:
          var _oI_=a[2],_oJ_=a[1];
          if(typeof match === "number")
           if(0 === match)var switch$0=0,switch$5=0;else var switch$5=1;
          else
           {if(3 === match[0])
             {var
               b=match[2],
               tyY$0=match[1],
               tyZ=tyVar(supp),
               aZforX=caml_call1(renameTyVar(_oJ_,tyZ,supp),_oI_),
               bZforY=caml_call1(renameTyVar(tyY$0,tyZ,supp),b),
               _oK_=
                function(param)
                 {var pb=param[3],pa=param[2],c=param[1];
                  return [0,[0,c,[4,tyZ,pa],[4,tyZ,pb]]]};
              return obind(mkMeet(aZforX,bZforY,supp),_oK_)}
            var switch$5=1}
          if(switch$5)var switch$0=1;
          break;
         default:
          var _oL_=a[2],_oM_=a[1];
          if(typeof match === "number")
           if(0 === match)var switch$0=0,switch$6=0;else var switch$6=1;
          else
           {if(4 === match[0])
             {var
               b$0=match[2],
               tyY$1=match[1],
               tyZ$0=tyVar(supp),
               aZforX$0=caml_call1(renameTyVar(_oM_,tyZ$0,supp),_oL_),
               bZforY$0=caml_call1(renameTyVar(tyY$1,tyZ$0,supp),b$0),
               _oN_=
                function(param)
                 {var pb=param[3],pa=param[2],c=param[1];
                  return [0,[0,c,[5,tyZ$0,pa],[5,tyZ$0,pb]]]};
              return obind(mkMeet(aZforX$0,bZforY$0,supp),_oN_)}
            var switch$6=1}
          if(switch$6)var switch$0=1}
      if(switch$0)return 0;
      var _ou_=dynTop(a);
      return [0,[0,a,refl(a),_ou_]]}
    function checkConsistent(a,b,supp)
     {var match=mkMeet(a,b,supp);return match?1:0}
    function slsubstname(sl,tyX,param)
     {if(0 === param[0]){var sl$0=param[1];return [0,sl$0]}
      var tyY=param[1];
      return caml_string_equal(tyX,tyY)?[0,sl]:[1,tyY]}
    function slsubstty(sl,tyX)
     {function f(param)
       {if(typeof param === "number")
         switch(param){case 0:return 0;case 1:return 1;default:return 2}
        else
         switch(param[0])
          {case 0:var nm=param[1];return [0,slsubstname(sl,tyX,nm)];
           case 1:
            var ty2=param[2],ty1=param[1],_or_=f(ty2);return [1,f(ty1),_or_];
           case 2:
            var ty2$0=param[2],ty1$0=param[1],_os_=f(ty2$0);
            return [2,f(ty1$0),_os_];
           case 3:
            var
             ty=param[2],
             tyY=param[1],
             ty$0=caml_string_equal(tyX,tyY)?ty:f(ty);
            return [3,tyY,ty$0];
           default:
            var
             ty$1=param[2],
             tyY$0=param[1],
             ty$2=caml_string_equal(tyX,tyY$0)?ty$1:f(ty$1);
            return [4,tyY$0,ty$2]}}
      return f}
    function slsubsttag(sl,tyX,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:return 0;
         case 1:return 1;
         case 2:return 2;
         case 3:return 3;
         case 4:return 4;
         default:return 5}
      var nm=param[1];
      return [0,slsubstname(sl,tyX,nm)]}
    function slsubstprec(sl,tyX)
     {function f(param)
       {if(typeof param === "number")
         switch(param){case 0:return 0;case 1:return 1;default:return 2}
        else
         switch(param[0])
          {case 0:
            var prec=param[2],tag=param[1],_oo_=f(prec);
            return [0,slsubsttag(sl,tyX,tag),_oo_];
           case 1:var nm=param[1];return [1,slsubstname(sl,tyX,nm)];
           case 2:
            var p2=param[2],p1=param[1],_op_=f(p2);return [2,f(p1),_op_];
           case 3:
            var p2$0=param[2],p1$0=param[1],_oq_=f(p2$0);
            return [3,f(p1$0),_oq_];
           case 4:
            var p=param[2],tyY=param[1],p$0=caml_string_equal(tyX,tyY)?p:f(p);
            return [4,tyY,p$0];
           default:
            var
             p$1=param[2],
             tyY$0=param[1],
             p$2=caml_string_equal(tyX,tyY$0)?p$1:f(p$1);
            return [5,tyY$0,p$2]}}
      return f}
    var
     PolyGNew_Gtypes=
      [0,
       pp_seal,
       show_seal,
       equal_seal,
       pp_tyname,
       show_tyname,
       equal_tyname,
       pp_tagty,
       show_tagty,
       equal_tagty,
       pp_gtype,
       show_gtype,
       equal_gtype,
       tyvar,
       renameTyVar,
       typ_from_tag,
       pp_precision,
       show_precision,
       equal_precision,
       refl,
       dynTop,
       obind,
       mkMeet,
       checkConsistent,
       slsubstname,
       slsubstty,
       slsubsttag,
       slsubstprec];
    caml_register_global(491,PolyGNew_Gtypes,"PolyGNew__Gtypes");
    function pp_dir(fmt,param)
     {return 0 === param
              ?caml_call2(Stdlib_format[13],fmt,cst_CC_Up)
              :caml_call2(Stdlib_format[13],fmt,cst_CC_Down)}
    function show_dir(x){return caml_call3(Stdlib_format[127],_ae_,pp_dir,x)}
    function equal_dir(lhs,rhs)
     {if(0 === lhs){if(0 === rhs)return 1}else if(0 !== rhs)return 1;return 0}
    function complement(param){return 0 === param?1:0}
    var
     pp_tm=function _on_(_ol_,_om_){return _on_.fun(_ol_,_om_)},
     show_tm=function _ok_(_oj_){return _ok_.fun(_oj_)};
    caml_update_dummy
     (pp_tm,
      function(fmt,param)
       {switch(param[0])
         {case 0:
           var a0=param[1];
           caml_call2(Stdlib_format[123],fmt,_af_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_ag_),a0);
           return caml_call2(Stdlib_format[123],fmt,_ah_);
          case 1:
           var a2=param[3],a1=param[2],a0$0=param[1];
           caml_call2(Stdlib_format[123],fmt,_ai_);
           caml_call1(caml_call1(pp_tm,fmt),a0$0);
           caml_call2(Stdlib_format[123],fmt,_aj_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_ak_),a1);
           caml_call2(Stdlib_format[123],fmt,_al_);
           caml_call1(caml_call1(pp_tm,fmt),a2);
           return caml_call2(Stdlib_format[123],fmt,_am_);
          case 2:
           var a1$0=param[2],a0$1=param[1];
           caml_call2(Stdlib_format[123],fmt,_an_);
           caml_call1(caml_call1(pp_tyname,fmt),a0$1);
           caml_call2(Stdlib_format[123],fmt,_ao_);
           caml_call1(caml_call1(pp_tm,fmt),a1$0);
           return caml_call2(Stdlib_format[123],fmt,_ap_);
          case 3:
           var a1$1=param[2],a0$2=param[1];
           caml_call2(Stdlib_format[123],fmt,_aq_);
           caml_call1(caml_call1(pp_tyname,fmt),a0$2);
           caml_call2(Stdlib_format[123],fmt,_ar_);
           caml_call1(caml_call1(pp_tm,fmt),a1$1);
           return caml_call2(Stdlib_format[123],fmt,_as_);
          case 4:
           var a0$3=param[1];
           caml_call2(Stdlib_format[123],fmt,_at_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_au_),a0$3);
           return caml_call2(Stdlib_format[123],fmt,_av_);
          case 5:
           var a2$0=param[3],a1$2=param[2],a0$4=param[1];
           caml_call2(Stdlib_format[123],fmt,_aw_);
           caml_call1(caml_call1(pp_tm,fmt),a0$4);
           caml_call2(Stdlib_format[123],fmt,_ax_);
           caml_call1(caml_call1(pp_tm,fmt),a1$2);
           caml_call2(Stdlib_format[123],fmt,_ay_);
           caml_call1(caml_call1(pp_tm,fmt),a2$0);
           return caml_call2(Stdlib_format[123],fmt,_az_);
          case 6:
           var a1$3=param[2],a0$5=param[1];
           caml_call2(Stdlib_format[123],fmt,_aA_);
           caml_call1(caml_call1(pp_tm,fmt),a0$5);
           caml_call2(Stdlib_format[123],fmt,_aB_);
           caml_call1(caml_call1(pp_tm,fmt),a1$3);
           return caml_call2(Stdlib_format[123],fmt,_aC_);
          case 7:
           var a3=param[4],a2$1=param[3],a1$4=param[2],a0$6=param[1];
           caml_call2(Stdlib_format[123],fmt,_aD_);
           caml_call1(caml_call1(pp_tm,fmt),a0$6);
           caml_call2(Stdlib_format[123],fmt,_aE_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_aF_),a1$4);
           caml_call2(Stdlib_format[123],fmt,_aG_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_aH_),a2$1);
           caml_call2(Stdlib_format[123],fmt,_aI_);
           caml_call1(caml_call1(pp_tm,fmt),a3);
           return caml_call2(Stdlib_format[123],fmt,_aJ_);
          case 8:
           var a2$2=param[3],a1$5=param[2],a0$7=param[1];
           caml_call2(Stdlib_format[123],fmt,_aK_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_aL_),a0$7);
           caml_call2(Stdlib_format[123],fmt,_aM_);
           caml_call1(caml_call1(pp_gtype,fmt),a1$5);
           caml_call2(Stdlib_format[123],fmt,_aN_);
           caml_call1(caml_call1(pp_tm,fmt),a2$2);
           return caml_call2(Stdlib_format[123],fmt,_aO_);
          case 9:
           var a1$6=param[2],a0$8=param[1];
           caml_call2(Stdlib_format[123],fmt,_aP_);
           caml_call1(caml_call1(pp_tm,fmt),a0$8);
           caml_call2(Stdlib_format[123],fmt,_aQ_);
           caml_call1(caml_call1(pp_tm,fmt),a1$6);
           return caml_call2(Stdlib_format[123],fmt,_aR_);
          case 10:
           var a2$3=param[3],a1$7=param[2],a0$9=param[1];
           caml_call2(Stdlib_format[123],fmt,_aS_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_aT_),a0$9);
           caml_call2(Stdlib_format[123],fmt,_aU_);
           caml_call1(caml_call1(pp_gtype,fmt),a1$7);
           caml_call2(Stdlib_format[123],fmt,_aV_);
           caml_call1(caml_call1(pp_tm,fmt),a2$3);
           return caml_call2(Stdlib_format[123],fmt,_aW_);
          case 11:
           var a3$0=param[4],a2$4=param[3],a1$8=param[2],a0$10=param[1];
           caml_call2(Stdlib_format[123],fmt,_aX_);
           caml_call1(caml_call1(pp_tm,fmt),a0$10);
           caml_call2(Stdlib_format[123],fmt,_aY_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_aZ_),a1$8);
           caml_call2(Stdlib_format[123],fmt,_a0_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_a1_),a2$4);
           caml_call2(Stdlib_format[123],fmt,_a2_);
           caml_call1(caml_call1(pp_tm,fmt),a3$0);
           return caml_call2(Stdlib_format[123],fmt,_a3_);
          case 12:
           var a3$1=param[4],a2$5=param[3],a1$9=param[2],a0$11=param[1];
           caml_call2(Stdlib_format[123],fmt,_a4_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_a5_),a0$11);
           caml_call2(Stdlib_format[123],fmt,_a6_);
           caml_call1(caml_call1(pp_gtype,fmt),a1$9);
           caml_call2(Stdlib_format[123],fmt,_a7_);
           caml_call2(Stdlib_format[123],fmt,_a8_);
           var
            _oh_=0,
            _oi_=
             function(sep,x)
              {if(sep)caml_call2(Stdlib_format[123],fmt,_a9_);
               var a2=x[3],a1=x[2],a0=x[1];
               caml_call2(Stdlib_format[123],fmt,_a__);
               caml_call1(caml_call2(Stdlib_format[123],fmt,_a$_),a0);
               caml_call2(Stdlib_format[123],fmt,_ba_);
               caml_call1(caml_call1(pp_precision,fmt),a1);
               caml_call2(Stdlib_format[123],fmt,_bb_);
               pp_dir(fmt,a2);
               caml_call2(Stdlib_format[123],fmt,_bc_);
               return 1};
           caml_call3(Stdlib_list[21],_oi_,_oh_,a2$5);
           caml_call2(Stdlib_format[123],fmt,_bd_);
           caml_call2(Stdlib_format[123],fmt,_be_);
           caml_call1(caml_call1(pp_tm,fmt),a3$1);
           return caml_call2(Stdlib_format[123],fmt,_bf_);
          case 13:
           var a0$12=param[1];
           caml_call2(Stdlib_format[123],fmt,_bg_);
           var a1$10=a0$12[2],a0$13=a0$12[1];
           caml_call2(Stdlib_format[123],fmt,_bh_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_bi_),a0$13);
           caml_call2(Stdlib_format[123],fmt,_bj_);
           caml_call1(caml_call1(pp_tm,fmt),a1$10);
           caml_call2(Stdlib_format[123],fmt,_bk_);
           return caml_call2(Stdlib_format[123],fmt,_bl_);
          case 14:
           var a0$14=param[1];
           caml_call2(Stdlib_format[123],fmt,_bm_);
           var a2$6=a0$14[3],a1$11=a0$14[2],a0$15=a0$14[1];
           caml_call2(Stdlib_format[123],fmt,_bn_);
           caml_call1(caml_call1(pp_tm,fmt),a0$15);
           caml_call2(Stdlib_format[123],fmt,_bo_);
           caml_call1(caml_call1(pp_tyname,fmt),a1$11);
           caml_call2(Stdlib_format[123],fmt,_bp_);
           caml_call1(caml_call1(pp_gtype,fmt),a2$6);
           caml_call2(Stdlib_format[123],fmt,_bq_);
           return caml_call2(Stdlib_format[123],fmt,_br_);
          case 15:
           var a2$7=param[3],a1$12=param[2],a0$16=param[1];
           caml_call2(Stdlib_format[123],fmt,_bs_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_bt_),a0$16);
           caml_call2(Stdlib_format[123],fmt,_bu_);
           caml_call1(caml_call1(pp_gtype,fmt),a1$12);
           caml_call2(Stdlib_format[123],fmt,_bv_);
           caml_call1(caml_call1(pp_tm,fmt),a2$7);
           return caml_call2(Stdlib_format[123],fmt,_bw_);
          case 16:
           var a2$8=param[3],a1$13=param[2],a0$17=param[1];
           caml_call2(Stdlib_format[123],fmt,_bx_);
           caml_call1(caml_call1(pp_precision,fmt),a0$17);
           caml_call2(Stdlib_format[123],fmt,_by_);
           pp_dir(fmt,a1$13);
           caml_call2(Stdlib_format[123],fmt,_bz_);
           caml_call1(caml_call1(pp_tm,fmt),a2$8);
           return caml_call2(Stdlib_format[123],fmt,_bA_);
          case 17:
           var a1$14=param[2],a0$18=param[1];
           caml_call2(Stdlib_format[123],fmt,_bB_);
           caml_call1(caml_call1(pp_tagty,fmt),a0$18);
           caml_call2(Stdlib_format[123],fmt,_bC_);
           caml_call1(caml_call1(pp_tm,fmt),a1$14);
           return caml_call2(Stdlib_format[123],fmt,_bD_);
          case 18:
           var a0$19=param[1];
           caml_call2(Stdlib_format[123],fmt,_bE_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_bF_),a0$19);
           return caml_call2(Stdlib_format[123],fmt,_bG_);
          case 19:
           var a1$15=param[2],a0$20=param[1];
           caml_call2(Stdlib_format[123],fmt,_bH_);
           caml_call1(caml_call1(pp_tm,fmt),a0$20);
           caml_call2(Stdlib_format[123],fmt,_bI_);
           caml_call1(caml_call1(pp_tm,fmt),a1$15);
           return caml_call2(Stdlib_format[123],fmt,_bJ_);
          default:
           var a1$16=param[2],a0$21=param[1];
           caml_call2(Stdlib_format[123],fmt,_bK_);
           caml_call1(caml_call1(pp_tagty,fmt),a0$21);
           caml_call2(Stdlib_format[123],fmt,_bL_);
           caml_call1(caml_call1(pp_tm,fmt),a1$16);
           return caml_call2(Stdlib_format[123],fmt,_bM_)}});
    caml_update_dummy
     (show_tm,function(x){return caml_call3(Stdlib_format[127],_bN_,pp_tm,x)});
    var equal_tm=function _og_(_oe_,_of_){return _og_.fun(_oe_,_of_)};
    caml_update_dummy
     (equal_tm,
      function(lhs,match)
       {switch(lhs[0])
         {case 0:
           if(0 === match[0])
            {var rhs0=match[1],lhs0=lhs[1];
             return caml_string_equal(lhs0,rhs0)}
           break;
          case 1:
           if(1 === match[0])
            {var
              rhs2=match[3],
              rhs1=match[2],
              rhs0$0=match[1],
              lhs2=lhs[3],
              lhs1=lhs[2],
              lhs0$0=lhs[1],
              _nH_=caml_call1(caml_call1(equal_tm,lhs0$0),rhs0$0),
              _nI_=_nH_?caml_string_equal(lhs1,rhs1):_nH_;
             return _nI_?caml_call1(caml_call1(equal_tm,lhs2),rhs2):_nI_}
           break;
          case 2:
           if(2 === match[0])
            {var
              rhs1$0=match[2],
              rhs0$1=match[1],
              lhs1$0=lhs[2],
              lhs0$1=lhs[1],
              _nJ_=caml_call1(caml_call1(equal_tyname,lhs0$1),rhs0$1);
             return _nJ_?caml_call1(caml_call1(equal_tm,lhs1$0),rhs1$0):_nJ_}
           break;
          case 3:
           if(3 === match[0])
            {var
              rhs1$1=match[2],
              rhs0$2=match[1],
              lhs1$1=lhs[2],
              lhs0$2=lhs[1],
              _nK_=caml_call1(caml_call1(equal_tyname,lhs0$2),rhs0$2);
             return _nK_?caml_call1(caml_call1(equal_tm,lhs1$1),rhs1$1):_nK_}
           break;
          case 4:
           if(4 === match[0])
            {var rhs0$3=match[1],lhs0$3=lhs[1];return lhs0$3 === rhs0$3?1:0}
           break;
          case 5:
           if(5 === match[0])
            {var
              rhs2$0=match[3],
              rhs1$2=match[2],
              rhs0$4=match[1],
              lhs2$0=lhs[3],
              lhs1$2=lhs[2],
              lhs0$4=lhs[1],
              _nL_=caml_call1(caml_call1(equal_tm,lhs0$4),rhs0$4),
              _nM_=_nL_?caml_call1(caml_call1(equal_tm,lhs1$2),rhs1$2):_nL_;
             return _nM_?caml_call1(caml_call1(equal_tm,lhs2$0),rhs2$0):_nM_}
           break;
          case 6:
           if(6 === match[0])
            {var
              rhs1$3=match[2],
              rhs0$5=match[1],
              lhs1$3=lhs[2],
              lhs0$5=lhs[1],
              _nN_=caml_call1(caml_call1(equal_tm,lhs0$5),rhs0$5);
             return _nN_?caml_call1(caml_call1(equal_tm,lhs1$3),rhs1$3):_nN_}
           break;
          case 7:
           if(7 === match[0])
            {var
              rhs3=match[4],
              rhs2$1=match[3],
              rhs1$4=match[2],
              rhs0$6=match[1],
              lhs3=lhs[4],
              lhs2$1=lhs[3],
              lhs1$4=lhs[2],
              lhs0$6=lhs[1],
              _nO_=caml_call1(caml_call1(equal_tm,lhs0$6),rhs0$6),
              _nP_=_nO_?caml_string_equal(lhs1$4,rhs1$4):_nO_,
              _nQ_=_nP_?caml_string_equal(lhs2$1,rhs2$1):_nP_;
             return _nQ_?caml_call1(caml_call1(equal_tm,lhs3),rhs3):_nQ_}
           break;
          case 8:
           if(8 === match[0])
            {var
              rhs2$2=match[3],
              rhs1$5=match[2],
              rhs0$7=match[1],
              lhs2$2=lhs[3],
              lhs1$5=lhs[2],
              lhs0$7=lhs[1],
              _nR_=caml_string_equal(lhs0$7,rhs0$7),
              _nS_=_nR_?caml_call1(caml_call1(equal_gtype,lhs1$5),rhs1$5):_nR_;
             return _nS_?caml_call1(caml_call1(equal_tm,lhs2$2),rhs2$2):_nS_}
           break;
          case 9:
           if(9 === match[0])
            {var
              rhs1$6=match[2],
              rhs0$8=match[1],
              lhs1$6=lhs[2],
              lhs0$8=lhs[1],
              _nT_=caml_call1(caml_call1(equal_tm,lhs0$8),rhs0$8);
             return _nT_?caml_call1(caml_call1(equal_tm,lhs1$6),rhs1$6):_nT_}
           break;
          case 10:
           if(10 === match[0])
            {var
              rhs2$3=match[3],
              rhs1$7=match[2],
              rhs0$9=match[1],
              lhs2$3=lhs[3],
              lhs1$7=lhs[2],
              lhs0$9=lhs[1],
              _nU_=caml_string_equal(lhs0$9,rhs0$9),
              _nV_=_nU_?caml_call1(caml_call1(equal_gtype,lhs1$7),rhs1$7):_nU_;
             return _nV_?caml_call1(caml_call1(equal_tm,lhs2$3),rhs2$3):_nV_}
           break;
          case 11:
           if(11 === match[0])
            {var
              rhs3$0=match[4],
              rhs2$4=match[3],
              rhs1$8=match[2],
              rhs0$10=match[1],
              lhs3$0=lhs[4],
              lhs2$4=lhs[3],
              lhs1$8=lhs[2],
              lhs0$10=lhs[1],
              _nW_=caml_call1(caml_call1(equal_tm,lhs0$10),rhs0$10),
              _nX_=_nW_?caml_string_equal(lhs1$8,rhs1$8):_nW_,
              _nY_=_nX_?caml_string_equal(lhs2$4,rhs2$4):_nX_;
             return _nY_?caml_call1(caml_call1(equal_tm,lhs3$0),rhs3$0):_nY_}
           break;
          case 12:
           if(12 === match[0])
            {var
              rhs3$1=match[4],
              rhs2$5=match[3],
              rhs1$9=match[2],
              rhs0$11=match[1],
              lhs3$1=lhs[4],
              lhs2$5=lhs[3],
              lhs1$9=lhs[2],
              lhs0$11=lhs[1],
              _nZ_=caml_string_equal(lhs0$11,rhs0$11),
              _n0_=_nZ_?caml_call1(caml_call1(equal_gtype,lhs1$9),rhs1$9):_nZ_;
             if(_n0_)
              {var x=lhs2$5,y=rhs2$5;
               for(;;)
                {if(x)
                  if(y)
                   {var
                     y$0=y[2],
                     b=y[1],
                     x$0=x[2],
                     a=x[1],
                     rhs2$6=b[3],
                     rhs1$10=b[2],
                     rhs0$12=b[1],
                     lhs2$6=a[3],
                     lhs1$10=a[2],
                     lhs0$12=a[1],
                     _n1_=caml_string_equal(lhs0$12,rhs0$12),
                     _n2_=
                      _n1_
                       ?caml_call1(caml_call1(equal_precision,lhs1$10),rhs1$10)
                       :_n1_,
                     _n3_=_n2_?equal_dir(lhs2$6,rhs2$6):_n2_;
                    if(_n3_){var x=x$0,y=y$0;continue}
                    var _n4_=_n3_,switch$0=1}
                  else
                   var switch$0=0;
                 else
                  if(y)var switch$0=0;else var _n4_=1,switch$0=1;
                 if(! switch$0)var _n4_=0;
                 var _n5_=_n4_;
                 break}}
             else
              var _n5_=_n0_;
             return _n5_?caml_call1(caml_call1(equal_tm,lhs3$1),rhs3$1):_n5_}
           break;
          case 13:
           if(13 === match[0])
            {var
              rhs0$13=match[1],
              lhs0$13=lhs[1],
              rhs1$11=rhs0$13[2],
              rhs0$14=rhs0$13[1],
              lhs1$11=lhs0$13[2],
              lhs0$14=lhs0$13[1],
              _n6_=caml_string_equal(lhs0$14,rhs0$14);
             return _n6_?caml_call1(caml_call1(equal_tm,lhs1$11),rhs1$11):_n6_}
           break;
          case 14:
           if(14 === match[0])
            {var
              rhs0$15=match[1],
              lhs0$15=lhs[1],
              rhs2$7=rhs0$15[3],
              rhs1$12=rhs0$15[2],
              rhs0$16=rhs0$15[1],
              lhs2$7=lhs0$15[3],
              lhs1$12=lhs0$15[2],
              lhs0$16=lhs0$15[1],
              _n7_=caml_call1(caml_call1(equal_tm,lhs0$16),rhs0$16),
              _n8_=
               _n7_?caml_call1(caml_call1(equal_tyname,lhs1$12),rhs1$12):_n7_;
             return _n8_
                     ?caml_call1(caml_call1(equal_gtype,lhs2$7),rhs2$7)
                     :_n8_}
           break;
          case 15:
           if(15 === match[0])
            {var
              rhs2$8=match[3],
              rhs1$13=match[2],
              rhs0$17=match[1],
              lhs2$8=lhs[3],
              lhs1$13=lhs[2],
              lhs0$17=lhs[1],
              _n9_=caml_string_equal(lhs0$17,rhs0$17),
              _n__=
               _n9_?caml_call1(caml_call1(equal_gtype,lhs1$13),rhs1$13):_n9_;
             return _n__?caml_call1(caml_call1(equal_tm,lhs2$8),rhs2$8):_n__}
           break;
          case 16:
           if(16 === match[0])
            {var
              rhs2$9=match[3],
              rhs1$14=match[2],
              rhs0$18=match[1],
              lhs2$9=lhs[3],
              lhs1$14=lhs[2],
              lhs0$18=lhs[1],
              _n$_=caml_call1(caml_call1(equal_precision,lhs0$18),rhs0$18),
              _oa_=_n$_?equal_dir(lhs1$14,rhs1$14):_n$_;
             return _oa_?caml_call1(caml_call1(equal_tm,lhs2$9),rhs2$9):_oa_}
           break;
          case 17:
           if(17 === match[0])
            {var
              rhs1$15=match[2],
              rhs0$19=match[1],
              lhs1$15=lhs[2],
              lhs0$19=lhs[1],
              _ob_=caml_call1(caml_call1(equal_tagty,lhs0$19),rhs0$19);
             return _ob_?caml_call1(caml_call1(equal_tm,lhs1$15),rhs1$15):_ob_}
           break;
          case 18:
           if(18 === match[0])
            {var rhs0$20=match[1],lhs0$20=lhs[1];
             return lhs0$20 === rhs0$20?1:0}
           break;
          case 19:
           if(19 === match[0])
            {var
              rhs1$16=match[2],
              rhs0$21=match[1],
              lhs1$16=lhs[2],
              lhs0$21=lhs[1],
              _oc_=caml_call1(caml_call1(equal_tm,lhs0$21),rhs0$21);
             return _oc_?caml_call1(caml_call1(equal_tm,lhs1$16),rhs1$16):_oc_}
           break;
          default:
           if(20 === match[0])
            {var
              rhs1$17=match[2],
              rhs0$22=match[1],
              lhs1$17=lhs[2],
              lhs0$22=lhs[1],
              _od_=caml_call1(caml_call1(equal_tagty,lhs0$22),rhs0$22);
             return _od_?caml_call1(caml_call1(equal_tm,lhs1$17),rhs1$17):_od_}}
        return 0});
    function slsubst(sl,tyX)
     {function f(param)
       {switch(param[0])
         {case 0:var y=param[1];return [0,y];
          case 1:
           var tk=param[3],x=param[2],t=param[1],_nq_=f(tk);
           return [1,f(t),x,_nq_];
          case 2:
           var t$0=param[2],nm=param[1],_nr_=f(t$0);
           return [2,slsubstname(sl,tyX,nm),_nr_];
          case 3:
           var t$1=param[2],nm$0=param[1],_ns_=f(t$1);
           return [3,slsubstname(sl,tyX,nm$0),_ns_];
          case 4:var b=param[1];return [4,b];
          case 5:
           var tf=param[3],tt=param[2],b$0=param[1],_nt_=f(tf),_nu_=f(tt);
           return [5,f(b$0),_nu_,_nt_];
          case 6:var t2=param[2],t1=param[1],_nv_=f(t2);return [6,f(t1),_nv_];
          case 7:
           var tk$0=param[4],x2=param[3],x1=param[2],tp=param[1],_nw_=f(tk$0);
           return [7,f(tp),x1,x2,_nw_];
          case 8:
           var t$2=param[3],ty=param[2],x$0=param[1],_nx_=f(t$2);
           return [8,x$0,caml_call1(slsubstty(sl,tyX),ty),_nx_];
          case 9:
           var ta=param[2],tf$0=param[1],_ny_=f(ta);return [9,f(tf$0),_ny_];
          case 10:
           var
            tbod=param[3],
            ty$0=param[2],
            tyY=param[1],
            tbod$0=caml_string_equal(tyX,tyY)?tbod:f(tbod);
           return [10,tyY,caml_call1(slsubstty(sl,tyX),ty$0),tbod$0];
          case 11:
           var
            tk$1=param[4],
            x$1=param[3],
            tyY$0=param[2],
            t$3=param[1],
            tk$2=caml_string_equal(tyX,tyY$0)?tk$1:f(tk$1);
           return [11,f(t$3),tyY$0,x$1,tk$2];
          case 12:
           var
            tbod$1=param[4],
            csts=param[3],
            ty$1=param[2],
            tyY$1=param[1],
            tbod$2=caml_string_equal(tyX,tyY$1)?tbod$1:f(tbod$1),
            _nz_=
             function(param)
              {var
                d=param[3],
                p=param[2],
                tyY=param[1],
                p$0=
                 caml_string_equal(tyX,tyY)
                  ?p
                  :caml_call1(slsubstprec(sl,tyX),p);
               return [0,tyY,p$0,d]},
            _nA_=caml_call2(Stdlib_list[17],_nz_,csts);
           return [12,tyY$1,caml_call1(slsubstty(sl,tyX),ty$1),_nA_,tbod$2];
          case 13:
           var
            match=param[1],
            t$4=match[2],
            tyY$2=match[1],
            t$5=caml_string_equal(tyX,tyY$2)?t$4:f(t$4);
           return [13,[0,tyY$2,t$5]];
          case 14:
           var
            match$0=param[1],
            a=match$0[3],
            nm$1=match$0[2],
            tf$1=match$0[1],
            _nB_=caml_call1(slsubstty(sl,tyX),a),
            _nC_=slsubstname(sl,tyX,nm$1);
           return [14,[0,f(tf$1),_nC_,_nB_]];
          case 15:
           var
            t$6=param[3],
            a$0=param[2],
            tyY$3=param[1],
            t$7=caml_string_equal(tyX,tyY$3)?t$6:f(t$6);
           return [15,tyY$3,a$0,t$7];
          case 16:
           var t$8=param[3],d=param[2],p=param[1],_nD_=f(t$8);
           return [16,caml_call1(slsubstprec(sl,tyX),p),d,_nD_];
          case 17:
           var t$9=param[2],g=param[1],_nE_=f(t$9);
           return [17,slsubsttag(sl,tyX,g),_nE_];
          case 18:var n=param[1];return [18,n];
          case 19:
           var tr=param[2],tl=param[1],_nF_=f(tr);return [19,f(tl),_nF_];
          default:
           var t$10=param[2],tg=param[1],_nG_=f(t$10);
           return [20,slsubsttag(sl,tyX,tg),_nG_]}}
      return f}
    function subst(v,x)
     {function f(param)
       {switch(param[0])
         {case 0:var y=param[1];return caml_string_equal(x,y)?v:[0,y];
          case 1:
           var
            tk=param[3],
            y$0=param[2],
            t=param[1],
            tk$0=caml_string_equal(x,y$0)?tk:f(tk);
           return [1,f(t),y$0,tk$0];
          case 2:var m=param[2],ty=param[1];return [2,ty,f(m)];
          case 3:var m$0=param[2],ty$0=param[1];return [3,ty$0,f(m$0)];
          case 4:var b=param[1];return [4,b];
          case 5:
           var ft=param[3],tt=param[2],b$0=param[1],_nl_=f(ft),_nm_=f(tt);
           return [5,f(b$0),_nm_,_nl_];
          case 6:var t2=param[2],t1=param[1],_nn_=f(t2);return [6,f(t1),_nn_];
          case 7:
           var kt=param[4],x2=param[3],x1=param[2],tp=param[1];
           if(caml_string_equal(x,x1))
            var switch$0=0;
           else
            if(caml_string_equal(x,x2))
             var switch$0=0;
            else
             var kt$0=f(kt),switch$0=1;
           if(! switch$0)var kt$0=kt;
           return [7,f(tp),x1,x2,kt$0];
          case 8:
           var
            tbod=param[3],
            ty$1=param[2],
            y$1=param[1],
            tbod$0=caml_string_equal(x,y$1)?tbod:f(tbod);
           return [8,y$1,ty$1,tbod$0];
          case 9:var ta=param[2],tf=param[1],_no_=f(ta);return [9,f(tf),_no_];
          case 10:
           var m$1=param[3],ty$2=param[2],tyX=param[1];
           return [10,tyX,ty$2,f(m$1)];
          case 11:
           var
            tk$1=param[4],
            y$2=param[3],
            tyX$0=param[2],
            t$0=param[1],
            tk$2=caml_string_equal(x,y$2)?tk$1:f(tk$1);
           return [11,f(t$0),tyX$0,y$2,tk$2];
          case 12:
           var t$1=param[4],csts=param[3],ty$3=param[2],tyX$1=param[1];
           return [12,tyX$1,ty$3,csts,f(t$1)];
          case 13:
           var match=param[1],t$2=match[2],tyX$2=match[1];
           return [13,[0,tyX$2,f(t$2)]];
          case 14:
           var match$0=param[1],a=match$0[3],nm=match$0[2],tf$0=match$0[1];
           return [14,[0,f(tf$0),nm,a]];
          case 15:
           var t$3=param[3],a$0=param[2],tyX$3=param[1];
           return [15,tyX$3,a$0,f(t$3)];
          case 16:
           var t$4=param[3],d=param[2],prec=param[1];
           return [16,prec,d,f(t$4)];
          case 17:var t$5=param[2],g=param[1];return [17,g,f(t$5)];
          case 18:var n=param[1];return [18,n];
          case 19:
           var tr=param[2],tl=param[1],_np_=f(tr);return [19,f(tl),_np_];
          default:var t$6=param[2],g$0=param[1];return [20,g$0,f(t$6)]}}
      return f}
    var
     PolyGNew_CC=
      [0,
       pp_dir,
       show_dir,
       equal_dir,
       complement,
       pp_tm,
       show_tm,
       equal_tm,
       slsubst,
       subst];
    caml_register_global(493,PolyGNew_CC,"PolyGNew__CC");
    function pp_tyvar(fmt){return caml_call2(Stdlib_format[123],fmt,_bO_)}
    function show_tyvar(x)
     {return caml_call3(Stdlib_format[127],_bP_,pp_tyvar,x)}
    var equal_tyvar=caml_string_equal;
    function pp_tmvar(fmt){return caml_call2(Stdlib_format[123],fmt,_bQ_)}
    function show_tmvar(x)
     {return caml_call3(Stdlib_format[127],_bR_,pp_tmvar,x)}
    var equal_tmvar=caml_string_equal;
    function pp_src_loc(fmt,x)
     {caml_call2(Stdlib_format[123],fmt,_bS_);
      caml_call3(Stdlib_format[123],fmt,_bT_,cst_Surf_line);
      var _nj_=x[1];
      caml_call1(caml_call2(Stdlib_format[123],fmt,_bU_),_nj_);
      caml_call2(Stdlib_format[123],fmt,_bV_);
      caml_call2(Stdlib_format[123],fmt,_bW_);
      caml_call3(Stdlib_format[123],fmt,_bX_,cst_col);
      var _nk_=x[2];
      caml_call1(caml_call2(Stdlib_format[123],fmt,_bY_),_nk_);
      caml_call2(Stdlib_format[123],fmt,_bZ_);
      return caml_call2(Stdlib_format[123],fmt,_b0_)}
    function show_src_loc(x)
     {return caml_call3(Stdlib_format[127],_b1_,pp_src_loc,x)}
    function equal_src_loc(param,_ni_){return 1}
    var
     pp_tm$0=function _nh_(_nf_,_ng_){return _nh_.fun(_nf_,_ng_)},
     show_tm$0=function _ne_(_nd_){return _ne_.fun(_nd_)},
     pp_tmctor=function _nc_(_na_,_nb_){return _nc_.fun(_na_,_nb_)},
     show_tmctor=function _m$_(_m__){return _m$_.fun(_m__)};
    caml_update_dummy
     (pp_tm$0,
      function(fmt,param)
       {var a1=param[2],a0=param[1];
        caml_call2(Stdlib_format[123],fmt,_b2_);
        pp_src_loc(fmt,a0);
        caml_call2(Stdlib_format[123],fmt,_b3_);
        caml_call1(caml_call1(pp_tmctor,fmt),a1);
        return caml_call2(Stdlib_format[123],fmt,_b4_)});
    caml_update_dummy
     (show_tm$0,
      function(x){return caml_call3(Stdlib_format[127],_b5_,pp_tm$0,x)});
    caml_update_dummy
     (pp_tmctor,
      function(fmt,param)
       {switch(param[0])
         {case 0:
           var a0=param[1];
           caml_call2(Stdlib_format[123],fmt,_b6_);
           caml_call1(pp_tmvar(fmt),a0);
           return caml_call2(Stdlib_format[123],fmt,_b7_);
          case 1:
           var a2=param[3],a1=param[2],a0$0=param[1];
           caml_call2(Stdlib_format[123],fmt,_b8_);
           caml_call1(caml_call1(pp_tm$0,fmt),a0$0);
           caml_call2(Stdlib_format[123],fmt,_b9_);
           caml_call1(pp_tmvar(fmt),a1);
           caml_call2(Stdlib_format[123],fmt,_b__);
           caml_call1(caml_call1(pp_tm$0,fmt),a2);
           return caml_call2(Stdlib_format[123],fmt,_b$_);
          case 2:
           var a1$0=param[2],a0$1=param[1];
           caml_call2(Stdlib_format[123],fmt,_ca_);
           caml_call1(pp_tyvar(fmt),a0$1);
           caml_call2(Stdlib_format[123],fmt,_cb_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$0);
           return caml_call2(Stdlib_format[123],fmt,_cc_);
          case 3:
           var a1$1=param[2],a0$2=param[1];
           caml_call2(Stdlib_format[123],fmt,_cd_);
           caml_call1(pp_tyvar(fmt),a0$2);
           caml_call2(Stdlib_format[123],fmt,_ce_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$1);
           return caml_call2(Stdlib_format[123],fmt,_cf_);
          case 4:
           var a0$3=param[1];
           caml_call2(Stdlib_format[123],fmt,_cg_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_ch_),a0$3);
           return caml_call2(Stdlib_format[123],fmt,_ci_);
          case 5:
           var a2$0=param[3],a1$2=param[2],a0$4=param[1];
           caml_call2(Stdlib_format[123],fmt,_cj_);
           caml_call1(caml_call1(pp_tm$0,fmt),a0$4);
           caml_call2(Stdlib_format[123],fmt,_ck_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$2);
           caml_call2(Stdlib_format[123],fmt,_cl_);
           caml_call1(caml_call1(pp_tm$0,fmt),a2$0);
           return caml_call2(Stdlib_format[123],fmt,_cm_);
          case 6:
           var a0$5=param[1];
           caml_call2(Stdlib_format[123],fmt,_cn_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_co_),a0$5);
           return caml_call2(Stdlib_format[123],fmt,_cp_);
          case 7:
           var a1$3=param[2],a0$6=param[1];
           caml_call2(Stdlib_format[123],fmt,_cq_);
           caml_call1(caml_call1(pp_tm$0,fmt),a0$6);
           caml_call2(Stdlib_format[123],fmt,_cr_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$3);
           return caml_call2(Stdlib_format[123],fmt,_cs_);
          case 8:
           var a1$4=param[2],a0$7=param[1];
           caml_call2(Stdlib_format[123],fmt,_ct_);
           caml_call1(caml_call1(pp_tm$0,fmt),a0$7);
           caml_call2(Stdlib_format[123],fmt,_cu_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$4);
           return caml_call2(Stdlib_format[123],fmt,_cv_);
          case 9:
           var a3=param[4],a2$1=param[3],a1$5=param[2],a0$8=param[1];
           caml_call2(Stdlib_format[123],fmt,_cw_);
           caml_call1(caml_call1(pp_tm$0,fmt),a0$8);
           caml_call2(Stdlib_format[123],fmt,_cx_);
           caml_call1(pp_tmvar(fmt),a1$5);
           caml_call2(Stdlib_format[123],fmt,_cy_);
           caml_call1(pp_tmvar(fmt),a2$1);
           caml_call2(Stdlib_format[123],fmt,_cz_);
           caml_call1(caml_call1(pp_tm$0,fmt),a3);
           return caml_call2(Stdlib_format[123],fmt,_cA_);
          case 10:
           var a2$2=param[3],a1$6=param[2],a0$9=param[1];
           caml_call2(Stdlib_format[123],fmt,_cB_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_cC_),a0$9);
           caml_call2(Stdlib_format[123],fmt,_cD_);
           caml_call1(caml_call1(pp_gtype,fmt),a1$6);
           caml_call2(Stdlib_format[123],fmt,_cE_);
           caml_call1(caml_call1(pp_tm$0,fmt),a2$2);
           return caml_call2(Stdlib_format[123],fmt,_cF_);
          case 11:
           var a1$7=param[2],a0$10=param[1];
           caml_call2(Stdlib_format[123],fmt,_cG_);
           caml_call1(caml_call1(pp_tm$0,fmt),a0$10);
           caml_call2(Stdlib_format[123],fmt,_cH_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$7);
           return caml_call2(Stdlib_format[123],fmt,_cI_);
          case 12:
           var a2$3=param[3],a1$8=param[2],a0$11=param[1];
           caml_call2(Stdlib_format[123],fmt,_cJ_);
           caml_call1(pp_tyvar(fmt),a0$11);
           caml_call2(Stdlib_format[123],fmt,_cK_);
           caml_call1(caml_call1(pp_gtype,fmt),a1$8);
           caml_call2(Stdlib_format[123],fmt,_cL_);
           caml_call1(caml_call1(pp_tm$0,fmt),a2$3);
           return caml_call2(Stdlib_format[123],fmt,_cM_);
          case 13:
           var a3$0=param[4],a2$4=param[3],a1$9=param[2],a0$12=param[1];
           caml_call2(Stdlib_format[123],fmt,_cN_);
           caml_call1(caml_call1(pp_tm$0,fmt),a0$12);
           caml_call2(Stdlib_format[123],fmt,_cO_);
           caml_call1(pp_tyvar(fmt),a1$9);
           caml_call2(Stdlib_format[123],fmt,_cP_);
           caml_call1(pp_tmvar(fmt),a2$4);
           caml_call2(Stdlib_format[123],fmt,_cQ_);
           caml_call1(caml_call1(pp_tm$0,fmt),a3$0);
           return caml_call2(Stdlib_format[123],fmt,_cR_);
          case 14:
           var a0$13=param[1];
           caml_call2(Stdlib_format[123],fmt,_cS_);
           var a1$10=a0$13[2],a0$14=a0$13[1];
           caml_call2(Stdlib_format[123],fmt,_cT_);
           caml_call1(pp_tyvar(fmt),a0$14);
           caml_call2(Stdlib_format[123],fmt,_cU_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$10);
           caml_call2(Stdlib_format[123],fmt,_cV_);
           return caml_call2(Stdlib_format[123],fmt,_cW_);
          case 15:
           var a0$15=param[1];
           caml_call2(Stdlib_format[123],fmt,_cX_);
           var a2$5=a0$15[3],a1$11=a0$15[2],a0$16=a0$15[1];
           caml_call2(Stdlib_format[123],fmt,_cY_);
           caml_call1(caml_call1(pp_tm$0,fmt),a0$16);
           caml_call2(Stdlib_format[123],fmt,_cZ_);
           caml_call1(pp_tyvar(fmt),a1$11);
           caml_call2(Stdlib_format[123],fmt,_c0_);
           caml_call1(caml_call1(pp_gtype,fmt),a2$5);
           caml_call2(Stdlib_format[123],fmt,_c1_);
           return caml_call2(Stdlib_format[123],fmt,_c2_);
          case 16:
           var a1$12=param[2],a0$17=param[1];
           caml_call2(Stdlib_format[123],fmt,_c3_);
           caml_call1(caml_call1(pp_gtype,fmt),a0$17);
           caml_call2(Stdlib_format[123],fmt,_c4_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$12);
           return caml_call2(Stdlib_format[123],fmt,_c5_);
          default:
           var a1$13=param[2],a0$18=param[1];
           caml_call2(Stdlib_format[123],fmt,_c6_);
           caml_call1(caml_call1(pp_tagty,fmt),a0$18);
           caml_call2(Stdlib_format[123],fmt,_c7_);
           caml_call1(caml_call1(pp_tm$0,fmt),a1$13);
           return caml_call2(Stdlib_format[123],fmt,_c8_)}});
    caml_update_dummy
     (show_tmctor,
      function(x){return caml_call3(Stdlib_format[127],_c9_,pp_tmctor,x)});
    var
     equal_tm$0=function _m9_(_m7_,_m8_){return _m9_.fun(_m7_,_m8_)},
     equal_tmctor=function _m6_(_m4_,_m5_){return _m6_.fun(_m4_,_m5_)};
    caml_update_dummy
     (equal_tm$0,
      function(param,_m3_)
       {var rhs1=_m3_[2],lhs1=param[2];
        return caml_call1(caml_call1(equal_tmctor,lhs1),rhs1)});
    caml_update_dummy
     (equal_tmctor,
      function(lhs,match)
       {switch(lhs[0])
         {case 0:
           if(0 === match[0])
            {var rhs0=match[1],lhs0=lhs[1];
             return caml_string_equal(lhs0,rhs0)}
           break;
          case 1:
           if(1 === match[0])
            {var
              rhs2=match[3],
              rhs1=match[2],
              rhs0$0=match[1],
              lhs2=lhs[3],
              lhs1=lhs[2],
              lhs0$0=lhs[1],
              _mF_=caml_call1(caml_call1(equal_tm$0,lhs0$0),rhs0$0),
              _mG_=_mF_?caml_string_equal(lhs1,rhs1):_mF_;
             return _mG_?caml_call1(caml_call1(equal_tm$0,lhs2),rhs2):_mG_}
           break;
          case 2:
           if(2 === match[0])
            {var
              rhs1$0=match[2],
              rhs0$1=match[1],
              lhs1$0=lhs[2],
              lhs0$1=lhs[1],
              _m0_=caml_string_equal(lhs0$1,rhs0$1);
             return _m0_?caml_call1(caml_call1(equal_tm$0,lhs1$0),rhs1$0):_m0_}
           break;
          case 3:
           if(3 === match[0])
            {var
              rhs1$1=match[2],
              rhs0$2=match[1],
              lhs1$1=lhs[2],
              lhs0$2=lhs[1],
              _m1_=caml_string_equal(lhs0$2,rhs0$2);
             return _m1_?caml_call1(caml_call1(equal_tm$0,lhs1$1),rhs1$1):_m1_}
           break;
          case 4:
           if(4 === match[0])
            {var rhs0$3=match[1],lhs0$3=lhs[1];return lhs0$3 === rhs0$3?1:0}
           break;
          case 5:
           if(5 === match[0])
            {var
              rhs2$0=match[3],
              rhs1$2=match[2],
              rhs0$4=match[1],
              lhs2$0=lhs[3],
              lhs1$2=lhs[2],
              lhs0$4=lhs[1],
              _mH_=caml_call1(caml_call1(equal_tm$0,lhs0$4),rhs0$4),
              _mI_=_mH_?caml_call1(caml_call1(equal_tm$0,lhs1$2),rhs1$2):_mH_;
             return _mI_?caml_call1(caml_call1(equal_tm$0,lhs2$0),rhs2$0):_mI_}
           break;
          case 6:
           if(6 === match[0])
            {var rhs0$5=match[1],lhs0$5=lhs[1];return lhs0$5 === rhs0$5?1:0}
           break;
          case 7:
           if(7 === match[0])
            {var
              rhs1$3=match[2],
              rhs0$6=match[1],
              lhs1$3=lhs[2],
              lhs0$6=lhs[1],
              _mJ_=caml_call1(caml_call1(equal_tm$0,lhs0$6),rhs0$6);
             return _mJ_?caml_call1(caml_call1(equal_tm$0,lhs1$3),rhs1$3):_mJ_}
           break;
          case 8:
           if(8 === match[0])
            {var
              rhs1$4=match[2],
              rhs0$7=match[1],
              lhs1$4=lhs[2],
              lhs0$7=lhs[1],
              _mK_=caml_call1(caml_call1(equal_tm$0,lhs0$7),rhs0$7);
             return _mK_?caml_call1(caml_call1(equal_tm$0,lhs1$4),rhs1$4):_mK_}
           break;
          case 9:
           if(9 === match[0])
            {var
              rhs3=match[4],
              rhs2$1=match[3],
              rhs1$5=match[2],
              rhs0$8=match[1],
              lhs3=lhs[4],
              lhs2$1=lhs[3],
              lhs1$5=lhs[2],
              lhs0$8=lhs[1],
              _mL_=caml_call1(caml_call1(equal_tm$0,lhs0$8),rhs0$8),
              _mM_=_mL_?caml_string_equal(lhs1$5,rhs1$5):_mL_,
              _mN_=_mM_?caml_string_equal(lhs2$1,rhs2$1):_mM_;
             return _mN_?caml_call1(caml_call1(equal_tm$0,lhs3),rhs3):_mN_}
           break;
          case 10:
           if(10 === match[0])
            {var
              rhs2$2=match[3],
              rhs1$6=match[2],
              rhs0$9=match[1],
              lhs2$2=lhs[3],
              lhs1$6=lhs[2],
              lhs0$9=lhs[1],
              _mO_=caml_string_equal(lhs0$9,rhs0$9),
              _mP_=_mO_?caml_call1(caml_call1(equal_gtype,lhs1$6),rhs1$6):_mO_;
             return _mP_?caml_call1(caml_call1(equal_tm$0,lhs2$2),rhs2$2):_mP_}
           break;
          case 11:
           if(11 === match[0])
            {var
              rhs1$7=match[2],
              rhs0$10=match[1],
              lhs1$7=lhs[2],
              lhs0$10=lhs[1],
              _mQ_=caml_call1(caml_call1(equal_tm$0,lhs0$10),rhs0$10);
             return _mQ_?caml_call1(caml_call1(equal_tm$0,lhs1$7),rhs1$7):_mQ_}
           break;
          case 12:
           if(12 === match[0])
            {var
              rhs2$3=match[3],
              rhs1$8=match[2],
              rhs0$11=match[1],
              lhs2$3=lhs[3],
              lhs1$8=lhs[2],
              lhs0$11=lhs[1],
              _m2_=caml_string_equal(lhs0$11,rhs0$11),
              _mR_=_m2_?caml_call1(caml_call1(equal_gtype,lhs1$8),rhs1$8):_m2_;
             return _mR_?caml_call1(caml_call1(equal_tm$0,lhs2$3),rhs2$3):_mR_}
           break;
          case 13:
           if(13 === match[0])
            {var
              rhs3$0=match[4],
              rhs2$4=match[3],
              rhs1$9=match[2],
              rhs0$12=match[1],
              lhs3$0=lhs[4],
              lhs2$4=lhs[3],
              lhs1$9=lhs[2],
              lhs0$12=lhs[1],
              _mS_=caml_call1(caml_call1(equal_tm$0,lhs0$12),rhs0$12),
              _mT_=_mS_?caml_string_equal(lhs1$9,rhs1$9):_mS_,
              _mU_=_mT_?caml_string_equal(lhs2$4,rhs2$4):_mT_;
             return _mU_?caml_call1(caml_call1(equal_tm$0,lhs3$0),rhs3$0):_mU_}
           break;
          case 14:
           if(14 === match[0])
            {var
              rhs0$13=match[1],
              lhs0$13=lhs[1],
              rhs1$10=rhs0$13[2],
              rhs0$14=rhs0$13[1],
              lhs1$10=lhs0$13[2],
              lhs0$14=lhs0$13[1],
              _mZ_=caml_string_equal(lhs0$14,rhs0$14);
             return _mZ_
                     ?caml_call1(caml_call1(equal_tm$0,lhs1$10),rhs1$10)
                     :_mZ_}
           break;
          case 15:
           if(15 === match[0])
            {var
              rhs0$15=match[1],
              lhs0$15=lhs[1],
              rhs2$5=rhs0$15[3],
              rhs1$11=rhs0$15[2],
              rhs0$16=rhs0$15[1],
              lhs2$5=lhs0$15[3],
              lhs1$11=lhs0$15[2],
              lhs0$16=lhs0$15[1],
              _mV_=caml_call1(caml_call1(equal_tm$0,lhs0$16),rhs0$16),
              _mW_=_mV_?caml_string_equal(lhs1$11,rhs1$11):_mV_;
             return _mW_
                     ?caml_call1(caml_call1(equal_gtype,lhs2$5),rhs2$5)
                     :_mW_}
           break;
          case 16:
           if(16 === match[0])
            {var
              rhs1$12=match[2],
              rhs0$17=match[1],
              lhs1$12=lhs[2],
              lhs0$17=lhs[1],
              _mX_=caml_call1(caml_call1(equal_gtype,lhs0$17),rhs0$17);
             return _mX_
                     ?caml_call1(caml_call1(equal_tm$0,lhs1$12),rhs1$12)
                     :_mX_}
           break;
          default:
           if(17 === match[0])
            {var
              rhs1$13=match[2],
              rhs0$18=match[1],
              lhs1$13=lhs[2],
              lhs0$18=lhs[1],
              _mY_=caml_call1(caml_call1(equal_tagty,lhs0$18),rhs0$18);
             return _mY_
                     ?caml_call1(caml_call1(equal_tm$0,lhs1$13),rhs1$13)
                     :_mY_}}
        return 0});
    var
     PolyGNew_Surf=
      [0,
       pp_tyvar,
       show_tyvar,
       equal_tyvar,
       pp_tmvar,
       show_tmvar,
       equal_tmvar,
       pp_src_loc,
       show_src_loc,
       equal_src_loc,
       pp_tm$0,
       show_tm$0,
       pp_tmctor,
       show_tmctor,
       equal_tm$0,
       equal_tmctor];
    caml_register_global(494,PolyGNew_Surf,"PolyGNew__Surf");
    function int$0(n)
     {var _mE_=caml_call1(Stdlib[33],n);return caml_call1(PPrint[3],_mE_)}
    function args(docs)
     {var
       _mz_=caml_call2(Stdlib_list[17],PPrint[13],docs),
       _mA_=caml_call1(PPrint[10],1),
       _mB_=caml_call2(PPrint[11],PPrint[38],_mA_),
       _mC_=caml_call2(PPrint[71],_mB_,_mz_),
       _mD_=caml_call1(PPrint[13],_mC_);
      return caml_call1(PPrint[15],_mD_)}
    function binding(name,pattern,scrutinee,kont)
     {var
       _mn_=caml_call1(PPrint[91],cst_in),
       _mo_=caml_call1(PPrint[15],scrutinee),
       _mp_=caml_call1(PPrint[91],cst$0),
       _mq_=caml_call2(PPrint[11],PPrint[39],_mp_),
       _mr_=caml_call1(PPrint[15],pattern),
       _ms_=caml_call2(PPrint[11],_mr_,_mq_),
       _mt_=caml_call2(PPrint[11],PPrint[39],_ms_),
       _mu_=caml_call1(PPrint[91],name),
       _mv_=caml_call2(PPrint[11],_mu_,_mt_),
       _mw_=caml_call2(PPrint[93],_mv_,_mo_),
       _mx_=caml_call2(PPrint[92],_mw_,_mn_),
       _my_=caml_call1(PPrint[13],_mx_);
      return caml_call2(PPrint[92],_my_,kont)}
    function app(rator,rand){return caml_call2(PPrint[93],rator,rand)}
    function src_loc(param)
     {var
       col=param[2],
       line=param[1],
       _me_=int$0(col),
       _mf_=caml_call2(PPrint[11],PPrint[39],_me_),
       _mg_=caml_call1(PPrint[91],cst_column),
       _mh_=caml_call2(PPrint[11],_mg_,_mf_),
       _mi_=caml_call2(PPrint[11],PPrint[39],_mh_),
       _mj_=int$0(line),
       _mk_=caml_call2(PPrint[11],_mj_,_mi_),
       _ml_=caml_call2(PPrint[11],PPrint[39],_mk_),
       _mm_=caml_call1(PPrint[91],cst_line);
      return caml_call2(PPrint[11],_mm_,_ml_)}
    function pptag(param)
     {if(typeof param === "number")
       switch(param)
        {case 0:return caml_call1(PPrint[3],cst_bool);
         case 1:return caml_call1(PPrint[3],cst_int);
         case 2:return caml_call1(PPrint[3],cst$1);
         case 3:return caml_call1(PPrint[3],cst$2);
         case 4:return caml_call1(PPrint[3],cst_exists);
         default:return caml_call1(PPrint[3],cst_forall)}
      var _mc_=param[1];
      if(0 === _mc_[0])
       {var n=_mc_[1],_md_=caml_call1(Stdlib[33],n);
        return caml_call1(PPrint[3],_md_)}
      var x=_mc_[1];
      return caml_call1(PPrint[3],x)}
    function loop(ctx,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:return caml_call1(PPrint[3],cst$3);
         case 1:return caml_call1(PPrint[3],cst_bool$0);
         default:return caml_call1(PPrint[3],cst_int$0)}
      else
       switch(param[0])
        {case 0:
          var
           p=param[2],
           tag=param[1],
           _lO_=[0,loop(0,p),0],
           _lP_=args([0,pptag(tag),_lO_]),
           _lQ_=caml_call1(PPrint[65],_lP_),
           _lR_=caml_call1(PPrint[91],cst_tag);
          return caml_call2(PPrint[11],_lR_,_lQ_);
         case 1:
          var _lS_=param[1];
          if(0 === _lS_[0]){var n=_lS_[1];return int$0(n)}
          var x=_lS_[1];
          return caml_call1(PPrint[3],x);
         case 2:
          var
           b=param[2],
           a=param[1],
           _lT_=loop(2,b),
           _lU_=caml_call1(PPrint[3],cst$4),
           _lV_=caml_call2(PPrint[11],_lU_,_lT_),
           _lW_=loop(1,a),
           x$0=caml_call2(PPrint[11],_lW_,_lV_);
          if(1 !== ctx)if(! (3 <= ctx))return x$0;
          return caml_call1(PPrint[65],x$0);
         case 3:
          var
           b$0=param[2],
           a$0=param[1],
           _lX_=loop(0,b$0),
           _lY_=caml_call1(PPrint[91],cst$5),
           _lZ_=caml_call2(PPrint[92],_lY_,_lX_),
           _l0_=caml_call2(PPrint[11],PPrint[39],_lZ_),
           _l1_=loop(1,a$0),
           x$1=caml_call2(PPrint[11],_l1_,_l0_);
          return 0 === ctx?x$1:caml_call1(PPrint[65],x$1);
         case 4:
          var
           a$1=param[2],
           x$2=param[1],
           _l2_=loop(0,a$1),
           _l3_=caml_call2(PPrint[92],PPrint[40],_l2_),
           _l4_=caml_call1(PPrint[91],x$2),
           _l5_=caml_call2(PPrint[11],_l4_,_l3_),
           _l6_=caml_call2(PPrint[11],PPrint[39],_l5_),
           _l7_=caml_call1(PPrint[91],cst_exists$0);
          return caml_call2(PPrint[11],_l7_,_l6_);
         default:
          var
           a$2=param[2],
           x$3=param[1],
           _l8_=loop(0,a$2),
           _l9_=caml_call2(PPrint[92],PPrint[40],_l8_),
           _l__=caml_call1(PPrint[91],x$3),
           _l$_=caml_call2(PPrint[11],_l__,_l9_),
           _ma_=caml_call2(PPrint[11],PPrint[39],_l$_),
           _mb_=caml_call1(PPrint[91],cst_forall$0);
          return caml_call2(PPrint[11],_mb_,_ma_)}}
    var _c__=0;
    function ppprec(_lN_){return loop(_c__,_lN_)}
    function ppty(a){return ppprec(refl(a))}
    function ppnm(nm){return ppty([0,nm])}
    function ppdir(param)
     {return 0 === param
              ?caml_call1(PPrint[3],cst_up)
              :caml_call1(PPrint[3],cst_down)}
    function ppcast(param)
     {var
       d=param[2],
       p=param[1],
       _lI_=ppprec(p),
       _lJ_=caml_call1(PPrint[13],_lI_),
       _lK_=caml_call1(PPrint[15],_lJ_),
       _lL_=caml_call1(PPrint[66],_lK_),
       _lM_=ppdir(d);
      return caml_call2(PPrint[11],_lM_,_lL_)}
    function pppackcast(param)
     {var d=param[3],p=param[2],tyX=param[1];return ppcast([0,[4,tyX,p],d])}
    function pppackcasts(csts)
     {function pretty_cast(param)
       {var d=param[3],p=param[2],tyX=param[1];return ppcast([0,[4,tyX,p],d])}
      var _lH_=args(caml_call2(Stdlib_list[17],pretty_cast,csts));
      return caml_call1(PPrint[64],_lH_)}
    function equal_tm_ctx(lhs,rhs)
     {switch(lhs)
       {case 0:if(0 === rhs)return 1;break;
        case 1:if(1 === rhs)return 1;break;
        case 2:if(2 === rhs)return 1;break;
        case 3:if(3 === rhs)return 1;break;
        case 4:if(4 === rhs)return 1;break;
        default:if(5 <= rhs)return 1}
      return 0}
    function wrap_if(ctx,ctxs,x)
     {function _lE_(_lG_){return equal_tm_ctx(ctx,_lG_)}
      if(caml_call2(Stdlib_list[29],_lE_,ctxs))
       {var _lF_=caml_call1(PPrint[15],x);return caml_call1(PPrint[65],_lF_)}
      return x}
    function loop$0(ctx,param)
     {switch(param[0])
       {case 0:var x=param[1];return caml_call1(PPrint[3],x);
        case 1:
         var
          tk=param[3],
          x$0=param[2],
          t=param[1],
          _jL_=loop$0(0,tk),
          _jM_=loop$0(5,t);
         return wrap_if
                 (ctx,
                  _c$_,
                  binding(cst_let,caml_call1(PPrint[91],x$0),_jM_,_jL_));
        case 2:
         var
          m=param[2],
          nm=param[1],
          _jN_=loop$0(2,m),
          _jO_=ppnm(nm),
          _jP_=caml_call2(PPrint[11],PPrint[39],_jO_),
          _jQ_=caml_call1(PPrint[91],cst_seal);
         return wrap_if(ctx,_da_,app(caml_call2(PPrint[11],_jQ_,_jP_),_jN_));
        case 3:
         var
          m$0=param[2],
          nm$0=param[1],
          _jR_=loop$0(2,m$0),
          _jS_=ppnm(nm$0),
          _jT_=caml_call2(PPrint[11],PPrint[39],_jS_),
          _jU_=caml_call1(PPrint[91],cst_unseal);
         return wrap_if(ctx,_db_,app(caml_call2(PPrint[11],_jU_,_jT_),_jR_));
        case 4:
         var b=param[1],_jV_=b?cst_true:cst_false;
         return caml_call1(PPrint[3],_jV_);
        case 5:
         var
          ft=param[3],
          tt=param[2],
          bt=param[1],
          _jW_=loop$0(0,ft),
          _jX_=caml_call1(PPrint[15],_jW_),
          _jY_=caml_call1(PPrint[3],cst_else),
          _jZ_=caml_call2(PPrint[11],_jY_,_jX_),
          _j0_=loop$0(0,tt),
          _j1_=caml_call1(PPrint[15],_j0_),
          _j2_=caml_call2(PPrint[92],_j1_,_jZ_),
          _j3_=caml_call1(PPrint[3],cst_then),
          _j4_=caml_call2(PPrint[11],_j3_,_j2_),
          _j5_=loop$0(5,bt),
          _j6_=caml_call1(PPrint[15],_j5_),
          _j7_=caml_call2(PPrint[92],_j6_,_j4_),
          _j8_=caml_call1(PPrint[3],cst_if),
          _j9_=caml_call2(PPrint[11],_j8_,_j7_),
          _j__=caml_call1(PPrint[13],_j9_);
         return wrap_if(ctx,_dc_,caml_call1(PPrint[15],_j__));
        case 6:
         var
          t2=param[2],
          t1=param[1],
          _j$_=[0,loop$0(0,t2),0],
          _ka_=args([0,loop$0(0,t1),_j$_]);
         return caml_call1(PPrint[65],_ka_);
        case 7:
         var
          kt=param[4],
          x2=param[3],
          x1=param[2],
          pt=param[1],
          _kb_=loop$0(0,kt),
          _kc_=loop$0(5,pt),
          _kd_=[0,caml_call1(PPrint[91],x2),0],
          _ke_=args([0,caml_call1(PPrint[91],x1),_kd_]);
         return wrap_if
                 (ctx,
                  _dd_,
                  binding(cst_let$0,caml_call1(PPrint[65],_ke_),_kc_,_kb_));
        case 8:
         var
          t$0=param[3],
          a=param[2],
          x$1=param[1],
          _kf_=loop$0(0,t$0),
          _kg_=caml_call1(PPrint[3],cst$6),
          _kh_=caml_call2(PPrint[92],_kg_,_kf_),
          _ki_=ppty(a),
          _kj_=caml_call1(PPrint[15],_ki_),
          _kk_=caml_call2(PPrint[11],_kj_,_kh_),
          _kl_=caml_call1(PPrint[3],cst$7),
          _km_=caml_call2(PPrint[11],_kl_,_kk_),
          _kn_=caml_call1(PPrint[3],x$1),
          _ko_=caml_call2(PPrint[11],_kn_,_km_),
          _kp_=caml_call1(PPrint[3],cst_fun),
          _kq_=caml_call2(PPrint[11],_kp_,_ko_);
         return wrap_if(ctx,_de_,caml_call1(PPrint[13],_kq_));
        case 9:
         var ta=param[2],tf=param[1],_kr_=loop$0(2,ta);
         return wrap_if(ctx,_df_,app(loop$0(1,tf),_kr_));
        case 10:
         var
          m$1=param[3],
          ty=param[2],
          tyX=param[1],
          _ks_=caml_call1(PPrint[3],cst$8),
          _kt_=loop$0(0,m$1),
          _ku_=caml_call1(PPrint[3],cst$9),
          _kv_=caml_call2(PPrint[92],_ku_,_kt_),
          _kw_=ppty(ty),
          _kx_=caml_call2(PPrint[11],_kw_,_kv_),
          _ky_=caml_call1(PPrint[3],cst$10),
          _kz_=caml_call2(PPrint[11],_ky_,_kx_),
          _kA_=caml_call1(PPrint[3],tyX),
          _kB_=caml_call2(PPrint[11],_kA_,_kz_),
          _kC_=caml_call1(PPrint[13],_kB_),
          _kD_=caml_call1(PPrint[15],_kC_),
          _kE_=caml_call2(PPrint[11],_kD_,_ks_),
          _kF_=caml_call1(PPrint[3],cst_pack);
         return caml_call2(PPrint[11],_kF_,_kE_);
        case 11:
         var
          kt$0=param[4],
          x$2=param[3],
          tyX$0=param[2],
          t$1=param[1],
          _kG_=loop$0(0,kt$0),
          _kH_=loop$0(5,t$1),
          _kI_=[0,caml_call1(PPrint[91],x$2),0],
          _kJ_=args([0,caml_call1(PPrint[91],tyX$0),_kI_]);
         return wrap_if
                 (ctx,
                  _dg_,
                  binding(cst_unpack,caml_call1(PPrint[66],_kJ_),_kH_,_kG_));
        case 12:
         var
          m$2=param[4],
          precs=param[3],
          ty$0=param[2],
          tyX$1=param[1],
          _kK_=caml_call1(PPrint[3],cst$11),
          _kL_=loop$0(0,m$2),
          _kM_=caml_call1(PPrint[15],_kL_),
          _kN_=caml_call1(PPrint[3],cst$12),
          _kO_=caml_call2(PPrint[92],_kN_,_kM_),
          _kP_=pppackcasts(precs),
          _kQ_=caml_call1(PPrint[15],_kP_),
          _kR_=caml_call2(PPrint[11],_kQ_,_kO_),
          _kS_=caml_call1(PPrint[3],cst$13),
          _kT_=caml_call2(PPrint[92],_kS_,_kR_),
          _kU_=ppty(ty$0),
          _kV_=caml_call1(PPrint[15],_kU_),
          _kW_=caml_call2(PPrint[11],_kV_,_kT_),
          _kX_=caml_call1(PPrint[3],cst$14),
          _kY_=caml_call2(PPrint[11],_kX_,_kW_),
          _kZ_=caml_call1(PPrint[3],tyX$1),
          _k0_=caml_call2(PPrint[11],_kZ_,_kY_),
          _k1_=caml_call1(PPrint[13],_k0_),
          _k2_=caml_call1(PPrint[15],_k1_),
          _k3_=caml_call2(PPrint[11],_k2_,_kK_),
          _k4_=caml_call1(PPrint[3],cst_pack$0);
         return caml_call2(PPrint[11],_k4_,_k3_);
        case 13:
         var
          match=param[1],
          t$2=match[2],
          tyX$2=match[1],
          _k5_=loop$0(0,t$2),
          _k6_=caml_call1(PPrint[3],cst$15),
          _k7_=caml_call2(PPrint[93],_k6_,_k5_),
          _k8_=caml_call1(PPrint[3],tyX$2),
          _k9_=caml_call2(PPrint[11],_k8_,_k7_),
          _k__=caml_call1(PPrint[3],cst_Lambda),
          _k$_=caml_call2(PPrint[11],_k__,_k9_);
         return wrap_if(ctx,_dh_,caml_call1(PPrint[13],_k$_));
        case 14:
         var
          match$0=param[1],
          a$0=match$0[3],
          nm$1=match$0[2],
          t$3=match$0[1],
          _la_=ppty(a$0),
          _lb_=caml_call2(PPrint[11],PPrint[39],_la_),
          _lc_=caml_call1(PPrint[91],cst$16),
          _ld_=caml_call2(PPrint[11],_lc_,_lb_),
          _le_=caml_call2(PPrint[11],PPrint[39],_ld_),
          _lf_=ppnm(nm$1),
          _lg_=caml_call2(PPrint[11],_lf_,_le_),
          _lh_=caml_call1(PPrint[64],_lg_);
         return wrap_if(ctx,_di_,app(loop$0(1,t$3),_lh_));
        case 15:
         var
          t$4=param[3],
          a$1=param[2],
          tyX$3=param[1],
          _li_=loop$0(0,t$4),
          _lj_=caml_call1(PPrint[3],cst_in$0),
          _lk_=caml_call2(PPrint[92],_lj_,_li_),
          _ll_=ppty(a$1),
          _lm_=caml_call2(PPrint[11],_ll_,_lk_),
          _ln_=caml_call1(PPrint[3],cst$17),
          _lo_=caml_call2(PPrint[11],_ln_,_lm_),
          _lp_=caml_call1(PPrint[3],tyX$3),
          _lq_=caml_call2(PPrint[11],_lp_,_lo_),
          _lr_=caml_call1(PPrint[3],cst_hide),
          _ls_=caml_call2(PPrint[11],_lr_,_lq_);
         return wrap_if(ctx,_dj_,caml_call1(PPrint[13],_ls_));
        case 16:
         var t$5=param[3],d=param[2],p=param[1],_lt_=loop$0(2,t$5);
         return wrap_if(ctx,_dk_,app(ppcast([0,p,d]),_lt_));
        case 17:
         var
          t$6=param[2],
          g=param[1],
          _lu_=loop$0(2,t$6),
          _lv_=pptag(g),
          _lw_=caml_call1(PPrint[66],_lv_),
          _lx_=caml_call1(PPrint[91],cst_dinj);
         return wrap_if(ctx,_dl_,app(caml_call2(PPrint[11],_lx_,_lw_),_lu_));
        case 18:
         var n=param[1],_ly_=caml_call1(Stdlib[33],n);
         return caml_call1(PPrint[3],_ly_);
        case 19:
         var
          tr=param[2],
          tl=param[1],
          _lz_=loop$0(4,tr),
          _lA_=caml_call1(PPrint[3],cst$18),
          _lB_=caml_call2(PPrint[11],_lA_,_lz_),
          _lC_=loop$0(4,tl);
         return wrap_if(ctx,_dm_,caml_call2(PPrint[11],_lC_,_lB_));
        default:
         var t$7=param[2],g$0=param[1],_lD_=loop$0(2,t$7);
         return wrap_if(ctx,_dn_,app(pptag(g$0),_lD_))}}
    var _do_=0;
    function pptm(_jK_){return loop$0(_do_,_jK_)}
    function string_of_doc(d)
     {var b=caml_call1(Stdlib_buffer[1],100);
      caml_call4(PPrint[18][1],0.8,100,b,d);
      return caml_call1(Stdlib_buffer[2],b)}
    var
     PolyGNew_Pretty=
      [0,
       int$0,
       args,
       binding,
       app,
       src_loc,
       pptag,
       ppprec,
       ppty,
       ppnm,
       ppdir,
       ppcast,
       pppackcast,
       pppackcasts,
       equal_tm_ctx,
       wrap_if,
       pptm,
       string_of_doc];
    caml_register_global(497,PolyGNew_Pretty,"PolyGNew__Pretty");
    var
     pp_binding=function _jJ_(_jH_,_jI_){return _jJ_.fun(_jH_,_jI_)},
     show_binding=function _jG_(_jF_){return _jG_.fun(_jF_)};
    caml_update_dummy
     (pp_binding,
      function(fmt,param)
       {switch(param[0])
         {case 0:
           var a0=param[1];
           caml_call2(Stdlib_format[123],fmt,_dp_);
           var a1=a0[2],a0$0=a0[1];
           caml_call2(Stdlib_format[123],fmt,_dq_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_dr_),a0$0);
           caml_call2(Stdlib_format[123],fmt,_ds_);
           caml_call1(caml_call1(pp_gtype,fmt),a1);
           caml_call2(Stdlib_format[123],fmt,_dt_);
           return caml_call2(Stdlib_format[123],fmt,_du_);
          case 1:
           var a0$1=param[1];
           caml_call2(Stdlib_format[123],fmt,_dv_);
           var a1$0=a0$1[2],a0$2=a0$1[1];
           caml_call2(Stdlib_format[123],fmt,_dw_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_dx_),a0$2);
           caml_call2(Stdlib_format[123],fmt,_dy_);
           caml_call1(caml_call1(pp_gtype,fmt),a1$0);
           caml_call2(Stdlib_format[123],fmt,_dz_);
           return caml_call2(Stdlib_format[123],fmt,_dA_);
          default:
           var a0$3=param[1];
           caml_call2(Stdlib_format[123],fmt,_dB_);
           caml_call1(caml_call2(Stdlib_format[123],fmt,_dC_),a0$3);
           return caml_call2(Stdlib_format[123],fmt,_dD_)}});
    caml_update_dummy
     (show_binding,
      function(x){return caml_call3(Stdlib_format[127],_dE_,pp_binding,x)});
    var
     pp_known_ty_var=function _jE_(_jC_,_jD_){return _jE_.fun(_jC_,_jD_)},
     show_known_ty_var=function _jB_(_jA_){return _jB_.fun(_jA_)};
    caml_update_dummy
     (pp_known_ty_var,
      function(fmt,param)
       {var a1=param[2],a0=param[1];
        caml_call2(Stdlib_format[123],fmt,_dF_);
        caml_call1(caml_call2(Stdlib_format[123],fmt,_dG_),a0);
        caml_call2(Stdlib_format[123],fmt,_dH_);
        caml_call1(caml_call1(pp_gtype,fmt),a1);
        return caml_call2(Stdlib_format[123],fmt,_dI_)});
    caml_update_dummy
     (show_known_ty_var,
      function(x)
       {return caml_call3(Stdlib_format[127],_dJ_,pp_known_ty_var,x)});
    var
     pp_env=function _jz_(_jx_,_jy_){return _jz_.fun(_jx_,_jy_)},
     show_env=function _jw_(_jv_){return _jw_.fun(_jv_)};
    caml_update_dummy
     (pp_env,
      function(fmt,param)
       {var a1=param[2],a0=param[1];
        caml_call2(Stdlib_format[123],fmt,_dK_);
        caml_call2(Stdlib_format[123],fmt,_dL_);
        var _jt_=0;
        function _ju_(sep,x)
         {if(sep)caml_call2(Stdlib_format[123],fmt,_dM_);
          caml_call1(caml_call1(pp_binding,fmt),x);
          return 1}
        caml_call3(Stdlib_list[21],_ju_,_jt_,a0);
        caml_call2(Stdlib_format[123],fmt,_dN_);
        caml_call2(Stdlib_format[123],fmt,_dO_);
        pp_supply(fmt,a1);
        return caml_call2(Stdlib_format[123],fmt,_dP_)});
    caml_update_dummy
     (show_env,
      function(x){return caml_call3(Stdlib_format[127],_dQ_,pp_env,x)});
    function pretty_env(param)
     {var bindings=param[1];
      function loop(param)
       {if(param)
         {var bindings=param[2],bnd=param[1];
          switch(bnd[0])
           {case 0:
             var
              match=bnd[1],
              ty=match[2],
              x=match[1],
              _jh_=ppty(ty),
              _ji_=caml_call1(PPrint[3],cst$19),
              _jj_=caml_call2(PPrint[11],_ji_,_jh_),
              _jk_=caml_call1(PPrint[3],x),
              _jp_=caml_call2(PPrint[11],_jk_,_jj_);
             break;
            case 1:
             var
              match$0=bnd[1],
              ty$0=match$0[2],
              tyX=match$0[1],
              _jl_=ppty(ty$0),
              _jm_=caml_call1(PPrint[3],cst$20),
              _jn_=caml_call2(PPrint[11],_jm_,_jl_),
              _jo_=caml_call1(PPrint[3],tyX),
              _jp_=caml_call2(PPrint[11],_jo_,_jn_);
             break;
            default:var tyX$0=bnd[1],_jp_=caml_call1(PPrint[3],tyX$0)}
          var
           _jq_=caml_call1(PPrint[3],cst$21),
           _jr_=caml_call2(PPrint[92],_jq_,_jp_),
           _js_=loop(bindings);
          return caml_call2(PPrint[11],_js_,_jr_)}
        return caml_call1(PPrint[3],cst$22)}
      var _jg_=loop(bindings);
      return caml_call1(PPrint[13],_jg_)}
    function is_free(tyX)
     {function f(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var _jf_=param$0[1];
            switch(_jf_[0])
             {case 0:var param$1=param$0[2],param$0=param$1;continue;
              case 1:var tyY=_jf_[1][1],env=param$0[2];break;
              default:var tyY=_jf_[1],env=param$0[2]}
            if(caml_string_equal(tyX,tyY))return 0;
            var param$0=env;
            continue}
          return 1}}
      return f}
    var SMap=caml_call1(Stdlib_map[1],[0,Stdlib_string[33]]),empty=0;
    function push(delta,env)
     {function _je_(bnding,param)
       {var supp=param[2],bndings=param[1];
        return [0,[0,[1,bnding],bndings],supp]}
      return caml_call3(Stdlib_list[22],_je_,delta,env)}
    function concat(d1,d2){return caml_call2(Stdlib_list[11],d1,d2)}
    function restrict_all(d,badXs)
     {function step(param,_jd_)
       {var badXs=_jd_[2],d=_jd_[1],a=param[2],tyX=param[1];
        return caml_call2(SMap[3],tyX,badXs)
                ?[0,d,caml_call3(SMap[4],tyX,0,badXs)]
                :[0,[0,[0,tyX,a],d],badXs]}
      return caml_call3(Stdlib_list[22],step,d,[0,0,badXs])[1]}
    function restrict(d,tyX){return restrict_all(d,caml_call2(SMap[6],tyX,0))}
    function intersect(d1,d2)
     {function to_map(d)
       {var _jb_=SMap[1];
        function _jc_(map,param)
         {var a=param[2],tyX=param[1];return caml_call3(SMap[4],tyX,a,map)}
        return caml_call3(Stdlib_list[21],_jc_,_jb_,d)}
      function f(param,m1,m2)
       {if(m1)
         {var _ja_=m1[1];
          if(m2){var v2=m2[1];return caml_equal(_ja_,v2)?0:_dR_}
          return _dS_}
        return m2?_dT_:0}
      var
       _i__=to_map(d2),
       _i$_=to_map(d1),
       conflicts=caml_call3(SMap[8],f,_i$_,_i__);
      return restrict_all(d1,conflicts)}
    function ins(tyX,a,d){return [0,[0,tyX,a],d]}
    function hide_many(d_small,d_big,t)
     {var d_small$0=d_small,d_big$0=d_big,t$0=t;
      for(;;)
       {if(d_big$0)
         {var
           d_big$1=d_big$0[2],
           match$0=d_big$0[1],
           a=match$0[2],
           tyX=match$0[1];
          if(d_small$0)
           var
            match=d_small$0[1],
            tyY=match[1],
            _i9_=caml_string_equal(tyX,tyY);
          else
           var _i9_=0;
          if(_i9_)
           {var
             d_small$1=caml_call1(Stdlib_list[6],d_small$0),
             d_small$0=d_small$1,
             d_big$0=d_big$1;
            continue}
          var t$1=[15,tyX,a,t$0],d_big$0=d_big$1,t$0=t$1;
          continue}
        return t$0}}
    var Delta=[0,empty,push,concat,intersect,hide_many,ins,restrict];
    function ret(x){return [0,x]}
    function bind(m,k)
     {if(0 === m[0]){var x=m[1];return caml_call1(k,x)}
      var e=m[1];
      return [1,e]}
    function lookupKnownVar(tyX,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var _i8_=param$0[1];
          if(1 === _i8_[0])
           {var env=param$0[2],match=_i8_[1],ty=match[2],tyY=match[1];
            if(caml_string_equal(tyX,tyY))return [0,ty];
            var param$0=env;
            continue}
          var param$1=param$0[2],param$0=param$1;
          continue}
        return 0}}
    function lookupTmVar(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var _i7_=param$0[1];
          if(0 === _i7_[0])
           {var env=param$0[2],match=_i7_[1],ty=match[2],y=match[1];
            if(caml_string_equal(x,y))return [0,ty];
            var param$0=env;
            continue}
          var param$1=param$0[2],param$0=param$1;
          continue}
        return 0}}
    function mkCast(fromty,toty,tm)
     {var _i6_=[16,dynTop(fromty),0,tm];return [16,dynTop(toty),1,_i6_]}
    function guard(cond,t,e,m){return cond?caml_call1(m,0):[1,[0,t[1],e]]}
    function strerror(t,x)
     {var _i5_=caml_call1(PPrint[3],x);return [1,[0,t[1],_i5_]]}
    function tagDncast(tagty,ty,tm)
     {if(typeof ty === "number")
       if(0 === ty)return [16,dynTop(typ_from_tag(tagty)),1,tm];
      return tm}
    function unpair(tm,param)
     {if(typeof param === "number")
       {if(0 === param)return _dU_}
      else
       if(1 === param[0]){var b=param[2],a=param[1];return [0,[0,a,b]]}
      return strerror
              (tm,
               cst_tried_a_pair_pattern_match_on_something_with_type_incompatible_with_pair)}
    function unfun(tm,param)
     {if(typeof param === "number")
       {if(0 === param)return _dV_}
      else
       if(2 === param[0]){var b=param[2],a=param[1];return [0,[0,a,b]]}
      return strerror(tm,cst_tried_to_apply_something_that_isn_t_a_function)}
    function unexists(tm,param)
     {if(typeof param === "number")
       {if(0 === param)return _dW_}
      else
       if(3 === param[0]){var a=param[2],tyX=param[1];return [0,[0,tyX,a]]}
      return strerror
              (tm,
               cst_tried_to_unpack_something_with_type_incompatible_with_existential_quantifier)}
    function unforall(tm,param)
     {if(typeof param === "number")
       {if(0 === param)return _dX_}
      else
       if(4 === param[0]){var a=param[2],tyX=param[1];return [0,[0,tyX,a]]}
      return strerror
              (tm,
               cst_tried_to_instantiate_something_with_type_incompatible_with_universal_quantifier)}
    function isBound(tyX,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var _i2_=param$0[1];
          switch(_i2_[0])
           {case 0:var param$1=param$0[2],param$0=param$1;continue;
            case 1:
             var
              env=param$0[2],
              match=_i2_[1],
              tyY=match[1],
              _i3_=caml_string_equal(tyX,tyY);
             if(_i3_)return _i3_;
             var param$0=env;
             continue;
            default:
             var
              env$0=param$0[2],
              tyY$0=_i2_[1],
              _i4_=caml_string_equal(tyX,tyY$0);
             if(_i4_)return _i4_;
             var param$0=env$0;
             continue}}
        return 0}}
    function res_and(m1,m2)
     {var match=caml_call1(m1,0);
      if(0 === match[0])return caml_call1(m2,0);
      var e=match[1];
      return [1,e]}
    function covers(env,param)
     {var env$0=env,param$0=param;
      for(;;)
       {if(typeof param$0 !== "number")
         switch(param$0[0])
          {case 0:
            var _i0_=param$0[1];
            if(0 !== _i0_[0])
             {var tyX=_i0_[1];return isBound(tyX,env$0)?_dZ_:[1,tyX]}
            break;
           case 1:
           case 2:
            var
             b=param$0[2],
             a=param$0[1],
             _i1_=function(param){return covers(env$0,b)};
            return res_and(function(param){return covers(env$0,a)},_i1_);
           default:
            var
             param$1=param$0[2],
             tyX$0=param$0[1],
             env$1=[0,[2,tyX$0],env$0],
             env$0=env$1,
             param$0=param$1;
            continue}
        return _dY_}}
    function push$0(ty,param)
     {var supp=param[2],bindings=param[1];return [0,[0,ty,bindings],supp]}
    function init_env(param){return [0,0,init_supply(0)]}
    function mkError(tm,msg){return [1,[0,tm[1],msg]]}
    function elab_tm(env,tm)
     {var _hc_=tm[2];
      switch(_hc_[0])
       {case 0:
         var x=_hc_[1],match=lookupTmVar(x,env[1]);
         if(match){var ty=match[1];return [0,[0,[0,x],Delta[1],ty]]}
         var
          _hd_=caml_call1(PPrint[3],x),
          _he_=caml_call1(PPrint[3],cst_unbound_variable);
         return mkError(tm,caml_call2(PPrint[92],_he_,_hd_));
        case 1:
         var
          tk=_hc_[3],
          x$0=_hc_[2],
          t=_hc_[1],
          _hf_=
           function(param)
            {var
              tyx=param[3],
              envdt=param[2],
              t=param[1],
              env$0=push$0([0,[0,x$0,tyx]],caml_call2(Delta[2],envdt,env));
             function _iZ_(param)
              {var tyo=param[3],envdt$0=param[2],tk=param[1];
               return [0,
                       [0,[1,t,x$0,tk],caml_call2(Delta[3],envdt$0,envdt),tyo]]}
             return bind(elab_tm(env$0,tk),_iZ_)};
         return bind(elab_tm(env,t),_hf_);
        case 2:
         var
          t$0=_hc_[2],
          tyX=_hc_[1],
          _hg_=
           function(param)
            {var
              tty=param[3],
              envdt=param[2],
              t=param[1],
              env$0=caml_call2(Delta[2],envdt,env),
              match=lookupKnownVar(tyX,env$0[1]);
             if(match)
              {var
                ty=match[1],
                _iH_=
                 function(param)
                  {return [0,
                           [0,[2,[1,tyX],mkCast(tty,ty,t)],envdt,[0,[1,tyX]]]]},
                _iI_=caml_call1(PPrint[3],tyX),
                _iJ_=caml_call1(PPrint[3],cst_sealed_as),
                _iK_=caml_call2(PPrint[92],_iJ_,_iI_),
                _iL_=ppty(ty),
                _iM_=caml_call2(PPrint[92],_iL_,_iK_),
                _iN_=caml_call1(PPrint[3],cst_at_incompatible_type),
                _iO_=caml_call2(PPrint[93],_iN_,_iM_),
                _iP_=ppty(tty),
                _iQ_=caml_call2(PPrint[92],_iP_,_iO_),
                _iR_=caml_call1(PPrint[3],cst_Tried_to_seal_a_val_of_type),
                _iS_=caml_call2(PPrint[93],_iR_,_iQ_);
               return guard(checkConsistent(ty,tty,env$0[2]),tm,_iS_,_iH_)}
             var
              _iT_=pretty_env(env$0),
              _iU_=caml_call1(PPrint[3],cst_in_env),
              _iV_=caml_call2(PPrint[92],_iU_,_iT_),
              _iW_=caml_call1(PPrint[3],tyX),
              _iX_=caml_call2(PPrint[92],_iW_,_iV_),
              _iY_=
               caml_call1
                (PPrint[3],
                 cst_unbound_or_unknown_type_variable_used_for_sealing);
             return mkError(tm,caml_call2(PPrint[92],_iY_,_iX_))};
         return bind(elab_tm(env,t$0),_hg_);
        case 3:
         var
          t$1=_hc_[2],
          tyX$0=_hc_[1],
          _hh_=
           function(param)
            {var
              tty=param[3],
              envdt=param[2],
              t=param[1],
              env$0=caml_call2(Delta[2],envdt,env),
              match=lookupKnownVar(tyX$0,env$0[1]);
             if(match)
              {var
                ty=match[1],
                _iD_=
                 function(param)
                  {return [0,
                           [0,[3,[1,tyX$0],tagDncast([0,[1,tyX$0]],tty,t)],envdt,ty]]},
                _iE_=
                 caml_call1
                  (PPrint[3],cst_Tried_to_unseal_a_val_with_incompatible_type);
               return guard
                       (checkConsistent([0,[1,tyX$0]],tty,env$0[2]),tm,_iE_,_iD_)}
             var
              _iF_=caml_call1(PPrint[3],tyX$0),
              _iG_=
               caml_call1
                (PPrint[3],
                 cst_unbound_or_unknown_type_variable_used_for_unsealing);
             return mkError(tm,caml_call2(PPrint[11],_iG_,_iF_))};
         return bind(elab_tm(env,t$1),_hh_);
        case 4:var b=_hc_[1];return [0,[0,[4,b],Delta[1],1]];
        case 5:
         var
          tf=_hc_[3],
          tt=_hc_[2],
          tb=_hc_[1],
          _hi_=
           function(param)
            {var
              tbty=param[3],
              deltb=param[2],
              tb=param[1],
              envb=caml_call2(Delta[2],deltb,env);
             function _iv_(param)
              {var ttty=param[3],deltt=param[2],tt=param[1];
               function _iw_(param)
                {var tfty=param[3],deltf=param[2],tf=param[1];
                 function _ix_(param)
                  {var match=mkMeet(ttty,tfty,envb[2]);
                   if(match)
                    {var
                      match$0=match[1],
                      ltfty=match$0[3],
                      lttty=match$0[2],
                      meetty=match$0[1],
                      delttandtf=caml_call2(Delta[4],deltt,deltf),
                      delbtf=caml_call2(Delta[3],delttandtf,deltb),
                      envtf=caml_call2(Delta[2],delttandtf,envb),
                      match$1=covers(envtf[1],meetty);
                     if(0 === match$1[0])
                      {var
                        _iz_=[16,ltfty,1,caml_call3(Delta[5],delttandtf,deltf,tf)],
                        _iA_=[16,lttty,1,caml_call3(Delta[5],delttandtf,deltt,tt)];
                       return [0,
                               [0,[5,tagDncast(0,tbty,tb),_iA_,_iz_],delbtf,meetty]]}
                     var
                      unboundX=match$1[1],
                      _iB_=caml_call1(PPrint[3],unboundX),
                      _iC_=
                       caml_call1
                        (PPrint[3],
                         cst_type_variable_in_output_of_if_one_branch_but_not_another);
                     return mkError(tm,caml_call2(PPrint[11],_iC_,_iB_))}
                   return mkError
                           (tm,
                            caml_call1
                             (PPrint[3],cst_Branches_of_an_if_were_not_consistent))}
                 var
                  _iy_=
                   caml_call1
                    (PPrint[3],
                     cst_Tried_to_do_an_if_on_something_inconsistent_with_bool);
                 return guard(checkConsistent(tbty,1,envb[2]),tm,_iy_,_ix_)}
               return bind(elab_tm(envb,tf),_iw_)}
             return bind(elab_tm(envb,tt),_iv_)};
         return bind(elab_tm(env,tb),_hi_);
        case 6:var n=_hc_[1];return [0,[0,[18,n],Delta[1],2]];
        case 7:
         var
          tr=_hc_[2],
          tl=_hc_[1],
          _hj_=
           function(param)
            {var tyl=param[3],delta_tl=param[2],tl=param[1];
             function _ik_(param)
              {var tyr=param[3],delta_tr=param[2],tr=param[1];
               function _il_(param)
                {function _ip_(param)
                  {var
                    _it_=caml_call2(Delta[3],delta_tl,delta_tr),
                    _iu_=tagDncast(1,tyr,tr);
                   return [0,[0,[19,tagDncast(1,tyl,tl),_iu_],_it_,2]]}
                 var
                  _iq_=ppty(tyl),
                  _ir_=
                   caml_call1(PPrint[3],cst_Tried_to_add_something_of_type),
                  _is_=caml_call2(PPrint[11],_ir_,_iq_);
                 return guard(checkConsistent(tyr,2,env[2]),tm,_is_,_ip_)}
               var
                _im_=ppty(tyl),
                _in_=
                 caml_call1(PPrint[3],cst_Tried_to_add_something_of_type$0),
                _io_=caml_call2(PPrint[11],_in_,_im_);
               return guard(checkConsistent(tyl,2,env[2]),tm,_io_,_il_)}
             return bind(elab_tm(caml_call2(Delta[2],delta_tl,env),tr),_ik_)};
         return bind(elab_tm(env,tl),_hj_);
        case 8:
         var
          t2=_hc_[2],
          t1=_hc_[1],
          _hk_=
           function(param)
            {var ty1=param[3],envd1=param[2],t1=param[1];
             function _ij_(param)
              {var ty2=param[3],envd2=param[2],t2=param[1];
               return [0,
                       [0,[6,t1,t2],caml_call2(Delta[3],envd1,envd2),[1,ty1,ty2]]]}
             return bind(elab_tm(caml_call2(Delta[2],envd1,env),t2),_ij_)};
         return bind(elab_tm(env,t1),_hk_);
        case 9:
         var
          tk$0=_hc_[4],
          x2=_hc_[3],
          x1=_hc_[2],
          tp=_hc_[1],
          _hl_=
           function(param)
            {var tpty=param[3],envdp=param[2],tp=param[1];
             function _ig_(param)
              {var ty2=param[2],ty1=param[1];
               function _ih_(param)
                {var
                  kty=param[3],
                  envdk=param[2],
                  tk=param[1],
                  _ii_=caml_call2(Delta[3],envdp,envdk);
                 return [0,[0,[7,tagDncast(2,tpty,tp),x1,x2,tk],_ii_,kty]]}
               return bind
                       (elab_tm
                         (push$0
                           ([0,[0,x2,ty2]],
                            push$0([0,[0,x1,ty1]],caml_call2(Delta[2],envdp,env))),
                          tk$0),
                        _ih_)}
             return bind(unpair(tm,tpty),_ig_)};
         return bind(elab_tm(env,tp),_hl_);
        case 10:
         var
          tbod=_hc_[3],
          ty$0=_hc_[2],
          x$1=_hc_[1],
          match$0=covers(env[1],ty$0);
         if(0 === match$0[0])
          {var
            _hm_=
             function(param)
              {var
                ty=param[3],
                delta_bod=param[2],
                tbod=param[1],
                match=covers(env[1],ty);
               if(0 === match[0])
                {var _ie_=Delta[1];
                 return [0,
                         [0,
                          [8,x$1,ty$0,caml_call3(Delta[5],Delta[1],delta_bod,tbod)],
                          _ie_,
                          [2,ty$0,ty]]]}
               var
                unboundX=match[1],
                _if_=caml_call2(Stdlib[28],unboundX,cst_in_function_body);
               return strerror
                       (tm,caml_call2(Stdlib[28],cst_Leaked_type_variable,_if_))};
           return bind(elab_tm(push$0([0,[0,x$1,ty$0]],env),tbod),_hm_)}
         var
          unboundX=match$0[1],
          _hn_=caml_call2(Stdlib[28],unboundX,cst_in_argument_to_function);
         return strerror
                 (tm,caml_call2(Stdlib[28],cst_Unbound_type_variable,_hn_));
        case 11:
         var
          ta=_hc_[2],
          tf$0=_hc_[1],
          _ho_=
           function(param)
            {var tyf=param[3],delta_tf=param[2],tf=param[1];
             function _h3_(param)
              {var tya=param[3],delta_ta=param[2],ta=param[1];
               function _h4_(param)
                {var tycod=param[2],tydom=param[1];
                 function _h5_(param)
                  {var
                    _ib_=caml_call2(Delta[3],delta_tf,delta_ta),
                    _ic_=[16,dynTop(tya),0,ta],
                    _id_=[16,dynTop(tydom),1,_ic_];
                   return [0,[0,[9,tagDncast(3,tyf,tf),_id_],_ib_,tycod]]}
                 var
                  _h6_=ppty(tya),
                  _h7_=
                   caml_call1(PPrint[3],cst_to_an_arg_of_incompatible_type),
                  _h8_=caml_call2(PPrint[11],_h7_,_h6_),
                  _h9_=ppty(tydom),
                  _h__=caml_call2(PPrint[11],_h9_,_h8_),
                  _h$_=
                   caml_call1(PPrint[3],cst_Applied_a_function_of_with_domain),
                  _ia_=caml_call2(PPrint[11],_h$_,_h__);
                 return guard(checkConsistent(tya,tydom,env[2]),tm,_ia_,_h5_)}
               return bind(unfun(tm,tyf),_h4_)}
             return bind(elab_tm(caml_call2(Delta[2],delta_tf,env),ta),_h3_)};
         return bind(elab_tm(env,tf$0),_ho_);
        case 12:
         var
          tbod$0=_hc_[3],
          ty$1=_hc_[2],
          tyX$1=_hc_[1],
          env$0=push$0([1,[0,tyX$1,ty$1]],env),
          _hp_=
           function(param)
            {var
              tybod=param[3],
              delta_bod=param[2],
              tbod=param[1],
              match=covers(env$0[1],tybod);
             if(0 === match[0])
              {var _hY_=Delta[1];
               return [0,
                       [0,
                        [10,tyX$1,ty$1,caml_call3(Delta[5],Delta[1],delta_bod,tbod)],
                        _hY_,
                        [3,tyX$1,tybod]]]}
             var
              unboundX=match[1],
              _hZ_=caml_call1(PPrint[3],cst_leaked_in_body_of_pack),
              _h0_=caml_call1(PPrint[3],unboundX),
              _h1_=caml_call2(PPrint[11],_h0_,_hZ_),
              _h2_=caml_call1(PPrint[3],cst_type_variable);
             return mkError(tm,caml_call2(PPrint[11],_h2_,_h1_))};
         return bind(elab_tm(env$0,tbod$0),_hp_);
        case 13:
         var
          tk$1=_hc_[4],
          x$2=_hc_[3],
          tyX$2=_hc_[2],
          tp$0=_hc_[1],
          _hq_=
           function(param)
            {var tytp=param[3],delta_tp=param[2],tp=param[1];
             function _hR_(param)
              {var tytpbod=param[2],tyY=param[1];
               function _hS_(param)
                {var
                  tktp=param[3],
                  delta_tk=param[2],
                  tk=param[1],
                  delta_tk$0=caml_call2(Delta[7],delta_tk,tyX$2),
                  big_delta=caml_call2(Delta[3],delta_tk$0,delta_tp),
                  match=covers(caml_call2(Delta[2],big_delta,env)[1],tktp);
                 if(0 === match[0])
                  return [0,
                          [0,[11,tagDncast(4,tytp,tp),tyX$2,x$2,tk],big_delta,tktp]];
                 var
                  unboundX=match[1],
                  _hU_=
                   caml_call1(PPrint[3],cst_bound_in_the_kont_of_an_unpack),
                  _hV_=caml_call1(PPrint[3],unboundX),
                  _hW_=caml_call2(PPrint[11],_hV_,_hU_),
                  _hX_=caml_call1(PPrint[3],cst_Leaked_a_type_variable);
                 return mkError(tm,caml_call2(PPrint[11],_hX_,_hW_))}
               var _hT_=push$0([2,tyX$2],env);
               return bind
                       (elab_tm
                         (push$0
                           ([0,
                             [0,x$2,caml_call1(renameTyVar(tyY,tyX$2,env[2]),tytpbod)]],
                            _hT_),
                          tk$1),
                        _hS_)}
             return bind(unexists(tm,tytp),_hR_)};
         return bind(elab_tm(env,tp$0),_hq_);
        case 14:
         var
          match$1=_hc_[1],
          tbod$1=match$1[2],
          tyX$3=match$1[1],
          _hr_=
           function(param)
            {var
              bodty=param[3],
              delta_bod=param[2],
              tbod=param[1],
              _hQ_=Delta[1];
             return [0,
                     [0,
                      [13,[0,tyX$3,caml_call3(Delta[5],Delta[1],delta_bod,tbod)]],
                      _hQ_,
                      [4,tyX$3,bodty]]]};
         return bind(elab_tm(push$0([2,tyX$3],env),tbod$1),_hr_);
        case 15:
         var
          match$2=_hc_[1],
          a=match$2[3],
          tyX$4=match$2[2],
          t$2=match$2[1],
          _hs_=
           function(param)
            {function _hM_(param)
              {var tty=param[3],delta=param[2],t=param[1];
               function _hN_(param)
                {var
                  b=param[2],
                  tyY=param[1],
                  _hO_=caml_call1(renameTyVar(tyY,tyX$4,env[2]),b),
                  _hP_=caml_call3(Delta[6],tyX$4,a,delta);
                 return [0,
                         [0,[14,[0,tagDncast(5,tty,t),[1,tyX$4],a]],_hP_,_hO_]]}
               return bind(unforall(tm,tty),_hN_)}
             return bind(elab_tm(env,t$2),_hM_)},
          _ht_=caml_call1(PPrint[3],cst_twice),
          _hu_=caml_call1(PPrint[3],tyX$4),
          _hv_=caml_call2(PPrint[11],_hu_,_ht_),
          _hw_=
           caml_call1
            (PPrint[3],
             cst_Instantiating_variables_must_be_unique_but_you_used),
          _hx_=caml_call2(PPrint[11],_hw_,_hv_),
          _hy_=env[1];
         return guard(caml_call1(is_free(tyX$4),_hy_),tm,_hx_,_hs_);
        case 16:
         var
          t$3=_hc_[2],
          ty$2=_hc_[1],
          _hz_=
           function(param)
            {var tty=param[3],delta=param[2],t=param[1];
             function _hD_(param)
              {var _hL_=[16,dynTop(tty),0,t];
               return [0,[0,[16,dynTop(ty$2),1,_hL_],delta,ty$2]]}
             var
              _hE_=ppty(ty$2),
              _hF_=caml_call1(PPrint[3],cst_to_an_inconsistent_type),
              _hG_=caml_call2(PPrint[92],_hF_,_hE_),
              _hH_=ppty(tty),
              _hI_=caml_call2(PPrint[11],_hH_,_hG_),
              _hJ_=caml_call1(PPrint[3],cst_Tried_to_cast_from_type),
              _hK_=caml_call2(PPrint[92],_hJ_,_hI_);
             return guard(checkConsistent(tty,ty$2,env[2]),tm,_hK_,_hD_)};
         return bind(elab_tm(env,t$3),_hz_);
        default:
         var
          t$4=_hc_[2],
          tg=_hc_[1],
          _hA_=typ_from_tag(tg),
          match$3=covers(env[1],_hA_);
         if(0 === match$3[0])
          {var
            _hB_=
             function(param)
              {var tty=param[3],delta=param[2],t=param[1];
               return [0,[0,[20,tg,[16,dynTop(tty),0,t]],delta,1]]};
           return bind(elab_tm(env,t$4),_hB_)}
         var
          unboundX$0=match$3[1],
          _hC_=caml_call2(Stdlib[28],unboundX$0,cst_tag_check);
         return strerror
                 (tm,caml_call2(Stdlib[28],cst_Unbound_type_variable$0,_hC_))}}
    function elab_prog(t)
     {var env=init_env(0);
      function _g7_(param)
       {var tty=param[3],delta=param[2],t$0=param[1],match=covers(0,tty);
        if(0 === match[0])
         return [0,[0,caml_call3(Delta[5],Delta[1],delta,t$0),tty]];
        var
         unboundX=match[1],
         _g8_=ppty(tty),
         _g9_=caml_call1(PPrint[3],cst_occurs_free_in_inferred_type),
         _g__=caml_call2(PPrint[11],_g9_,_g8_),
         _g$_=caml_call1(PPrint[3],unboundX),
         _ha_=caml_call2(PPrint[11],_g$_,_g__),
         _hb_=caml_call1(PPrint[3],cst_Type_of_a_program_should_be_closed_but);
        return mkError(t,caml_call2(PPrint[11],_hb_,_ha_))}
      return bind(elab_tm(env,t),_g7_)}
    var
     PolyGNew_TcElab=
      [0,
       pp_binding,
       show_binding,
       pp_known_ty_var,
       show_known_ty_var,
       pp_env,
       show_env,
       pretty_env,
       is_free,
       Delta,
       ret,
       bind,
       lookupKnownVar,
       lookupTmVar,
       mkCast,
       guard,
       strerror,
       tagDncast,
       unpair,
       unfun,
       unexists,
       unforall,
       isBound,
       res_and,
       covers,
       push$0,
       init_env,
       mkError,
       elab_tm,
       elab_prog];
    caml_register_global(500,PolyGNew_TcElab,"PolyGNew__TcElab");
    var
     Error=
      [248,cst_PolyGNew_Parser_MenhirBasics_Error,caml_fresh_oo_id(0)];
    function cpos(param)
     {var
       pos_cnum=param[4],
       pos_bol=param[3],
       pos_lnum=param[2],
       col=pos_cnum - pos_bol | 0;
      return [0,pos_lnum,col]}
    function token2terminal(tok)
     {if(typeof tok === "number")
       switch(tok)
        {case 0:return 2;
         case 1:return 3;
         case 2:return 5;
         case 3:return 6;
         case 4:return 7;
         case 5:return 8;
         case 6:return 9;
         case 7:return 10;
         case 8:return 11;
         case 9:return 12;
         case 10:return 13;
         case 11:return 14;
         case 12:return 15;
         case 13:return 17;
         case 14:return 18;
         case 15:return 19;
         case 16:return 20;
         case 17:return 21;
         case 18:return 22;
         case 19:return 23;
         case 20:return 24;
         case 21:return 25;
         case 22:return 26;
         case 23:return 27;
         case 24:return 28;
         case 25:return 29;
         case 26:return 30;
         case 27:return 31;
         case 28:return 32;
         case 29:return 33;
         case 30:return 34;
         case 31:return 35;
         case 32:return 36;
         default:return 37}
      else
       switch(tok[0]){case 0:return 1;case 1:return 4;default:return 16}}
    var error_terminal=0;
    function token2value(tok)
     {if(typeof tok === "number")
       switch(tok)
        {case 0:return 0;
         case 1:return 0;
         case 2:return 0;
         case 3:return 0;
         case 4:return 0;
         case 5:return 0;
         case 6:return 0;
         case 7:return 0;
         case 8:return 0;
         case 9:return 0;
         case 10:return 0;
         case 11:return 0;
         case 12:return 0;
         case 13:return 0;
         case 14:return 0;
         case 15:return 0;
         case 16:return 0;
         case 17:return 0;
         case 18:return 0;
         case 19:return 0;
         case 20:return 0;
         case 21:return 0;
         case 22:return 0;
         case 23:return 0;
         case 24:return 0;
         case 25:return 0;
         case 26:return 0;
         case 27:return 0;
         case 28:return 0;
         case 29:return 0;
         case 30:return 0;
         case 31:return 0;
         case 32:return 0;
         default:return 0}
      else
       switch(tok[0])
        {case 0:var v=tok[1];return v;
         case 1:var v$0=tok[1];return v$0;
         default:var v$1=tok[1];return v$1}}
    var start=1;
    function _d0_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _g6_=menhir_stack[5][5],
       match=_g6_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyX=_g6_[2],
       endpos_ty=menhir_stack[4],
       ty=menhir_stack[2],
       v=[4,tyX,ty];
      return [0,menhir_s,v,startpos_1,endpos_ty,menhir_stack$0]}
    function _d1_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _g5_=menhir_stack[5],
       match=_g5_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       ty=_g5_[2],
       endpos_3=menhir_stack[4];
      return [0,menhir_s,ty,startpos_1,endpos_3,menhir_stack$0]}
    function _d2_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _g4_=menhir_stack[5][5],
       match=_g4_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyX=_g4_[2],
       endpos_ty=menhir_stack[4],
       ty=menhir_stack[2],
       v=[3,tyX,ty];
      return [0,menhir_s,v,startpos_1,endpos_ty,menhir_stack$0]}
    function _d3_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_ty1=match[3],
       ty1=match[2],
       menhir_s=match[1],
       endpos_ty2=menhir_stack[4],
       ty2=menhir_stack[2],
       v=[2,ty1,ty2];
      return [0,menhir_s,v,startpos_ty1,endpos_ty2,menhir_stack$0]}
    function _d4_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_ty1=match[3],
       ty1=match[2],
       menhir_s=match[1],
       endpos_ty2=menhir_stack[4],
       ty2=menhir_stack[2],
       v=[1,ty1,ty2];
      return [0,menhir_s,v,startpos_ty1,endpos_ty2,menhir_stack$0]}
    function _d5_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,0,startpos_1,endpos_1,menhir_stack$0]}
    function _d6_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_tyX=menhir_stack[4],
       startpos_tyX=menhir_stack[3],
       tyX=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,[1,tyX]];
      return [0,menhir_s,v,startpos_tyX,endpos_tyX,menhir_stack$0]}
    function _d7_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,2,startpos_1,endpos_1,menhir_stack$0]}
    function _d8_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,1,startpos_1,endpos_1,menhir_stack$0]}
    function _d9_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _g1_=menhir_stack[5][5],
       _g2_=_g1_[5][5][5],
       _g3_=_g2_[5][5],
       match=_g3_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyX=_g3_[2],
       x=_g2_[2],
       t=_g1_[2],
       endpos_tk=menhir_stack[4],
       tk=menhir_stack[2],
       v=[0,cpos(startpos_1),[13,t,tyX,x,tk]];
      return [0,menhir_s,v,startpos_1,endpos_tk,menhir_stack$0]}
    function _d__(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gY_=menhir_stack[5][5],
       _gZ_=_gY_[5][5][5],
       _g0_=_gZ_[5][5],
       match=_g0_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       x1=_g0_[2],
       x2=_gZ_[2],
       t=_gY_[2],
       endpos_tk=menhir_stack[4],
       tk=menhir_stack[2],
       v=[0,cpos(startpos_1),[9,t,x1,x2,tk]];
      return [0,menhir_s,v,startpos_1,endpos_tk,menhir_stack$0]}
    function _d$_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gW_=menhir_stack[5][5],
       _gX_=_gW_[5][5],
       match=_gX_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tb=_gX_[2],
       tt=_gW_[2],
       endpos_tf=menhir_stack[4],
       tf=menhir_stack[2],
       v=[0,cpos(startpos_1),[5,tb,tt,tf]];
      return [0,menhir_s,v,startpos_1,endpos_tf,menhir_stack$0]}
    function _ea_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gU_=menhir_stack[5][5],
       _gV_=_gU_[5][5],
       match=_gV_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       x=_gV_[2],
       t=_gU_[2],
       endpos_tk=menhir_stack[4],
       tk=menhir_stack[2],
       v=[0,cpos(startpos_1),[1,t,x,tk]];
      return [0,menhir_s,v,startpos_1,endpos_tk,menhir_stack$0]}
    function _eb_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gT_=menhir_stack[5][5],
       match=_gT_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyX=_gT_[2],
       endpos_tbod=menhir_stack[4],
       tbod=menhir_stack[2],
       v=[0,cpos(startpos_1),[14,[0,tyX,tbod]]];
      return [0,menhir_s,v,startpos_1,endpos_tbod,menhir_stack$0]}
    function _ec_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gR_=menhir_stack[5][5],
       _gS_=_gR_[5][5],
       match=_gS_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       x=_gS_[2],
       ty=_gR_[2],
       endpos_tbod=menhir_stack[4],
       tbod=menhir_stack[2],
       v=[0,cpos(startpos_1),[10,x,ty,tbod]];
      return [0,menhir_s,v,startpos_1,endpos_tbod,menhir_stack$0]}
    function _ed_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_tl=match[3],
       tl=match[2],
       menhir_s=match[1],
       endpos_tr=menhir_stack[4],
       tr=menhir_stack[2],
       v=[0,cpos(startpos_tl),[7,tl,tr]];
      return [0,menhir_s,v,startpos_tl,endpos_tr,menhir_stack$0]}
    function _ee_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gP_=menhir_stack[5],
       _gQ_=_gP_[5][5],
       match=_gQ_[5][5],
       menhir_stack$0=match[5],
       startpos_tf=match[3],
       tf=match[2],
       menhir_s=match[1],
       tyX=_gQ_[2],
       a=_gP_[2],
       endpos_6=menhir_stack[4],
       v=[0,cpos(startpos_tf),[15,[0,tf,tyX,a]]];
      return [0,menhir_s,v,startpos_tf,endpos_6,menhir_stack$0]}
    function _ef_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_tf=match[3],
       tf=match[2],
       menhir_s=match[1],
       endpos_ta=menhir_stack[4],
       ta=menhir_stack[2],
       v=[0,cpos(startpos_tf),[11,tf,ta]];
      return [0,menhir_s,v,startpos_tf,endpos_ta,menhir_stack$0]}
    function _eg_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gO_=menhir_stack[5],
       match=_gO_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyX=_gO_[2],
       endpos_t=menhir_stack[4],
       t=menhir_stack[2],
       v=[0,cpos(startpos_1),[3,tyX,t]];
      return [0,menhir_s,v,startpos_1,endpos_t,menhir_stack$0]}
    function _eh_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gN_=menhir_stack[5],
       match=_gN_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyX=_gN_[2],
       endpos_t=menhir_stack[4],
       t=menhir_stack[2],
       v=[0,cpos(startpos_1),[2,tyX,t]];
      return [0,menhir_s,v,startpos_1,endpos_t,menhir_stack$0]}
    function _ei_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_ty=menhir_stack[4],
       ty=menhir_stack[2],
       v=[0,cpos(startpos_t),[16,ty,t]];
      return [0,menhir_s,v,startpos_t,endpos_ty,menhir_stack$0]}
    function _ej_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_t=menhir_stack[4],
       startpos_t=menhir_stack[3],
       t=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,t,startpos_t,endpos_t,menhir_stack$0]}
    function _ek_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_2=menhir_stack[4];
      return [0,menhir_s,t,startpos_t,endpos_2,menhir_stack$0]}
    function _el_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gK_=menhir_stack[5],
       _gL_=_gK_[5][5],
       _gM_=_gL_[5][5],
       match=_gM_[5][5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyx=_gM_[2],
       ty=_gL_[2],
       tbod=_gK_[2],
       endpos_8=menhir_stack[4],
       v=[0,cpos(startpos_1),[12,tyx,ty,tbod]];
      return [0,menhir_s,v,startpos_1,endpos_8,menhir_stack$0]}
    function _em_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gI_=menhir_stack[5],
       _gJ_=_gI_[5][5],
       match=_gJ_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       t1=_gJ_[2],
       t2=_gI_[2],
       endpos_5=menhir_stack[4],
       v=[0,cpos(startpos_1),[8,t1,t2]];
      return [0,menhir_s,v,startpos_1,endpos_5,menhir_stack$0]}
    function _en_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=[0,cpos(startpos_1),_eo_];
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _ep_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_1=menhir_stack[4],
       startpos_1=menhir_stack[3],
       menhir_s=menhir_stack[1],
       v=[0,cpos(startpos_1),_eq_];
      return [0,menhir_s,v,startpos_1,endpos_1,menhir_stack$0]}
    function _er_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_x=menhir_stack[4],
       startpos_x=menhir_stack[3],
       x=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,cpos(startpos_x),[0,x]];
      return [0,menhir_s,v,startpos_x,endpos_x,menhir_stack$0]}
    function _es_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_n=menhir_stack[4],
       startpos_n=menhir_stack[3],
       n=menhir_stack[2],
       menhir_s=menhir_stack[1],
       v=[0,cpos(startpos_n),[6,n]];
      return [0,menhir_s,v,startpos_n,endpos_n,menhir_stack$0]}
    function _et_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gH_=menhir_stack[5],
       match=_gH_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       t=_gH_[2],
       endpos_3=menhir_stack[4];
      return [0,menhir_s,t,startpos_1,endpos_3,menhir_stack$0]}
    function _eu_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_tl=match[3],
       tl=match[2],
       menhir_s=match[1],
       endpos_tr=menhir_stack[4],
       tr=menhir_stack[2],
       v=[0,cpos(startpos_tl),[7,tl,tr]];
      return [0,menhir_s,v,startpos_tl,endpos_tr,menhir_stack$0]}
    function _ev_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_t=menhir_stack[4],
       startpos_t=menhir_stack[3],
       t=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,t,startpos_t,endpos_t,menhir_stack$0]}
    function _ew_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gF_=menhir_stack[5],
       _gG_=_gF_[5][5],
       match=_gG_[5][5],
       menhir_stack$0=match[5],
       startpos_tf=match[3],
       tf=match[2],
       menhir_s=match[1],
       tyX=_gG_[2],
       a=_gF_[2],
       endpos_6=menhir_stack[4],
       v=[0,cpos(startpos_tf),[15,[0,tf,tyX,a]]];
      return [0,menhir_s,v,startpos_tf,endpos_6,menhir_stack$0]}
    function _ex_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5],
       menhir_stack$0=match[5],
       startpos_tf=match[3],
       tf=match[2],
       menhir_s=match[1],
       endpos_ta=menhir_stack[4],
       ta=menhir_stack[2],
       v=[0,cpos(startpos_tf),[11,tf,ta]];
      return [0,menhir_s,v,startpos_tf,endpos_ta,menhir_stack$0]}
    function _ey_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gE_=menhir_stack[5],
       match=_gE_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyX=_gE_[2],
       endpos_t=menhir_stack[4],
       t=menhir_stack[2],
       v=[0,cpos(startpos_1),[3,tyX,t]];
      return [0,menhir_s,v,startpos_1,endpos_t,menhir_stack$0]}
    function _ez_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       _gD_=menhir_stack[5],
       match=_gD_[5],
       menhir_stack$0=match[5],
       startpos_1=match[3],
       menhir_s=match[1],
       tyX=_gD_[2],
       endpos_t=menhir_stack[4],
       t=menhir_stack[2],
       v=[0,cpos(startpos_1),[2,tyX,t]];
      return [0,menhir_s,v,startpos_1,endpos_t,menhir_stack$0]}
    function _eA_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       menhir_stack$0=menhir_stack[5],
       endpos_t=menhir_stack[4],
       startpos_t=menhir_stack[3],
       t=menhir_stack[2],
       menhir_s=menhir_stack[1];
      return [0,menhir_s,t,startpos_t,endpos_t,menhir_stack$0]}
    function _eB_(menhir_env)
     {var
       menhir_stack=menhir_env[3],
       match=menhir_stack[5][5],
       menhir_stack$0=match[5],
       startpos_t=match[3],
       t=match[2],
       menhir_s=match[1],
       endpos_ty=menhir_stack[4],
       ty=menhir_stack[2],
       v=[0,cpos(startpos_t),[16,ty,t]];
      return [0,menhir_s,v,startpos_t,endpos_ty,menhir_stack$0]}
    var
     semantic_action=
      [0,
       function(menhir_env)
        {var
          menhir_stack=menhir_env[3],
          menhir_stack$0=menhir_stack[5],
          endpos_t=menhir_stack[4],
          startpos_t=menhir_stack[3],
          t=menhir_stack[2],
          menhir_s=menhir_stack[1];
         return [0,menhir_s,t,startpos_t,endpos_t,menhir_stack$0]},
       _eB_,
       _eA_,
       _ez_,
       _ey_,
       _ex_,
       _ew_,
       _ev_,
       _eu_,
       _et_,
       _es_,
       _er_,
       _ep_,
       _en_,
       _em_,
       _el_,
       _ek_,
       _ej_,
       _ei_,
       _eh_,
       _eg_,
       _ef_,
       _ee_,
       _ed_,
       _ec_,
       _eb_,
       _ea_,
       _d$_,
       _d__,
       _d9_,
       _d8_,
       _d7_,
       _d6_,
       _d5_,
       _d4_,
       _d3_,
       _d2_,
       _d1_,
       _d0_],
     ET=
      caml_call1
       (MenhirLib[15][1],
        [0,
         token2terminal,
         error_terminal,
         token2value,
         default_reduction,
         error,
         action,
         lhs,
         goto$0,
         start,
         semantic_action,
         Error,
         0]),
     TI=caml_call1(MenhirLib[5][1],ET),
     entry=TI[2],
     offer=TI[3],
     resume=TI[4],
     lexer_lexbuf_to_supplier=TI[5],
     loop$1=TI[6],
     loop_handle=TI[7],
     loop_handle_undo=TI[8],
     shifts=TI[9],
     acceptable=TI[10],
     number=TI[11],
     production_index=TI[12],
     find_production=TI[13],
     stack=TI[14],
     top=TI[15],
     pop_many=TI[16],
     get=TI[17],
     current_state_number=TI[18],
     equal=TI[19],
     positions=TI[20],
     env_has_default_reduction=TI[21],
     state_has_default_reduction=TI[22],
     pop=TI[23],
     force_reduction=TI[24],
     input_needed=TI[25],
     start$0=TI[26];
    function prog(lexer,lexbuf){return caml_call3(entry,0,lexer,lexbuf)}
    function prog$0(initial_position)
     {return caml_call2(start$0,0,initial_position)}
    var
     Incremental=[0,prog$0],
     PolyGNew_Parser=
      [0,
       Error,
       prog,
       [0,
        offer,
        resume,
        lexer_lexbuf_to_supplier,
        loop$1,
        loop_handle,
        loop_handle_undo,
        shifts,
        acceptable,
        number,
        production_index,
        find_production,
        stack,
        top,
        pop_many,
        get,
        current_state_number,
        equal,
        positions,
        env_has_default_reduction,
        state_has_default_reduction,
        pop,
        force_reduction,
        input_needed],
       Incremental];
    caml_register_global(502,PolyGNew_Parser,"PolyGNew__Parser");
    var LexingError=[248,cst_PolyGNew_Lexer_LexingError,caml_fresh_oo_id(0)];
    function next_line(lexbuf)
     {var pos=lexbuf[12];
      lexbuf[12] = [0,pos[1],pos[2] + 1 | 0,lexbuf[6],pos[4]];
      return 0}
    function read$0(counter,lexbuf)
     {var _gC_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_read_rec$0(counter$0,lexbuf,_gC_)}
      return caml_trampoline_return(ocaml_lex_read_rec$0,[0,lexbuf,_gC_])}
    function ocaml_lex_read_rec$0(counter,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3
           (Stdlib_lexing[18],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(39 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return read$0(counter$0,lexbuf)}
           return caml_trampoline_return(read$0,[0,lexbuf]);
          case 1:
           next_line(lexbuf);
           if(counter < 50)
            {var counter$1=counter + 1 | 0;return read$0(counter$1,lexbuf)}
           return caml_trampoline_return(read$0,[0,lexbuf]);
          case 2:return 2;
          case 3:return 22;
          case 4:
           return [2,
                   runtime.caml_int_of_string
                    (caml_call1(Stdlib_lexing[6],lexbuf))];
          case 5:return 10;
          case 6:return 14;
          case 7:return 6;
          case 8:return 15;
          case 9:return 7;
          case 10:return 16;
          case 11:return 8;
          case 12:return 29;
          case 13:return 24;
          case 14:return 25;
          case 15:return 30;
          case 16:return 28;
          case 17:return 11;
          case 18:return 33;
          case 19:return 9;
          case 20:return 3;
          case 21:return 18;
          case 22:return 13;
          case 23:return 19;
          case 24:return 4;
          case 25:return 27;
          case 26:return 12;
          case 27:return 1;
          case 28:return 20;
          case 29:return 32;
          case 30:return 23;
          case 31:return 21;
          case 32:return 31;
          case 33:return 17;
          case 34:return 5;
          case 35:return 0;
          case 36:return [0,caml_call1(Stdlib_lexing[6],lexbuf)];
          case 37:return [1,caml_call1(Stdlib_lexing[6],lexbuf)];
          case 38:
           var _gB_=caml_call1(Stdlib_lexing[6],lexbuf);
           throw [0,
                  LexingError,
                  caml_call2(Stdlib[28],cst_Unexpected_char,_gB_)];
          default:return 26}}}
    function read(lexbuf){return caml_trampoline(read$0(0,lexbuf))}
    function ocaml_lex_read_rec(lexbuf,ocaml_lex_state)
     {return caml_trampoline(ocaml_lex_read_rec$0(0,lexbuf,ocaml_lex_state))}
    var
     PolyGNew_Lexer=
      [0,LexingError,next_line,ocaml_lex_tables,read,ocaml_lex_read_rec];
    caml_register_global(504,PolyGNew_Lexer,"PolyGNew__Lexer");
    function print_position(lexbuf)
     {var pos=lexbuf[12];
      return caml_call3
              (Stdlib_printf[4],_eC_,pos[2],(pos[4] - pos[3] | 0) + 1 | 0)}
    function line_num(lexbuf){return lexbuf[12][2]}
    function from_string(s)
     {var lexbuf=caml_call2(Stdlib_lexing[3],0,s);
      try
       {var t=prog(read,lexbuf)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === LexingError)
         {var
           e=exn[2],
           _gu_=caml_call2(Stdlib[28],cst$23,e),
           _gv_=print_position(lexbuf),
           _gw_=caml_call2(Stdlib[28],_gv_,_gu_);
          return [1,[0,line_num(lexbuf),_gw_]]}
        if(exn === Error)
         {var
           _gx_=caml_call1(Stdlib_lexing[6],lexbuf),
           _gy_=caml_call2(Stdlib[28],cst_current_lexeme,_gx_),
           _gz_=print_position(lexbuf),
           _gA_=caml_call2(Stdlib[28],_gz_,_gy_);
          return [1,[0,line_num(lexbuf),_gA_]]}
        throw exn}
      return [0,t]}
    var PolyGNew_Parse=[0,print_position,line_num,from_string];
    caml_register_global(506,PolyGNew_Parse,"PolyGNew__Parse");
    function pretty_store(param)
     {var _gi_=param[2],_gj_=param[1];
      if(_gi_)
       {var
         xs=_gi_[2],
         x=_gi_[1],
         _gk_=pretty_store([0,_gj_ - 1 | 0,xs]),
         _gl_=caml_call1(PPrint[3],cst$24),
         _gm_=caml_call2(PPrint[11],_gl_,_gk_),
         _gn_=ppty(x),
         _go_=caml_call1(PPrint[13],_gn_),
         _gp_=caml_call2(PPrint[11],_go_,_gm_),
         _gq_=caml_call1(PPrint[3],cst$25),
         _gr_=caml_call2(PPrint[11],_gq_,_gp_),
         _gs_=caml_call1(Stdlib[33],_gj_),
         _gt_=caml_call1(PPrint[3],_gs_);
        return caml_call2(PPrint[11],_gt_,_gr_)}
      return caml_call1(PPrint[3],cst$26)}
    function bind$0(m,k,sto)
     {var _gf_=caml_call1(m,sto),_gg_=_gf_[2],_gh_=_gf_[1];
      if(0 === _gg_[0]){var x=_gg_[1];return caml_call2(k,x,_gh_)}
      var e=_gg_[1];
      return [0,_gh_,[1,e]]}
    function ret$0(x,sto){return [0,sto,[0,x]]}
    function fmap(f,m)
     {function _gb_(x)
       {var _gd_=caml_call1(f,x);
        return function(_ge_){return ret$0(_gd_,_ge_)}}
      return function(_gc_){return bind$0(m,_gb_,_gc_)}}
    function failure(e,sto){return [0,sto,[1,e]]}
    function runmap(f,ov)
     {if(ov){var x=ov[1];return [0,caml_call1(f,x)]}return 0}
    function nope(s)
     {var
       _f9_=caml_call1(PPrint[3],s),
       _f__=caml_call1(PPrint[3],cst_Shouldn_t_happen),
       _f$_=caml_call2(PPrint[92],_f__,_f9_);
      return function(_ga_){return failure(_f$_,_ga_)}}
    function allocate(ty,param)
     {var tys=param[2],len=param[1];
      return [0,[0,len + 1 | 0,[0,ty,tys]],[0,len + 1 | 0]]}
    function deref(sl$1,param)
     {var tys$1=param[2],len=param[1],sl=sl$1,tys=tys$1;
      for(;;)
       {if(0 === sl)
         if(tys)var ty=tys[1],_f8_=[0,ty],switch$0=1;else var switch$0=0;
        else
         {if(tys){var tys$0=tys[2],sl$0=sl - 1 | 0,sl=sl$0,tys=tys$0;continue}
          var switch$0=0}
        if(! switch$0)
         var
          _f8_=
           [1,
            caml_call1
             (PPrint[3],cst_tried_to_lookup_a_seal_that_wasn_t_allocated)];
        return [0,[0,len,tys$1],_f8_]}}
    function applyCasts(sl,csts,t)
     {function _f7_(param,t)
       {var d=param[3],p=param[2],tyX=param[1];
        return [16,caml_call1(slsubstprec(sl,tyX),p),d,t]}
      return caml_call3(Stdlib_list[22],_f7_,csts,t)}
    function cststep(v,d,p)
     {if(typeof p !== "number")
       switch(p[0])
        {case 0:
          var prec=p[2],g=p[1];
          if(0 === d)
           {var _fM_=[17,g,[16,prec,0,v]];
            return [0,function(_f6_){return ret$0(_fM_,_f6_)}]}
          if(17 === v[0])
           {var v$0=v[2],g$0=v[1];
            if(caml_equal(g,g$0))
             var
              _fO_=[16,prec,1,v$0],
              _fP_=function(_f4_){return ret$0(_fO_,_f4_)};
            else
             var
              _fQ_=pptag(g),
              _fR_=caml_call1(PPrint[3],cst_to_a_type_with_tag),
              _fS_=caml_call2(PPrint[92],_fR_,_fQ_),
              _fT_=pptag(g$0),
              _fU_=caml_call2(PPrint[92],_fT_,_fS_),
              _fV_=caml_call1(PPrint[3],cst_Tried_to_cast_something_with_tag),
              _fW_=caml_call2(PPrint[92],_fV_,_fU_),
              _fP_=function(_f5_){return failure(_fW_,_f5_)};
            var _fN_=_fP_}
          else
           var _fN_=nope(cst_dyn_downcast_on_non_dyn_value);
          return [0,_fN_];
         case 2:
          var p2=p[2],p1=p[1];
          if(6 === v[0])
           var
            v2=v[2],
            v1=v[1],
            _fY_=[6,[16,p1,d,v1],[16,p2,d,v2]],
            _fX_=function(_f3_){return ret$0(_fY_,_f3_)};
          else
           var _fX_=nope(cst_prod_cast_on_non_pair_value);
          return [0,_fX_];
         case 4:
          var p$0=p[2],tyX=p[1];
          if(12 === v[0])
           var
            m=v[4],
            casts=v[3],
            ty=v[2],
            tyY=v[1],
            _f0_=[12,tyY,ty,[0,[0,tyX,p$0,d],casts],m],
            _fZ_=function(_f2_){return ret$0(_f0_,_f2_)};
          else
           var _fZ_=nope(cst_existential_cast_on_non_castpack);
          return [0,_fZ_];
         case 1:break;
         default:return 0}
      return [0,function(_f1_){return ret$0(v,_f1_)}]}
    function step(param)
     {switch(param[0])
       {case 0:
         var x=param[1];
         return [0,nope(caml_call2(Stdlib[28],cst_unbound_variable$0,x))];
        case 1:
         var tk=param[3],x$0=param[2],t=param[1],match=step(t);
         if(match)
          var r=match[1],_eW_=fmap(function(t){return [1,t,x$0,tk]},r);
         else
          var
           _eX_=caml_call1(subst(t,x$0),tk),
           _eW_=function(_fK_){return ret$0(_eX_,_fK_)};
         return [0,_eW_];
        case 2:
         var
          m=param[2],
          ty=param[1],
          _eY_=step(m),
          _eZ_=function(m){return [2,ty,m]};
         return runmap(function(_fJ_){return fmap(_eZ_,_fJ_)},_eY_);
        case 3:
         var m$0=param[2],ty$0=param[1],match$0=step(m$0);
         if(match$0)
          var r$0=match$0[1],_e0_=fmap(function(m){return [3,ty$0,m]},r$0);
         else
          if(2 === m$0[0])
           var v=m$0[2],_e0_=function(_fI_){return ret$0(v,_fI_)};
          else
           var _e0_=nope(cst_sealprj_of_non_seal);
         return [0,_e0_];
        case 4:return 0;
        case 5:
         var f=param[3],t$0=param[2],b=param[1],match$1=step(b);
         if(match$1)
          var r$1=match$1[1],_e1_=fmap(function(b){return [5,b,t$0,f]},r$1);
         else
          if(4 === b[0])
           var
            b$0=b[1],
            _e2_=
             b$0
              ?function(_fG_){return ret$0(t$0,_fG_)}
              :function(_fH_){return ret$0(f,_fH_)},
            _e1_=_e2_;
          else
           var _e1_=nope(cst_if_of_a_non_bool);
         return [0,_e1_];
        case 6:
         var t2=param[2],t1=param[1],match$2=step(t1);
         if(match$2)
          {var r$2=match$2[1];
           return [0,fmap(function(t1){return [6,t1,t2]},r$2)]}
         var match$3=step(t2);
         if(match$3)
          {var r$3=match$3[1];
           return [0,fmap(function(t2){return [6,t1,t2]},r$3)]}
         return 0;
        case 7:
         var
          tk$0=param[4],
          x2=param[3],
          x1=param[2],
          tp=param[1],
          match$4=step(tp);
         if(match$4)
          var
           r$4=match$4[1],
           _e3_=fmap(function(tp){return [7,tp,x1,x2,tk$0]},r$4);
         else
          if(6 === tp[0])
           var
            v2=tp[2],
            v1=tp[1],
            _e4_=caml_call1(subst(v2,x2),tk$0),
            _e5_=caml_call1(subst(v1,x1),_e4_),
            _e3_=function(_fF_){return ret$0(_e5_,_fF_)};
          else
           var _e3_=nope(cst_pair_pattern_match_on_non_pair);
         return [0,_e3_];
        case 8:return 0;
        case 9:
         var ta=param[2],tf=param[1],match$5=step(tf);
         if(match$5)
          var r$5=match$5[1],_e6_=fmap(function(tf){return [9,tf,ta]},r$5);
         else
          {var match$6=step(ta);
           if(match$6)
            var r$6=match$6[1],_e7_=fmap(function(ta){return [9,tf,ta]},r$6);
           else
            {switch(tf[0])
              {case 8:
                var
                 tbod=tf[3],
                 x$1=tf[1],
                 _e8_=caml_call1(subst(ta,x$1),tbod),
                 _e7_=function(_fE_){return ret$0(_e8_,_fE_)},
                 switch$0=1;
                break;
               case 16:
                var _e9_=tf[1];
                if(typeof _e9_ === "number")
                 var switch$1=1;
                else
                 if(3 === _e9_[0])
                  var
                   v$0=tf[3],
                   d=tf[2],
                   outp=_e9_[2],
                   inp=_e9_[1],
                   _e__=[16,outp,d,[9,v$0,[16,inp,complement(d),ta]]],
                   _e7_=function(_fD_){return ret$0(_e__,_fD_)},
                   switch$0=1,
                   switch$1=0;
                 else
                  var switch$1=1;
                if(switch$1)var switch$0=0;
                break;
               default:var switch$0=0}
             if(! switch$0)
              var
               _e7_=
                nope(cst_non_function_proxy_in_function_application_position)}
           var _e6_=_e7_}
         return [0,_e6_];
        case 10:
         var m$1=param[3],ty$1=param[2],tyX=param[1],_e$_=[12,tyX,ty$1,0,m$1];
         return [0,function(_fC_){return ret$0(_e$_,_fC_)}];
        case 11:
         var
          mk=param[4],
          x$2=param[3],
          tyX$0=param[2],
          e=param[1],
          match$7=step(e);
         if(match$7)
          var
           r$7=match$7[1],
           _fa_=fmap(function(e){return [11,e,tyX$0,x$2,mk]},r$7);
         else
          if(12 === e[0])
           var
            tbod$0=e[4],
            csts=e[3],
            ty$2=e[2],
            tyX$1=e[1],
            _fb_=
             function(sl)
              {var
                _fz_=caml_call1(slsubst(sl,tyX$0),mk),
                _fA_=
                 [1,
                  applyCasts(sl,csts,caml_call1(slsubst(sl,tyX$1),tbod$0)),
                  x$2,
                  _fz_];
               return function(_fB_){return ret$0(_fA_,_fB_)}},
            _fc_=function(_fy_){return allocate(ty$2,_fy_)},
            _fa_=function(_fx_){return bind$0(_fc_,_fb_,_fx_)};
          else
           var _fa_=nope(cst_tried_to_unpack_a_non_pack);
         return [0,_fa_];
        case 12:return 0;
        case 13:return 0;
        case 14:
         var
          match$8=param[1],
          a=match$8[3],
          nm=match$8[2],
          t$1=match$8[1],
          match$9=step(t$1);
         if(match$9)
          var
           r$8=match$9[1],
           _fd_=fmap(function(t){return [14,[0,t,nm,a]]},r$8);
         else
          {if(0 === nm[0])
            {switch(t$1[0])
              {case 13:
                var
                 sl=nm[1],
                 match$10=t$1[1],
                 tbod$1=match$10[2],
                 tyX$2=match$10[1],
                 _ff_=caml_call1(slsubst(sl,tyX$2),tbod$1),
                 _fe_=function(_fw_){return ret$0(_ff_,_fw_)},
                 switch$2=1;
                break;
               case 16:
                var _fg_=t$1[1];
                if(typeof _fg_ === "number")
                 var switch$3=1;
                else
                 if(5 === _fg_[0])
                  var
                   sl$0=nm[1],
                   t$2=t$1[3],
                   d$0=t$1[2],
                   p=_fg_[2],
                   tyX$3=_fg_[1],
                   _fh_=
                    [16,
                     caml_call1(slsubstprec(sl$0,tyX$3),p),
                     d$0,
                     [14,[0,t$2,[0,sl$0],a]]],
                   _fe_=function(_fv_){return ret$0(_fh_,_fv_)},
                   switch$2=1,
                   switch$3=0;
                 else
                  var switch$3=1;
                if(switch$3)var switch$2=0;
                break;
               default:var switch$2=0}
             if(! switch$2)
              var _fe_=nope(cst_tried_to_instantiate_a_non_Lambda_proxy)}
           else
            var
             tyX$4=nm[1],
             _fe_=nope(caml_call2(Stdlib[28],cst_free_type_variable,tyX$4));
           var _fd_=_fe_}
         return [0,_fd_];
        case 15:
         var
          t$3=param[3],
          a$0=param[2],
          tyX$5=param[1],
          _fi_=
           function(sl)
            {var _ft_=caml_call1(slsubst(sl,tyX$5),t$3);
             return function(_fu_){return ret$0(_ft_,_fu_)}},
          _fj_=function(_fs_){return allocate(a$0,_fs_)};
         return [0,function(_fr_){return bind$0(_fj_,_fi_,_fr_)}];
        case 16:
         var t$4=param[3],d$1=param[2],prec=param[1],match$11=step(t$4);
         if(match$11)
          {var r$9=match$11[1];
           return [0,fmap(function(t){return [16,prec,d$1,t]},r$9)]}
         return cststep(t$4,d$1,prec);
        case 17:
         var t$5=param[2],g=param[1],match$12=step(t$5);
         if(match$12)
          {var r$10=match$12[1];
           return [0,fmap(function(t){return [17,g,t]},r$10)]}
         return 0;
        case 18:return 0;
        case 19:
         var tr=param[2],tl=param[1],match$13=step(tl);
         if(match$13)
          var
           r$11=match$13[1],
           _fk_=fmap(function(tl){return [19,tl,tr]},r$11);
         else
          {var match$14=step(tr);
           if(match$14)
            var
             r$12=match$14[1],
             _fl_=fmap(function(tr){return [19,tl,tr]},r$12);
           else
            {if(18 === tl[0])
              if(18 === tr[0])
               var
                nr=tr[1],
                nl=tl[1],
                _fn_=[18,nl + nr | 0],
                _fm_=function(_fq_){return ret$0(_fn_,_fq_)},
                switch$4=1;
              else
               var switch$4=0;
             else
              var switch$4=0;
             if(! switch$4)var _fm_=nope(cst_added_non_ints);
             var _fl_=_fm_}
           var _fk_=_fl_}
         return [0,_fk_];
        default:
         var t$6=param[2],g$0=param[1],match$15=step(t$6);
         if(match$15)
          var r$13=match$15[1],_fo_=fmap(function(t){return [20,g$0,t]},r$13);
         else
          if(17 === t$6[0])
           var
            g$1=t$6[1],
            _fp_=caml_equal(g$0,g$1)?_eD_:_eE_,
            _fo_=function(_fL_){return ret$0(_fp_,_fL_)};
          else
           var _fo_=nope(cst_has_tag_on_something_that_wasn_t_a_dyn_inj);
         return [0,_fo_]}}
    function big_step(t)
     {var t$0=t,st$0=st;
      for(;;)
       {var match=step(t$0);
        if(match)
         {var k=match[1],_eT_=caml_call1(k,st$0),_eU_=_eT_[2],_eV_=_eT_[1];
          if(0 === _eU_[0]){var t$1=_eU_[1],t$0=t$1,st$0=_eV_;continue}
          var e=_eU_[1];
          return [1,e]}
        return [0,t$0]}}
    var
     PolyGNew_Interpreter=
      [0,
       pretty_store,
       bind$0,
       ret$0,
       fmap,
       failure,
       runmap,
       nope,
       allocate,
       deref,
       applyCasts,
       step,
       cststep,
       st,
       big_step];
    caml_register_global(507,PolyGNew_Interpreter,"PolyGNew__Interpreter");
    var failure_to_see=caml_call2(Stdlib[28],unseeable,cst_bool$1);
    function id_k_1(nm)
     {var _eS_=caml_call2(Stdlib[28],nm,cst_X_bool_seal_X_true);
      return caml_call2(Stdlib[28],cst_unseal_X,_eS_)}
    function id_k_2(nm)
     {var _eR_=caml_call2(Stdlib[28],nm,cst_X_int_seal_X_5_in_true);
      return caml_call2(Stdlib[28],cst_let_y,_eR_)}
    var
     _eF_=id_k_1(cst_id),
     id_1=caml_call2(Stdlib[28],good_id_init,_eF_),
     _eG_=id_k_2(cst_id$0),
     id_2=caml_call2(Stdlib[28],good_id_init,_eG_),
     _eH_=id_k_1(cst_bad_id),
     bad_id_1=caml_call2(Stdlib[28],bad_id_init,_eH_),
     _eI_=id_k_2(cst_bad_id$0),
     bad_id_2=caml_call2(Stdlib[28],bad_id_init,_eI_);
    function swap_k_1(nm)
     {var
       _eQ_=
        caml_call2
         (Stdlib[28],
          nm,
          cst_X_bool_Y_int_seal_X_true_seal_Y_42_in_unseal_X_x_unseal_Y_y);
      return caml_call2(Stdlib[28],cst_let_y_x,_eQ_)}
    function swap_k_2(nm)
     {var
       _eP_=
        caml_call2
         (Stdlib[28],
          nm,
          cst_X_int_Y_bool_seal_X_42_seal_Y_true_in_unseal_Y_y_unseal_X_x);
      return caml_call2(Stdlib[28],cst_let_y_x$0,_eP_)}
    var
     _eJ_=swap_k_1(cst_swap),
     swap_1=caml_call2(Stdlib[28],good_swap_init,_eJ_),
     _eK_=swap_k_2(cst_swap$0),
     swap_2=caml_call2(Stdlib[28],good_swap_init,_eK_),
     _eL_=swap_k_1(cst_bad_swap),
     bad_swap_1=caml_call2(Stdlib[28],bad_swap_init,_eL_),
     _eM_=swap_k_2(cst_bad_swap$0),
     bad_swap_2=caml_call2(Stdlib[28],bad_swap_init,_eM_);
    function good_flipper_c(f)
     {var
       _eO_=
        caml_call2
         (Stdlib[28],
          f,
          cst_in_let_init_p_p_in_let_flip_read_p_in_read_init_read_flip_init);
      return caml_call2
              (Stdlib[28],
               cst_let_not_lambda_b_bool_if_b_then_false_else_true_in_unpack_X_p,
               _eO_)}
    function bad_flipper_c(f)
     {var
       _eN_=
        caml_call2
         (Stdlib[28],
          f,
          cst_in_let_init_p_p_in_let_flip_read_p_in_read_flip_true_X);
      return caml_call2
              (Stdlib[28],
               cst_let_not_lambda_b_bool_if_b_then_false_else_true_in_unpack_X_p$0,
               _eN_)}
    var
     flipper_1=good_flipper_c(flipper_p_1),
     flipper_2=good_flipper_c(flipper_p_2),
     bad_flipper_1=bad_flipper_c(flipper_p_1),
     bad_flipper_2=bad_flipper_c(flipper_p_2),
     PolyGNew_Examples=
      [0,
       unseeable,
       failure_to_see,
       bool,
       pair,
       exist_fun,
       ex_incompat,
       fun_cast,
       paper_1_noseal,
       paper_1_seal,
       paper_2_noseal,
       paper_2_seal,
       paper_3_noseal,
       paper_3_seal,
       paper_4_noseal,
       paper_4_seal,
       paper_5_noseal,
       paper_5_seal,
       paper_6_noseal,
       paper_6_seal,
       good_id_init,
       bad_id_init,
       id_k_1,
       id_k_2,
       id_1,
       id_2,
       bad_id_1,
       bad_id_2,
       good_swap_init,
       bad_swap_init,
       swap_k_1,
       swap_k_2,
       swap_1,
       swap_2,
       bad_swap_1,
       bad_swap_2,
       good_flipper_c,
       bad_flipper_c,
       flipper_p_1,
       flipper_p_2,
       flipper_1,
       flipper_2,
       bad_flipper_1,
       bad_flipper_2];
    caml_register_global(508,PolyGNew_Examples,"PolyGNew__Examples");
    return}
  (function(){return this}()));


//# 1 ".web.eobjs/byte/web.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Runtime_error=caml_new_string("Runtime error:"),
     cst_Static_type_error=caml_new_string("Static type error"),
     cst_Parse_error_at=caml_new_string("Parse error at "),
     cst_term=caml_new_string("term"),
     cst=caml_new_string(""),
     cst_type=caml_new_string("type"),
     cst_store=caml_new_string("store"),
     cst_pc=caml_new_string("pc"),
     cst_next$0=caml_new_string("next"),
     cst_nextmany$0=caml_new_string("nextmany"),
     cst_next=caml_new_string("next"),
     cst_nextmany=caml_new_string("nextmany"),
     cst_prev$0=caml_new_string("prev"),
     cst_prevmany$0=caml_new_string("prevmany"),
     cst_prev=caml_new_string("prev"),
     cst_prevmany=caml_new_string("prevmany"),
     cst_machine$0=caml_new_string("machine"),
     cst_machine=caml_new_string("machine"),
     cst_this_text_should_not_be_displayed=
      caml_new_string("this text should not be displayed :)"),
     cst_This_is_a_bug=caml_new_string("This is a bug,"),
     cst_fail_exist_unseal=caml_new_string("fail_exist_unseal"),
     cst_bool=caml_new_string("bool"),
     cst_pair=caml_new_string("pair"),
     cst_exist_fun=caml_new_string("exist_fun"),
     cst_ex_mismatch=caml_new_string("ex_mismatch"),
     cst_fun_cast=caml_new_string("fun_cast"),
     cst_paper_1_noseal=caml_new_string("paper_1_noseal"),
     cst_paper_1_seal=caml_new_string("paper_1_seal"),
     cst_paper_2_noseal=caml_new_string("paper_2_noseal"),
     cst_paper_2_seal=caml_new_string("paper_2_seal"),
     cst_paper_3_noseal=caml_new_string("paper_3_noseal"),
     cst_paper_3_seal=caml_new_string("paper_3_seal"),
     cst_paper_4_noseal=caml_new_string("paper_4_noseal"),
     cst_paper_4_seal=caml_new_string("paper_4_seal"),
     cst_paper_5_noseal=caml_new_string("paper_5_noseal"),
     cst_paper_5_seal=caml_new_string("paper_5_seal"),
     cst_paper_6_noseal=caml_new_string("paper_6_noseal"),
     cst_paper_6_seal=caml_new_string("paper_6_seal"),
     cst_id_1=caml_new_string("id_1"),
     cst_id_2=caml_new_string("id_2"),
     cst_bad_id_1=caml_new_string("bad_id_1"),
     cst_bad_id_2=caml_new_string("bad_id_2"),
     cst_swap_1=caml_new_string("swap_1"),
     cst_swap_2=caml_new_string("swap_2"),
     cst_bad_swap_1=caml_new_string("bad_swap_1"),
     cst_bad_swap_2=caml_new_string("bad_swap_2"),
     cst_flipper_1=caml_new_string("flipper_1"),
     cst_flipper_2=caml_new_string("flipper_2"),
     cst_bad_flipper_1=caml_new_string("bad_flipper_1"),
     cst_bad_flipper_2=caml_new_string("bad_flipper_2"),
     cst_load=caml_new_string("load"),
     cst_next$1=caml_new_string("next"),
     cst_prev$1=caml_new_string("prev"),
     cst_prevmany$1=caml_new_string("prevmany"),
     cst_nextmany$1=caml_new_string("nextmany"),
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     PPrint=global_data.PPrint,
     PolyGNew_Parse=global_data.PolyGNew__Parse,
     PolyGNew_TcElab=global_data.PolyGNew__TcElab,
     PolyGNew_Interpreter=global_data.PolyGNew__Interpreter,
     PolyGNew_Pretty=global_data.PolyGNew__Pretty,
     Stdlib=global_data.Stdlib,
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     PolyGNew_Examples=global_data.PolyGNew__Examples;
    function set_error(ln,m)
     {Js_of_ocaml_Js[50][1].seterror(ln,m.toString());return 0}
    function clear_errors(param){Js_of_ocaml_Js[50][1].clearerrors();return 0}
    function set_click(i,h)
     {caml_call1(Js_of_ocaml_Dom_html[6],i).onclick = h;return 0}
    function hide_machine(param)
     {return caml_call1(Js_of_ocaml_Dom_html[6],cst_machine).setAttribute
              ("hidden","on")}
    function reveal_machine(param)
     {return caml_call1(Js_of_ocaml_Dom_html[6],cst_machine$0).removeAttribute
              ("hidden")}
    function set_text(i,t)
     {Js_of_ocaml_Js[50][1].settext(i.toString(),t.toString());return 0}
    function set_editor(t)
     {clear_errors(0);
      hide_machine(0);
      Js_of_ocaml_Js[50][1].codemirror.setValue(t.toString());
      return 0}
    function get_editor(param)
     {return Js_of_ocaml_Js[50][1].codemirror.getValue()}
    function ex_handle(s)
     {function _t_(param){set_editor(s);return Js_of_ocaml_Js[8]}
      return caml_call1(Js_of_ocaml_Dom_html[10],_t_)}
    function no_past(param)
     {caml_call1(Js_of_ocaml_Dom_html[6],cst_prev).setAttribute
       ("disabled","on");
      caml_call1(Js_of_ocaml_Dom_html[6],cst_prevmany).setAttribute
       ("disabled","on");
      return 0}
    function some_past(param)
     {caml_call1(Js_of_ocaml_Dom_html[6],cst_prev$0).removeAttribute
       ("disabled");
      caml_call1(Js_of_ocaml_Dom_html[6],cst_prevmany$0).removeAttribute
       ("disabled");
      return 0}
    function no_future(param)
     {caml_call1(Js_of_ocaml_Dom_html[6],cst_next).setAttribute
       ("disabled","on");
      caml_call1(Js_of_ocaml_Dom_html[6],cst_nextmany).setAttribute
       ("disabled","on");
      return 0}
    function some_future(param)
     {caml_call1(Js_of_ocaml_Dom_html[6],cst_next$0).removeAttribute
       ("disabled");
      caml_call1(Js_of_ocaml_Dom_html[6],cst_nextmany$0).removeAttribute
       ("disabled");
      return 0}
    function next_term_state(t)
     {var match=caml_call1(PolyGNew_Interpreter[11],t);
      if(match){var i=match[1];return [2,t,i]}
      return [1,t]}
    var
     _a_=PolyGNew_Interpreter[13],
     _b_=caml_call1(PPrint[3],cst_this_text_should_not_be_displayed),
     _c_=caml_call1(PPrint[3],cst_This_is_a_bug),
     init_state=[0,[0,caml_call2(PPrint[92],_c_,_b_)],_a_,0,0,0],
     state=[0,init_state];
    function render(param)
     {var
       match=state[1],
       pc=match[4],
       mayTy=match[3],
       sto=match[2],
       tm_st=match[1],
       _p_=0,
       no_past$0=0 === pc?no_past:some_past;
      no_past$0(_p_);
      switch(tm_st[0])
       {case 0:var s=tm_st[1];no_future(0);var s$0=s;break;
        case 1:
         var v=tm_st[1];
         no_future(0);
         var s$0=caml_call1(PolyGNew_Pretty[16],v);
         break;
        default:
         var t=tm_st[1];
         some_future(0);
         var s$0=caml_call1(PolyGNew_Pretty[16],t)}
      set_text(cst_term,caml_call1(PolyGNew_Pretty[17],s$0));
      if(mayTy)
       var
        ty=mayTy[1],
        _q_=caml_call1(PolyGNew_Pretty[8],ty),
        _r_=caml_call1(PolyGNew_Pretty[17],_q_);
      else
       var _r_=cst;
      set_text(cst_type,_r_);
      var _s_=caml_call1(PolyGNew_Interpreter[1],sto);
      set_text(cst_store,caml_call1(PolyGNew_Pretty[17],_s_));
      set_text(cst_pc,caml_call1(Stdlib[33],pc));
      return 0}
    function load(param)
     {var s=runtime.caml_js_to_string(get_editor(0));
      clear_errors(0);
      var match=caml_call1(PolyGNew_Parse[3],s);
      if(0 === match[0])
       {var t=match[1],_g_=caml_call1(PolyGNew_TcElab[29],t);
        if(0 === _g_[0])
         {var
           match$0=_g_[1],
           ty=match$0[2],
           t$0=match$0[1],
           tm_st=next_term_state(t$0);
          state[1] = [0,tm_st,PolyGNew_Interpreter[13],[0,ty],0,0];
          reveal_machine(0)}
        else
         {var
           match$1=_g_[1],
           msg=match$1[2],
           loc=match$1[1],
           _h_=caml_call1(PPrint[10],0),
           _i_=caml_call2(PPrint[11],_h_,msg),
           _j_=caml_call1(PolyGNew_Pretty[5],loc),
           _k_=caml_call2(PPrint[11],_j_,_i_),
           _l_=caml_call2(PPrint[11],PPrint[39],_k_),
           _m_=caml_call1(PPrint[91],cst_Static_type_error),
           _n_=caml_call2(PPrint[11],_m_,_l_),
           _o_=caml_call1(PolyGNew_Pretty[17],_n_);
          set_error(loc[1],_o_);
          hide_machine(0)}}
      else
       {var match$2=match[1],msg$0=match$2[2],line=match$2[1];
        set_error(line,caml_call2(Stdlib[28],cst_Parse_error_at,msg$0));
        hide_machine(0)}
      render(0);
      return Js_of_ocaml_Js[8]}
    function step(param)
     {var
       match=state[1],
       hist=match[5],
       pc=match[4],
       mayTy=match[3],
       sto=match[2],
       tm_st=match[1];
      if(2 === tm_st[0])
       {var
         m=tm_st[2],
         match$0=caml_call1(m,sto),
         res=match$0[2],
         sto$0=match$0[1];
        if(0 === res[0])
         var t=res[1],tm_st$0=next_term_state(t);
        else
         var
          e=res[1],
          _d_=caml_call1(PPrint[13],e),
          _e_=caml_call1(PPrint[3],cst_Runtime_error),
          _f_=caml_call2(PPrint[92],_e_,_d_),
          tm_st$0=[0,caml_call2(PPrint[12],2,_f_)];
        state[1] = [0,tm_st$0,sto$0,mayTy,pc + 1 | 0,[0,[0,tm_st,sto],hist]]}
      render(0);
      return Js_of_ocaml_Js[8]}
    function step_back(param)
     {var match=state[1],hist=match[5],pc=match[4],mayTy=match[3];
      if(hist)
       {var
         hist$0=hist[2],
         match$0=hist[1],
         sto=match$0[2],
         tst=match$0[1],
         pc$0=pc - 1 | 0;
        state[1] = [0,tst,sto,mayTy,pc$0,hist$0];
        return pc$0}
      return 0}
    function prev(param){step_back(0);render(0);return Js_of_ocaml_Js[8]}
    function prev_many(param)
     {for(;;)
       {if(0 === step_back(0)){render(0);return Js_of_ocaml_Js[8]}continue}}
    function next_many(param)
     {var n=100;
      for(;;)
       {if(0 === n)return Js_of_ocaml_Js[8];
        step(0);
        var n$0=n - 1 | 0,n=n$0;
        continue}}
    set_click(cst_fail_exist_unseal,ex_handle(PolyGNew_Examples[2]));
    set_click(cst_bool,ex_handle(PolyGNew_Examples[3]));
    set_click(cst_pair,ex_handle(PolyGNew_Examples[4]));
    set_click(cst_exist_fun,ex_handle(PolyGNew_Examples[5]));
    set_click(cst_ex_mismatch,ex_handle(PolyGNew_Examples[6]));
    set_click(cst_fun_cast,ex_handle(PolyGNew_Examples[7]));
    set_click(cst_paper_1_noseal,ex_handle(PolyGNew_Examples[8]));
    set_click(cst_paper_1_seal,ex_handle(PolyGNew_Examples[9]));
    set_click(cst_paper_2_noseal,ex_handle(PolyGNew_Examples[10]));
    set_click(cst_paper_2_seal,ex_handle(PolyGNew_Examples[11]));
    set_click(cst_paper_3_noseal,ex_handle(PolyGNew_Examples[12]));
    set_click(cst_paper_3_seal,ex_handle(PolyGNew_Examples[13]));
    set_click(cst_paper_4_noseal,ex_handle(PolyGNew_Examples[14]));
    set_click(cst_paper_4_seal,ex_handle(PolyGNew_Examples[15]));
    set_click(cst_paper_5_noseal,ex_handle(PolyGNew_Examples[16]));
    set_click(cst_paper_5_seal,ex_handle(PolyGNew_Examples[17]));
    set_click(cst_paper_6_noseal,ex_handle(PolyGNew_Examples[18]));
    set_click(cst_paper_6_seal,ex_handle(PolyGNew_Examples[19]));
    set_click(cst_id_1,ex_handle(PolyGNew_Examples[24]));
    set_click(cst_id_2,ex_handle(PolyGNew_Examples[25]));
    set_click(cst_bad_id_1,ex_handle(PolyGNew_Examples[26]));
    set_click(cst_bad_id_2,ex_handle(PolyGNew_Examples[27]));
    set_click(cst_swap_1,ex_handle(PolyGNew_Examples[32]));
    set_click(cst_swap_2,ex_handle(PolyGNew_Examples[33]));
    set_click(cst_bad_swap_1,ex_handle(PolyGNew_Examples[34]));
    set_click(cst_bad_swap_2,ex_handle(PolyGNew_Examples[35]));
    set_click(cst_flipper_1,ex_handle(PolyGNew_Examples[40]));
    set_click(cst_flipper_2,ex_handle(PolyGNew_Examples[41]));
    set_click(cst_bad_flipper_1,ex_handle(PolyGNew_Examples[42]));
    set_click(cst_bad_flipper_2,ex_handle(PolyGNew_Examples[43]));
    set_click(cst_load,caml_call1(Js_of_ocaml_Dom_html[10],load));
    set_click(cst_next$1,caml_call1(Js_of_ocaml_Dom_html[10],step));
    set_click(cst_prev$1,caml_call1(Js_of_ocaml_Dom_html[10],prev));
    set_click(cst_prevmany$1,caml_call1(Js_of_ocaml_Dom_html[10],prev_many));
    set_click(cst_nextmany$1,caml_call1(Js_of_ocaml_Dom_html[10],next_many));
    hide_machine(0);
    set_editor(PolyGNew_Examples[2]);
    var
     Web=
      [0,
       set_error,
       clear_errors,
       set_click,
       hide_machine,
       reveal_machine,
       set_text,
       set_editor,
       get_editor,
       ex_handle,
       no_past,
       some_past,
       no_future,
       some_future,
       next_term_state,
       init_state];
    runtime.caml_register_global(97,Web,"Web");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ3ZWIuYmMuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZXJyX25vX3ByZWQiLCJlcnJfbm9fc3VjYyIsInplcm8kMiIsIm9uZSQyIiwibWludXNfb25lJDIiLCJtaW5faW50JDIiLCJtYXhfaW50JDIiLCJkdW1teV9wb3MiLCJ6ZXJvX3BvcyIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImxvY2ZtdCIsImN1cnJlbnRfZGlyX25hbWUiLCJwYXJlbnRfZGlyX25hbWUiLCJkaXJfc2VwIiwicXVvdGVxdW90ZSIsImN1cnJlbnRfZGlyX25hbWUkMCIsInBhcmVudF9kaXJfbmFtZSQwIiwiZGlyX3NlcCQwIiwiY3VycmVudF9kaXJfbmFtZSQxIiwicGFyZW50X2Rpcl9uYW1lJDEiLCJkaXJfc2VwJDEiLCJ6ZXJvJDQiLCJvbmUkNCIsImkiLCJlcmFzZV9yZWwiLCJyZXN0IiwicmVzdCQwIiwicmVzdCQxIiwicmVzdCQyIiwicmVzdCQzIiwicmVzdCQ0IiwicmVzdCQ1IiwicmVzdCQ2IiwicmVzdCQ3IiwidHkiLCJyZXN0JDgiLCJ0eTEiLCJyZXN0JDkiLCJyZXN0JDEwIiwicmVzdCQxMSIsInJlc3QkMTIiLCJyZXN0JDEzIiwiY29uY2F0X2ZtdHR5IiwiZm10dHkxIiwiZm10dHkyIiwidHkyIiwiY29uY2F0X2ZtdCIsImZtdDEiLCJmbXQyIiwicGFkIiwicGFkJDAiLCJwcmVjIiwicGFkJDEiLCJpY29udiIsInByZWMkMCIsInBhZCQyIiwiaWNvbnYkMCIsInByZWMkMSIsInBhZCQzIiwiaWNvbnYkMSIsInByZWMkMiIsInBhZCQ0IiwiaWNvbnYkMiIsInByZWMkMyIsInBhZCQ1IiwiZmNvbnYiLCJwYWQkNiIsInN0ciIsImNociIsImZtdHR5IiwicGFkJDciLCJmbXR0eSQwIiwicGFkJDgiLCJyZXN0JDE0IiwicmVzdCQxNSIsInJlc3QkMTYiLCJmbXRpbmdfbGl0IiwicmVzdCQxNyIsImZtdGluZ19nZW4iLCJyZXN0JDE4IiwicmVzdCQxOSIsImNoYXJfc2V0Iiwid2lkdGhfb3B0IiwicmVzdCQyMCIsImNvdW50ZXIiLCJyZXN0JDIxIiwicmVzdCQyMiIsImlnbiIsInJlc3QkMjMiLCJmIiwiYXJpdHkiLCJzIiwieCIsInkiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb24iLCJtYXhfaW50IiwiczEiLCJzMiIsImwxIiwibDIiLCJuIiwiYiIsImwiLCJpJDAiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmdfb3B0IiwiYXBwZW5kIiwidGwiLCJoZCIsIm1vZGUiLCJwZXJtIiwibmFtZSIsImMiLCJpdGVyIiwiYSIsIm9jIiwib2ZzIiwibGVuIiwiY2hhbiIsInYiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwiciIsImxlbiQxIiwib2ZzJDEiLCJidWlsZF9yZXN1bHQiLCJidWYiLCJhY2N1IiwiYmVnIiwiYWNjdSQwIiwicmVzIiwic3RyMiIsInN0cjEiLCJleGl0X2Z1bmN0aW9uIiwiZyIsImZfYWxyZWFkeV9yYW4iLCJyZXRjb2RlIiwiZW1wdHkiLCJyZXR1cm4kMCIsIm1hcCIsInNlcSIsIm5leHQiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJmbGF0X21hcCQwIiwiZmxhdF9tYXBfYXBwJDAiLCJ0YWlsIiwiZmxhdF9tYXBfYXBwIiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhY2MkMCIsImFjYyQxIiwibm9uZSIsInNvbWUiLCJ2YWx1ZSIsIm8iLCJkZWZhdWx0JDAiLCJnZXQiLCJiaW5kIiwiam9pbiIsIm1hcCQwIiwiZm9sZCIsIml0ZXIkMCIsImlzX25vbmUiLCJpc19zb21lIiwiZXF1YWwiLCJlcSIsIm8wIiwibzEiLCJ2MSIsInYwIiwiY29tcGFyZSIsImNtcCIsInRvX3Jlc3VsdCIsInRvX2xpc3QiLCJ0b19zZXEiLCJvayIsImVycm9yIiwiZSIsInZhbHVlJDAiLCJnZXRfb2siLCJnZXRfZXJyb3IiLCJiaW5kJDAiLCJqb2luJDAiLCJtYXAkMSIsIm1hcF9lcnJvciIsImZvbGQkMCIsIml0ZXIkMSIsIml0ZXJfZXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwiZXF1YWwkMCIsInIwIiwibWF0Y2giLCJlMSIsImNvbXBhcmUkMCIsInRvX29wdGlvbiIsInRvX2xpc3QkMCIsInRvX3NlcSQwIiwiZXF1YWwkMSIsImNvbXBhcmUkMSIsInRvX2ludCIsInRvX2Zsb2F0IiwidG9fc3RyaW5nJDAiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSQyIiwiYzEiLCJjMiIsImVxdWFsJDIiLCJtaW4kMCIsIm1heCQwIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsImJvbSIsInJlcCIsInN1Y2MiLCJ1IiwicHJlZCIsImlzX3ZhbGlkIiwib2ZfaW50IiwiaXNfY2hhciIsIm9mX2NoYXIiLCJ0b19jaGFyIiwidW5zYWZlX3RvX2NoYXIiLCJlcXVhbCQzIiwiY29tcGFyZSQzIiwiaGFzaCIsIm1hdGNoJDIiLCJsZW5ndGgiLCJwYXJhbSQwIiwiY29ucyIsIm50aCIsImwkMCIsIm4kMCIsImwkMSIsIm4kMSIsIm50aF9vcHQiLCJyZXZfYXBwZW5kIiwibDEkMCIsImwyJDAiLCJsMSQxIiwibDIkMSIsInJldiIsImluaXRfYXV4IiwicmV2X2luaXRfdGhyZXNob2xkIiwicGFyYW0iLCJhY2N1JDEiLCJhMiIsImExIiwicCIsInBhaXIiLCJyeSIsInJ4IiwidDIiLCJoMiIsInQxIiwiaDEiLCJjaG9wIiwiayIsImskMCIsImskMSIsInNvcnQiLCJ4MiIsIngxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJyZXZfc29ydCIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImF1eCIsImRpcmVjdCIsImRlcHRoIiwiX3VfIiwibGVmdCIsInJpZ2h0Iiwic3Jjb2ZmIiwiZHN0b2ZmIiwiY3B5bGVuIiwib2ZzMSIsIm9mczIiLCJzZXAiLCJzZXBsZW4iLCJkc3QiLCJpc19zcGFjZSIsImoiLCJhcHBseTEiLCJpbmRleF9yZWMiLCJsaW0iLCJpJDEiLCJpbmRleF9yZWNfb3B0IiwicmluZGV4X3JlYyIsInJpbmRleF9yZWNfb3B0IiwibmV3X2xlbiIsIm5ld19idWYiLCJpc19zcGFjZSQwIiwiaW5kZXhfcmVjJDAiLCJpbmRleF9yZWNfb3B0JDAiLCJyaW5kZXhfcmVjJDAiLCJyaW5kZXhfcmVjX29wdCQwIiwiZXF1YWwkNiIsImNvbXBhcmUkNiIsInRvX3N0cmluZyQyIiwidG9fYnVmZmVyIiwiYnVmZiIsImZsYWdzIiwiaGVhZGVyX3NpemUiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwibWFyc2hhbCIsIm9iaiIsInVubWFyc2hhbCIsInBvcyIsImZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWciLCJsYXN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWciLCJsYXp5X3RhZyIsImNsb3N1cmVfdGFnIiwib2JqZWN0X3RhZyIsImluZml4X3RhZyIsImZvcndhcmRfdGFnIiwibm9fc2Nhbl90YWciLCJhYnN0cmFjdF90YWciLCJzdHJpbmdfdGFnIiwiZG91YmxlX3RhZyIsImRvdWJsZV9hcnJheV90YWciLCJjdXN0b21fdGFnIiwiaW50X3RhZyIsIm91dF9vZl9oZWFwX3RhZyIsInVuYWxpZ25lZF90YWciLCJvZl92YWwiLCJzbG90IiwiaWQiLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJleHRlbnNpb25fbmFtZSIsImV4dGVuc2lvbl9pZCIsIm1heF9lcGhlX2xlbmd0aCIsImNyZWF0ZSIsImxlbmd0aCQwIiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQiLCJtc2ciLCJnZXRfa2V5IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwiZTIiLCJvMiIsInN4Iiwic3kiLCJpbml0IiwibGEiLCJsYiIsInJlcyQwIiwibGlzdF9sZW5ndGgiLCJwYXJhbSQxIiwidGwkMCIsImhkJDAiLCJtYXhzb24iLCJpMzEiLCJ0cmlja2xlZG93biIsInRyaWNrbGUiLCJidWJibGVkb3duIiwiYnViYmxlIiwiaSQyIiwiZSQwIiwiZmF0aGVyIiwibWVyZ2UiLCJzcmMxb2ZzIiwic3JjMWxlbiIsInNyYzIiLCJzcmMyb2ZzIiwic3JjMmxlbiIsImRzdG9mcyIsInNyYzFyIiwic3JjMnIiLCJzMiQxIiwiczEkMSIsImkxIiwiaTIiLCJkIiwiaTIkMCIsImQkMCIsInMyJDAiLCJpMSQwIiwiZCQxIiwiczEkMCIsImlzb3J0dG8iLCJzcmNvZnMiLCJzb3J0dG8iLCJ0IiwiemVybyIsIm9uZSIsIm1pbnVzX29uZSIsImlzX2Zpbml0ZSIsImlzX2luZmluaXRlIiwiaXNfbmFuIiwicGkiLCJpc19pbnRlZ2VyIiwic3VjYyQwIiwicHJlZCQwIiwiZXF1YWwkNyIsIm1pbiQxIiwibWF4JDEiLCJtaW5fbWF4IiwibWluX251bSIsIm1heF9udW0iLCJtaW5fbWF4X251bSIsImhhc2gkMCIsInVuc2FmZV9maWxsIiwidW5zYWZlX2JsaXQiLCJzcmMiLCJzb2ZzIiwiZG9mcyIsImNoZWNrIiwibWFrZSQxIiwicmVzdWx0IiwiaW5pdCQzIiwiYXBwZW5kJDEiLCJjb25jYXQkMiIsImhsZW4iLCJzdWIkMiIsImNvcHkkMiIsImZpbGwkMSIsImJsaXQkMiIsInRvX2xpc3QkMiIsIm9mX2xpc3QkMCIsImgiLCJpdGVyJDYiLCJpdGVyMiQxIiwibWFwJDYiLCJtYXAyJDEiLCJpdGVyaSQzIiwibWFwaSQzIiwiZm9sZF9sZWZ0JDIiLCJmb2xkX3JpZ2h0JDEiLCJleGlzdHMkMSIsImZvcl9hbGwkMSIsIm1lbSQxIiwibWVtX2llZWUiLCJzb3J0JDAiLCJzdGFibGVfc29ydCIsInRvX3NlcSQ1IiwidG9fc2VxaSQyIiwib2Zfc2VxJDMiLCJtYXBfdG9fYXJyYXkiLCJtYXBfZnJvbV9hcnJheSIsInplcm8kMCIsIm9uZSQwIiwibWludXNfb25lJDAiLCJhYnMkMCIsIm1heF9pbnQkMCIsIm1pbl9pbnQkMCIsImxvZ25vdCIsImVxdWFsJDgiLCJjb21wYXJlJDciLCJ0b19zdHJpbmckMyIsInplcm8kMSIsIm9uZSQxIiwibWludXNfb25lJDEiLCJzdWNjJDEiLCJwcmVkJDEiLCJhYnMkMSIsIm1pbl9pbnQkMSIsIm1heF9pbnQkMSIsImxvZ25vdCQwIiwidW5zaWduZWRfdG9faW50IiwidG9fc3RyaW5nJDQiLCJvZl9zdHJpbmdfb3B0JDAiLCJjb21wYXJlJDgiLCJlcXVhbCQ5IiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJ1bnNpZ25lZF9kaXYiLCJxIiwidW5zaWduZWRfcmVtIiwic3VjYyQyIiwicHJlZCQyIiwiYWJzJDIiLCJsb2dub3QkMSIsIm1heF9pbnQkMyIsInVuc2lnbmVkX3RvX2ludCQwIiwidG9fc3RyaW5nJDUiLCJvZl9zdHJpbmdfb3B0JDEiLCJjb21wYXJlJDkiLCJlcXVhbCQxMCIsInVuc2lnbmVkX2NvbXBhcmUkMCIsInVuc2lnbmVkX2RpdiQwIiwidW5zaWduZWRfcmVtJDAiLCJ6ZXJvJDMiLCJvbmUkMyIsIm1pbnVzX29uZSQzIiwic3VjYyQzIiwicHJlZCQzIiwiYWJzJDMiLCJtaW5faW50JDMiLCJtYXhfaW50JDQiLCJsb2dub3QkMiIsInVuc2lnbmVkX3RvX2ludCQxIiwidG9fc3RyaW5nJDYiLCJvZl9zdHJpbmdfb3B0JDIiLCJjb21wYXJlJDEwIiwiZXF1YWwkMTEiLCJ1bnNpZ25lZF9jb21wYXJlJDEiLCJ1bnNpZ25lZF9kaXYkMSIsInVuc2lnbmVkX3JlbSQxIiwiZW5naW5lIiwidGJsIiwic3RhdGUiLCJuZXdfZW5naW5lIiwiZnJvbV9mdW5jdGlvbiIsIm9wdCIsInN0aCIsIndpdGhfcG9zaXRpb25zIiwiYXV4X2J1ZmZlciIsImxleGJ1ZiIsInJlYWQiLCJuZXdsZW4iLCJuZXdidWYiLCJmcm9tX2NoYW5uZWwiLCJmcm9tX3N0cmluZyQwIiwibGV4ZW1lIiwic3ViX2xleGVtZSIsInN1Yl9sZXhlbWVfb3B0Iiwic3ViX2xleGVtZV9jaGFyIiwic3ViX2xleGVtZV9jaGFyX29wdCIsImxleGVtZV9jaGFyIiwibGV4ZW1lX3N0YXJ0IiwibGV4ZW1lX2VuZCIsImxleGVtZV9zdGFydF9wIiwibGV4ZW1lX2VuZF9wIiwibmV3X2xpbmUiLCJsY3AiLCJmbHVzaF9pbnB1dCIsImVudiIsImdyb3dfc3RhY2tzIiwib2xkc2l6ZSIsIm5ld3NpemUiLCJuZXdfcyIsIm5ld192IiwibmV3X3N0YXJ0IiwibmV3X2VuZCIsImNsZWFyX3BhcnNlciIsImN1cnJlbnRfbG9va2FoZWFkX2Z1biIsInl5cGFyc2UiLCJ0YWJsZXMiLCJzdGFydCIsImxleGVyIiwiaW5pdF9hc3AiLCJpbml0X3NwIiwiaW5pdF9zdGFja2Jhc2UiLCJpbml0X3N0YXRlIiwiaW5pdF9jdXJyX2NoYXIiLCJpbml0X2x2YWwiLCJpbml0X2VycmZsYWciLCJjbWQiLCJhcmciLCJhcmckMCIsImNtZCQwIiwiYXJnJDEiLCJleG4iLCJjdXJyX2NoYXIiLCJ0b2siLCJwZWVrX3ZhbCIsInN5bWJvbF9zdGFydF9wb3MiLCJzdCIsImVuIiwic3ltYm9sX2VuZF9wb3MiLCJyaHNfc3RhcnRfcG9zIiwicmhzX2VuZF9wb3MiLCJzeW1ib2xfc3RhcnQiLCJzeW1ib2xfZW5kIiwicmhzX3N0YXJ0IiwicmhzX2VuZCIsImlzX2N1cnJlbnRfbG9va2FoZWFkIiwicGFyc2VfZXJyb3IiLCJoZWlnaHQiLCJobCIsImgkMCIsImhyIiwiYmFsIiwibHIiLCJsdiIsImxsIiwibHJyIiwibHJ2IiwibHJsIiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2IiwicmxsIiwiYWRkIiwic2luZ2xldG9uIiwiYWRkX21pbl9lbGVtZW50IiwiYWRkX21heF9lbGVtZW50IiwicmgiLCJsaCIsIm1pbl9lbHQiLCJtaW5fZWx0X29wdCIsIm1heF9lbHQiLCJtYXhfZWx0X29wdCIsInJlbW92ZV9taW5fZWx0IiwiciQwIiwiY29uY2F0Iiwic3BsaXQiLCJwcmVzIiwicHJlcyQwIiwiaXNfZW1wdHkiLCJtZW0iLCJyZW1vdmUiLCJ1bmlvbiIsInIyIiwidjIiLCJyMSIsInIyJDAiLCJyMSQwIiwiaW50ZXIiLCJzcGxpdF9iaXMiLCJkaXNqb2ludCIsImRpZmYiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJzdWJzZXQiLCJmb3JfYWxsIiwiZXhpc3RzIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsInYkMCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0Iiwib2ZfbGlzdCIsInN1YiIsImwkMyIsIngwIiwibCQ0IiwieDAkMCIsImwkNSIsIngwJDEiLCJubCIsIm1pZCIsImwkMiIsIng0IiwiYWRkX3NlcSIsIm9mX3NlcSIsInNlcV9vZl9lbnVtIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtYXBpIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiYWRkX21heF9iaW5kaW5nIiwiY29uY2F0X29yX2pvaW4iLCJkMSIsImQyIiwiZDIkMCIsImQxJDAiLCJkMiQxIiwiZDEkMSIsInB2ZCIsIm0kMSIsIm0xIiwibTIiLCJiaW5kaW5nc19hdXgiLCJiaW5kaW5ncyIsImNyZWF0ZSQwIiwiY2xlYXIiLCJjb3B5JDMiLCJwdXNoIiwicG9wIiwicG9wX29wdCIsInRvcCIsInRvcF9vcHQiLCJsZW5ndGgkMSIsIml0ZXIkNyIsImZvbGQkMSIsInRvX3NlcSQ2Iiwib2Zfc2VxJDQiLCJjcmVhdGUkMSIsImNsZWFyJDAiLCJjZWxsIiwicGVlayIsImNvbnRlbnQiLCJwZWVrX29wdCIsInRha2UiLCJ0YWtlX29wdCIsImNvcHkkNCIsInFfcmVzIiwicHJldiIsImlzX2VtcHR5JDAiLCJsZW5ndGgkMiIsIml0ZXIkOCIsImZvbGQkMiIsInRyYW5zZmVyIiwicTEiLCJxMiIsInRvX3NlcSQ3IiwiYWRkX3NlcSQwIiwib2Zfc2VxJDUiLCJyYWlzZV91bmRlZmluZWQiLCJmb3JjZV9sYXp5X2Jsb2NrIiwiYmxrIiwiY2xvc3VyZSIsImZvcmNlX3ZhbF9sYXp5X2Jsb2NrIiwiZm9yY2UiLCJsenYiLCJmb3JjZV92YWwiLCJmcm9tX2Z1biIsImZyb21fdmFsIiwiaXNfdmFsIiwiY291bnQiLCJmaWxsX2J1ZmYiLCJnZXRfZGF0YSIsImQxMSIsImEkMCIsImEkMSIsInBlZWtfZGF0YSIsInBlZWskMCIsImp1bmtfZGF0YSIsImp1bmsiLCJuZ2V0X2RhdGEiLCJhbCIsIm5wZWVrIiwiZW1wdHkkMSIsIml0ZXIkOSIsInN0cm0iLCJmcm9tIiwib2ZfbGlzdCQxIiwib2Zfc3RyaW5nJDAiLCJvZl9ieXRlcyIsIm9mX2NoYW5uZWwiLCJpYXBwIiwiaWNvbnMiLCJpc2luZyIsImxhcHAiLCJsY29ucyIsImxzaW5nIiwic2VtcHR5Iiwic2xhenkiLCJkdW1wIiwiZHVtcF9kYXRhIiwiY3JlYXRlJDIiLCJjb250ZW50cyIsInRvX2J5dGVzIiwic3ViJDMiLCJibGl0JDMiLCJudGgkMCIsImxlbmd0aCQzIiwiY2xlYXIkMSIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJ1JDAiLCJoaSIsImxvIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJpJDciLCJjdXJyZW50IiwiaSQ4Iiwib3BlbmluZyIsImkkNiIsImxpbSQwIiwiaSQzIiwic3RvcCIsImkkNCIsImkkNSIsImskMiIsIm5leHRfaSIsImlkZW50IiwiaSQ5IiwiaSQxMCIsImkkMTEiLCJ0cnVuY2F0ZSIsInRvX3NlcSQ4IiwidG9fc2VxaSQzIiwiYWRkX3NlcSQxIiwib2Zfc2VxJDYiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsIngkMCIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImJwcmludF9wYWR0eSIsInBhZHR5IiwiYnByaW50X2lnbm9yZWRfZmxhZyIsImlnbl9mbGFnIiwiYnByaW50X3BhZF9vcHQiLCJicHJpbnRfcGFkZGluZyIsInBhZHR5JDAiLCJicHJpbnRfcHJlY2lzaW9uIiwiYnByaW50X2ljb252X2ZsYWciLCJicHJpbnRfYWx0aW50X2ZtdCIsImJwcmludF9mY29udl9mbGFnIiwic3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0Iiwic3RyJDAiLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4iLCJmb3JtYXR0aW5nX2dlbiIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJzdWJfZm10dHkkMCIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10JDEiLCJjaHIkMCIsInByaW50X2NoYXIiLCJpc19hbG9uZSQwIiwiaXNfYWxvbmUiLCJhZnRlciIsImJlZm9yZSIsImokMCIsImokMSIsImZtdCQwIiwic3ltbSIsImZtdHR5X3JlbF9kZXQiLCJkZSIsImVkIiwiYWYiLCJmYSIsImRlJDAiLCJlZCQwIiwiYWYkMCIsImZhJDAiLCJkZSQxIiwiZWQkMSIsImFmJDEiLCJmYSQxIiwiZGUkMiIsImVkJDIiLCJhZiQyIiwiZmEkMiIsImRlJDMiLCJlZCQzIiwiYWYkMyIsImZhJDMiLCJkZSQ0IiwiZWQkNCIsImFmJDQiLCJmYSQ0IiwiZGUkNSIsImVkJDUiLCJhZiQ1IiwiZmEkNSIsImRlJDYiLCJlZCQ2IiwiYWYkNiIsImZhJDYiLCJkZSQ3IiwiZWQkNyIsImFmJDciLCJmYSQ3IiwiZGUkOCIsImVkJDgiLCJhZiQ4IiwiZmEkOCIsInRyYW5zIiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJyZXN0MiIsInJlc3QyJDAiLCJyZXN0MiQxIiwicmVzdDIkMiIsInJlc3QyJDMiLCJyZXN0MiQ0IiwicmVzdDIkNSIsInJlc3QyJDYiLCJyZXN0MiQ3IiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImZtdHR5X29mX3BhZGRpbmdfZm10dHkiLCJmbXR0eV9vZl9jdXN0b20iLCJhcml0eSQwIiwiZm10dHlfb2ZfZm10IiwidHlfcmVzdCIsInByZWNfdHkiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJ0eSQwIiwiZm10dHkkNCIsImZtdHR5JDUiLCJ0eXBlX3BhZGRpbmciLCJ3IiwidHlwZV9wYWRwcmVjIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwiZm10dHlfcmVzdCIsImZtdF9yZXN0IiwiZm10dHlfcmVzdCQwIiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXR0eV9yZXN0JDEiLCJmbXQkMiIsImZtdF9yZXN0JDIiLCJmbXR0eV9yZXN0JDIiLCJmbXQkMyIsImZtdF9yZXN0JDMiLCJmbXR0eV9yZXN0JDMiLCJmbXQkNCIsImZtdF9yZXN0JDQiLCJmbXR0eV9yZXN0JDQiLCJmbXQkNSIsImZtdF9yZXN0JDUiLCJmbXR0eV9yZXN0JDUiLCJmbXR0eSQ2IiwiZm10JDYiLCJmbXRfcmVzdCQ2IiwiZm10dHlfcmVzdCQ2IiwiZm10dHkkNyIsImZtdCQ3IiwiZm10X3Jlc3QkNyIsImZtdHR5X3Jlc3QkNyIsImZtdHR5JDgiLCJmbXQkOCIsImZtdF9yZXN0JDgiLCJmbXR0eV9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10JDkiLCJmbXRfcmVzdCQ5IiwiZm10dHkkMTAiLCJmbXQkMTAiLCJmbXRfcmVzdCQxMCIsImZtdHR5JDExIiwiZm10JDExIiwiZm10X3Jlc3QkMTEiLCJmbXR0eSQxMiIsImZtdCQxMiIsImZtdHR5X3Jlc3QkOSIsImZtdF9yZXN0JDEyIiwiZm10dHkkMTMiLCJmbXQkMTMiLCJmbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdHR5X3Jlc3QkMTEiLCJmbXRfcmVzdCQxNCIsImZtdHR5JDE1IiwiZm10JDE1IiwiZm10dHlfcmVzdCQxMiIsImZtdF9yZXN0JDE1IiwiZm10dHkkMTYiLCJmbXQkMTYiLCJmbXRfcmVzdCQxNiIsImZtdHR5JDE3IiwiZm10JDE3IiwiZm10X3Jlc3QkMTciLCJmbXR0eTMiLCJmbXQzIiwic3RyJDEiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTgiLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOSIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDIwIiwiZm10JDIwIiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIxIiwiZm10JDIxIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInN1Yl9mbXR0eV9yZXN0Iiwic3ViX2ZtdHR5X3Jlc3QkMCIsInN1Yl9mbXR0eV9yZXN0JDEiLCJzdWJfZm10dHlfcmVzdCQyIiwic3ViX2ZtdHR5X3Jlc3QkMyIsInN1Yl9mbXR0eV9yZXN0JDQiLCJzdWJfZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkNiIsInN1Yl9mbXR0eV9yZXN0JDciLCJzdWJfZm10dHlfcmVzdCQ4Iiwic3ViX2ZtdHR5X3Jlc3QkOSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJzdWJfZm10dHlfcmVzdCQxMiIsInN1Yl9mbXR0eV9yZXN0JDEzIiwic3ViX2ZtdHR5X3Jlc3QkMTQiLCJzdWIyX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTUiLCJzdWIyX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxNiIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE4Iiwic3ViX2ZtdHR5X3Jlc3QkMTkiLCJzdWJfZm10dHlfcmVzdCQyMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJzdWJfZm10dHlfcmVzdCQyMyIsInN1Yl9mbXR0eV9yZXN0JDI0Iiwic3ViX2ZtdHR5X3Jlc3QkMjUiLCJzdWJfZm10dHlfcmVzdCQyNiIsInJlY2FzdCIsImZpeF9wYWRkaW5nIiwid2lkdGgkMCIsImZpeF9pbnRfcHJlY2lzaW9uIiwicmVzJDEiLCJzdHJpbmdfdG9fY2FtbF9zdHJpbmciLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJzaWduIiwic3ltYiIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIiwibWFrZV9wcmludGYiLCJwJDAiLCJwJDEiLCJtYWtlX3BhZGRpbmciLCJuZXdfYWNjIiwibWFrZV9wcmludGYkMCIsImFjYyQyIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImthY2MiLCJrJDQiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaWdub3JlZF9wYXJhbSIsImZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIiwibWFrZV9pcHJpbnRmIiwibWFrZV9pcHJpbnRmJDAiLCJrb2MiLCJyZXN0JDI0IiwicmVzdCQyNSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMiIsInAkMyIsInAkNCIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwicGFyc2VfbHdvcmQiLCJwYXJzZV9pbnQiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsInVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCIsImVuZF9pbmQiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJhZGRfbGl0ZXJhbCIsImxpdF9zdGFydCIsInNpemUiLCJwYXJzZSIsInN0cl9pbmQkMiIsInBhcnNlX2ZsYWdzIiwic3RyX2luZCQwIiwicGFyc2VfdGFnIiwicGFyc2VfZ29vZF9icmVhayIsInBhcnNlX21hZ2ljX3NpemUiLCJzdHJfaW5kJDEiLCJwYXJzZV9jb252ZXJzaW9uIiwicGN0X2luZCIsInBsdXMiLCJzcGFjZSIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImluY29tcGF0aWJsZV9mbGFnIiwiY2hlY2tfbm9fMCIsIm9wdF9vZl9wYWQiLCJ3aWR0aCQxIiwiZ2V0X3BhZF9vcHQiLCJnZXRfcGFkcHJlY19vcHQiLCJmbXRfcmVzdWx0Iiwic3ViX2VuZCIsInNlYXJjaF9zdWJmb3JtYXRfZW5kIiwic3ViX2ZtdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJuZXh0X2luZCIsImNoYXJfc2V0JDEiLCJpZ25vcmVkJDkiLCJjaGFyX2Zvcm1hdCIsImZtdF9yZXN0JDIxIiwiZm10X3Jlc3QkMjIiLCJwYWQkOSIsImZtdF9yZXN0JDIzIiwiaWdub3JlZCQxMCIsImZtdF9yZXN0JDI0IiwicGFkJDEwIiwiZm10X3Jlc3QkMjUiLCJzdWJfZW5kJDAiLCJzdWJfZm10JDAiLCJmbXRfcmVzdCQyNiIsImlnbm9yZWQkMTEiLCJpZ25vcmVkJDMiLCJzeW1iJDAiLCJpZ25vcmVkJDUiLCJjb21wdXRlX2ludF9jb252IiwiaWdub3JlZCQ4IiwicHJlYyQ0Iiwic3BhY2UkMSIsInBsdXMkMiIsInBsdXMkMyIsInNwYWNlJDIiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQwIiwic3BhY2UkMCIsInBsdXMkMSIsImlnbiQwIiwicGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIiwibWludXMiLCJwYXJzZV9jb252IiwicGFyc2VfYWZ0ZXJfcGFkZGluZyIsInBhcnNlX2xpdGVyYWwiLCJwYXJzZV9wb3NpdGl2ZSIsIm5ld19pbmQiLCJtaW51cyQwIiwic2V0X2ZsYWciLCJzdHJfaW5kJDMiLCJzdHJfaW5kJDQiLCJzdHJfaW5kJDUiLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm9ybWF0JDAiLCJmb3JtYXR0aW5nJDAiLCJmb3JtYXR0aW5nIiwic3RyX2luZF8xIiwicGFyc2VfaW50ZWdlciIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsImZvcm1hdHRpbmdfbGl0JDAiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJzdWJfZW5kJDEiLCJzdWJfZW5kJDIiLCJzdHJfaW5kJDYiLCJzdHJfaW5kJDciLCJvcHRpb24iLCJzdWJmbXQiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsInByaW50ZiIsImVwcmludGYiLCJrc3ByaW50ZiIsInNwcmludGYiLCJhc3NvYzMiLCJ5MiIsInkxIiwic3BsaXQkMCIsIm1ha2Vfc3ltbGlzdCIsInByZWZpeCIsInN1ZmZpeCIsImhlbHBfYWN0aW9uIiwiYWRkX2hlbHAiLCJzcGVjbGlzdCIsImFkZDIiLCJ1c2FnZV9iIiwiZXJybXNnIiwiZG9jIiwic3BlYyIsImtleSIsInVzYWdlX3N0cmluZyIsInVzYWdlIiwiYm9vbF9vZl9zdHJpbmdfb3B0JDAiLCJpbnRfb2Zfc3RyaW5nX29wdCQwIiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCIsImFsbG93X2V4cGFuZCIsImFyZ3YiLCJhbm9uZnVuIiwiaW5pdHBvcyIsImNvbnZlcnRfZXJyb3IiLCJwcm9nbmFtZSIsImFjdGlvbiIsImZvbGxvdyQwIiwia2V5d29yZCIsIm5vX2FyZyQwIiwiZm9sbG93Iiwibm9fYXJnIiwiZ2V0X2FyZyQwIiwiZ2V0X2FyZyIsImNvbnN1bWVfYXJnJDAiLCJjb25zdW1lX2FyZyIsInRyZWF0X2FjdGlvbiQwIiwidHJlYXRfYWN0aW9uIiwiZiQwIiwiZiQxIiwiciQxIiwiZiQyIiwiciQyIiwiYXJnJDIiLCJmJDMiLCJhcmckMyIsIngkMSIsInIkMyIsImFyZyQ0IiwieCQyIiwic3BlY3MiLCJmJDQiLCJhcmckNSIsImYkNSIsImYkNiIsImFyZyQ2IiwibmV3YXJnIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMiLCJwYXJzZV9hcmd2X2R5bmFtaWMiLCJjdXJyZW50JDAiLCJwYXJzZV9hcmd2IiwibXNnJDAiLCJtc2ckMSIsInBhcnNlX2R5bmFtaWMiLCJwYXJzZV9leHBhbmQiLCJzZWNvbmRfd29yZCIsImxvb3AiLCJtYXhfYXJnX2xlbiIsImN1ciIsImt3ZCIsInJlcGxhY2VfbGVhZGluZ190YWIiLCJzZWVuIiwiYWxpZ24iLCJsaW1pdCIsImNvbXBsZXRlZCIsImtzZCIsImN1dGNvbCQwIiwic3BhY2VzJDAiLCJjdXRjb2wiLCJrd2RfbGVuIiwic3BhY2VzIiwicmVhZF9hdXgiLCJ0cmltIiwiZmlsZSIsIndvcmRzIiwic3Rhc2giLCJ3b3JkIiwicmVhZF9hcmciLCJyZWFkX2FyZzAiLCJ3cml0ZV9hdXgiLCJhcmdzIiwid3JpdGVfYXJnIiwid3JpdGVfYXJnMCIsInByaW50ZXJzIiwiZmllbGQiLCJvdGhlcl9maWVsZHMiLCJmaWVsZHMiLCJ0b19zdHJpbmckNyIsImNvbnYiLCJjaGFyJDAiLCJsaW5lIiwiY2hhciQxIiwibGluZSQwIiwiZmlsZSQwIiwiY2hhciQyIiwibGluZSQxIiwiZmlsZSQxIiwiY29uc3RydWN0b3IiLCJwcmludCIsImZjdCIsImNhdGNoJDAiLCJjb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJidCIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsImluZm8iLCJpc19yYWlzZSIsInByaW50X3Jhd19iYWNrdHJhY2UiLCJvdXRjaGFuIiwicmF3X2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInByaW50X2JhY2t0cmFjZSIsInJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIiwiYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UiLCJiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUiLCJiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiIsImJhY2t0cmFjZV9zbG90cyIsImdldF9iYWNrdHJhY2UiLCJyZWdpc3Rlcl9wcmludGVyIiwiZm4iLCJleG5fc2xvdCIsImV4bl9zbG90X2lkIiwiZXhuX3Nsb3RfbmFtZSIsInVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwic2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwiY29uc3QkMCIsImZsaXAiLCJuZWdhdGUiLCJwcm90ZWN0IiwiZmluYWxseSQwIiwid29yayIsImZpbmFsbHlfbm9fZXhuIiwid29ya19leG4iLCJ3b3JrX2J0IiwicHJpbnRfc3RhdCIsImFsbG9jYXRlZF9ieXRlcyIsIm1hIiwicHJvIiwibWkiLCJjcmVhdGVfYWxhcm0iLCJkZWxldGVfYWxhcm0iLCJzdHJpbmciLCJieXRlcyIsInN1YnN0cmluZyIsInN1YmJ5dGVzIiwiZmlsZW5hbWUiLCJvdXRwdXQkMCIsImRpZ2VzdCIsImlucHV0JDAiLCJjaGFyX2hleCIsInRvX2hleCIsImZyb21faGV4IiwiZGlnaXQiLCJuZXdfc3RhdGUiLCJhc3NpZ24iLCJzdDEiLCJzdDIiLCJmdWxsX2luaXQiLCJzZWVkIiwic2VlZCQwIiwibWFrZSQyIiwibWFrZV9zZWxmX2luaXQiLCJjb3B5JDUiLCJiaXRzIiwiY3VydmFsIiwibmV3dmFsIiwibmV3dmFsMzAiLCJpbnQkMCIsImJvdW5kIiwiaW50MzIiLCJiMSIsImIyIiwiaW50NjQiLCJiMyIsIm5hdGl2ZWludCIsImZsb2F0JDAiLCJib29sIiwiYml0cyQwIiwiaW50JDEiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiZnVsbF9pbml0JDAiLCJpbml0JDQiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJoYXNoJDEiLCJoYXNoX3BhcmFtIiwic2VlZGVkX2hhc2giLCJvbmdvaW5nX3RyYXZlcnNhbCIsImZsaXBfb25nb2luZ190cmF2ZXJzYWwiLCJwYXJhbXMiLCJyYW5kb21pemVkX2RlZmF1bHQiLCJyYW5kb21pemVkIiwicmFuZG9taXplIiwiaXNfcmFuZG9taXplZCIsInBybmciLCJjcmVhdGUkMyIsImluaXRpYWxfc2l6ZSIsInJhbmRvbSIsImNsZWFyJDIiLCJyZXNldCQwIiwiY29weV9idWNrZXRsaXN0Iiwia2V5JDAiLCJuZXh0JDAiLCJjb3B5JDYiLCJsZW5ndGgkNCIsInJlc2l6ZSQwIiwiaW5kZXhmdW4iLCJvZGF0YSIsIm9zaXplIiwibnNpemUiLCJuZGF0YSIsIm5kYXRhX3RhaWwiLCJpbnBsYWNlIiwiY2VsbCQwIiwibmlkeCIsIm1hdGNoJDAiLCJrZXlfaW5kZXgiLCJhZGQkMCIsImJ1Y2tldCIsImZpbmQkMCIsImsxIiwibmV4dDEiLCJrMiIsIm5leHQyIiwiazMiLCJkMyIsIm5leHQzIiwiZmluZF9vcHQkMCIsImZpbmRfYWxsJDAiLCJmaW5kX2luX2J1Y2tldCIsInJlcGxhY2UiLCJtZW0kMiIsIml0ZXIkMTAiLCJkb19idWNrZXQiLCJvbGRfdHJhdiIsImZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQiLCJmaWx0ZXJfbWFwX2lucGxhY2UiLCJmb2xkJDMiLCJiJDAiLCJidWNrZXRfbGVuZ3RoIiwic3RhdHMiLCJtYmwiLCJoaXN0byIsInRvX3NlcSQ5IiwidGJsX2RhdGEiLCJidWNrIiwiYnVjayQwIiwiYnVjayQxIiwidG9fc2VxX2tleXMiLCJ0b19zZXFfdmFsdWVzIiwiYWRkX3NlcSQyIiwicmVwbGFjZV9zZXEiLCJvZl9zZXEkNyIsImZpbmRfYWxsIiwiY29weSIsInN6Iiwid2Vha19jcmVhdGUiLCJsZW5ndGgkNSIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0JDAiLCJzZXQiLCJnZXQkMCIsImdldF9jb3B5IiwiY2hlY2skMCIsImJsaXQkNCIsImZpbGwkMiIsImFyIiwiZW1wdHlidWNrZXQiLCJnZXRfaW5kZXgiLCJzeiQwIiwic3okMSIsImNvdW50X2J1Y2tldCIsImFkZF9hdXgiLCJzZXR0ZXIiLCJpbmRleCIsImJ1Y2tldCQwIiwiaGFzaGVzIiwibmV3c3oiLCJuZXdidWNrZXQiLCJuZXdoYXNoZXMiLCJoYnVja2V0IiwicHJldl9sZW4iLCJsaXZlIiwiaiQyIiwibmV3dCIsIm9iIiwib2giLCJzZXR0ZXIkMCIsIm5iIiwibmkiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsImZpbmRfc2hhZG93IiwiaWZmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJpZCQwIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwiYWR2YW5jZV9sZWZ0Iiwic2l6ZSQwIiwicGVuZGluZ19jb3VudCIsInNpemUkMSIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJpbml0aWFsaXplX3NjYW5fc3RhY2siLCJzdGFjayIsInF1ZXVlX2VsZW0iLCJzZXRfc2l6ZSIsImxlZnRfdG90YWwiLCJzY2FuX3B1c2giLCJlbGVtIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3N0YWciLCJwcF9jbG9zZV9zdGFnIiwicHBfb3Blbl90YWciLCJwcF9jbG9zZV90YWciLCJwcF9zZXRfcHJpbnRfdGFncyIsInBwX3NldF9tYXJrX3RhZ3MiLCJwcF9nZXRfcHJpbnRfdGFncyIsInBwX2dldF9tYXJrX3RhZ3MiLCJwcF9zZXRfdGFncyIsInBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfaW50IiwicHBfcHJpbnRfZmxvYXQiLCJwcF9wcmludF9ib29sIiwicHBfcHJpbnRfY2hhciIsInBwX29wZW5faGJveCIsInBwX29wZW5fdmJveCIsInBwX29wZW5faHZib3giLCJwcF9vcGVuX2hvdmJveCIsInBwX29wZW5fYm94IiwicHBfcHJpbnRfbmV3bGluZSIsInBwX3ByaW50X2ZsdXNoIiwicHBfZm9yY2VfbmV3bGluZSIsInBwX3ByaW50X2lmX25ld2xpbmUiLCJwcF9wcmludF9jdXN0b21fYnJlYWsiLCJwcF9wcmludF9icmVhayIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfY3V0IiwicHBfb3Blbl90Ym94IiwicHBfY2xvc2VfdGJveCIsInBwX3ByaW50X3RicmVhayIsInBwX3ByaW50X3RhYiIsInBwX3NldF90YWIiLCJwcF9zZXRfbWF4X2JveGVzIiwicHBfZ2V0X21heF9ib3hlcyIsInBwX292ZXJfbWF4X2JveGVzIiwicHBfc2V0X2VsbGlwc2lzX3RleHQiLCJwcF9nZXRfZWxsaXBzaXNfdGV4dCIsInBwX2xpbWl0IiwicHBfc2V0X21heF9pbmRlbnQiLCJwcF9nZXRfbWF4X2luZGVudCIsInBwX3NldF9tYXJnaW4iLCJuZXdfbWF4X2luZGVudCIsImNoZWNrX2dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJwcF9nZXRfbWFyZ2luIiwicHBfc2V0X2dlb21ldHJ5IiwibWF4X2luZGVudCIsIm1hcmdpbiIsInBwX3NhZmVfc2V0X2dlb21ldHJ5IiwicHBfZ2V0X2dlb21ldHJ5IiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZGlzcGxheV9uZXdsaW5lIiwiYmxhbmtfbGluZSIsImRpc3BsYXlfaW5kZW50IiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsImRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyIsImRlZmF1bHRfcHBfbWFya19jbG9zZV90YWciLCJkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnIiwiZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWciLCJwcF9tYWtlX2Zvcm1hdHRlciIsInBwX3F1ZXVlIiwic3lzX3RvayIsInNjYW5fc3RhY2siLCJmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyIsIm91dF9mdW5zIiwibWFrZV9mb3JtYXR0ZXIiLCJvdXRwdXQiLCJmbHVzaCIsInBwZiIsImZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCIsImZvcm1hdHRlcl9vZl9idWZmZXIiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwic3RkYnVmIiwic3RkX2Zvcm1hdHRlciIsImVycl9mb3JtYXR0ZXIiLCJzdHJfZm9ybWF0dGVyIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJvcGVuX2hib3giLCJvcGVuX3Zib3giLCJvcGVuX2h2Ym94Iiwib3Blbl9ob3Zib3giLCJvcGVuX2JveCIsImNsb3NlX2JveCIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwib3Blbl9zdGFnIiwiY2xvc2Vfc3RhZyIsInByaW50X2FzIiwicHJpbnRfc3RyaW5nJDAiLCJwcmludF9pbnQkMCIsInByaW50X2Zsb2F0JDAiLCJwcmludF9jaGFyJDAiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X25ld2xpbmUkMCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJvcHQkMSIsInBwX3ByaW50X3RleHQiLCJwcF9wcmludF9vcHRpb24iLCJwcF9wcmludF9yZXN1bHQiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJvdXRwdXRfYWNjJDAiLCJidHkiLCJwJDUiLCJwJDYiLCJzdHJwdXRfYWNjJDAiLCJrZnByaW50ZiQwIiwiaWtmcHJpbnRmJDAiLCJpZnByaW50ZiQwIiwiZnByaW50ZiQwIiwicHJpbnRmJDAiLCJlcHJpbnRmJDAiLCJrZHByaW50ZiIsImRwcmludGYiLCJrcHJpbnRmIiwic3ByaW50ZiQwIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzIiwicHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImJwcmludGYkMCIsInBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInN0cmluZ2lmeSIsInBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImZ1bnMiLCJtYXJrX29wZW5fdGFnIiwibWFya19jbG9zZV90YWciLCJwcmludF9vcGVuX3RhZyIsInByaW50X2Nsb3NlX3RhZyIsInNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwiZm5hbWUiLCJjaGFyX2NvdW50IiwicmVzZXRfdG9rZW4iLCJpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciIsInRva2VuX3N0cmluZyIsInRva2VuX2J1ZmZlciIsInNraXBfY2hhciIsImlnbm9yZV9jaGFyIiwic3RvcmVfY2hhciIsImRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUiLCJjcmVhdGUkNCIsImluYW1lIiwiZnJvbV9zdHJpbmckMSIsImZyb21fZnVuY3Rpb24kMCIsInNjYW5fY2xvc2VfYXRfZW5kIiwic2Nhbl9yYWlzZV9hdF9lbmQiLCJmcm9tX2ljIiwic2Nhbl9jbG9zZV9pYyIsImVvZiIsInN0ZGliIiwib3Blbl9pbl9maWxlIiwib3Blbl9pbiIsImZyb21fZmlsZSIsImZyb21fZmlsZV9iaW4iLCJmcm9tX2NoYW5uZWwkMCIsImNsb3NlX2luJDAiLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9pYyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQiLCJzY2FuX2ludF9jb252ZXJzaW9uIiwic2Nhbl9mcmFjdGlvbmFsX3BhcnQiLCJzY2FuX2V4cG9uZW50X3BhcnQiLCJzY2FuX2Zsb2F0IiwicHJlY2lzaW9uIiwicHJlY2lzaW9uJDAiLCJjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyIsInNjYW5faGV4X2Zsb2F0Iiwid2lkdGgkNCIsIndpZHRoJDUiLCJ3aWR0aCQ2Iiwid2lkdGgkMTAiLCJ3aWR0aCQ3Iiwid2lkdGgkOCIsIndpZHRoJDkiLCJzY2FuX2NhbWxfZmxvYXRfcmVzdCIsIndpZHRoX3ByZWNpc2lvbiIsImZyYWNfd2lkdGgiLCJzY2FuX2NhbWxfZmxvYXQiLCJzY2FuX3N0cmluZyIsInN0cCIsInNjYW5fY2hhciIsImhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGVja19uZXh0X2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyIsInNjYW5fYmFja3NsYXNoX2NoYXIiLCJjMCIsImdldF9kaWdpdCIsImdldF9kaWdpdCQwIiwiYzEkMCIsImMyJDAiLCJzY2FuX2NhbWxfY2hhciIsImZpbmRfc3RvcCIsInNjYW5fY2FtbF9zdHJpbmciLCJmaW5kX3N0b3AkMCIsInNraXBfc3BhY2VzIiwic2Nhbl9jaGFyc19pbl9jaGFyX3NldCIsInNjYW5faW5kaWMiLCJzY2FuX2NoYXJzIiwic2NhbmZfYmFkX2lucHV0IiwiZ2V0X2NvdW50ZXIiLCJ3aWR0aF9vZl9wYWRfb3B0Iiwic3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCIsImZtdGluZyIsInRha2VfZm9ybWF0X3JlYWRlcnMkMCIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMkMCIsInJlYWRlciIsIm5ld19rIiwicmVhZGVyc19yZXN0IiwidGFrZV9mb3JtYXRfcmVhZGVycyIsImZtdCQyMyIsImZtdCQyNCIsImZtdCQyNSIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMiLCJwYWRfcHJlY19zY2FuZiIsInJlYWRlcnMiLCJzY2FuIiwibWFrZV9zY2FuZiIsInNjYW4kMCIsInN0cl9yZXN0Iiwic2NhbiQxIiwic2NhbiQyIiwic2NhbiQzIiwic2NhbiQ0IiwiY29udiQwIiwic2NhbiQ1IiwiY29udiQxIiwic2NhbiQ2IiwiY29udiQyIiwic2NhbiQ3IiwicHJlYyQ1Iiwic2NhbiQ4IiwiZm10aW5nX2xpdCQwIiwic3RwJDAiLCJzJDIiLCJzdHJfcmVzdCQwIiwiYXJnX3Jlc3QiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwiYnNjYW5mIiwia3NzY2FuZiIsInNzY2FuZiIsInNjYW5mIiwiYnNjYW5mX2Zvcm1hdCIsImZvcm1hdCIsInNzY2FuZl9mb3JtYXQiLCJmb3JtYXRfZnJvbV9zdHJpbmciLCJ1bmVzY2FwZWQiLCJrZnNjYW5mIiwiZnNjYW5mIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJwYXJhbXMkMCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJkdW1teV9pdGVtIiwidGFnIiwiY29tcGFyZSQxMSIsImNvbXBhcmUkMTIiLCJjb21wYXJlJDEzIiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwidG9fbGlzdCQzIiwiYXJyIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfc2xvdCIsIm5ld192YXJpYWJsZSIsInRvX2FycmF5IiwibmV3X21ldGhvZHNfdmFyaWFibGVzIiwibWV0aHMiLCJ2YWxzIiwibWV0aHMkMCIsIm5tZXRocyIsIm52YWxzIiwiZ2V0X3ZhcmlhYmxlIiwiZ2V0X3ZhcmlhYmxlcyIsImFkZF9pbml0aWFsaXplciIsImNyZWF0ZV90YWJsZSIsInB1YmxpY19tZXRob2RzIiwidGFncyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInN1cGVyJDAiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0IiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsInJ1bl9pbml0aWFsaXplcnMiLCJpbml0cyIsInJ1bl9pbml0aWFsaXplcnNfb3B0IiwiY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyIsImdldF9kYXRhJDAiLCJidWlsZF9wYXRoIiwia2V5cyIsImxvb2t1cF90YWJsZXMiLCJyb290IiwidGFibGVzJDIiLCJ0YWJsZXMkMCIsInRhYmxlcyQxIiwibmV3X2NhY2hlIiwic2V0X21ldGhvZHMiLCJjbG8iLCJjbG8kMCIsIm4kMiIsIm4kMyIsIm4kNCIsIm4kNSIsIm4kNiIsIngkMyIsIm4kNyIsIngkNCIsIm4kOCIsImYkNyIsIm4kOSIsIngkNSIsImYkOCIsImUkMiIsIm4kMTAiLCJ4JDYiLCJmJDkiLCJuJDExIiwieCQ3IiwibiQxMiIsIngkOCIsIm4kMTMiLCJuJDE0IiwiZSQzIiwibiQxNSIsIm0kMiIsIngkOSIsIm0kMyIsIm4kMTYiLCJtJDQiLCJlJDQiLCJuJDE3IiwibSQ1IiwibiQxOCIsInN0YXRzJDAiLCJpbml0aWFsX2J1ZmZlciIsImJ1ZmZlciIsImJ1ZnBvcyIsInJlc2V0X2J1ZmZlciIsInN0b3JlIiwibmV3YnVmZmVyIiwiZ2V0X3N0cmluZyIsIm1ha2VfbGV4ZXIiLCJrZXl3b3JkcyIsImt3ZF90YWJsZSIsImlkZW50X29yX2tleXdvcmQiLCJrZXl3b3JkX29yX2Vycm9yIiwiZW5kX2V4cG9uZW50X3BhcnQiLCJleHBvbmVudF9wYXJ0IiwibnVtYmVyIiwiaWRlbnQyIiwibmVnX251bWJlciIsIm5leHRfdG9rZW4kMCIsImVzY2FwZSIsIm1heWJlX2NvbW1lbnQiLCJjb21tZW50IiwibmV4dF90b2tlbiIsImlucHV0IiwiaGtleSIsImNsZWFuIiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsInJlcGxhY2VfYnVja2V0IiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJjcmVhdGUkNSIsImdldF9rZXkkMCIsImdldF9rZXlfY29weSQwIiwic2V0X2tleSQwIiwidW5zZXRfa2V5JDAiLCJjaGVja19rZXkkMCIsImJsaXRfa2V5JDAiLCJnZXRfZGF0YSQxIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJzZXRfa2V5X2RhdGEiLCJjcmVhdGUkNiIsImdldF9rZXkxIiwiZ2V0X2tleTFfY29weSIsInNldF9rZXkxIiwidW5zZXRfa2V5MSIsImNoZWNrX2tleTEiLCJnZXRfa2V5MiIsImdldF9rZXkyX2NvcHkiLCJzZXRfa2V5MiIsInVuc2V0X2tleTIiLCJjaGVja19rZXkyIiwiYmxpdF9rZXkxIiwiYmxpdF9rZXkyIiwiYmxpdF9rZXkxMiIsImdldF9kYXRhJDIiLCJnZXRfZGF0YV9jb3B5JDAiLCJzZXRfZGF0YSQwIiwidW5zZXRfZGF0YSQwIiwiY2hlY2tfZGF0YSQwIiwiYmxpdF9kYXRhJDAiLCJrMiQwIiwiazEkMCIsImNyZWF0ZSQ3IiwibGVuZ3RoJDYiLCJnZXRfa2V5JDEiLCJnZXRfa2V5X2NvcHkkMSIsInNldF9rZXkkMSIsInVuc2V0X2tleSQxIiwiY2hlY2tfa2V5JDEiLCJibGl0X2tleSQxIiwiZ2V0X2RhdGEkMyIsImdldF9kYXRhX2NvcHkkMSIsInNldF9kYXRhJDEiLCJ1bnNldF9kYXRhJDEiLCJjaGVja19kYXRhJDEiLCJibGl0X2RhdGEkMSIsImtpIiwiazAiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX3MiLCJsZW5fZiIsInF1b3RlIiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwiaXNfZGlyX3NlcCQwIiwiaXNfcmVsYXRpdmUkMCIsImlzX2ltcGxpY2l0JDAiLCJjaGVja19zdWZmaXgkMCIsImNob3Bfc3VmZml4X29wdCQwIiwidGVtcF9kaXJfbmFtZSIsInF1b3RlJDAiLCJhZGRfYnMiLCJsb29wJDAiLCJsb29wX2JzIiwiZHJpdmVfYW5kX3BhdGgiLCJkaXJuYW1lJDAiLCJwYXRoIiwiZHJpdmUiLCJkaXIiLCJiYXNlbmFtZSQwIiwiYmFzZW5hbWUkMSIsImRpcm5hbWUkMSIsImN1cnJlbnRfZGlyX25hbWUkMiIsInBhcmVudF9kaXJfbmFtZSQyIiwiZGlyX3NlcCQyIiwiaXNfZGlyX3NlcCQxIiwiaXNfcmVsYXRpdmUkMSIsImlzX2ltcGxpY2l0JDEiLCJjaGVja19zdWZmaXgkMSIsImNob3Bfc3VmZml4X29wdCQxIiwidGVtcF9kaXJfbmFtZSQwIiwicXVvdGUkMSIsImJhc2VuYW1lJDIiLCJkaXJuYW1lJDIiLCJjb25jYXQkMyIsImNob3Bfc3VmZml4IiwiZXh0ZW5zaW9uX2xlbiIsImV4dGVuc2lvbiIsImNob3BfZXh0ZW5zaW9uIiwicmVtb3ZlX2V4dGVuc2lvbiIsInBybmckMCIsInRlbXBfZmlsZV9uYW1lIiwidGVtcF9kaXIiLCJybmQiLCJjdXJyZW50X3RlbXBfZGlyX25hbWUiLCJzZXRfdGVtcF9kaXJfbmFtZSIsImdldF90ZW1wX2Rpcl9uYW1lIiwidGVtcF9maWxlIiwidHJ5X25hbWUiLCJjb3VudGVyJDEiLCJvcGVuX3RlbXBfZmlsZSIsInN0aCQwIiwicGVybXMiLCJzdGgkMSIsImFkZCQxIiwic3ViJDQiLCJuZWciLCJjb25qIiwibXVsIiwiZGl2IiwiaW52Iiwibm9ybTIiLCJub3JtIiwicSQwIiwicG9sYXIiLCJzcXJ0IiwidyQwIiwiZXhwIiwibG9nIiwicG93IiwiZW5hYmxlZCIsImlmX3NwYWNldGltZV9lbmFibGVkIiwiY3JlYXRlJDgiLCJjaGFubmVsIiwic2F2ZV9ldmVudCIsInRpbWUiLCJldmVudF9uYW1lIiwic2F2ZV9hbmRfY2xvc2UiLCJ0YWtlJDAiLCJjbG9zZWQiLCJzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIiwiZmxvYXQzMiIsImZsb2F0NjQiLCJpbnQ4X3NpZ25lZCIsImludDhfdW5zaWduZWQiLCJpbnQxNl9zaWduZWQiLCJpbnQxNl91bnNpZ25lZCIsImludDMyJDEiLCJpbnQ2NCQxIiwiaW50JDIiLCJuYXRpdmVpbnQkMSIsImNvbXBsZXgzMiIsImNvbXBsZXg2NCIsImtpbmRfc2l6ZV9pbl9ieXRlcyIsImNfbGF5b3V0IiwiZm9ydHJhbl9sYXlvdXQiLCJkaW1zIiwic2l6ZV9pbl9ieXRlcyIsImNyZWF0ZSQ5Iiwia2luZCIsImxheW91dCIsImdldCQxIiwic2V0JDAiLCJzaXplX2luX2J5dGVzJDAiLCJvZl92YWx1ZSIsImNyZWF0ZSQxMCIsImRpbSIsInNpemVfaW5fYnl0ZXMkMSIsInNsaWNlIiwib2ZfYXJyYXkiLCJiYSIsImNyZWF0ZSQxMSIsImRpbTEiLCJkaW0yIiwic2l6ZV9pbl9ieXRlcyQyIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0Iiwib2ZfYXJyYXkkMCIsInJvdyIsImNyZWF0ZSQxMiIsImRpbTMiLCJzaXplX2luX2J5dGVzJDMiLCJzbGljZV9sZWZ0XzEiLCJzbGljZV9yaWdodF8xIiwic2xpY2VfbGVmdF8yIiwic2xpY2VfcmlnaHRfMiIsIm9mX2FycmF5JDEiLCJjb2wiLCJhcnJheTBfb2ZfZ2VuYXJyYXkiLCJhcnJheTFfb2ZfZ2VuYXJyYXkiLCJhcnJheTJfb2ZfZ2VuYXJyYXkiLCJhcnJheTNfb2ZfZ2VuYXJyYXkiLCJyZXNoYXBlXzAiLCJyZXNoYXBlXzEiLCJyZXNoYXBlXzIiLCJyZXNoYXBlXzMiLCJkZWZhdWx0X3JlZHVjdGlvbiIsImVycm9yIiwiYWN0aW9uIiwibGhzIiwiZ290byQwIiwib2NhbWxfbGV4X3RhYmxlcyIsInN0IiwidW5zZWVhYmxlIiwiYm9vbCIsInBhaXIiLCJleGlzdF9mdW4iLCJleF9pbmNvbXBhdCIsImZ1bl9jYXN0IiwicGFwZXJfMV9ub3NlYWwiLCJwYXBlcl8xX3NlYWwiLCJwYXBlcl8yX25vc2VhbCIsInBhcGVyXzJfc2VhbCIsInBhcGVyXzNfbm9zZWFsIiwicGFwZXJfM19zZWFsIiwicGFwZXJfNF9ub3NlYWwiLCJwYXBlcl80X3NlYWwiLCJwYXBlcl81X25vc2VhbCIsInBhcGVyXzVfc2VhbCIsInBhcGVyXzZfbm9zZWFsIiwicGFwZXJfNl9zZWFsIiwiZ29vZF9pZF9pbml0IiwiYmFkX2lkX2luaXQiLCJnb29kX3N3YXBfaW5pdCIsImJhZF9zd2FwX2luaXQiLCJmbGlwcGVyX3BfMSIsImZsaXBwZXJfcF8yIiwicHBfc3VwcGx5IiwiZm10IiwieCIsInNob3dfc3VwcGx5IiwiaW5pdF9zdXBwbHkiLCJ0eVZhciIsInN1cHAiLCJuIiwicHBfc2VhbCIsInNob3dfc2VhbCIsImVxdWFsX3NlYWwiLCJhIiwiYiIsInBwX3R5bmFtZSIsInNob3dfdHluYW1lIiwiYTAiLCJhMCQwIiwiZXF1YWxfdHluYW1lIiwibWF0Y2giLCJyaHMwIiwicmhzMCQwIiwicHBfdGFndHkiLCJzaG93X3RhZ3R5IiwiZXF1YWxfdGFndHkiLCJsaHMwIiwicHBfZ3R5cGUiLCJzaG93X2d0eXBlIiwiYTEiLCJhMSQwIiwiYTAkMSIsImExJDEiLCJhMCQyIiwiYTEkMiIsImEwJDMiLCJlcXVhbF9ndHlwZSIsInJoczEiLCJsaHMxIiwibGhzMCQwIiwicmhzMSQwIiwicmhzMCQxIiwibGhzMSQwIiwibGhzMCQxIiwicmhzMSQxIiwicmhzMCQyIiwibGhzMSQxIiwibGhzMCQyIiwicmhzMSQyIiwicmhzMCQzIiwibGhzMSQyIiwibGhzMCQzIiwidHl2YXIiLCJyZW5hbWVUeVZhciIsImZyb21UeSIsInRvVHkiLCJmIiwidHkiLCJ0eVoiLCJ0b1R5JDAiLCJiJDAiLCJhJDAiLCJhJDEiLCJ0eVokMCIsInR5WiQxIiwiYSQyIiwidHlaJDIiLCJ0eVokMyIsInR5cF9mcm9tX3RhZyIsIm5tIiwicHBfcHJlY2lzaW9uIiwic2hvd19wcmVjaXNpb24iLCJhMSQzIiwiYTAkNCIsImVxdWFsX3ByZWNpc2lvbiIsInJoczEkMyIsInJoczAkNCIsImxoczEkMyIsImxoczAkNCIsInJlZmwiLCJ4JDAiLCJkeW5Ub3AiLCJvYmluZCIsIm0iLCJrIiwibWtNZWV0Iiwic2wiLCJ0eVkiLCJiMiIsImIxIiwicDFyIiwicDFsIiwiYzEiLCJwMnIiLCJwMmwiLCJjMiIsImIyJDAiLCJiMSQwIiwidHlZJDAiLCJhWmZvclgiLCJiWmZvclkiLCJwYiIsInBhIiwiYyIsInR5WSQxIiwiYVpmb3JYJDAiLCJiWmZvclkkMCIsImNoZWNrQ29uc2lzdGVudCIsInNsc3Vic3RuYW1lIiwidHlYIiwic2wkMCIsInNsc3Vic3R0eSIsInR5MiIsInR5MSIsInR5MiQwIiwidHkxJDAiLCJ0eSQwIiwidHkkMSIsInR5JDIiLCJzbHN1YnN0dGFnIiwic2xzdWJzdHByZWMiLCJwcmVjIiwidGFnIiwicDIiLCJwMSIsInAyJDAiLCJwMSQwIiwicCIsInAkMCIsInAkMSIsInAkMiIsInBwX2RpciIsInNob3dfZGlyIiwiZXF1YWxfZGlyIiwicmhzIiwiY29tcGxlbWVudCIsInBwX3RtIiwic2hvd190bSIsImEyIiwiYTIkMCIsImEwJDUiLCJhMyIsImEyJDEiLCJhMSQ0IiwiYTAkNiIsImEyJDIiLCJhMSQ1IiwiYTAkNyIsImExJDYiLCJhMCQ4IiwiYTIkMyIsImExJDciLCJhMCQ5IiwiYTMkMCIsImEyJDQiLCJhMSQ4IiwiYTAkMTAiLCJhMyQxIiwiYTIkNSIsImExJDkiLCJhMCQxMSIsInNlcCIsImEwJDEyIiwiYTEkMTAiLCJhMCQxMyIsImEwJDE0IiwiYTIkNiIsImExJDExIiwiYTAkMTUiLCJhMiQ3IiwiYTEkMTIiLCJhMCQxNiIsImEyJDgiLCJhMSQxMyIsImEwJDE3IiwiYTEkMTQiLCJhMCQxOCIsImEwJDE5IiwiYTEkMTUiLCJhMCQyMCIsImExJDE2IiwiYTAkMjEiLCJlcXVhbF90bSIsInJoczIiLCJsaHMyIiwicmhzMiQwIiwibGhzMiQwIiwicmhzMCQ1IiwibGhzMCQ1IiwicmhzMyIsInJoczIkMSIsInJoczEkNCIsInJoczAkNiIsImxoczMiLCJsaHMyJDEiLCJsaHMxJDQiLCJsaHMwJDYiLCJyaHMyJDIiLCJyaHMxJDUiLCJyaHMwJDciLCJsaHMyJDIiLCJsaHMxJDUiLCJsaHMwJDciLCJyaHMxJDYiLCJyaHMwJDgiLCJsaHMxJDYiLCJsaHMwJDgiLCJyaHMyJDMiLCJyaHMxJDciLCJyaHMwJDkiLCJsaHMyJDMiLCJsaHMxJDciLCJsaHMwJDkiLCJyaHMzJDAiLCJyaHMyJDQiLCJyaHMxJDgiLCJyaHMwJDEwIiwibGhzMyQwIiwibGhzMiQ0IiwibGhzMSQ4IiwibGhzMCQxMCIsInJoczMkMSIsInJoczIkNSIsInJoczEkOSIsInJoczAkMTEiLCJsaHMzJDEiLCJsaHMyJDUiLCJsaHMxJDkiLCJsaHMwJDExIiwieSIsInkkMCIsInJoczIkNiIsInJoczEkMTAiLCJyaHMwJDEyIiwibGhzMiQ2IiwibGhzMSQxMCIsImxoczAkMTIiLCJyaHMwJDEzIiwibGhzMCQxMyIsInJoczEkMTEiLCJyaHMwJDE0IiwibGhzMSQxMSIsImxoczAkMTQiLCJyaHMwJDE1IiwibGhzMCQxNSIsInJoczIkNyIsInJoczEkMTIiLCJyaHMwJDE2IiwibGhzMiQ3IiwibGhzMSQxMiIsImxoczAkMTYiLCJyaHMyJDgiLCJyaHMxJDEzIiwicmhzMCQxNyIsImxoczIkOCIsImxoczEkMTMiLCJsaHMwJDE3IiwicmhzMiQ5IiwicmhzMSQxNCIsInJoczAkMTgiLCJsaHMyJDkiLCJsaHMxJDE0IiwibGhzMCQxOCIsInJoczEkMTUiLCJyaHMwJDE5IiwibGhzMSQxNSIsImxoczAkMTkiLCJyaHMwJDIwIiwibGhzMCQyMCIsInJoczEkMTYiLCJyaHMwJDIxIiwibGhzMSQxNiIsImxoczAkMjEiLCJyaHMxJDE3IiwicmhzMCQyMiIsImxoczEkMTciLCJsaHMwJDIyIiwic2xzdWJzdCIsInRrIiwidCIsInQkMCIsInQkMSIsIm5tJDAiLCJ0ZiIsInR0IiwidDIiLCJ0MSIsInRrJDAiLCJ4MiIsIngxIiwidHAiLCJ0JDIiLCJ0YSIsInRmJDAiLCJ0Ym9kIiwidGJvZCQwIiwidGskMSIsIngkMSIsInQkMyIsInRrJDIiLCJ0Ym9kJDEiLCJjc3RzIiwidGJvZCQyIiwiZCIsInQkNCIsInR5WSQyIiwidCQ1Iiwibm0kMSIsInRmJDEiLCJ0JDYiLCJ0eVkkMyIsInQkNyIsInQkOCIsInQkOSIsImciLCJ0ciIsInRsIiwidCQxMCIsInRnIiwic3Vic3QiLCJ2IiwibSQwIiwiZnQiLCJrdCIsImt0JDAiLCJ5JDEiLCJtJDEiLCJ5JDIiLCJ0eVgkMCIsInR5JDMiLCJ0eVgkMSIsInR5WCQyIiwidHlYJDMiLCJnJDAiLCJwcF90eXZhciIsInNob3dfdHl2YXIiLCJlcXVhbF90eXZhciIsInBwX3RtdmFyIiwic2hvd190bXZhciIsImVxdWFsX3RtdmFyIiwicHBfc3JjX2xvYyIsInNob3dfc3JjX2xvYyIsImVxdWFsX3NyY19sb2MiLCJwcF90bSQwIiwic2hvd190bSQwIiwicHBfdG1jdG9yIiwic2hvd190bWN0b3IiLCJlcXVhbF90bSQwIiwiZXF1YWxfdG1jdG9yIiwiaW50JDAiLCJhcmdzIiwiZG9jcyIsImJpbmRpbmciLCJuYW1lIiwicGF0dGVybiIsInNjcnV0aW5lZSIsImtvbnQiLCJhcHAiLCJyYXRvciIsInJhbmQiLCJzcmNfbG9jIiwiY29sIiwibGluZSIsInBwdGFnIiwibG9vcCIsImN0eCIsIngkMiIsIngkMyIsInBwcHJlYyIsInBwdHkiLCJwcG5tIiwicHBkaXIiLCJwcGNhc3QiLCJwcHBhY2tjYXN0IiwicHBwYWNrY2FzdHMiLCJwcmV0dHlfY2FzdCIsImVxdWFsX3RtX2N0eCIsIndyYXBfaWYiLCJjdHhzIiwibG9vcCQwIiwiYnQiLCJwdCIsIm0kMiIsInByZWNzIiwicHB0bSIsInN0cmluZ19vZl9kb2MiLCJwcF9iaW5kaW5nIiwic2hvd19iaW5kaW5nIiwicHBfa25vd25fdHlfdmFyIiwic2hvd19rbm93bl90eV92YXIiLCJwcF9lbnYiLCJzaG93X2VudiIsInByZXR0eV9lbnYiLCJiaW5kaW5ncyIsImJuZCIsImlzX2ZyZWUiLCJwYXJhbSQxIiwiZW52IiwiZW1wdHkiLCJwdXNoIiwiZGVsdGEiLCJibmRpbmciLCJibmRpbmdzIiwiY29uY2F0IiwiZDEiLCJkMiIsInJlc3RyaWN0X2FsbCIsImJhZFhzIiwic3RlcCIsInJlc3RyaWN0IiwiaW50ZXJzZWN0IiwidG9fbWFwIiwibWFwIiwibTEiLCJtMiIsInYyIiwiY29uZmxpY3RzIiwiaW5zIiwiaGlkZV9tYW55IiwiZF9zbWFsbCIsImRfYmlnIiwiZF9zbWFsbCQwIiwiZF9iaWckMCIsImRfYmlnJDEiLCJkX3NtYWxsJDEiLCJyZXQiLCJiaW5kIiwiZSIsImxvb2t1cEtub3duVmFyIiwibG9va3VwVG1WYXIiLCJta0Nhc3QiLCJmcm9tdHkiLCJ0b3R5IiwidG0iLCJndWFyZCIsImNvbmQiLCJzdHJlcnJvciIsInRhZ0RuY2FzdCIsInRhZ3R5IiwidW5wYWlyIiwidW5mdW4iLCJ1bmV4aXN0cyIsInVuZm9yYWxsIiwiaXNCb3VuZCIsImVudiQwIiwicmVzX2FuZCIsImNvdmVycyIsInB1c2gkMCIsImluaXRfZW52IiwibWtFcnJvciIsIm1zZyIsImVsYWJfdG0iLCJ0eXgiLCJlbnZkdCIsInR5byIsImVudmR0JDAiLCJ0dHkiLCJ0YiIsInRidHkiLCJkZWx0YiIsImVudmIiLCJ0dHR5IiwiZGVsdHQiLCJ0ZnR5IiwiZGVsdGYiLCJsdGZ0eSIsImx0dHR5IiwibWVldHR5IiwiZGVsdHRhbmR0ZiIsImRlbGJ0ZiIsImVudnRmIiwidW5ib3VuZFgiLCJ0eWwiLCJkZWx0YV90bCIsInR5ciIsImRlbHRhX3RyIiwiZW52ZDEiLCJlbnZkMiIsInRwdHkiLCJlbnZkcCIsImt0eSIsImVudmRrIiwiZGVsdGFfYm9kIiwidHlmIiwiZGVsdGFfdGYiLCJ0eWEiLCJkZWx0YV90YSIsInR5Y29kIiwidHlkb20iLCJ0eWJvZCIsInRwJDAiLCJ0eXRwIiwiZGVsdGFfdHAiLCJ0eXRwYm9kIiwidGt0cCIsImRlbHRhX3RrIiwiZGVsdGFfdGskMCIsImJpZ19kZWx0YSIsImJvZHR5IiwidHlYJDQiLCJ1bmJvdW5kWCQwIiwiZWxhYl9wcm9nIiwiRXJyb3IiLCJjcG9zIiwicG9zX2NudW0iLCJwb3NfYm9sIiwicG9zX2xudW0iLCJ0b2tlbjJ0ZXJtaW5hbCIsInRvayIsImVycm9yX3Rlcm1pbmFsIiwidG9rZW4ydmFsdWUiLCJ2JDAiLCJ2JDEiLCJzdGFydCIsIm1lbmhpcl9lbnYiLCJtZW5oaXJfc3RhY2siLCJtZW5oaXJfc3RhY2skMCIsInN0YXJ0cG9zXzEiLCJtZW5oaXJfcyIsImVuZHBvc190eSIsImVuZHBvc18zIiwic3RhcnRwb3NfdHkxIiwiZW5kcG9zX3R5MiIsImVuZHBvc18xIiwiZW5kcG9zX3R5WCIsInN0YXJ0cG9zX3R5WCIsImVuZHBvc190ayIsImVuZHBvc190ZiIsImVuZHBvc190Ym9kIiwic3RhcnRwb3NfdGwiLCJlbmRwb3NfdHIiLCJzdGFydHBvc190ZiIsImVuZHBvc182IiwiZW5kcG9zX3RhIiwiZW5kcG9zX3QiLCJzdGFydHBvc190IiwiZW5kcG9zXzIiLCJlbmRwb3NfOCIsImVuZHBvc181IiwiZW5kcG9zX3giLCJzdGFydHBvc194IiwiZW5kcG9zX24iLCJzdGFydHBvc19uIiwic2VtYW50aWNfYWN0aW9uIiwicHJvZyIsImxleGVyIiwibGV4YnVmIiwicHJvZyQwIiwiaW5pdGlhbF9wb3NpdGlvbiIsIm5leHRfbGluZSIsInBvcyIsInJlYWQkMCIsIm9jYW1sX2xleF9yZWFkX3JlYyQwIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJvY2FtbF9sZXhfc3RhdGUkMSIsInJlYWQiLCJvY2FtbF9sZXhfcmVhZF9yZWMiLCJwcmludF9wb3NpdGlvbiIsImxpbmVfbnVtIiwiZnJvbV9zdHJpbmciLCJzIiwicHJldHR5X3N0b3JlIiwieHMiLCJiaW5kJDAiLCJzdG8iLCJyZXQkMCIsImZtYXAiLCJmYWlsdXJlIiwicnVubWFwIiwib3YiLCJub3BlIiwiYWxsb2NhdGUiLCJ0eXMiLCJsZW4iLCJkZXJlZiIsInNsJDEiLCJ0eXMkMSIsInR5cyQwIiwiYXBwbHlDYXN0cyIsImNzdHN0ZXAiLCJ2MSIsImNhc3RzIiwiciIsInIkMCIsInIkMSIsInIkMiIsInIkMyIsInIkNCIsInIkNSIsInIkNiIsIm91dHAiLCJpbnAiLCJtayIsInIkNyIsInIkOCIsImQkMCIsInR5WCQ1IiwiZCQxIiwiciQ5IiwiciQxMCIsInIkMTEiLCJyJDEyIiwibnIiLCJubCIsInIkMTMiLCJnJDEiLCJiaWdfc3RlcCIsInN0JDAiLCJmYWlsdXJlX3RvX3NlZSIsImlkX2tfMSIsImlkX2tfMiIsImlkXzEiLCJpZF8yIiwiYmFkX2lkXzEiLCJiYWRfaWRfMiIsInN3YXBfa18xIiwic3dhcF9rXzIiLCJzd2FwXzEiLCJzd2FwXzIiLCJiYWRfc3dhcF8xIiwiYmFkX3N3YXBfMiIsImdvb2RfZmxpcHBlcl9jIiwiYmFkX2ZsaXBwZXJfYyIsImZsaXBwZXJfMSIsImZsaXBwZXJfMiIsImJhZF9mbGlwcGVyXzEiLCJiYWRfZmxpcHBlcl8yIiwic2V0X2Vycm9yIiwibG4iLCJtIiwiY2xlYXJfZXJyb3JzIiwic2V0X2NsaWNrIiwiaSIsImgiLCJoaWRlX21hY2hpbmUiLCJyZXZlYWxfbWFjaGluZSIsInNldF90ZXh0IiwidCIsInNldF9lZGl0b3IiLCJnZXRfZWRpdG9yIiwiZXhfaGFuZGxlIiwicyIsIm5vX3Bhc3QiLCJzb21lX3Bhc3QiLCJub19mdXR1cmUiLCJzb21lX2Z1dHVyZSIsIm5leHRfdGVybV9zdGF0ZSIsImluaXRfc3RhdGUiLCJzdGF0ZSIsInJlbmRlciIsInBjIiwibWF5VHkiLCJzdG8iLCJ0bV9zdCIsIm5vX3Bhc3QkMCIsInMkMCIsInYiLCJ0eSIsImxvYWQiLCJ0JDAiLCJtc2ciLCJsb2MiLCJtc2ckMCIsImxpbmUiLCJzdGVwIiwiaGlzdCIsInJlcyIsInN0byQwIiwidG1fc3QkMCIsImUiLCJzdGVwX2JhY2siLCJoaXN0JDAiLCJ0c3QiLCJwYyQwIiwicHJldiIsInByZXZfbWFueSIsIm5leHRfbWFueSIsIm4iLCJuJDAiXSwibWFwcGluZ3MiOiI7Ozs7SUE4bENBO0lDOWRBLGtDQUFvQyxVQUFXO0lBN2IvQztNQUNFO2dCQUVFLG1CQUFxQixnQkFFckIsT0FBTztlQUVQO1NBRUo7SUNqSkE7TUFDRTtPQUFPO09BQ0E7T0FDQTtNQUNQLG9EQUNGO0lBNUNBLHNCQUF3QjtJQXdEeEI7TUFDRTtPQUFPO09BQ0E7T0FDQTs7Ozs7Ozs7Ozs7Ozs7TUFDUCxvREFDRjtJQTlCQTtNQUNFLElBQU8sVUFDQSx1QkFDQTtNQUNQLG9EQUNGO0lBd0xBO01BQ0UsNkRBQ0Y7SUZoQkE7TUFDRSxJQUFNLFdBQ0E7TUFDTixJQUFVO01BQ1YsUUFDRjtJRXBLQTtNQUNFO09BQU87T0FDQTtPQUNBO01BQ1Asb0RBQ0Y7SUFqREE7TUFDRSxlQUFpQjtNQUNqQixlQUFpQjtNQUNqQixlQUFpQjtNQUNqQixlQUFpQjtN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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVOzs7Ozs7O0lheGVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NrQktBO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDd0JBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQzs7OztLQ3pCQUM7S0FvSEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N5OUVNQztLQVFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDeGxGZEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ21ERUM7S0FDQUM7S0FDQUM7OztLQTNEWUM7S0EwRlpDO0tBQ0FDO0tBQ0FDOzs7S0E0RUFDO0tBQ0FDO0tBQ0FD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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NrUE9DOzs7OztLQUdBQzs7Ozs7S0FNQUM7Ozs7Ozs7Ozs7S0FHQUM7S0FHQUM7Ozs7Ozs7Ozs7Ozs7S0NqUEZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQzZMYUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDM01iQzs7OztLQUdBQztLQUVBQzs7O0tBRUFDOzs7S0FHQUM7OztLQU1BQzs7O0tBSUFDOztLQUVBQzs7O0tBR0FDOztLQUVBQzs7O0tBR0FDOzs7S0FFQUM7OztLQUdBQzs7O0tBRUFDOzs7S0FHQUM7OztLQUdBQzs7O0tBR0FDOzs7S0FFQUM7OztLQUlBQztLQUNBQzs7Ozs7OztLQVVBQzs7O0tBRUFDOzs7Ozs7O0tBbUJBQzs7O0tBR0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7YUN2RkpDOzs7TUFDaUIsV0FEakI7TUFDaUIsb0NBRGpCQyxRQUNpQjthQURqQkU7MkRBQ2lCO2FBR2JDLG1CQUFpQixZ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QkFBaUIsb0NBcEdibkI7SUFxR0oscUJBQWlCLG9DQS9FYk07SUFnRkoscUJBQWlCLG9DQXZEYlU7SUF3REoseUJBQXFCLG9DQW5EakJDO0lBb0RKLHlCQUFxQixvQ0E1Q2pCQztJQTZDSjtJQUNBOzs7O09Bdk1FakQ7T0FJQUc7T0FHQUM7T0FJQUc7T0FFQUM7T0FFQUM7T0FHQUU7T0FNQUM7T0FHQUM7T0FRQUU7T0FLQUM7T0FLQUM7T0FLQUM7T0FLQUM7T0FLQUM7SUEySUY7VUQvTUgiLCJzb3VyY2VzIjpbIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9zdGRsaWIuanMiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvbWxTdHJpbmcuanMiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvaW50NjQuanMiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvaWVlZV83NTQuanMiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvZnMuanMiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvZnNfZmFrZS5qcyIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9mc19ub2RlLmpzIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2JpZ2FycmF5LmpzIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2JpZ3N0cmluZy5qcyIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9qc2xpYi5qcyIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9pby5qcyIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9tYXJzaGFsLmpzIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2djLmpzIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL3dlYWsuanMiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvanNfb2Zfb2NhbWwtY29tcGlsZXIvcGFyc2luZy5qcyIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci91bml4LmpzIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2ludGVybmFsTW9kLmpzIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL2xleGluZy5qcyIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9wb2x5ZmlsbC9qc29uMi5qcyIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9tZDUuanMiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvdWNoYXIubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvaW50NjQubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9wcmludGV4Yy5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9maWxlbmFtZS5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9jb21wbGV4Lm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9zdGRsaWIubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvZmxvYXQubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvbmF0aXZlaW50Lm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2xpc3QubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvc2VxLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL29wdGlvbi5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9yZXN1bHQubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvYm9vbC5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9jaGFyLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2J5dGVzLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL3N0cmluZy5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC91bml0Lm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL21hcnNoYWwubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvb2JqLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2FycmF5Lm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2ludC5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9pbnQzMi5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9wYXJzaW5nLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL3NldC5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9tYXAubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvc3RhY2subWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvcXVldWUubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsTGF6eS5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9sYXp5Lm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL3N0cmVhbS5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9idWZmZXIubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvcHJpbnRmLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2FyZy5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9mdW4ubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvZ2MubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvZGlnZXN0Lm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL3JhbmRvbS5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9oYXNodGJsLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL3dlYWsubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvZm9ybWF0Lm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL3NjYW5mLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2NhbGxiYWNrLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbE9PLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2dlbmxleC5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19vcGFtL2xpYi9vY2FtbC9lcGhlbWVyb24ubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fb3BhbS9saWIvb2NhbWwvc3BhY2V0aW1lLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX29wYW0vbGliL29jYW1sL2JpZ2FycmF5Lm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX2J1aWxkL2RlZmF1bHQvbGliL3BhcnNlci5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19idWlsZC9kZWZhdWx0L2xpYi9sZXhlci5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19idWlsZC9kZWZhdWx0L2xpYi9pbnRlcnByZXRlci5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19idWlsZC9kZWZhdWx0L2xpYi9leGFtcGxlcy5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19idWlsZC9kZWZhdWx0L2xpYi9mcmVzaC5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19idWlsZC9kZWZhdWx0L2xpYi9ndHlwZXMubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fYnVpbGQvZGVmYXVsdC9saWIvQ0MubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fYnVpbGQvZGVmYXVsdC9saWIvc3VyZi5tbCIsIi9ob21lL21heC9jb2RlL29jYW1sc3JjL2dyYWR1YWwtcG9seW1vcnBoaXNtLWFydGlmYWN0L19idWlsZC9kZWZhdWx0L2xpYi9wcmV0dHkubWwiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fYnVpbGQvZGVmYXVsdC9saWIvdGNFbGFiLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX2J1aWxkL2RlZmF1bHQvbGliL3BhcnNlci5tbHkiLCIvaG9tZS9tYXgvY29kZS9vY2FtbHNyYy9ncmFkdWFsLXBvbHltb3JwaGlzbS1hcnRpZmFjdC9fYnVpbGQvZGVmYXVsdC9saWIvbGV4ZXIubWxsIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX2J1aWxkL2RlZmF1bHQvbGliL3BhcnNlLm1sIiwiL2hvbWUvbWF4L2NvZGUvb2NhbWxzcmMvZ3JhZHVhbC1wb2x5bW9ycGhpc20tYXJ0aWZhY3QvX2J1aWxkL2RlZmF1bHQvd2VicGFnZS93ZWIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQ29yZVxuXG4vL1Byb3ZpZGVzOiByYXdfYXJyYXlfc3ViXG5mdW5jdGlvbiByYXdfYXJyYXlfc3ViIChhLGksbCkge1xuICB2YXIgYiA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IGw7IGorKykgYltqXSA9IGFbaStqXTtcbiAgcmV0dXJuIGJcbn1cblxuLy9Qcm92aWRlczogcmF3X2FycmF5X2NvcHlcbmZ1bmN0aW9uIHJhd19hcnJheV9jb3B5IChhKSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYltpXSA9IGFbaV07XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiByYXdfYXJyYXlfY29ucyAoYSx4KSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwrMSk7XG4gIGJbMF09eDtcbiAgZm9yKHZhciBpID0gMTsgaSA8PSBsOyBpKysgKSBiW2ldID0gYVtpLTFdO1xuICByZXR1cm4gYlxufVxuXG4vL1Byb3ZpZGVzOiByYXdfYXJyYXlfYXBwZW5kX29uZVxuZnVuY3Rpb24gcmF3X2FycmF5X2FwcGVuZF9vbmUoYSx4KSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwrMSk7XG4gIHZhciBpID0gMDtcbiAgZm9yKDsgaSA8IGw7IGkrKyApIGJbaV0gPSBhW2ldO1xuICBiW2ldPXg7XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogcmF3X2FycmF5X3N1YlxuLy9SZXF1aXJlczogcmF3X2FycmF5X2FwcGVuZF9vbmVcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICBpZihmLmZ1bilcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgYXJncyk7XG4gIHZhciBuID0gZi5sZW5ndGg7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd19hcnJheV9zdWIoYXJncywwLG4pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICByYXdfYXJyYXlfc3ViKGFyZ3MsbixhcmdzTGVuIC0gbikpO1xuICBlbHNlXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KXsgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgcmF3X2FycmF5X2FwcGVuZF9vbmUoYXJncyx4KSk7IH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmKG5hbWVfb3B0ICYmIGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MpXG4gICAgbiA9IGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MobmFtZV9vcHQpO1xuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9SYWlzZSBleGNlcHRpb25cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfY29uc3RhbnQgKHRhZykgeyB0aHJvdyB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAodGFnKSB7IHJldHVybiB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZyAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBhcmcpIHsgdGhyb3cgWzAsIHRhZywgYXJnXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX3N0cmluZyAodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBjYW1sX25ld19zdHJpbmcgKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c19lcnJvciAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5TeXNfZXJyb3IsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dyYXBfZXhjZXB0aW9uIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9qc190b19zdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50XG5mdW5jdGlvbiBjYW1sX3dyYXBfZXhjZXB0aW9uKGUpIHtcbiAgaWYoZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gZTtcbiAgLy9TdGFja19vdmVyZmxvdzogY2hyb21lLCBzYWZhcmlcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuUmFuZ2VFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuUmFuZ2VFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICBpZihqb29fZ2xvYmFsX29iamVjdC5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1dyYXAgRXJyb3IgaW4gSnMuRXJyb3IgZXhjZXB0aW9uXG4gIGlmKGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICByZXR1cm4gWzAsY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIiksZV07XG4gIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICByZXR1cm4gWzAsY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLGNhbWxfanNfdG9fc3RyaW5nIChTdHJpbmcoZSkpXTtcbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5FcnJvcihcIkpzIGV4Y2VwdGlvbiBjb250YWluaW5nIGJhY2t0cmFjZVwiKTtcbiAgcmV0dXJuIGV4bjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfdGFnIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyAoeCkgeyByZXR1cm4gKHggaW5zdGFuY2VvZiBBcnJheSk/eFswXTooeCBpbnN0YW5jZW9mIE1sQnl0ZXMpPzI1MjoxMDAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlICh4LCBzKSB7XG4gIGlmIChzPD0wIHx8IHMgKyAxID4geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIk9iai50cnVuY2F0ZVwiKTtcbiAgaWYgKHgubGVuZ3RoICE9IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X21ha2VfZm9yd2FyZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuaWYgKCFNYXRoLmltdWwpXG4gIE1hdGguaW11bCA9XG4gIGZ1bmN0aW9uICh4LHkpIHtcbiAgICB5IHw9IDA7XG4gICAgcmV0dXJuICgoKCh4ID4+IDE2KSAqIHkpIDw8IDE2KSArICh4ICYgMHhmZmZmKSAqIHkpfDA7XG4gIH07XG52YXIgY2FtbF9tdWwgPSBNYXRoLmltdWw7XG5cbi8vc2xpZ2h0bHkgc2xvd2VyXG4vLyBmdW5jdGlvbiBtdWwzMih4LHkpIHtcbi8vICAgdmFyIHhsbyA9IHggJiAweGZmZmY7XG4vLyAgIHZhciB4aGkgPSB4IC0geGxvO1xuLy8gICByZXR1cm4gKCgoeGhpICogeSkgfDApICsgeGxvICogeSl8MDtcbi8vIH1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vLy8vLy8vLy8vLy8vIFBlcnZhc2l2ZVxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0IChhcnJheSwgaW5kZXgsIG5ld3ZhbCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGFycmF5W2luZGV4KzFdPW5ld3ZhbDsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZ2V0IChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXgrMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludF9jb21wYXJlLCBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgTWxCeXRlcykge1xuICAgICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNhbWxfc3RyaW5nX2NvbXBhcmUoYSwgYik7XG4gICAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4geDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSAmJiBhWzBdID09PSAoYVswXXwwKSkge1xuICAgICAgICB2YXIgdGEgPSBhWzBdO1xuICAgICAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZ1xuICAgICAgICBpZiAodGEgPT09IDI1NCkgdGE9MDtcbiAgICAgICAgLy8gRm9yd2FyZCBvYmplY3RcbiAgICAgICAgaWYgKHRhID09PSAyNTApIHtcbiAgICAgICAgICBhID0gYVsxXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChiIGluc3RhbmNlb2YgQXJyYXkgJiYgYlswXSA9PT0gKGJbMF18MCkpIHtcbiAgICAgICAgICB2YXIgdGIgPSBiWzBdO1xuICAgICAgICAgIC8vIGlnbm9yZSBkb3VibGVfYXJyYXlfdGFnXG4gICAgICAgICAgaWYgKHRiID09PSAyNTQpIHRiPTA7XG4gICAgICAgICAgLy8gRm9yd2FyZCBvYmplY3RcbiAgICAgICAgICBpZiAodGIgPT09IDI1MCkge1xuICAgICAgICAgICAgYiA9IGJbMV07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRhICE9IHRiKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRhIDwgdGIpPy0xOjE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGEpIHtcbiAgICAgICAgICAgIGNhc2UgMjQ4OiB7XG4gICAgICAgICAgICAgIC8vIE9iamVjdFxuICAgICAgICAgICAgICB2YXIgeCA9IGNhbWxfaW50X2NvbXBhcmUoYVsyXSwgYlsyXSk7XG4gICAgICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiB4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjUxOiB7XG4gICAgICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgICAgIC8vIEludDY0XG4gICAgICAgICAgICAgIHZhciB4ID0gY2FtbF9pbnQ2NF9jb21wYXJlKGEsIGIpO1xuICAgICAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4geDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChiIGluc3RhbmNlb2YgTWxCeXRlcyB8fFxuICAgICAgICAgICAgICAgICAoYiBpbnN0YW5jZW9mIEFycmF5ICYmIGJbMF0gPT09IChiWzBdfDApKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhICE9IFwibnVtYmVyXCIgJiYgYSAmJiBhLmNvbXBhcmUpIHtcbiAgICAgICAgdmFyIGNtcCA9IGEuY29tcGFyZShiLHRvdGFsKTtcbiAgICAgICAgaWYgKGNtcCAhPSAwKSByZXR1cm4gY21wO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcbiAgICB2YXIgaSA9IHN0YWNrLnBvcCgpO1xuICAgIGIgPSBzdGFjay5wb3AoKTtcbiAgICBhID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGkgKyAxIDwgYS5sZW5ndGgpIHN0YWNrLnB1c2goYSwgYiwgaSArIDEpO1xuICAgIGEgPSBhW2ldO1xuICAgIGIgPSBiW2ldO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZSAoYSwgYikgeyByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdHJ1ZSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaW50X2NvbXBhcmUgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pbnRfY29tcGFyZSAoYSwgYikge1xuICBpZiAoYSA8IGIpIHJldHVybiAoLTEpOyBpZiAoYSA9PSBiKSByZXR1cm4gMDsgcmV0dXJuIDE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID09IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbm90ZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpICE9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPj0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcnRoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVydGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPiAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDw9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3N0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc3RoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDwgMCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyAocyk7XG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopcChbKy1dP1swLTldKykvaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDRcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNF18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cblxuLy8vLy8vLy8vLy8vLyBGb3JtYXRcbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHJhd2J1ZmZlcikge1xuICBpZiAoZi51cHBlcmNhc2UpIHJhd2J1ZmZlciA9IHJhd2J1ZmZlci50b1VwcGVyQ2FzZSgpO1xuICB2YXIgbGVuID0gcmF3YnVmZmVyLmxlbmd0aDtcbiAgLyogQWRqdXN0IGxlbiB0byByZWZsZWN0IGFkZGl0aW9uYWwgY2hhcnMgKHNpZ24sIGV0YykgKi9cbiAgaWYgKGYuc2lnbmVkY29udiAmJiAoZi5zaWduIDwgMCB8fCBmLnNpZ25zdHlsZSAhPSAnLScpKSBsZW4rKztcbiAgaWYgKGYuYWx0ZXJuYXRlKSB7XG4gICAgaWYgKGYuYmFzZSA9PSA4KSBsZW4gKz0gMTtcbiAgICBpZiAoZi5iYXNlID09IDE2KSBsZW4gKz0gMjtcbiAgfVxuICAvKiBEbyB0aGUgZm9ybWF0dGluZyAqL1xuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJyAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIGlmIChmLnNpZ25lZGNvbnYpIHtcbiAgICBpZiAoZi5zaWduIDwgMCkgYnVmZmVyICs9ICctJztcbiAgICBlbHNlIGlmIChmLnNpZ25zdHlsZSAhPSAnLScpIGJ1ZmZlciArPSBmLnNpZ25zdHlsZTtcbiAgfVxuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDgpIGJ1ZmZlciArPSAnMCc7XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gMTYpIGJ1ZmZlciArPSBcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcwJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJzAnO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09ICctJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nIChidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9pbnQgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nLCBjYW1sX3N0cl9yZXBlYXRcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB4LnRvRml4ZWQocHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vLy8vLy8vLy8vLy8vIEhhc2h0Ymxcbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF91bml2X3BhcmFtIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBjYXNlIDI1NTpcbiAgICAgICAgLy8gSW50NjRcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsxXSArIChvYmpbMl0gPDwgMjQpKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2JqLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGhhc2hfYXV4IChvYmpbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTWxCeXRlcykge1xuICAgICAgY291bnQgLS07XG4gICAgICBzd2l0Y2ggKG9iai50ICYgNikge1xuICAgICAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKG9iaik7XG4gICAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICAgIGZvciAodmFyIGIgPSBvYmouYywgbCA9IG9iai5sLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBvYmouYywgbCA9IG9iai5sLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBhW2ldKSB8IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogPT09IChvYmp8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGNvdW50IC0tO1xuICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICtvYmopIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBjb3VudC0tO1xuICAgICAgdmFyIHAgPSBjYW1sX2ludDY0X3RvX2J5dGVzIChjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKG9iaikpO1xuICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgaS0tKSBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBwW2ldKSB8IDA7XG4gICAgfSBlbHNlIGlmKG9iaiAmJiBvYmouaGFzaCAmJiB0eXBlb2Ygb2JqLmhhc2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQ3VzdG9tXG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmouaGFzaCgpKSB8IDA7XG4gICAgfVxuICB9XG4gIGhhc2hfYXV4IChvYmopO1xuICByZXR1cm4gaGFzaF9hY2N1ICYgMHgzRkZGRkZGRjtcbn1cblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCxkKSB7XG4gIGQgPSBjYW1sX211bChkLCAweGNjOWUyZDUxfDApO1xuICBkID0gKChkIDw8IDE1KSB8IChkID4+PiAoMzItMTUpKSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKChoIDw8IDEzKSB8IChoID4+PiAoMzItMTMpKSk7ICAgLy9ST1RMMzIoaCwgMTMpO1xuICByZXR1cm4gKCgoaCArIChoIDw8IDIpKXwwKSArICgweGU2NTQ2YjY0fDApKXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9maW5hbChoKSB7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIGggPSBjYW1sX211bCAoaCwgMHg4NWViY2E2YnwwKTtcbiAgaCBePSBoID4+PiAxMztcbiAgaCA9IGNhbWxfbXVsIChoLCAweGMyYjJhZTM1fDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHYwKTtcbiAgdmFyIGxvID0gdlsxXSB8ICh2WzJdIDw8IDI0KTtcbiAgdmFyIGhpID0gKHZbMl0gPj4+IDgpIHwgKHZbM10gPDwgMTYpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgbG8pO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgaGkpO1xuICByZXR1cm4gaDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIHZhciBsbyA9IHZbMV0gfCAodlsyXSA8PCAyNCk7XG4gIHZhciBoaSA9ICh2WzJdID4+PiA4KSB8ICh2WzNdIDw8IDE2KTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGxvKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGhpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nX3N0clxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nX3N0cihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nX2FycihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gc1tpXVxuICAgICAgfCAoc1tpKzFdIDw8IDgpXG4gICAgICB8IChzW2krMl0gPDwgMTYpXG4gICAgICB8IChzW2krM10gPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzW2krMl0gPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzW2krMV0gPDwgODtcbiAgY2FzZSAxOiB3IHw9IHNbaV07XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nX3N0clxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHN3aXRjaCAodi50ICYgNikge1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHYpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nX3N0cihoLCB2LmMpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nX2FycihoLCB2LmMpO1xuICB9XG4gIHJldHVybiBoXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50NjQsIGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nXG52YXIgSEFTSF9RVUVVRV9TSVpFID0gMjU2O1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gSEFTSF9RVUVVRV9TSVpFKSBzeiA9IEhBU0hfUVVFVUVfU0laRTtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTU6XG4gICAgICAgIC8vIEludDY0XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0YWcgPSAoKHYubGVuZ3RoIC0gMSkgPDwgMTApIHwgdlswXTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAod3IgPj0gc3opIGJyZWFrO1xuICAgICAgICAgIHF1ZXVlW3dyKytdID0gdltpXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmKHYgJiYgdi5oYXNoICYmIHR5cGVvZiB2Lmhhc2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQ3VzdG9tXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdi5oYXNoKCkpO1xuICAgIH1cbiAgfVxuICBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuXG4vLy8vLy8vLy8vLy8vIFN5c1xuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9jb25maWcgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfbmV3X3N0cmluZyhcIlVuaXhcIiksIDMyLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9uZXdfc3RyaW5nKFwianNfb2Zfb2NhbWxcIildO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICB2YXIgeCA9IG5vd14weGZmZmZmZmZmKk1hdGgucmFuZG9tKCk7XG4gIHJldHVybiBbMCx4XTtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2ludF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIGNvbnN0XG4vLyBtYXhfaW50IC8gNCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgb3ZlcmZsb3dcbi8vbGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxOztcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgKCkgeyByZXR1cm4gKDB4N0ZGRkZGRkYvNCkgfCAwO31cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gMTsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNtZC50b1N0cmluZygpO1xuICBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLmxvZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT0gXCJ1bmRlZmluZWRcIlxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMpIHtcbiAgICB0cnkge3JlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYyhjbWQpOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IG51bGwpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlKGV4biwgYnQpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrICgpIHsgcmV0dXJuIFswXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssdil7XG4gIGlmKCFqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnYpXG4gICAgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52ID0ge31cbiAgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfanNfdG9fc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG4gPSBuYW1lLnRvU3RyaW5nKCk7XG4gIC8vbm9kZWpzIGVudlxuICBpZihnLnByb2Nlc3NcbiAgICAgJiYgZy5wcm9jZXNzLmVudlxuICAgICAmJiBnLnByb2Nlc3MuZW52W25dICE9IHVuZGVmaW5lZClcbiAgICByZXR1cm4gY2FtbF9qc190b19zdHJpbmcoZy5wcm9jZXNzLmVudltuXSk7XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudlxuICAgICAmJiBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZbbl0pXG4gICAgcmV0dXJuIGNhbWxfanNfdG9fc3RyaW5nKGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltuXSlcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQgKCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYoZy5xdWl0KSBnLnF1aXQoY29kZSk7XG4gIC8vbm9kZWpzXG4gIGlmKGcucHJvY2VzcyAmJiBnLnByb2Nlc3MuZXhpdClcbiAgICBnLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2FyZ3YgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfanNfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfc3ViXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gcmF3X2FycmF5X3N1Yihhcmd2LDIsYXJndi5sZW5ndGggLSAyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9qc190b19zdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX2pzX3RvX3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBbMCwgcCwgYXJnczJdO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyAoKSB7cmV0dXJuIDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ic3dhcDE2XG5mdW5jdGlvbiBjYW1sX2Jzd2FwMTYoeCkge1xuICByZXR1cm4gKCgoKHggJiAweDAwRkYpIDw8IDgpIHxcbiAgICAgICAgICAgKCh4ICYgMHhGRjAwKSA+PiA4KSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9ic3dhcCh4KSB7XG4gIHJldHVybiAoKCh4ICYgMHgwMDAwMDBGRikgPDwgMjQpIHxcbiAgICAgICAgICAoKHggJiAweDAwMDBGRjAwKSA8PCA4KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMEZGMDAwMCkgPj4+IDgpIHxcbiAgICAgICAgICAoKHggJiAweEZGMDAwMDAwKSA+Pj4gMjQpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYnN3YXAoeCkge1xuICByZXR1cm4gW1xuICAgIDI1NSxcbiAgICAoKCh4WzNdICYgMHgwMDAwZmYwMCkgPj4gOCkgfFxuICAgICAoKHhbM10gJiAweDAwMDAwMGZmKSA8PCA4KSB8XG4gICAgICgoeFsyXSAmIDB4MDBmZjAwMDApKSksXG4gICAgKCgoeFsyXSAmIDB4MDAwMGZmMDApID4+IDgpIHxcbiAgICAgKCh4WzJdICYgMHgwMDAwMDBmZikgPDwgOCkgfFxuICAgICAoKHhbMV0gJiAweDAwZmYwMDAwKSkpLFxuICAgICgoKHhbMV0gJiAweDAwMDBmZjAwKSA+PiA4KSB8XG4gICAgICgoeFsxXSAmIDB4MDAwMDAwZmYpIDw8IDgpKV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X29mX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF9vZl9qc19hcnJheShhKXtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGk9YS5sZW5ndGggLSAxOyBpPj0wOyBpLS0pe1xuICAgIHZhciBlID0gYVtpXTtcbiAgICBsID0gWzAsZSxsXTtcbiAgfVxuICByZXR1cm4gbFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfdmFyaWFudChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhcIlwiKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYgKHMucmVwZWF0KSByZXR1cm4gcy5yZXBlYXQobik7IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX3N0cmluZ1xuLy9SZXF1aXJlczogcmF3X2FycmF5X3N1YlxuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIHJhd19hcnJheV9zdWIoYSxpLCBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2FzY2lpXG5mdW5jdGlvbiBjYW1sX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgc3dpdGNoIChzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiBzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoY2FtbF9pc19hc2NpaShzLmMpKSB7XG4gICAgICBzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHMuYztcbiAgICB9XG4gICAgcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzLmMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sICsgMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sICsgMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCArIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyAzLCBiNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDMyXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdG9fanNfc3RyaW5nXG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe3JldHVybiBjYW1sX3RvX2pzX3N0cmluZyh0aGlzKX07XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkge1xuICAgIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkocy5sKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShzLmwpO1xuICB9XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2Zfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIChzKSB7XG4gIGlmICgocy50ICYgNikgIT0gMCAvKiBCWVRFUyAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc190b19zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFjYW1sX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmcgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBuZXcgTWxCeXRlcygwLHMscy5sZW5ndGgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheSAoYSkgeyByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPy0xOihzMS5jID4gczIuYyk/MTowO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfY29tcGFyZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPy0xOihzMS5jID4gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jID09IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2ZpbGxfYnl0ZXMocywgaSwgbCwgYykge1xuICBpZiAobCA+IDApIHtcbiAgICBpZiAoaSA9PSAwICYmIChsID49IHMubCB8fCAocy50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsID49IHMuYy5sZW5ndGgpKSkge1xuICAgICAgaWYgKGMgPT0gMCkge1xuICAgICAgICBzLmMgPSBcIlwiO1xuICAgICAgICBzLnQgPSAyOyAvKiBQQVJUSUFMICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLmMgPSBjYW1sX3N0cl9yZXBlYXQgKGwsIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICBzLnQgPSAobCA9PSBzLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ZpbGxfYnl0ZXNcbnZhciBjYW1sX2ZpbGxfc3RyaW5nID0gY2FtbF9maWxsX2J5dGVzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19zdHJpbmcsIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKSB7XG4gIGlmIChsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGlmICgoaTIgPT0gMCkgJiZcbiAgICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbGVuID49IHMyLmMubGVuZ3RoKSkpIHtcbiAgICBzMi5jID0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgLy8gVE9ETzogczEgLT4gc3RyaW5nIHRvIGJ5dGVzXG4gIHJldHVybiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHsgcmV0dXJuIHMubCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gc31cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHsgcmV0dXJuIHN9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWNvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWNvbXBhcmUoeCx5KSB7XG4gIGlmICh4WzNdID4geVszXSkgcmV0dXJuIDE7XG4gIGlmICh4WzNdIDwgeVszXSkgcmV0dXJuIC0xO1xuICBpZiAoeFsyXSA+IHlbMl0pIHJldHVybiAxO1xuICBpZiAoeFsyXSA8IHlbMl0pIHJldHVybiAtMTtcbiAgaWYgKHhbMV0gPiB5WzFdKSByZXR1cm4gMTtcbiAgaWYgKHhbMV0gPCB5WzFdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91Y29tcGFyZVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCx5KSB7IHJldHVybiBjYW1sX2ludDY0X3Vjb21wYXJlKHgseSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSkge1xuICB2YXIgeDMgPSB4WzNdIDw8IDE2O1xuICB2YXIgeTMgPSB5WzNdIDw8IDE2O1xuICBpZiAoeDMgPiB5MykgcmV0dXJuIDE7XG4gIGlmICh4MyA8IHkzKSByZXR1cm4gLTE7XG4gIGlmICh4WzJdID4geVsyXSkgcmV0dXJuIDE7XG4gIGlmICh4WzJdIDwgeVsyXSkgcmV0dXJuIC0xO1xuICBpZiAoeFsxXSA+IHlbMV0pIHJldHVybiAxO1xuICBpZiAoeFsxXSA8IHlbMV0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkge1xuICB2YXIgeTEgPSAtIHhbMV07XG4gIHZhciB5MiA9IC0geFsyXSArICh5MSA+PiAyNCk7XG4gIHZhciB5MyA9IC0geFszXSArICh5MiA+PiAyNCk7XG4gIHJldHVybiBbMjU1LCB5MSAmIDB4ZmZmZmZmLCB5MiAmIDB4ZmZmZmZmLCB5MyAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkge1xuICB2YXIgejEgPSB4WzFdICsgeVsxXTtcbiAgdmFyIHoyID0geFsyXSArIHlbMl0gKyAoejEgPj4gMjQpO1xuICB2YXIgejMgPSB4WzNdICsgeVszXSArICh6MiA+PiAyNCk7XG4gIHJldHVybiBbMjU1LCB6MSAmIDB4ZmZmZmZmLCB6MiAmIDB4ZmZmZmZmLCB6MyAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkge1xuICB2YXIgejEgPSB4WzFdIC0geVsxXTtcbiAgdmFyIHoyID0geFsyXSAtIHlbMl0gKyAoejEgPj4gMjQpO1xuICB2YXIgejMgPSB4WzNdIC0geVszXSArICh6MiA+PiAyNCk7XG4gIHJldHVybiBbMjU1LCB6MSAmIDB4ZmZmZmZmLCB6MiAmIDB4ZmZmZmZmLCB6MyAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tdWwoeCx5KSB7XG4gIHZhciB6MSA9IHhbMV0gKiB5WzFdO1xuICB2YXIgejIgPSAoKHoxICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB4WzJdICogeVsxXSArIHhbMV0gKiB5WzJdO1xuICB2YXIgejMgPSAoKHoyICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB4WzNdICogeVsxXSArIHhbMl0gKiB5WzJdICsgeFsxXSAqIHlbM107XG4gIHJldHVybiBbMjU1LCB6MSAmIDB4ZmZmZmZmLCB6MiAmIDB4ZmZmZmZmLCB6MyAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfemVybyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc196ZXJvKHgpIHtcbiAgcmV0dXJuICh4WzNdfHhbMl18eFsxXSkgPT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7XG4gIHJldHVybiAoeFszXSA8PCAxNikgPCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX21pbl9pbnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbWluX2ludCh4KSB7XG4gIHJldHVybiB4WzNdID09IDB4ODAwMCAmJiAoeFsxXXx4WzJdKSA9PSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX21pbnVzX29uZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19taW51c19vbmUoeCkge1xuICByZXR1cm4geFszXSA9PSAweGZmZmYgJiYgKHhbMV0meFsyXSkgPT0gMHhmZmZmZmY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkge1xuICByZXR1cm4gWzI1NSwgeFsxXSZ5WzFdLCB4WzJdJnlbMl0sIHhbM10meVszXV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IgKHgsIHkpIHtcbiAgcmV0dXJuIFsyNTUsIHhbMV18eVsxXSwgeFsyXXx5WzJdLCB4WzNdfHlbM11dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHtcbiAgcmV0dXJuIFsyNTUsIHhbMV1eeVsxXSwgeFsyXV55WzJdLCB4WzNdXnlbM11dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4geDtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICh4WzFdIDw8IHMpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbMl0gPDwgcykgfCAoeFsxXSA+PiAoMjQgLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbM10gPDwgcykgfCAoeFsyXSA+PiAoMjQgLSBzKSkpICYgMHhmZmZmXTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gWzI1NSwgMCxcbiAgICAgICAgICAgICh4WzFdIDw8IChzIC0gMjQpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzJdIDw8IChzIC0gMjQpKSB8ICh4WzFdID4+ICg0OCAtIHMpKSkgJiAweGZmZmZdO1xuICByZXR1cm4gWzI1NSwgMCwgMCwgKHhbMV0gPDwgKHMgLSA0OCkpICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4geDtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICgoeFsxXSA+PiBzKSB8ICh4WzJdIDw8ICgyNCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFsyXSA+PiBzKSB8ICh4WzNdIDw8ICgyNCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICh4WzNdID4+IHMpXTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICgoeFsyXSA+PiAocyAtIDI0KSkgfCAoeFszXSA8PCAoNDggLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoeFszXSA+PiAocyAtIDI0KSksXG4gICAgICAgICAgICAwXTtcbiAgcmV0dXJuIFsyNTUsICh4WzNdID4+IChzIC0gNDgpKSwgMCwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHg7XG4gIHZhciBoID0gKHhbM10gPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKCh4WzFdID4+IHMpIHwgKHhbMl0gPDwgKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzJdID4+IHMpIHwgKGggPDwgKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzNdIDw8IDE2KSA+PiBzKSA+Pj4gMTZdO1xuICB2YXIgc2lnbiA9ICh4WzNdIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gWzI1NSxcbiAgICAgICAgICAgICgoeFsyXSA+PiAocyAtIDI0KSkgfCAoeFszXSA8PCAoNDggLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbM10gPDwgMTYpID4+IChzIC0gMjQpID4+IDE2KSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgc2lnbiAmIDB4ZmZmZl07XG4gIHJldHVybiBbMjU1LFxuICAgICAgICAgICgoeFszXSA8PCAxNikgPj4gKHMgLSAzMikpICYgMHhmZmZmZmYsXG4gICAgICAgICAgc2lnbiAmIDB4ZmZmZmZmLCBzaWduICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sc2wxIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xzbDEgKHgpIHtcbiAgeFszXSA9ICh4WzNdIDw8IDEpIHwgKHhbMl0gPj4gMjMpO1xuICB4WzJdID0gKCh4WzJdIDw8IDEpIHwgKHhbMV0gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB4WzFdID0gKHhbMV0gPDwgMSkgJiAweGZmZmZmZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sc3IxIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xzcjEgKHgpIHtcbiAgeFsxXSA9ICgoeFsxXSA+Pj4gMSkgfCAoeFsyXSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHhbMl0gPSAoKHhbMl0gPj4+IDEpIHwgKHhbM10gPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB4WzNdID0geFszXSA+Pj4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91ZGl2bW9kIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3Vjb21wYXJlLCBjYW1sX2ludDY0X2xzbDEsIGNhbWxfaW50NjRfbHNyMVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91ZGl2bW9kICh4LCB5KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgbW9kdWx1cyA9IGNhbWxfb2JqX2R1cCh4KTtcbiAgdmFyIGRpdmlzb3IgPSBjYW1sX29ial9kdXAoeSk7XG4gIHZhciBxdW90aWVudCA9IFsyNTUsIDAsIDAsIDBdO1xuICB3aGlsZSAoY2FtbF9pbnQ2NF91Y29tcGFyZSAobW9kdWx1cywgZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgY2FtbF9pbnQ2NF9sc2wxIChkaXZpc29yKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgY2FtbF9pbnQ2NF9sc2wxIChxdW90aWVudCk7XG4gICAgaWYgKGNhbWxfaW50NjRfdWNvbXBhcmUgKG1vZHVsdXMsIGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50WzFdICsrO1xuICAgICAgbW9kdWx1cyA9IGNhbWxfaW50NjRfc3ViIChtb2R1bHVzLCBkaXZpc29yKTtcbiAgICB9XG4gICAgY2FtbF9pbnQ2NF9sc3IxIChkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gWzAscXVvdGllbnQsIG1vZHVsdXNdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X25lZywgY2FtbF9pbnQ2NF91ZGl2bW9kXG5mdW5jdGlvbiBjYW1sX2ludDY0X2RpdiAoeCwgeSlcbntcbiAgaWYgKGNhbWxfaW50NjRfaXNfemVybyAoeSkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geFszXSBeIHlbM107XG4gIGlmICh4WzNdICYgMHg4MDAwKSB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIGlmICh5WzNdICYgMHg4MDAwKSB5ID0gY2FtbF9pbnQ2NF9uZWcoeSk7XG4gIHZhciBxID0gY2FtbF9pbnQ2NF91ZGl2bW9kKHgsIHkpWzFdO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgcSA9IGNhbWxfaW50NjRfbmVnKHEpO1xuICByZXR1cm4gcTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9uZWcsIGNhbWxfaW50NjRfdWRpdm1vZFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QgKHgsIHkpXG57XG4gIGlmIChjYW1sX2ludDY0X2lzX3plcm8gKHkpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHhbM107XG4gIGlmICh4WzNdICYgMHg4MDAwKSB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIGlmICh5WzNdICYgMHg4MDAwKSB5ID0gY2FtbF9pbnQ2NF9uZWcoeSk7XG4gIHZhciByID0gY2FtbF9pbnQ2NF91ZGl2bW9kKHgsIHkpWzJdO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IGNhbWxfaW50NjRfbmVnKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9pbnQzMiAoeCkge1xuICByZXR1cm4gWzI1NSwgeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2ludDMyICh4KSB7XG4gIHJldHVybiB4WzFdIHwgKHhbMl0gPDwgMjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2Zsb2F0ICh4KSB7XG4gIHJldHVybiAoKHhbM10gPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgeFsyXSAqIE1hdGgucG93KDIsIDI0KSkgKyB4WzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoeCkge1xuICBpZiAoeCA8IDApIHggPSBNYXRoLmNlaWwoeCk7XG4gIHJldHVybiBbMjU1LFxuICAgICAgICAgIHggJiAweGZmZmZmZixcbiAgICAgICAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICAgICAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWRpdm1vZCwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSBjYW1sX2ludDY0X3VkaXZtb2QoeCwgd2Jhc2UpO1xuICAgIHggPSBwWzFdO1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHBbMl0pKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdCwgTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91ZGl2bW9kLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgY2FtbF9pbnQ2NF91ZGl2bW9kKFsyNTUsIDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZl0sIGJhc2U2NClbMV07XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoclsyXSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChbMjU1LCAwLCAwLCAweDgwMDBdLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gWzI1NSwgYVs3XSB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgIGFbNF0gfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSwgYVsxXSB8IChhWzBdIDw8IDgpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkge1xuICByZXR1cm4gW3hbM10gPj4gOCwgeFszXSAmIDB4ZmYsIHhbMl0gPj4gMTYsICh4WzJdID4+IDgpICYgMHhmZiwgeFsyXSAmIDB4ZmYsXG4gICAgICAgICAgeFsxXSA+PiAxNiwgKHhbMV0gPj4gOCkgJiAweGZmLCB4WzFdICYgMHhmZl07XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAoeCkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKSByZXR1cm4gWzI1NSwgMSwgMCwgMHg3ZmYwXTtcbiAgICByZXR1cm4gKHggPiAwKT9bMjU1LDAsMCwweDdmZjBdOlsyNTUsMCwwLDB4ZmZmMF07XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8weDgwMDA6KHg+PTApPzA6MHg4MDAwO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICAvLyBJbnQ2NC5iaXRzX29mX2Zsb2F0IDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3ID0gMHg3ZmIwMDAwMDAwMDAwMDAwTFxuICAvLyB1c2luZyBNYXRoLkxPRzJFKk1hdGgubG9nKHgpIGluIHBsYWNlIG9mIE1hdGgubG9nMiByZXN1bHQgaW4gcHJlY2lzaW9uIGxvc3RcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDEwMjM7XG4gIGlmIChleHAgPD0gMCkge1xuICAgIGV4cCA9IDA7XG4gICAgeCAvPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgfSBlbHNlIHtcbiAgICB4IC89IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICAgIGlmICh4IDwgMTYpIHtcbiAgICAgIHggKj0gMjsgZXhwIC09MTsgfVxuICAgIGlmIChleHAgPT0gMCkge1xuICAgICAgeCAvPSAyOyB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLDI0KTtcbiAgdmFyIHIzID0geHwwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4fDA7XG4gIHggPSAoeCAtIHIyKSAqIGs7XG4gIHZhciByMSA9IHh8MDtcbiAgcjMgPSAocjMgJjB4ZikgfCBzaWduIHwgZXhwIDw8IDQ7XG4gIHJldHVybiBbMjU1LCByMSwgcjIsIHIzXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCAoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9qc190b19zdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9qc190b19zdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgdmFyIGNzdCA9IE1hdGgucG93KDIscHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZihwcmVjID49IDApe1xuICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9qc190b19zdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGV4cCA9ICh4WzNdICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKHhbMV18eFsyXXwoeFszXSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuICh4WzNdICYgMHg4MDAwKT8oLUluZmluaXR5KTpJbmZpbml0eTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwtMjQpO1xuICB2YXIgcmVzID0gKHhbMV0qayt4WzJdKSprKyh4WzNdJjB4Zik7XG4gIGlmIChleHAgPiAwKSB7XG4gICAgcmVzICs9IDE2O1xuICAgIHJlcyAqPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgfSBlbHNlXG4gICAgcmVzICo9IE1hdGgucG93KDIsLTEwMjYpO1xuICBpZiAoeFszXSAmIDB4ODAwMCkgcmVzID0gLSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0ICh4LHkpIHtcbiAgaWYoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiBOYU47XG4gIGlmKHg9PXkpIHJldHVybiB5O1xuICBpZih4PT0wKXtcbiAgICBpZih5IDwgMClcbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgLTEwNzQpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMDc0KVxuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKCh4PHkpID09ICh4PjApKVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X2FkZChiaXRzLCBvbmUpXG4gIGVsc2VcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKVxuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGJpdHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RydW5jX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3RydW5jX2Zsb2F0KHgpe1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KDEpO1xuICBpbnQzMmFbMF0gPSB4O1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KGludDMyYS5idWZmZXIpO1xuICByZXR1cm4gZmxvYXQzMmFbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2xhc3NpZnlfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2xhc3NpZnlfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT0gMCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKHgpPzQ6Mztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICB2YXIgbmVnID0gKDEveCkgPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IgKHgpO1xuICAgIHZhciBmID0geCAtIGk7XG4gICAgaWYgKG5lZykgeyBpID0gLWk7IGYgPSAtZjsgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKGlzTmFOICh4KSkgcmV0dXJuIFswLCBOYU4sIE5hTl07XG4gIHJldHVybiBbMCwgMS94LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQgKHgsZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHsgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9mcmV4cF9mbG9hdCAoeCkge1xuICBpZiAoKHggPT0gMCkgfHwgIWlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIGlmICh4IDwgMC41KSB7IHggKj0gMjsgZXhwIC09IDE7IH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IHkgLSAxO1xuICByZXR1cm4gKE1hdGguYWJzKHgpPjE/ejooej09MD94Ongqei9NYXRoLmxvZyh5KSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gMSArIHgsIHogPSB5IC0gMTtcbiAgcmV0dXJuICh6PT0wP3g6eCpNYXRoLmxvZyh5KS96KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkge1xuICB2YXIgeCA9IE1hdGguYWJzKHgpLCB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSksIGIgPSBNYXRoLm1pbih4LHkpIC8gKGE/YToxKTtcbiAgcmV0dXJuIChhICogTWF0aC5zcXJ0KDEgKyBiKmIpKTtcbn1cblxuLy8gRklYOiB0aGVzZSBmaXZlIGZ1bmN0aW9ucyBvbmx5IGdpdmUgYXBwcm94aW1hdGUgcmVzdWx0cy5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguTE9HMTBFICogTWF0aC5sb2coeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0gTWF0aC5leHAoLXgpO1xuICByZXR1cm4gKHkgLSB6KSAvICh5ICsgeik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuaWYoam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAmJiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywnLycpO1xuZWxzZVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9ICBcIi9zdGF0aWNcIjtcbmlmKGNhbWxfY3VycmVudF9kaXIuc2xpY2UoLTEpICE9PSBcIi9cIikgY2FtbF9jdXJyZW50X2RpciArPSBcIi9cIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbnZhciBjYW1sX3Jvb3QgPSBjYW1sX2N1cnJlbnRfZGlyLm1hdGNoKC9bXlxcL10qXFwvLylbMF07XG5cblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKXsgIH1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT0obmFtZSBpbnN0YW5jZW9mIE1sQnl0ZXMpP25hbWUudG9TdHJpbmcoKTpuYW1lO1xuICBpZihuYW1lLmNoYXJDb2RlQXQoMCkgIT0gNDcpXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBjYXNlIFwiXCI6IGlmKG5jb21wLmxlbmd0aCA9PSAwKSBuY29tcC5wdXNoKFwiXCIpOyBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW11cbmlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2UoY2FtbF9yb290KX0pO1xufSBlbHNlIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QpfSk7XG59XG5qc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290K1wic3RhdGljL1wiLCBkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QrXCJzdGF0aWMvXCIpfSk7XG5cbi8vUHJvdmlkZXM6Y2FtbF9saXN0X21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGlzdF9tb3VudF9wb2ludCgpe1xuICB2YXIgcHJldiA9IDBcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspe1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9uZXdfc3RyaW5nKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiByZXNvbHZlX2ZzX2RldmljZShuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpO1xuICB2YXIgbmFtZV9zbGFzaCA9IG5hbWUgKyBcIi9cIjtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpuYW1lLGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKG5hbWUsZil9KVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bm1vdW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX21ha2VfcGF0aFxuZnVuY3Rpb24gY2FtbF91bm1vdW50KG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyhjYW1sX2N1cnJlbnRfZGlyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2hkaXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfY2hkaXIoZGlyKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZGlyKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICBpZihyb290LnJlc3QpIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGggKyByb290LnJlc3QgKyBcIi9cIjtcbiAgICBlbHNlIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGg7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoZGlyKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpe1xuICBuYW1lID0gKG5hbWUgaW5zdGFuY2VvZiBNbEJ5dGVzKT9uYW1lLnRvU3RyaW5nKCk6bmFtZTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfYV9kaXJcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9hX2RpcihuYW1lKXtcbiAgbmFtZSA9IChuYW1lIGluc3RhbmNlb2YgTWxCeXRlcyk/bmFtZS50b1N0cmluZygpOm5hbWU7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmlsZV9leGlzdHNcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19maWxlX2V4aXN0cyAobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UucmVhZGRpcihyb290LnJlc3QpO1xuICB2YXIgbCA9IG5ldyBBcnJheShhLmxlbmd0aCArIDEpO1xuICBsWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspXG4gICAgbFtpKzFdID0gY2FtbF9uZXdfc3RyaW5nKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGUodmZkLCBraW5kLCBsYXlvdXQsIHNoYXJlZCwgZGltcywgcG9zKSB7XG4gIC8vIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsYXJnbil7XG4gIHJldHVybiBjYW1sX2JhX21hcF9maWxlKGFyZ3ZbMF0sYXJndlsxXSxhcmd2WzJdLGFyZ3ZbM10sYXJndls0XSxhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsY29udGVudCl7XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUpXG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZigham9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXApIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wID0gW107XG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1qb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcFxuICBpZih0bXApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspe1xuICAgICAgY2FtbF9jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSx0bXBbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUgPSBjYW1sX2NyZWF0ZV9maWxlO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKCEgcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LGNvbnRlbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3Qse3Jkb25seToxfSk7XG4gICAgdmFyIGxlbiAgPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBmaWxlLnJlYWQoMCxidWYsMCxsZW4pO1xuICAgIHJldHVybiBidWZcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZURldmljZVxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9uZXdfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gTWxGYWtlRGV2aWNlIChyb290LCBmKSB7XG4gIHRoaXMuY29udGVudD17fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24obmFtZSkge1xuICBpZighdGhpcy5jb250ZW50W25hbWVdICYmIHRoaXMubG9va3VwRnVuKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMubG9va3VwRnVuKGNhbWxfbmV3X3N0cmluZyh0aGlzLnJvb3QpLCBjYW1sX25ld19zdHJpbmcobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkgdGhpcy5jb250ZW50W25hbWVdPW5ldyBNbEZha2VGaWxlKHJlc1sxXSk7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCk7XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZiAobi5tYXRjaChyKSkgcmV0dXJuIDFcbiAgfVxuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0pIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIHZhciBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjb250ZW50IGluc3RhbmNlb2YgTWxCeXRlcylcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9zdHJpbmdfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQudG9TdHJpbmcpIHtcbiAgICB2YXIgbWxzdHJpbmcgPSBjYW1sX25ld19zdHJpbmcoY29udGVudC50b1N0cmluZygpKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShtbHN0cmluZyk7XG4gIH1cbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCxjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0XG5mdW5jdGlvbiBNbEZha2VGaWxlKGNvbnRlbnQpe1xuICB0aGlzLmRhdGEgPSBjb250ZW50O1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9ieXRlcyhidWYsIHBvcywgdGhpcy5kYXRhLCBvZmZzZXQsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBjYW1sX2JsaXRfYnl0ZXModGhpcy5kYXRhLCBvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19nZXQodGhpcy5kYXRhLCBvZmZzZXQpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZUZpbGVcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnKVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZpbGVcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gIHJldHVybiBiXG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBjb25zdHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvcih2YXIga2V5IGluIGYpe1xuICAgIHN3aXRjaChrZXkpe1xuICAgIGNhc2UgXCJyZG9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fUkRPTkxZOyBicmVhaztcbiAgICBjYXNlIFwid3Jvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1dST05MWTsgYnJlYWs7XG4gICAgY2FzZSBcImFwcGVuZFwiICA6XG4gICAgICByZXMgfD0gY29uc3RzLk9fV1JPTkxZIHwgY29uc3RzLk9fQVBQRU5EO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNyZWF0ZVwiICAgOiByZXMgfD0gY29uc3RzLk9fQ1JFQVQ7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY2F0ZVwiIDogcmVzIHw9IGNvbnN0cy5PX1RSVU5DOyAgICBicmVhaztcbiAgICBjYXNlIFwiZXhjbFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19FWENMOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJpbmFyeVwiICAgOiByZXMgfD0gY29uc3RzLk9fQklOQVJZOyAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0XCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX1RFWFQ7ICAgICBicmVhaztcbiAgICBjYXNlIFwibm9uYmxvY2tcIiA6IHJlcyB8PSBjb25zdHMuT19OT05CTE9DSzsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgcmV0dXJuIG5ldyBNbE5vZGVGaWxlKGZkKTtcbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLG4pIHtcbiAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfc2V0XG5cbnZhciBCdWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXJcblxuZnVuY3Rpb24gTWxOb2RlRmlsZShmZCl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oYSk7XG4gIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oYSk7XG4gIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgY2FtbF9ieXRlc19zZXQoYnVmLGJ1Zl9vZmZzZXQgKyBpLGJ1ZmZlcltidWZfb2Zmc2V0K2ldKTtcbiAgfVxuICByZXR1cm4gMFxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KDEpO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oYSk7XG4gIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCAwLCAxLCBvZmZzZXQpO1xuICByZXR1cm4gYnVmZmVyWzBdO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbn1cblxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVGaWxlO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuLy9cbi8vIE5vdGU7IGludDY0K2NvbXBsZXggc3VwcG9ydCBpZiBwcm92aWRlZCBieSBhbGxvY2F0aW5nIGEgc2Vjb25kIFR5cGVkQXJyYXlcbi8vIE5vdGU7IGFjY2Vzc29yIGZ1bmN0aW9ucyBhcmUgc2VsZWN0ZWQgd2hlbiB0aGUgYmlnYXJyYXkgaXMgY3JlYXRlZC4gIEl0IGlzIGFzc3VtZWRcbi8vICAgICAgIHRoYXQgdGhpcyByZXN1bHRzIGluIGp1c3QgYSBmdW5jdGlvbiBwb2ludGVyIGFuZCB3aWxsIHRodXMgYmUgZmFzdC5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9pbml0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhX2luaXQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXRfdmlld3Ncbi8vUmVxdWlyZXM6IGNhbWxfYmFfdmlld3NcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdF92aWV3cygpIHtcbiAgaWYgKCFjYW1sX2JhX3ZpZXdzKSB7XG4gICAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgICBjYW1sX2JhX3ZpZXdzID0gW1xuICAgICAgW1xuICAgICAgICBnLkZsb2F0MzJBcnJheSwgZy5GbG9hdDY0QXJyYXksIGcuSW50OEFycmF5LCBnLlVpbnQ4QXJyYXksXG4gICAgICAgIGcuSW50MTZBcnJheSwgZy5VaW50MTZBcnJheSwgZy5JbnQzMkFycmF5LCBnLkludDMyQXJyYXksXG4gICAgICAgIGcuSW50MzJBcnJheSwgZy5JbnQzMkFycmF5LCBnLkZsb2F0MzJBcnJheSwgZy5GbG9hdDY0QXJyYXksIGcuVWludDhBcnJheV0sXG4gICAgICBbXG4gICAgICAgIDAgLyogR2VuZXJhbCAqLywgMCAvKiBHZW5lcmFsICovLCAwIC8qIEdlbmVyYWwgKi8sIDAgLyogR2VuZXJhbCAqLyxcbiAgICAgICAgMCAvKiBHZW5lcmFsICovLCAwIC8qIEdlbmVyYWwgKi8sIDAgLyogR2VuZXJhbCAqLywgMSAvKiBJbnQ2NCAqLyxcbiAgICAgICAgMCAvKiBHZW5lcmFsICovLCAwIC8qIEdlbmVyYWwgKi8sIDIgLyogQ29tcGxleCAqLywgMiAvKiBDb21wbGV4ICovLCAwIC8qIEdlbmVyYWwgKi9dXG4gICAgXTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemUoZGltcykge1xuICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgIGlmIChkaW1zW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIHNpemUgPSBzaXplICogZGltc1tpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV92aWV3c1xudmFyIGNhbWxfYmFfdmlld3M7XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhLCBkYXRhMiwgZGF0YV90eXBlLCBraW5kLCBsYXlvdXQsIGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG5cbiAgLy9cbiAgLy8gRnVuY3Rpb25zIHRvIGNvbXB1dGUgdGhlIG9mZnNldHMgZm9yIEMgb3IgRm9ydHJhbiBsYXlvdXQgYXJyYXlzXG4gIC8vIGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIGluZGljZXMuXG4gIC8vXG4gIGZ1bmN0aW9uIG9mZnNldF9jKGluZGV4KSB7XG4gICAgdmFyIG9mcyA9IDA7XG4gICAgaWYgKG5fZGltcyAhPSBpbmRleC5sZW5ndGgpXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgICAgaWYgKGluZGV4W2ldIDwgMCB8fCBpbmRleFtpXSA+PSBkaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogZGltc1tpXSkgKyBpbmRleFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9mcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZnNldF9mb3J0cmFuKGluZGV4KSB7XG4gICAgdmFyIG9mcyA9IDA7XG4gICAgaWYgKG5fZGltcyAhPSBpbmRleC5sZW5ndGgpXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiB3cm9uZyBudW1iZXIgb2YgaW5kaWNlc1wiKTtcbiAgICBmb3IgKHZhciBpID0gbl9kaW1zIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChpbmRleFtpXSA8IDEgfHwgaW5kZXhbaV0gPiBkaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogZGltc1tpXSkgKyAoaW5kZXhbaV0gLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mcztcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSBsYXlvdXQgPT0gMCA/IG9mZnNldF9jIDogb2Zmc2V0X2ZvcnRyYW47XG5cbiAgdmFyIGRpbTAgPSBkaW1zWzBdO1xuXG4gIC8vXG4gIC8vIEVsZW1lbnQgZ2V0IGZ1bmN0aW9ucy5cbiAgLy9cbiAgZnVuY3Rpb24gZ2V0X3N0ZChpbmRleCkge1xuICAgIHZhciBvZnMgPSBvZmZzZXQoaW5kZXgpO1xuICAgIHZhciB2ID0gZGF0YVtvZnNdO1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0X2ludDY0KGluZGV4KSB7XG4gICAgdmFyIG9mZiA9IG9mZnNldChpbmRleCk7XG4gICAgdmFyIGwgPSBkYXRhW29mZl07XG4gICAgdmFyIGggPSBkYXRhMltvZmZdO1xuICAgIHJldHVybiBbXG4gICAgICAyNTUsXG4gICAgICBsICYgMHhmZmZmZmYsXG4gICAgICAoKGwgPj4+IDI0KSAmIDB4ZmYpIHwgKChoICYgMHhmZmZmKSA8PCA4KSxcbiAgICAgIChoID4+PiAxNikgJiAweGZmZmZdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0X2NvbXBsZXgoaW5kZXgpIHtcbiAgICB2YXIgb2ZmID0gb2Zmc2V0KGluZGV4KTtcbiAgICB2YXIgciA9IGRhdGFbb2ZmXTtcbiAgICB2YXIgaSA9IGRhdGEyW29mZl07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICB9XG5cbiAgdmFyIGdldCA9IGRhdGFfdHlwZSA9PSAxIC8qIEludDY0ICovID8gZ2V0X2ludDY0IDogKGRhdGFfdHlwZSA9PSAyIC8qIENvbXBsZXggKi8gPyBnZXRfY29tcGxleCA6IGdldF9zdGQpO1xuXG4gIGZ1bmN0aW9uIGdldDFfYyhpKSB7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gZGltMClcbiAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICByZXR1cm4gZGF0YVtpXTtcbiAgfVxuICBmdW5jdGlvbiBnZXQxX2ZvcnRyYW4oaSkge1xuICAgIGlmIChpIDwgMSB8fCBpID4gZGltMClcbiAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICByZXR1cm4gZGF0YVtpIC0gMV07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0MV9hbnkoaSkge1xuICAgIHJldHVybiBnZXQoW2ldKTtcbiAgfVxuXG4gIHZhciBnZXQxID0gZGF0YV90eXBlID09IDAgLyogR2VuZXJhbCAqLyA/IChsYXlvdXQgPT0gMCA/IGdldDFfYyA6IGdldDFfZm9ydHJhbikgOiBnZXQxX2FueTtcblxuICAvL1xuICAvLyBFbGVtZW50IHNldCBmdW5jdGlvbnNcbiAgLy9cbiAgZnVuY3Rpb24gc2V0X3N0ZF9yYXcob2ZmLCB2KSB7XG4gICAgZGF0YVtvZmZdID0gdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldF9pbnQ2NF9yYXcob2ZmLCB2KSB7XG4gICAgZGF0YVtvZmZdID0gdlsxXSB8ICgodlsyXSAmIDB4ZmYpIDw8IDI0KTtcbiAgICBkYXRhMltvZmZdID0gKCh2WzJdID4+PiA4KSAmIDB4ZmZmZikgfCAodlszXSA8PCAxNik7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRfY29tcGxleF9yYXcob2ZmLCB2KSB7XG4gICAgZGF0YVtvZmZdID0gdlsxXTtcbiAgICBkYXRhMltvZmZdID0gdlsyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldF9zdGQoaW5kZXgsIHYpIHtcbiAgICB2YXIgb2ZzID0gb2Zmc2V0KGluZGV4KTtcbiAgICByZXR1cm4gc2V0X3N0ZF9yYXcob2ZzLCB2KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRfaW50NjQoaW5kZXgsIHYpIHtcbiAgICByZXR1cm4gc2V0X2ludDY0X3JhdyhvZmZzZXQoaW5kZXgpLCB2KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRfY29tcGxleChpbmRleCwgdikge1xuICAgIHJldHVybiBzZXRfY29tcGxleF9yYXcob2Zmc2V0KGluZGV4KSwgdik7XG4gIH1cblxuICB2YXIgc2V0ID0gZGF0YV90eXBlID09IDEgLyogSW50NjQgKi8gPyBzZXRfaW50NjQgOiAoZGF0YV90eXBlID09IDIgLyogQ29tcGxleCAqLyA/IHNldF9jb21wbGV4IDogc2V0X3N0ZCk7XG5cbiAgZnVuY3Rpb24gc2V0MV9jKGksIHYpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBkaW0wKVxuICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgIGRhdGFbaV0gPSB2O1xuICB9XG4gIGZ1bmN0aW9uIHNldDFfZm9ydHJhbihpLCB2KSB7XG4gICAgaWYgKGkgPCAxIHx8IGkgPiBkaW0wKVxuICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgIGRhdGFbaSAtIDFdID0gdjtcbiAgfVxuICBmdW5jdGlvbiBzZXQxX2FueShpLCB2KSB7XG4gICAgc2V0KFtpXSwgdik7XG4gIH1cblxuICB2YXIgc2V0MSA9IGRhdGFfdHlwZSA9PSAwIC8qIEdlbmVyYWwgKi8gPyAobGF5b3V0ID09IDAgPyBzZXQxX2MgOiBzZXQxX2ZvcnRyYW4pIDogc2V0MV9hbnk7XG5cbiAgLy9cbiAgLy8gb3RoZXJcbiAgLy9cbiAgZnVuY3Rpb24gbnRoX2RpbShpKSB7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbl9kaW1zKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICAgIHJldHVybiBkaW1zW2ldO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsbCh2KSB7XG4gICAgaWYgKGRhdGFfdHlwZSA9PSAwIC8qIEdlbmVyYWwgKi8pXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHNldF9zdGRfcmF3KGksIHYpO1xuICAgIGlmIChkYXRhX3R5cGUgPT0gMSAvKiBJbnQ2NCAqLylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgc2V0X2ludDY0X3JhdyhpLCB2KTtcbiAgICBpZiAoZGF0YV90eXBlID09IDIgLyogQ29tcGxleCAqLylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgc2V0X2NvbXBsZXhfcmF3KGksIHYpO1xuICB9XG4gIGZ1bmN0aW9uIGJsaXQoZnJvbSkge1xuICAgIGlmIChuX2RpbXMgIT0gZnJvbS5udW1fZGltcylcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKVxuICAgICAgaWYgKGRpbXNbaV0gIT0gZnJvbS5udGhfZGltKGkpKVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gICAgZGF0YS5zZXQoZnJvbS5kYXRhKTtcbiAgICBpZiAoZGF0YV90eXBlICE9IDAgLyogR2VuZXJhbCAqLylcbiAgICAgIGRhdGEyLnNldChmcm9tLmRhdGEyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1YihvZnMsIGxlbikge1xuICAgIHZhciBjaGFuZ2VkX2RpbTtcbiAgICB2YXIgbXVsID0gMTtcblxuICAgIGlmIChsYXlvdXQgPT0gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuX2RpbXM7IGkrKylcbiAgICAgICAgbXVsID0gbXVsICogZGltc1tpXTtcbiAgICAgIGNoYW5nZWRfZGltID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAobl9kaW1zIC0gMSk7IGkrKylcbiAgICAgICAgbXVsID0gbXVsICogZGltc1tpXTtcbiAgICAgIGNoYW5nZWRfZGltID0gbl9kaW1zIC0gMTtcbiAgICAgIG9mcyA9IG9mcyAtIDE7XG4gICAgfVxuXG4gICAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGRpbXNbY2hhbmdlZF9kaW1dKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc3ViOiBiYWQgc3ViLWFycmF5XCIpO1xuXG4gICAgdmFyIG5ld19kYXRhID0gZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgICB2YXIgbmV3X2RhdGEyID0gZGF0YV90eXBlID09IDAgLyogR2VuZXJhbCAqLyA/IG51bGwgOiBkYXRhMi5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcblxuICAgIHZhciBuZXdfZGltcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspXG4gICAgICBuZXdfZGltc1tpXSA9IGRpbXNbaV07XG4gICAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuXG4gICAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX2Zyb20obmV3X2RhdGEsIG5ld19kYXRhMiwgZGF0YV90eXBlLCBraW5kLCBsYXlvdXQsIG5ld19kaW1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNsaWNlKHZpbmQpIHtcbiAgICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSBbXTtcbiAgICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgICB2YXIgb2ZzO1xuXG4gICAgaWYgKG51bV9pbmRzID49IG5fZGltcylcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gICAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICAgIGlmIChsYXlvdXQgPT0gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgICBmb3IgKDsgaSA8IG5fZGltczsgaSsrKVxuICAgICAgICBpbmRleFtpXSA9IDA7XG4gICAgICBvZnMgPSBvZmZzZXQoaW5kZXgpO1xuICAgICAgc3ViX2RpbXMgPSBkaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgICBpbmRleFtuX2RpbXMgLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zIC0gbnVtX2luZHM7IGkrKylcbiAgICAgICAgaW5kZXhbaV0gPSAxO1xuICAgICAgb2ZzID0gb2Zmc2V0KGluZGV4KTtcbiAgICAgIHN1Yl9kaW1zID0gZGltcy5zbGljZSgwLCBudW1faW5kcyk7XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgICB2YXIgbmV3X2RhdGEgPSBkYXRhLnN1YmFycmF5KG9mcywgb2ZzICsgc2l6ZSk7XG4gICAgdmFyIG5ld19kYXRhMiA9IGRhdGFfdHlwZSA9PSAwIC8qIEdlbmVyYWwgKi8gPyBudWxsIDogZGF0YTIuc3ViYXJyYXkob2ZzLCBvZnMgKyBzaXplKTtcblxuICAgIHJldHVybiBjYW1sX2JhX2NyZWF0ZV9mcm9tKG5ld19kYXRhLCBuZXdfZGF0YTIsIGRhdGFfdHlwZSwga2luZCwgbGF5b3V0LCBzdWJfZGltcyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNoYXBlKHZkaW0pIHtcbiAgICB2YXIgbmV3X2RpbSA9IFtdO1xuICAgIHZhciBudW1fZGltcyA9IHZkaW0ubGVuZ3RoO1xuXG4gICAgaWYgKG51bV9kaW1zIDwgMSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgICB2YXIgbnVtX2VsdHMgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgbmV3X2RpbVtpXSA9IHZkaW1baV07XG4gICAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgICBpZiAobnVtX2VsdHMgIT0gc2l6ZSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG5cbiAgICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhLCBkYXRhMiwgZGF0YV90eXBlLCBraW5kLCBsYXlvdXQsIG5ld19kaW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZShiLCB0b3RhbCkge1xuICAgIGlmIChsYXlvdXQgIT0gYi5sYXlvdXQpXG4gICAgICByZXR1cm4gYi5sYXlvdXQgLSBsYXlvdXQ7XG4gICAgaWYgKG5fZGltcyAhPSBiLm51bV9kaW1zKVxuICAgICAgcmV0dXJuIGIubnVtX2RpbXMgLSBuX2RpbXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKylcbiAgICAgIGlmIChudGhfZGltKGkpICE9IGIubnRoX2RpbShpKSlcbiAgICAgICAgcmV0dXJuIChudGhfZGltKGkpIDwgYi5udGhfZGltKGkpKSA/IC0xIDogMTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMTA6XG4gICAgY2FzZSAxMTpcbiAgICAgIHZhciB4LCB5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICB5ID0gYi5kYXRhW2ldO1xuXG4gICAgICAgIC8vZmlyc3QgYXJyYXlcbiAgICAgICAgaWYgKHggPCB5KVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKHggPiB5KVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICAgICAgaWYgKCF0b3RhbClcbiAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIGlmICh4ID09IHgpXG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKHkgPT0geSlcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YTIpIHtcbiAgICAgICAgICAvL3NlY29uZCBhcnJheVxuICAgICAgICAgIHggPSBkYXRhMltpXTtcbiAgICAgICAgICB5ID0gYi5kYXRhMltpXTtcbiAgICAgICAgICBpZiAoeCA8IHkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgaWYgKHggPiB5KVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICAgICAgICBpZiAoIXRvdGFsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgIGlmICh4ID09IHgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIGlmICh5ID09IHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNDpcbiAgICBjYXNlIDU6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgODpcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxMjpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChkYXRhW2ldID4gYi5kYXRhW2ldKVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDc6XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGEyW2ldIDwgYi5kYXRhMltpXSlcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChkYXRhMltpXSA+IGIuZGF0YTJbaV0pXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChkYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgZGF0YTI6IGRhdGEyLFxuICAgIGRhdGFfdHlwZTogZGF0YV90eXBlLFxuICAgIG51bV9kaW1zOiBuX2RpbXMsXG4gICAgbnRoX2RpbTogbnRoX2RpbSxcbiAgICBraW5kOiBraW5kLFxuICAgIGxheW91dDogbGF5b3V0LFxuICAgIHNpemU6IHNpemUsXG4gICAgc3ViOiBzdWIsXG4gICAgc2xpY2U6IHNsaWNlLFxuICAgIGJsaXQ6IGJsaXQsXG4gICAgZmlsbDogZmlsbCxcbiAgICByZXNoYXBlOiByZXNoYXBlLFxuICAgIGdldDogZ2V0LFxuICAgIGdldDE6IGdldDEsXG4gICAgc2V0OiBzZXQsXG4gICAgc2V0MTogc2V0MSxcbiAgICBjb21wYXJlOiBjb21wYXJlXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfdmlld3Ncbi8vUmVxdWlyZXM6IGNhbWxfYmFfaW5pdF92aWV3c1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgLy8gSW5pdGlhbGl6ZSBUeXBlZEFycmF5IHZpZXdzXG4gIGNhbWxfYmFfaW5pdF92aWV3cygpO1xuXG4gIC8vIHNldCB1cCBkaW1lbnNpb25zIGFuZCBjYWxjdWxhdGUgc2l6ZVxuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcblxuICAvL3ZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuXG4gIC8vIEFsbG9jYXRlIFR5cGVkQXJyYXlcbiAgdmFyIHZpZXcgPSBjYW1sX2JhX3ZpZXdzWzBdW2tpbmRdO1xuICBpZiAoIXZpZXcpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB2YXIgZGF0YSA9IG5ldyB2aWV3KHNpemUpO1xuXG4gIC8vIDJuZCBUeXBlZEFycmF5IGZvciBpbnQ2NCwgY29tcGxleDMyIGFuZCBjb21wbGV4NjRcbiAgdmFyIGRhdGFfdHlwZSA9IGNhbWxfYmFfdmlld3NbMV1ba2luZF07XG4gIHZhciBkYXRhMiA9IG51bGw7XG4gIGlmIChkYXRhX3R5cGUgIT0gMCAvKiBHZW5lcmFsICovKSB7XG4gICAgZGF0YTIgPSBuZXcgdmlldyhzaXplKTtcbiAgfVxuXG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGEsIGRhdGEyLCBkYXRhX3R5cGUsIGtpbmQsIGxheW91dCwgZGltcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuZnVuY3Rpb24gY2FtbF9iYV9jaGFuZ2VfbGF5b3V0KGJhLCBsYXlvdXQpIHtcbiAgaWYoYmEubGF5b3V0ID09IGxheW91dCkgcmV0dXJuIGJhO1xuICB2YXIgZGltcyA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmEubnVtX2RpbXM7IGkrKylcbiAgICBkaW1zW2ldID0gYmEubnRoX2RpbShpKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX2Zyb20oYmEuZGF0YSwgYmEuZGF0YTIsIGJhLmRhdGFfdHlwZSwgYmEua2luZCwgbGF5b3V0LCBkaW1zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhLCBfZGltKSB7XG4gIHJldHVybiBiYS5udW1fZGltcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBkaW0pIHtcbiAgcmV0dXJuIGJhLm50aF9kaW0oZGltKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gYmEubnRoX2RpbSgwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gYmEubnRoX2RpbSgxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gYmEubnRoX2RpbSgyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpbmRleCkge1xuICByZXR1cm4gYmEuZ2V0KGNhbWxfanNfZnJvbV9hcnJheShpbmRleCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgYjEgPSBiYS5nZXQxKGkwKTtcbiAgdmFyIGIyID0gYmEuZ2V0MShpMCsxKSA8PCA4O1xuICByZXR1cm4gKGIxIHwgYjIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICB2YXIgYjEgPSBiYS5nZXQxKGkwKTtcbiAgdmFyIGIyID0gYmEuZ2V0MShpMCsxKSA8PCA4O1xuICB2YXIgYjMgPSBiYS5nZXQxKGkwKzIpIDw8IDE2O1xuICB2YXIgYjQgPSBiYS5nZXQxKGkwKzMpIDw8IDI0O1xuICByZXR1cm4gKGIxIHwgYjIgfCBiMyB8IGI0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIGIxID0gYmEuZ2V0MShpMCk7XG4gIHZhciBiMiA9IGJhLmdldDEoaTArMSkgPDwgODtcbiAgdmFyIGIzID0gYmEuZ2V0MShpMCsyKSA8PCAxNjtcbiAgdmFyIGI0ID0gYmEuZ2V0MShpMCszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0MShpMCs0KSA8PCA4O1xuICB2YXIgYjYgPSBiYS5nZXQxKGkwKzUpIDw8IDE2O1xuICB2YXIgYjcgPSBiYS5nZXQxKGkwKzYpO1xuICB2YXIgYjggPSBiYS5nZXQxKGkwKzcpIDw8IDg7XG4gIHJldHVybiBbMjU1LCBiMSB8IGIyIHwgYjMsIGI0IHwgYjUgfCBiNiwgYjcgfCBiOCBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8xKGJhLCBpMCkge1xuICByZXR1cm4gYmEuZ2V0MShpMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KFtpMCwgaTFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KFtpMCwgaTEsIGkyXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaW5kZXgsIHYpIHtcbiAgcmV0dXJuIGJhLnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaW5kZXgpLCB2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgYmEuc2V0MShpMCwgdiAmIDB4ZmYpO1xuICBiYS5zZXQxKGkwKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgYmEuc2V0MShpMCwgdiAmIDB4ZmYpO1xuICBiYS5zZXQxKGkwKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICBiYS5zZXQxKGkwKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0MShpMCszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICBiYS5zZXQxKGkwLCB2WzFdICYgMHhmZik7XG4gIGJhLnNldDEoaTArMSwgKHZbMV0gPj4gOCkgJiAweGZmKTtcbiAgYmEuc2V0MShpMCsyLCB2WzFdID4+IDE2KTtcbiAgYmEuc2V0MShpMCszLCB2WzJdICYgMHhmZik7XG4gIGJhLnNldDEoaTArNCwgKHZbMl0gPj4gOCkgJiAweGZmKTtcbiAgYmEuc2V0MShpMCs1LCB2WzJdID4+IDE2KTtcbiAgYmEuc2V0MShpMCs2LCB2WzNdICYgMHhmZik7XG4gIGJhLnNldDEoaTArNywgdlszXSA+PiA4KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIHJldHVybiBiYS5zZXQxKGkwLCB2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIHJldHVybiBiYS5zZXQoW2kwLCBpMV0sIHYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIHJldHVybiBiYS5zZXQoW2kwLCBpMSwgaTJdLCB2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9ibGl0XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgZHN0LmJsaXQoc3JjKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCBpbml0KSB7XG4gIGJhLmZpbGwoaW5pdCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHJldHVybiBiYS5zdWIob2ZzLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgcmV0dXJuIGJhLnNsaWNlKGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfcmVzaGFwZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgcmV0dXJuIGJhLnJlc2hhcGUoY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpKTtcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19hbGxvY1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVcbi8vV2Vha2RlZlxuLy9XaWxsIGJlIGRlZmluZWQgaW4gQmFzZVxuZnVuY3Rpb24gYmlnc3RyaW5nX2FsbG9jKF8sc2l6ZSl7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZSgxMiwgMCwgWzAsc2l6ZV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZGVzdHJveV9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vV2Vha2RlZlxuLy9XaWxsIGJlIGRlZmluZWQgaW4gQ29yZV9rZXJuZWxcbmZ1bmN0aW9uIGJpZ3N0cmluZ19kZXN0cm95X3N0dWIodl9ic3RyKSB7XG4gIGlmICh2X2JzdHIuZGF0YTIgIT0gbnVsbCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ3N0cmluZ19kZXN0cm95OiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB9XG5cbiAgaWYgKHZfYnN0ci5oYXNPd25Qcm9wZXJ0eSgnX19pc19kZWFsbG9jYXRlZCcpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnc3RyaW5nX2Rlc3Ryb3k6IGJpZ3N0cmluZyBpcyBhbHJlYWR5IGRlYWxsb2NhdGVkXCIpO1xuICB9XG5cbiAgdmFyIGRlc3Ryb3llZF9kYXRhID0gbmV3IHZfYnN0ci5kYXRhLl9fcHJvdG9fXy5jb25zdHJ1Y3RvcigwKTtcbiAgdmFyIGRlc3Ryb3llZF9iaWdzdHJpbmcgPVxuICAgICAgY2FtbF9iYV9jcmVhdGVfZnJvbShkZXN0cm95ZWRfZGF0YSwgbnVsbCwgdl9ic3RyLmRhdGFfdHlwZSwgdl9ic3RyLmtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZfYnN0ci5sYXlvdXQsIFswXSk7XG4gIGRlc3Ryb3llZF9iaWdzdHJpbmcuX19pc19kZWFsbG9jYXRlZCA9IHRydWU7XG5cbiAgLy8gTXV0YXRlIHRoZSBvcmlnaW5hbCBiaWdzdHJpbmcgaW4tcGxhY2UsIHRvIHNpbXVsYXRlIHdoYXQgdGhlIEMgdmVyc2lvbiBkb2VzXG4gIE9iamVjdC5hc3NpZ24odl9ic3RyLCBkZXN0cm95ZWRfYmlnc3RyaW5nKTtcblxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0LCBjYW1sX2JhX2dldF8xXG4vL1dlYWtkZWZcbi8vV2lsbCBiZSBkZWZpbmVkIGluIEJhc2VcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViKHZfYnN0ciwgdl9zcmNfcG9zLCB2X3N0ciwgdl9kc3RfcG9zLCB2X2xlbil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKXtcbiAgICB2YXIgYyA9IGNhbWxfYmFfZ2V0XzEodl9ic3RyLHZfc3JjX3BvcyArIGkpO1xuICAgIGNhbWxfYnl0ZXNfc2V0KHZfc3RyLHZfZHN0X3BvcyArIGksYyk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19zdHJpbmdfc3R1YlxuLy9SZXF1aXJlczogYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcbi8vRnJvbSBjc3RydWN0XG52YXIgYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX3N0cmluZ19zdHViID0gYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViXG4vL0Zyb20gY3N0cnVjdFxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXQsIGNhbWxfYmFfc2V0XzFcbi8vV2Vha2RlZlxuLy9XaWxsIGJlIGRlZmluZWQgaW4gQmFzZVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViKHZfc3RyLCB2X3NyY19wb3MsIHZfYnN0ciwgdl9kc3RfcG9zLCB2X2xlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykgY2FtbF9iYV9zZXRfMSh2X2JzdHIsdl9kc3RfcG9zICsgaSxjYW1sX3N0cmluZ19nZXQodl9zdHIsdl9zcmNfcG9zICsgaSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0LCBjYW1sX2JhX3NldF8xXG4vL1dlYWtkZWZcbi8vV2lsbCBiZSBkZWZpbmVkIGluIEJhc2VcbmZ1bmN0aW9uIGJpZ3N0cmluZ19ibGl0X2J5dGVzX2JpZ3N0cmluZ19zdHViKHZfc3RyLCB2X3NyY19wb3MsIHZfYnN0ciwgdl9kc3RfcG9zLCB2X2xlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykgY2FtbF9iYV9zZXRfMSh2X2JzdHIsdl9kc3RfcG9zICsgaSxjYW1sX2J5dGVzX2dldCh2X3N0cix2X3NyY19wb3MgKyBpKSk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YlxudmFyIGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nID0gYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfYmFfc2V0XzFcbi8vV2Vha2RlZlxuLy9XaWxsIGJlIGRlZmluZWQgaW4gQmFzZVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfc3R1YihzMSwgaTEsIHMyLCBpMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgY2FtbF9iYV9zZXRfMShzMixpMiArIGksY2FtbF9iYV9nZXRfMShzMSxpMSArIGkpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19tZW1jbXBfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuLy9XZWFrZGVmXG4vL1dpbGwgYmUgZGVmaW5lZCBpbiBCYXNlXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtY21wX3N0dWIodl9zMSwgdl9zMV9wb3MsIHZfczIsIHZfczJfcG9zLCB2X2xlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMSh2X3MxLHZfczFfcG9zICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHZfczIsdl9zMl9wb3MgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZmluZFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuLy9XZWFrZGVmXG4vL1dpbGwgYmUgZGVmaW5lZCBpbiBCYXNlXG5mdW5jdGlvbiBiaWdzdHJpbmdfZmluZChicywgY2hyLCBwb3MsIGxlbil7XG4gIHdoaWxlKGxlbiA+IDApe1xuICAgIGlmKGNhbWxfYmFfZ2V0XzEoYnMscG9zKSA9PSBjaHIpIHJldHVybiBwb3M7XG4gICAgcG9zKys7XG4gICAgbGVuLS07XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vanNfb2Zfb2NhbWwgbGliXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlclxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vanNfb2Zfb2NhbWwgbGliXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyKGFiKSB7XG4gIHZhciB0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGFiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX2Zyb20odGEsIG51bGwsIDAsIDEyLCAwLCBbdGEubGVuZ3RoXSlcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfc3RyaW5nX2FycihoLGJzLmRhdGEpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfcHVyZV9leHByIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX3B1cmVfZXhwciAoZikgeyByZXR1cm4gZigpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLGYsdikgeyBvW2ZdPXY7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gbyBpbnN0YW5jZW9mIGM7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc190eXBlb2YgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190eXBlb2YobykgeyByZXR1cm4gdHlwZW9mIG87IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICBqb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3I/am9vX2dsb2JhbF9vYmplY3QubmF2aWdhdG9yLnVzZXJBZ2VudDpcIlwiO1xuICByZXR1cm4gdWEuaW5kZXhPZihcIk1TSUVcIikgIT0gLTEgJiYgdWEuaW5kZXhPZihcIk9wZXJhXCIpICE9IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lc2NhcGUgY29uc3QgKGNvbnN0KVxudmFyIGNhbWxfanNfcmVnZXhwcyA9IHsgYW1wOi8mL2csIGx0Oi88L2csIHF1b3Q6L1xcXCIvZywgYWxsOi9bJjxcXFwiXS8gfTtcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lc2NhcGUgKHMpIHtcbiAgaWYgKCFjYW1sX2pzX3JlZ2V4cHMuYWxsLnRlc3QocykpIHJldHVybiBzO1xuICByZXR1cm4gcy5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5hbXAsIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMubHQsIFwiJmx0O1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5xdW90LCBcIiZxdW90O1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VudGl0aWVzIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gIHRlbXAuaW5uZXJIVE1MPSBzO1xuICBzdHI9IHRlbXAudGV4dENvbnRlbnQgfHwgdGVtcC5pbm5lclRleHQ7XG4gIHRlbXA9bnVsbDtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLy8vLy8vLy8vLy8gRGVidWdnaW5nIGNvbnNvbGVcbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGU/am9vX2dsb2JhbF9vYmplY3QuY29uc29sZTp7fTtcbiAgdmFyIG0gPSBbXCJsb2dcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiwgXCJhc3NlcnRcIiwgXCJkaXJcIiwgXCJkaXJ4bWxcIixcbiAgICAgICAgICAgXCJ0cmFjZVwiLCBcImdyb3VwXCIsIFwiZ3JvdXBDb2xsYXBzZWRcIiwgXCJncm91cEVuZFwiLCBcInRpbWVcIiwgXCJ0aW1lRW5kXCJdO1xuICBmdW5jdGlvbiBmICgpIHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgaWYgKCFjW21baV1dKSBjW21baV1dPWY7XG4gIHJldHVybiBjO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZVxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lKHJlcykge1xuICB2YXIgYyA9IDE7XG4gIHdoaWxlKHJlcyAmJiByZXMuam9vX3RyYW1wKXtcbiAgICByZXMgPSByZXMuam9vX3RyYW1wLmFwcGx5KG51bGwsIHJlcy5qb29fYXJncyk7XG4gICAgYysrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lX3JldHVyblxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lX3JldHVybihmLGFyZ3MpIHtcbiAgcmV0dXJuIHtqb29fdHJhbXA6Zixqb29fYXJnczphcmdzfTtcbn1cblxuLy9Qcm92aWRlczoganNfcHJpbnRfc3Rkb3V0IChjb25zdClcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZG91dChzKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZG91dC53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAgJiYgdi5sb2cgJiYgdi5sb2cocyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZGVyciAoY29uc3QpXG5mdW5jdGlvbiBqc19wcmludF9zdGRlcnIocykge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRlcnIud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgJiYgdi5lcnJvciAmJiB2LmVycm9yKHMpO1xuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIElvXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICBkZWxldGUgY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9zdGRfb3V0cHV0KGNoYW5pZCxzKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBzdHIgPSBjYW1sX25ld19zdHJpbmcocyk7XG4gIHZhciBzbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgc3RyLCAwLCBzbGVuKTtcbiAgY2hhbi5vZmZzZXQgKz0gc2xlbjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcyxNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnIsIGpzX3ByaW50X3N0ZG91dFxuLy9SZXF1aXJlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChpZHgsb3V0cHV0LGZpbGUsZmxhZ3MpIHtcbiAgaWYoY2FtbF9nbG9iYWxfZGF0YS5mZHMgPT09IHVuZGVmaW5lZCkgY2FtbF9nbG9iYWxfZGF0YS5mZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmxhZ3M9ZmxhZ3M/ZmxhZ3M6e307XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8uZmlsZSA9IGZpbGU7XG4gIGluZm8ub2Zmc2V0ID0gZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MDtcbiAgaW5mby5mbGFncyA9IGZsYWdzO1xuICBpbmZvLm91dHB1dCA9IG91dHB1dDtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbaWR4XSA9IGluZm87XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4IHx8IGlkeCA+IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHgpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCA9IGlkeDtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lLnRvU3RyaW5nKCkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lLnRvU3RyaW5nKCkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LGYpO1xuICB2YXIgaWR4ID0gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeD9jYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4OjA7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChpZHgrMSxjYW1sX3N0ZF9vdXRwdXQsZmlsZSxmKTtcbn1cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMCxjYW1sX3N0ZF9vdXRwdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkaW5cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMSxqc19wcmludF9zdGRvdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3Rkb3V0XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDIsanNfcHJpbnRfc3RkZXJyLCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGVyclxuXG5cbi8vIG9jYW1sIENoYW5uZWxzXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lKCkge1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dF9jaGFubmVsc19saXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX291dF9jaGFubmVsc19saXN0ICgpIHtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGMgPSAwOyBjIDwgY2FtbF9tbF9jaGFubmVscy5sZW5ndGg7IGMrKyl7XG4gICAgaWYoY2FtbF9tbF9jaGFubmVsc1tjXSAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm9wZW5lZCAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm91dClcbiAgICAgIGw9WzAsY2FtbF9tbF9jaGFubmVsc1tjXS5mZCxsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQgKGZkKSB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLnJkb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyByZWFkb25seVwiKTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDp0cnVlLFxuICAgIGJ1ZmZlcjpcIlwiXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3lzX29wZW4sY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIChmZCkgIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3Mud3Jvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHdyaXRlb25seVwiKTtcblxuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICByZWZpbGw6bnVsbFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdO1xuICBkYXRhLmZsYWdzLnRleHQgPSAhbW9kZVxuICBkYXRhLmZsYWdzLmJpbmFyeSA9IG1vZGVcbiAgcmV0dXJuIDA7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNoYW4ub3BlbmVkID0gZmFsc2U7XG4gIGNoYW4uZmlsZS5jbG9zZSgpO1xuICBjYW1sX3N5c19jbG9zZShjaGFuLmZkKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsKGNoYW5pZCxmKSB7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5yZWZpbGwgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbikge1xuICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgdmFyIHN0cl9sZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aChzdHIpO1xuICBpZiAoc3RyX2xlbiA9PSAwKSBjaGFuLnJlZmlsbCA9IG51bGw7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLmZpbGUubGVuZ3RoKCksIHN0ciwgMCwgc3RyX2xlbik7XG4gIHJldHVybiBzdHJfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsID09IG51bGwpIHJldHVybjtcbiAgaWYgKGNoYW4uZmlsZS5sZW5ndGgoKSAhPSBjaGFuLm9mZnNldCkgcmV0dXJuO1xuICBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIHMsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBsMiA9IGNoYW4uZmlsZS5sZW5ndGgoKSAtIGNoYW4ub2Zmc2V0O1xuICBpZiAobDIgPT0gMCAmJiBjaGFuLnJlZmlsbCAhPSBudWxsKSBsMiA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICBpZiAobDIgPCBsKSBsID0gbDI7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBzLCBpLCBsKTtcbiAgY2hhbi5vZmZzZXQgKz0gbDtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKDgpO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCw4KTtcblxuICAvLyBIZWFkZXIgaXMgMjAgYnl0ZXNcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKGJ1ZiwgMCkgKyAyMDtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcblxuICB2YXIgb2Zmc2V0ID0gWzBdO1xuICB2YXIgcmVzID0gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhidWYsIG9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0ID0gY2hhbi5vZmZzZXQgKyBvZmZzZXRbMF07XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIGlmIChjaGFuLm9mZnNldCA+PSBjaGFuLmZpbGUubGVuZ3RoKCkpXG4gICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgcmVzID0gY2hhbi5maWxlLnJlYWRfb25lKGNoYW4ub2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQrKztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZmlsZSA9IGNoYW4uZmlsZTtcbiAgd2hpbGUgKChjaGFuLm9mZnNldCArIDMpID49IGZpbGUubGVuZ3RoKCkpIHtcbiAgICB2YXIgbCA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICAgIGlmIChsID09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfVxuICB2YXIgbyA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgciA9KGZpbGUucmVhZF9vbmUobyAgKSA8PCAyNClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMSkgPDwgMTYpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzIpIDw8IDgpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzMpKTtcbiAgY2hhbi5vZmZzZXQrPTQ7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luXzY0KGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbihjaGFuaWQpIHtyZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luXzY0KGNoYW5pZCkge3JldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X3NjYW5fbGluZShjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIHZhciBwID0gY2hhbi5vZmZzZXQ7XG4gIHZhciBsZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKHAgPj0gbGVuKSB7IHJldHVybiAwO31cbiAgd2hpbGUodHJ1ZSkge1xuICAgIGlmKHAgPj0gbGVuKSByZXR1cm4gLSAocCAtIGNoYW4ub2Zmc2V0KTtcbiAgICBpZihjaGFuLmZpbGUucmVhZF9vbmUocCkgPT0gMTApIHJldHVybiBwIC0gY2hhbi5vZmZzZXQgKyAxO1xuICAgIHArKztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBmbHVzaCBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICBpZighY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXIgPT0gXCJcIikgcmV0dXJuIDA7XG4gIGlmKGNoYW4uZmRcbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF1cbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dDtcbiAgICBzd2l0Y2gob3V0cHV0Lmxlbmd0aCl7XG4gICAgY2FzZSAyOiBvdXRwdXQoY2hhbmlkLGNoYW4uYnVmZmVyKTticmVhaztcbiAgICBkZWZhdWx0OiBvdXRwdXQoY2hhbi5idWZmZXIpXG4gICAgfTtcbiAgfVxuICBjaGFuLmJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3Qgb3V0cHV0IHRvIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIHZhciBzdHJpbmc7XG4gIGlmKG9mZnNldCA9PSAwICYmIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ1ZmZlcikgPT0gbGVuKVxuICAgIHN0cmluZyA9IGJ1ZmZlcjtcbiAgZWxzZSB7XG4gICAgc3RyaW5nID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXMoYnVmZmVyLG9mZnNldCxzdHJpbmcsMCxsZW4pO1xuICB9XG4gIHZhciBqc3N0cmluZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoc3RyaW5nKTtcbiAgdmFyIGlkID0ganNzdHJpbmcubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gIGlmKGlkIDwgMClcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmc7XG4gIGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZy5zdWJzdHIoMCxpZCsxKTtcbiAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGNoYW4uYnVmZmVyICs9IGpzc3RyaW5nLnN1YnN0cihpZCsxKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dChjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pe1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX25ld19zdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nLCBjYW1sX21sX291dHB1dCxjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlIChjaGFuaWQsdixfZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtyZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXRfNjQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0IChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyXG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBNbEJ5dGVzUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sQnl0ZXNSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX25ld19zdHJpbmcodGhpcy5zLnN1YnN0cmluZyhpLCBpICsgbGVuKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogQmlnU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gQmlnU3RyaW5nUmVhZGVyIChicywgaSkgeyB0aGlzLnMgPSBiczsgdGhpcy5pID0gaTsgfVxuQmlnU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgOCkgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDI0ID4+IDE2KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpICAgICAgICAgKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdmFyIGFyciA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKXtcbiAgICAgIGFycltqXSA9IGNhbWxfYmFfZ2V0XzEodGhpcy5zLCBpK2opO1xuICAgIH1cbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICB9XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKGEpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoY2FtbF9pbnQ2NF9vZl9ieXRlcyAoYSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXNSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbEJ5dGVzUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXNSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sQnl0ZXNSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcblxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcykge1xuICB2YXIgX21hZ2ljID0gcmVhZGVyLnJlYWQzMnUgKClcbiAgdmFyIF9ibG9ja19sZW4gPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIG51bV9vYmplY3RzID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV8zMiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfNjQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gKG51bV9vYmplY3RzID4gMCk/W106bnVsbDtcbiAgdmFyIG9ial9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gaW50ZXJuX3JlYyAoKSB7XG4gICAgdmFyIGNvZGUgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgIGlmIChjb2RlID49IDB4NDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovKSB7XG4gICAgICBpZiAoY29kZSA+PSAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovKSB7XG4gICAgICAgIHZhciB0YWcgPSBjb2RlICYgMHhGO1xuICAgICAgICB2YXIgc2l6ZSA9IChjb2RlID4+IDQpICYgMHg3O1xuICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gKGNvZGUgJiAweDNGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvZGUgPj0gMHgyMC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcgKi8pIHtcbiAgICAgICAgdmFyIGxlbiA9IGNvZGUgJiAweDFGO1xuICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDAwOiAvL2NzdC5DT0RFX0lOVDg6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkOHMgKCk7XG4gICAgICAgIGNhc2UgMHgwMTogLy9jc3QuQ09ERV9JTlQxNjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQxNnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMjogLy9jc3QuQ09ERV9JTlQzMjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMzogLy9jc3QuQ09ERV9JTlQ2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGludGVnZXIgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDQ6IC8vY3N0LkNPREVfU0hBUkVEODpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNTogLy9jc3QuQ09ERV9TSEFSRUQxNjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQxNnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDY6IC8vY3N0LkNPREVfU0hBUkVEMzI6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA4OiAvL2NzdC5DT0RFX0JMT0NLMzI6XG4gICAgICAgICAgdmFyIGhlYWRlciA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHZhciB0YWcgPSBoZWFkZXIgJiAweEZGO1xuICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyID4+IDEwO1xuICAgICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMzogLy9jc3QuQ09ERV9CTE9DSzY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGRhdGEgYmxvY2sgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDk6IC8vY3N0LkNPREVfU1RSSU5HODpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEE6IC8vY3N0LkNPREVfU1RSSU5HMzI6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQzogLy9jc3QuQ09ERV9ET1VCTEVfTElUVExFOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbNyAtIGldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBCOiAvL2NzdC5DT0RFX0RPVUJMRV9CSUc6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFtpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRTogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBEOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MDc6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBGOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEwOiAvL2NzdC5DT0RFX0NPREVQT0lOVEVSOlxuICAgICAgICBjYXNlIDB4MTE6IC8vY3N0LkNPREVfSU5GSVhQT0lOVEVSOlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGNvZGUgcG9pbnRlclwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEyOiAvL2NzdC5DT0RFX0NVU1RPTTpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICBzd2l0Y2gocykge1xuICAgICAgICAgIGNhc2UgXCJfalwiOlxuICAgICAgICAgICAgLy8gSW50NjRcbiAgICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZhciB2ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIFwiX2lcIjpcbiAgICAgICAgICAgIC8vIEludDMyXG4gICAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgY2FzZSBcIl9uXCI6XG4gICAgICAgICAgICAvLyBOYXRpdmVpbnRcbiAgICAgICAgICAgIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IG5hdGl2ZSBpbnRlZ2VyIHZhbHVlIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB1bmtub3duIGN1c3RvbSBibG9jayBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMgKCk7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNpemUgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBkID0gdi5sZW5ndGg7XG4gICAgaWYgKGQgPCBzaXplKSBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgIHZbZF0gPSBpbnRlcm5fcmVjICgpO1xuICB9XG4gIGlmICh0eXBlb2Ygb2ZzIT1cIm51bWJlclwiKSBvZnNbMF0gPSByZWFkZXIuaTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICBmdW5jdGlvbiBnZXQzMihzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSA8PCAyNCkgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDIpIDw8IDgpIHxcbiAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIH1cbiAgaWYgKGdldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGdldDMyKHMsIG9mcyArIDQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIGZpbmFsaXplOmZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCAweDg0OTVBNkJFKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLmJsb2NrX2xlbik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfNjQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2h1bms7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGZ1bmN0aW9uIGV4dGVybl9yZWMgKHYpIHtcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgICAgaWYgKHZbMF0gPT0gMjU1KSB7XG4gICAgICAgICAgLy8gSW50NjRcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHdyaXRlci53cml0ZSAoOCwgXCJfalxcMFwiLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHdyaXRlci53cml0ZSAoOCwgYltpXSk7XG4gICAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gNDtcbiAgICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAzO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIE1sQnl0ZXMpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLiBJdCBzZWVtcyBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiK3R5cGVfb2ZfditcIilcIik7XG4gICAgICAgICAgLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgLy8gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBCIC8qY3N0LkNPREVfRE9VQkxFX0JJRyovKTtcbiAgICAgICAgICAvLyAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFtpXSl9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgd3JpdGVyLmZpbmFsaXplICgpO1xuICAgIHJldHVybiB3cml0ZXIuY2h1bms7XG4gIH1cbn0gKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgKHYsIF9mbCkge1xuICAvKiBpZ25vcmVzIGZsYWdzLi4uICovXG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzICh2LCBfZmwpIHtcbiAgLyogaWdub3JlcyBmbGFncy4uLiAqL1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodikpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9ibGl0X2J5dGVzXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIgKHMsIG9mcywgbGVuLCB2LCBfZmwpIHtcbiAgLyogaWdub3JlcyBmbGFncy4uLiAqL1xuICB2YXIgdCA9IGNhbWxfb3V0cHV0X3ZhbCAodik7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliOiBjb2RlIHNwZWNpZmljIHRvIEpzX29mX29jYW1sXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9ib29sKHgpIHsgcmV0dXJuICEheDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYm9vbCh4KSB7IHJldHVybiAreDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9mbG9hdCh4KSB7IHJldHVybiB4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9zdHJpbmcocykgeyByZXR1cm4gcy50b1N0cmluZygpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbi8vUmVxdWlyZXM6IHJhd19hcnJheV9zdWJcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9hcnJheShhKSB7IHJldHVybiByYXdfYXJyYXlfc3ViKGEsMSxhLmxlbmd0aC0xKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuLy9SZXF1aXJlczogcmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkgeyByZXR1cm4gcmF3X2FycmF5X2NvbnMoYSwwKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IHgudG9TdHJpbmcoKTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc192YXI6IFxcXCJcIiArIHggKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLlwiKTtcbiAgICAvL2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUuZXJyb3IoXCJKcy5VbnNhZmUuZXZhbF9zdHJpbmdcIilcbiAgfVxuICByZXR1cm4gZXZhbCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfY2FsbCAoY29uc3QsIG11dGFibGUsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfY2FsbChmLCBvLCBhcmdzKSB7IHJldHVybiBmLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuX2NhbGwgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2Z1bl9jYWxsKGYsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBmKCk7XG4gIGNhc2UgMjogcmV0dXJuIGYgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBmIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX21ldGhfY2FsbCAobXV0YWJsZSwgY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bZi50b1N0cmluZygpXS5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19uZXcgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX25ldyhjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2pzX25ld19hcnIgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX29qc19uZXdfYXJyKGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDA6IHJldHVybiBuZXcgYztcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGMgKGFbMF0pO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGEpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAwKXtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFt1bmRlZmluZWRdKTtcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1xuLy9SZXF1aXJlczogY2FtbF9qc193cmFwX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikoYXJndW1lbnRzKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihuID09IGFyaXR5KSByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmd1bWVudHMpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gJiYgaSA8IGFyaXR5OyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuLHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixyYXdfYXJyYXlfY29ucyhhcmd1bWVudHMsdGhpcykpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbixyYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3VtZW50c10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW4sIHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSkgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgcmF3X2FycmF5X2NvbnMoYXJndW1lbnRzLHRoaXMpKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbiAmJiBpIDw9IGFyaXR5OyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbixyYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZi5hcHBseShudWxsLCByYXdfYXJyYXlfY29ucyhhcmd1bWVudHMsdGhpcykpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgKHMpIHtyZXR1cm4gY2FtbF9uZXdfc3RyaW5nIChzKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKHMudG9TdHJpbmcoKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblwiKTtcbiAgcmV0dXJuIGV2YWwocy50b1N0cmluZygpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXCIpO1xuICByZXR1cm4gZXZhbChzLnRvU3RyaW5nKCkpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bcFsxXS50b1N0cmluZygpXSA9IHBbMl07XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHBvcnRfdmFyXG5mdW5jdGlvbiBjYW1sX2pzX2V4cG9ydF92YXIgKCl7XG4gIGlmKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHNcbiAgZWxzZVxuICAgIHJldHVybiBqb29fZ2xvYmFsX29iamVjdDtcbn1cbiIsIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc3RhdCgpIHtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc2V0XG5mdW5jdGlvbiBjYW1sX2djX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19nZXRcbmZ1bmN0aW9uIGNhbWxfZ2NfZ2V0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDBdXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUEksIGJ1dCB3aXRob3V0IHRoZSB3ZWFrIHNlbWFudGljc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9WZXJzaW9uOiA8IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gM1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NyZWF0ZSAobikge1xuICBpZiAobiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgdmFyIHggPSBbMjUxLFwiY2FtbF9lcGhlX2xpc3RfaGVhZFwiXTtcbiAgeC5sZW5ndGggPSBjYW1sX2VwaGVfa2V5X29mZnNldCArIG47XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfc2V0KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9rZXlcIik7XG4gIHJldHVybiAoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgXT09PXVuZGVmaW5lZCk/MDp4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXQsY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF93ZWFrX2dldCh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmICh6IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHopXTtcbiAgcmV0dXJuIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jaGVjayBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NoZWNrKHgsIGkpIHtcbiAgaWYoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldIT09dW5kZWZpbmVkICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSAhPT0wKVxuICAgIHJldHVybiAxO1xuICBlbHNlXG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIC8vIG1pbnVzIG9uZSBiZWNhdXNlIGNhbWxfYXJyYXlfYmxpdCB3b3JrcyBvbiBvY2FtbCBhcnJheVxuICBjYW1sX2FycmF5X2JsaXQoYTEsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTEgLSAxLFxuICAgICAgICAgICAgICAgICAgYTIsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTIgLSAxLFxuICAgICAgICAgICAgICAgICAgbGVuKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jcmVhdGVcbnZhciBjYW1sX2VwaGVfY3JlYXRlID0gY2FtbF93ZWFrX2NyZWF0ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19ibGl0XG52YXIgY2FtbF9lcGhlX2JsaXRfa2V5ID0gY2FtbF93ZWFrX2JsaXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRcbnZhciBjYW1sX2VwaGVfZ2V0X2tleSA9IGNhbWxfd2Vha19nZXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldF9jb3B5XG52YXIgY2FtbF9lcGhlX2dldF9rZXlfY29weSA9IGNhbWxfd2Vha19nZXRfY29weVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY2hlY2tcbnZhciBjYW1sX2VwaGVfY2hlY2tfa2V5ID0gY2FtbF93ZWFrX2NoZWNrXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2tleSh4LCBpLCB2KSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIFswLCB2XSlcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2tleSh4LCBpKSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIDApXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgZHN0W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0pXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2xleF9hcnJheVxuZnVuY3Rpb24gY2FtbF9wYXJzZV9lbmdpbmUodGFibGVzLCBlbnYsIGNtZCwgYXJnKVxue1xuICB2YXIgRVJSQ09ERSA9IDI1NjtcblxuICAvL3ZhciBTVEFSVCA9IDA7XG4gIC8vdmFyIFRPS0VOX1JFQUQgPSAxO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMSA9IDI7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8yID0gMztcbiAgLy92YXIgU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEID0gNDtcbiAgLy92YXIgRVJST1JfREVURUNURUQgPSA1O1xuICB2YXIgbG9vcCA9IDY7XG4gIHZhciB0ZXN0c2hpZnQgPSA3O1xuICB2YXIgc2hpZnQgPSA4O1xuICB2YXIgc2hpZnRfcmVjb3ZlciA9IDk7XG4gIHZhciByZWR1Y2UgPSAxMDtcblxuICB2YXIgUkVBRF9UT0tFTiA9IDA7XG4gIHZhciBSQUlTRV9QQVJTRV9FUlJPUiA9IDE7XG4gIHZhciBHUk9XX1NUQUNLU18xID0gMjtcbiAgdmFyIEdST1dfU1RBQ0tTXzIgPSAzO1xuICB2YXIgQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04gPSA0O1xuICB2YXIgQ0FMTF9FUlJPUl9GVU5DVElPTiA9IDU7XG5cbiAgdmFyIGVudl9zX3N0YWNrID0gMTtcbiAgdmFyIGVudl92X3N0YWNrID0gMjtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0X3N0YWNrID0gMztcbiAgdmFyIGVudl9zeW1iX2VuZF9zdGFjayA9IDQ7XG4gIHZhciBlbnZfc3RhY2tzaXplID0gNTtcbiAgdmFyIGVudl9zdGFja2Jhc2UgPSA2O1xuICB2YXIgZW52X2N1cnJfY2hhciA9IDc7XG4gIHZhciBlbnZfbHZhbCA9IDg7XG4gIHZhciBlbnZfc3ltYl9zdGFydCA9IDk7XG4gIHZhciBlbnZfc3ltYl9lbmQgPSAxMDtcbiAgdmFyIGVudl9hc3AgPSAxMTtcbiAgdmFyIGVudl9ydWxlX2xlbiA9IDEyO1xuICB2YXIgZW52X3J1bGVfbnVtYmVyID0gMTM7XG4gIHZhciBlbnZfc3AgPSAxNDtcbiAgdmFyIGVudl9zdGF0ZSA9IDE1O1xuICB2YXIgZW52X2VycmZsYWcgPSAxNjtcblxuICAvLyB2YXIgX3RibF9hY3Rpb25zID0gMTtcbiAgdmFyIHRibF90cmFuc2xfY29uc3QgPSAyO1xuICB2YXIgdGJsX3RyYW5zbF9ibG9jayA9IDM7XG4gIHZhciB0YmxfbGhzID0gNDtcbiAgdmFyIHRibF9sZW4gPSA1O1xuICB2YXIgdGJsX2RlZnJlZCA9IDY7XG4gIHZhciB0YmxfZGdvdG8gPSA3O1xuICB2YXIgdGJsX3NpbmRleCA9IDg7XG4gIHZhciB0YmxfcmluZGV4ID0gOTtcbiAgdmFyIHRibF9naW5kZXggPSAxMDtcbiAgdmFyIHRibF90YWJsZXNpemUgPSAxMTtcbiAgdmFyIHRibF90YWJsZSA9IDEyO1xuICB2YXIgdGJsX2NoZWNrID0gMTM7XG4gIC8vIHZhciBfdGJsX2Vycm9yX2Z1bmN0aW9uID0gMTQ7XG4gIC8vIHZhciBfdGJsX25hbWVzX2NvbnN0ID0gMTU7XG4gIC8vIHZhciBfdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cbiAgaWYgKCF0YWJsZXMuZGdvdG8pIHtcbiAgICB0YWJsZXMuZGVmcmVkID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGVmcmVkXSk7XG4gICAgdGFibGVzLnNpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3NpbmRleF0pO1xuICAgIHRhYmxlcy5jaGVjayAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9jaGVja10pO1xuICAgIHRhYmxlcy5yaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9yaW5kZXhdKTtcbiAgICB0YWJsZXMudGFibGUgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfdGFibGVdKTtcbiAgICB0YWJsZXMubGVuICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGVuXSk7XG4gICAgdGFibGVzLmxocyAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xoc10pO1xuICAgIHRhYmxlcy5naW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9naW5kZXhdKTtcbiAgICB0YWJsZXMuZGdvdG8gID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGdvdG9dKTtcbiAgfVxuXG4gIHZhciByZXMgPSAwLCBuLCBuMSwgbjIsIHN0YXRlMTtcblxuICAvLyBSRVNUT1JFXG4gIHZhciBzcCA9IGVudltlbnZfc3BdO1xuICB2YXIgc3RhdGUgPSBlbnZbZW52X3N0YXRlXTtcbiAgdmFyIGVycmZsYWcgPSBlbnZbZW52X2VycmZsYWddO1xuXG4gIGV4aXQ6Zm9yICg7Oykge1xuICAgIHN3aXRjaChjbWQpIHtcbiAgICBjYXNlIDA6Ly9TVEFSVDpcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGVycmZsYWcgPSAwO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDY6Ly9sb29wOlxuICAgICAgbiA9IHRhYmxlcy5kZWZyZWRbc3RhdGVdO1xuICAgICAgaWYgKG4gIT0gMCkgeyBjbWQgPSByZWR1Y2U7IGJyZWFrOyB9XG4gICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID49IDApIHsgY21kID0gdGVzdHNoaWZ0OyBicmVhazsgfVxuICAgICAgcmVzID0gUkVBRF9UT0tFTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgbGV4ZXIgYW5kIHVwZGF0ZXMgKi9cbiAgICAgIC8qIHN5bWJfc3RhcnQgYW5kIHN5bWJfZW5kICovXG4gICAgY2FzZSAxOi8vVE9LRU5fUkVBRDpcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9ibG9ja11bYXJnWzBdICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSBhcmdbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9jb25zdF1bYXJnICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGNtZCA9IHNoaWZ0X3JlY292ZXI7IGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3AgPD0gZW52W2Vudl9zdGFja2Jhc2VdKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgICAgIHNwLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID09IDApIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgODovL3NoaWZ0OlxuICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgOTovL3NoaWZ0X3JlY292ZXI6XG4gICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBzcCsrO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18xO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDI6Ly9TVEFDS1NfR1JPV05fMTpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9sdmFsXTtcbiAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9zdGFydF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF07XG4gICAgICBjbWQgPSBsb29wO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDEwOi8vcmVkdWNlOlxuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2UgY29uc3Rcbi8vRHVtbXkgZnVuY3Rpb24hXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoKSB7IHJldHVybiAwOyB9XG4iLCIvL1Byb3ZpZGVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF9nZXR0aW1lb2ZkYXkgKCkge1xuICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDA7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfdGltZVxuLy9SZXF1aXJlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfdGltZSAoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHVuaXhfZ2V0dGltZW9mZGF5ICgpKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIHVuaXhfZ210aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgcmV0dXJuIFswLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi9dXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gWzAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgZC5nZXREYXkoKSwgZG95LFxuICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovXVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X21rdGltZVxuLy9SZXF1aXJlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IHVuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gWzAsdCx0bTJdO1xufVxuXG4vL1Byb3ZpZGVzOiB3aW5fc3RhcnR1cCBjb25zdFxuZnVuY3Rpb24gd2luX3N0YXJ0dXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5fY2xlYW51cCBjb25zdFxuZnVuY3Rpb24gd2luX2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5faGFuZGxlX2ZkIGNvbnN0XG5mdW5jdGlvbiB3aW5faGFuZGxlX2ZkKHgpIHtyZXR1cm4geDt9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QobG9jLHNoYXBlKSB7XG4gIGZ1bmN0aW9uIHVuZGVmX21vZHVsZSAoX3gpIHtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJnKGNhbWxfZ2xvYmFsX2RhdGEuVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUsIGxvYyk7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcCAoc2hhcGUsc3RydWN0LGlkeCl7XG4gICAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgICAgc3dpdGNoKHNoYXBlKXtcbiAgICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgICAgIHN0cnVjdFtpZHhdPXtmdW46dW5kZWZfbW9kdWxlfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6Ly9sYXp5XG4gICAgICAgIHN0cnVjdFtpZHhdPVsyNDYsIHVuZGVmX21vZHVsZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDovL2Nhc2UgMjovL2NsYXNzXG4gICAgICAgIHN0cnVjdFtpZHhdPVtdO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgICBjYXNlIDA6Ly9tb2R1bGVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBbMF07XG4gICAgICAgIGZvcih2YXIgaT0xO2k8c2hhcGVbMV0ubGVuZ3RoO2krKylcbiAgICAgICAgICBsb29wKHNoYXBlWzFdW2ldLHN0cnVjdFtpZHhdLGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDE6Ly9WYWx1ZVxuICAgICAgICBzdHJ1Y3RbaWR4XSA9IHNoYXBlWzFdO1xuICAgICAgfVxuICB9XG4gIHZhciByZXMgPSBbXTtcbiAgbG9vcChzaGFwZSxyZXMsMCk7XG4gIHJldHVybiByZXNbMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlLHJlYWwseCkge1xuICBpZih0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpXG4gICAgc3dpdGNoKHNoYXBlKXtcbiAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgICAgcmVhbC5mdW4gPSB4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOi8vbGF6eVxuICAgIGRlZmF1bHQ6Ly9jYXNlIDI6Ly9jbGFzc1xuICAgICAgY2FtbF91cGRhdGVfZHVtbXkocmVhbCx4KTtcbiAgICB9XG4gIGVsc2VcbiAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgIGNhc2UgMDovL21vZHVsZVxuICAgICAgZm9yKHZhciBpPTE7aTxzaGFwZVsxXS5sZW5ndGg7aSsrKVxuICAgICAgICBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlWzFdW2ldLHJlYWxbaV0seFtpXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vY2FzZSAxOi8vVmFsdWVcbiAgICBkZWZhdWx0OlxuICAgIH07XG4gIHJldHVybiAwXG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UtMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX3N0cmluZyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsbnVsbCwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsbGVuKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBjaGFuX2xlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYobGVuPDApIGxlbiA9IGNoYW5fbGVuIC0gY2hhbi5vZmZzZXQ7XG4gIGlmKGNoYW4ub2Zmc2V0ICsgbGVuID4gY2hhbl9sZW4pIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG4gIHJldHVybiBjYW1sX21kNV9zdHJpbmcoYnVmLDAsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xudmFyIGNhbWxfbWQ1X3N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgc3dpdGNoIChzLnQgJiA2KSB7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgdmFyIGIgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9XG4gICAgICAgICAgYi5jaGFyQ29kZUF0KGopIHwgKGIuY2hhckNvZGVBdChqKzEpIDw8IDgpIHxcbiAgICAgICAgICAoYi5jaGFyQ29kZUF0KGorMikgPDwgMTYpIHwgKGIuY2hhckNvZGVBdChqKzMpIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBiLmNoYXJDb2RlQXQoaSArIG9mcykgPDwgKDggKiAoaSAmIDMpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPSBhW2pdIHwgKGFbaisxXSA8PCA4KSB8IChhW2orMl0gPDwgMTYpIHwgKGFbaiszXSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYVtpICsgb2ZzXSA8PCAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkobWQ1KGJ1ZiwgbGVuKSk7XG4gIH1cbn0gKCk7XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IGxleF9yZWZpbGwgcmVhZF9mdW4gYXV4X2J1ZmZlciBsZXhidWYgPVxuICBsZXQgcmVhZCA9XG4gICAgcmVhZF9mdW4gYXV4X2J1ZmZlciAoQnl0ZXMubGVuZ3RoIGF1eF9idWZmZXIpIGluXG4gIGxldCBuID1cbiAgICBpZiByZWFkID4gMFxuICAgIHRoZW4gcmVhZFxuICAgIGVsc2UgKGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZTsgMCkgaW5cbiAgKCogQ3VycmVudCBzdGF0ZSBvZiB0aGUgYnVmZmVyOlxuICAgICAgICA8LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0+XG4gICAgICAgIHwgIGp1bmsgfCAgICAgIHZhbGlkIGRhdGEgICAgIHwgICBqdW5rICAgIHxcbiAgICAgICAgXiAgICAgICBeICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgXlxuICAgICAgICAwICAgIHN0YXJ0X3BvcyAgICAgICAgICAgICBidWZmZXJfZW5kICAgIEJ5dGVzLmxlbmd0aCBidWZmZXJcbiAgKilcbiAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuICsgbiA+IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlciB0aGVuIGJlZ2luXG4gICAgKCogVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG5cbiAgICAgICA8PSBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXJcbiAgICB0aGVuIGJlZ2luXG4gICAgICAoKiBCdXQgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGlmIHdlIHJlY2xhaW0gdGhlIGp1bmsgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgb2YgdGhlIGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbGV4YnVmLmxleF9idWZmZXIgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBXZSBtdXN0IGdyb3cgdGhlIGJ1ZmZlci4gIERvdWJsaW5nIGl0cyBzaXplIHdpbGwgcHJvdmlkZSBlbm91Z2hcbiAgICAgICAgIHNwYWNlIHNpbmNlIG4gPD0gU3RyaW5nLmxlbmd0aCBhdXhfYnVmZmVyIDw9IFN0cmluZy5sZW5ndGggYnVmZmVyLlxuICAgICAgICAgV2F0Y2ggb3V0IGZvciBzdHJpbmcgbGVuZ3RoIG92ZXJmbG93LCB0aG91Z2guICopXG4gICAgICBsZXQgbmV3bGVuID1cbiAgICAgICAgbWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCB3aXRoX3Bvc2l0aW9ucyBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3NcblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBsZXQgbGVuID0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3MgbGVuXG5cbmxldCBzdWJfbGV4ZW1lIGxleGJ1ZiBpMSBpMiA9XG4gIGxldCBsZW4gPSBpMi1pMSBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlblxuXG5sZXQgc3ViX2xleGVtZV9vcHQgbGV4YnVmIGkxIGkyID1cbiAgaWYgaTEgPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IGxlbiA9IGkyLWkxIGluXG4gICAgU29tZSAoQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW4pXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTm9uZVxuICBlbmRcblxubGV0IHN1Yl9sZXhlbWVfY2hhciBsZXhidWYgaSA9IEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXJfb3B0IGxleGJ1ZiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBTb21lIChCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaSlcbiAgZWxzZVxuICAgIE5vbmVcblxuXG5sZXQgbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPVxuICBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgKGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgaSlcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3AucG9zX2NudW1cbmxldCBsZXhlbWVfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19jbnVtXG5cbmxldCBsZXhlbWVfc3RhcnRfcCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3BcbmxldCBsZXhlbWVfZW5kX3AgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3BcblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxldCBsY3AgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgICAgeyBsY3Agd2l0aFxuICAgICAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgICAgIHBvc19ib2wgPSBsY3AucG9zX2NudW07XG4gICAgICB9XG5cblxuXG4oKiBEaXNjYXJkIGRhdGEgbGVmdCBpbiBsZXhlciBidWZmZXIuICopXG5cbmxldCBmbHVzaF9pbnB1dCBsYiA9XG4gIGxiLmxleF9jdXJyX3BvcyA8LSAwO1xuICBsYi5sZXhfYWJzX3BvcyA8LSAwO1xuICBsZXQgbGNwID0gbGIubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsYi5sZXhfY3Vycl9wIDwtIHt6ZXJvX3BvcyB3aXRoIHBvc19mbmFtZSA9IGxjcC5wb3NfZm5hbWV9O1xuICBsYi5sZXhfYnVmZmVyX2xlbiA8LSAwO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAoKiBUb29scyB0byBtYW5pcHVsYXRlIHNjYW5uaW5nIHNldCBvZiBjaGFycyAoc2VlICVbLi4uXSkgKilcblxudHlwZSBtdXRhYmxlX2NoYXJfc2V0ID0gYnl0ZXNcblxuKCogQ3JlYXRlIGEgZnJlc2gsIGVtcHR5LCBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGNyZWF0ZV9jaGFyX3NldCAoKSA9IEJ5dGVzLm1ha2UgMzIgJ1xcMDAwJ1xuXG4oKiBBZGQgYSBjaGFyIGluIGEgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICBCeXRlcy5zZXQgY2hhcl9zZXQgc3RyX2luZFxuICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKEJ5dGVzLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsb3IgbWFzaykpXG5cbmxldCBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBCeXRlcy50b19zdHJpbmcgY2hhcl9zZXRcblxuKCogQ29tcHV0ZSB0aGUgY29tcGxlbWVudCBvZiBhIGNoYXIgc2V0LiAqKVxubGV0IHJldl9jaGFyX3NldCBjaGFyX3NldCA9XG4gIGxldCBjaGFyX3NldCcgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIDMxIGRvXG4gICAgQnl0ZXMuc2V0IGNoYXJfc2V0JyBpXG4gICAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IGkpIGx4b3IgMHhGRikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNoYXJfc2V0J1xuXG4oKiBSZXR1cm4gdHJ1ZSBpZiBhIGBjJyBpcyBpbiBgY2hhcl9zZXQnLiAqKVxubGV0IGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxhbmQgbWFzaykgPD4gMFxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogSWdub3JlZCBwYXJhbSBjb252ZXJzaW9uICopXG5cbigqIEdBRFQgdXNlZCB0byBhYnN0cmFjdCBhbiBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlci4gKilcbigqIFNlZSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiID0gUGFyYW1fZm9ybWF0X0VCQiA6XG4gICAgKCd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiXG5cbigqIENvbXB1dGUgYSBwYWRkaW5nIGFzc29jaWF0ZWQgdG8gYSBwYWRfb3B0aW9uIChzZWUgXCIlXzQyZFwiKS4gKilcbmxldCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wYWRkaW5nXG4gIHwgU29tZSB3aWR0aCAtPiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuXG4oKiBDb21wdXRlIGEgcHJlY2lzaW9uIGFzc29jaWF0ZWQgdG8gYSBwcmVjX29wdGlvbiAoc2VlIFwiJV8uNDJmXCIpLiAqKVxubGV0IHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQgPSBtYXRjaCBwcmVjX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wcmVjaXNpb25cbiAgfCBTb21lIG5kZWMgLT4gTGl0X3ByZWNpc2lvbiBuZGVjXG5cbigqIFR1cm4gYW4gaWdub3JlZCBwYXJhbSBpbnRvIGl0cyBlcXVpdmFsZW50IG5vdC1pZ25vcmVkIGZvcm1hdCBub2RlLiAqKVxuKCogVXNlZCBmb3IgZm9ybWF0IHByZXR0eS1wcmludGluZyBhbmQgU2NhbmYuICopXG5sZXQgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+ICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYXJhbV9mb3JtYXRfZWJiID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2hhciBmbXQpXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX2NoYXIgZm10KVxuICB8IElnbm9yZWRfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDMyIChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50MzIgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChOYXRpdmVpbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQ2NCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDY0IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfZmxvYXQgKHBhZF9vcHQsIHByZWNfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGbG9hdCAoRmxvYXRfZiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Jvb2wgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEJvb2wgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChSZWFkZXIgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10KVxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlcyAqKVxuXG50eXBlICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlbiA9XG4gIHwgQWNjX29wZW5fdGFnIG9mICgnYiwgJ2MpIGFjY1xuICB8IEFjY19vcGVuX2JveCBvZiAoJ2IsICdjKSBhY2NcblxuKCogUmV2ZXJzZWQgbGlzdCBvZiBwcmludGluZyBhdG9tcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBwcmludGYgYXJndW1lbnRzLiAqKVxuYW5kICgnYiwgJ2MpIGFjYyA9XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IG9mICgnYiwgJ2MpIGFjYyAqIGZvcm1hdHRpbmdfbGl0XG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gb2YgKCdiLCAnYykgYWNjICogKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuXG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBMaXRlcmFsIHN0cmluZyAqKVxuICB8IEFjY19jaGFyX2xpdGVyYWwgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIExpdGVyYWwgY2hhciAqKVxuICB8IEFjY19kYXRhX3N0cmluZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIEdlbmVyYXRlZCBzdHJpbmcgKilcbiAgfCBBY2NfZGF0YV9jaGFyICAgICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBHZW5lcmF0ZWQgY2hhciAqKVxuICB8IEFjY19kZWxheSAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IgLT4gJ2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBEZWxheWVkIHByaW50aW5nICglYSwgJXQpICopXG4gIHwgQWNjX2ZsdXNoICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAgICAgICAgICAgICAgKCogRmx1c2ggKilcbiAgfCBBY2NfaW52YWxpZF9hcmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nXG4gICAgICAoKiBSYWlzZSBJbnZhbGlkX2FyZ3VtZW50IG1zZyAqKVxuICB8IEVuZF9vZl9hY2NcblxuKCogTGlzdCBvZiBoZXRlcm9nZW5lb3VzIHZhbHVlcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBzY2FuZiBjYWxsYmFjayBhcmd1bWVudHMuICopXG50eXBlICgnYSwgJ2IpIGhldGVyX2xpc3QgPVxuICB8IENvbnMgOiAnYyAqICgnYSwgJ2IpIGhldGVyX2xpc3QgLT4gKCdjIC0+ICdhLCAnYikgaGV0ZXJfbGlzdFxuICB8IE5pbCA6ICgnYiwgJ2IpIGhldGVyX2xpc3RcblxuKCogRXhpc3RlbnRpYWwgQmxhY2sgQm94ZXMuICopXG4oKiBVc2VkIHRvIGFic3RyYWN0IHNvbWUgZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRkaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmIgPSBQYWRkaW5nX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRwcmVjIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmIgPSBQYWRwcmVjX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICd6KSBwcmVjaXNpb24gKiAoJ3osICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZGRpbmdfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiID0gUGFkZGluZ19mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwYWRkaW5nICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wcmVjaXNpb25fZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmIgPSBQcmVjaXNpb25fZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkcHJlY19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmIgPSBQYWRwcmVjX2ZtdF9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAncCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgdGhlICdhIGFuZCAnZCBwYXJhbWV0ZXJzIG9mIGFuIGZtdC4gKilcbigqIE91dHB1dCB0eXBlIG9mIHRoZSBmb3JtYXQgcGFyc2luZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiID0gRm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2Zvcm1hdF9nZW4gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiID0gRm10X2ZtdHR5X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXQgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYiA9IEZtdHR5X2ZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10dHkgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10X2ZtdHR5X2ViYiAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgZm10dHkgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIGZvcm1hdCB0eXBlcy4gKilcbnR5cGUgZm10dHlfZWJiID0gRm10dHlfRUJCIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+IGZtdHR5X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcGFkZGluZyB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcGFkZGluZ3MuICopXG50eXBlIHBhZGRpbmdfZWJiID0gUGFkZGluZ19FQkIgOiAoJ2EsICdiKSBwYWRkaW5nIC0+IHBhZGRpbmdfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwcmVjaXNpb24gdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHByZWNpc2lvbnMuICopXG50eXBlIHByZWNpc2lvbl9lYmIgPSBQcmVjaXNpb25fRUJCIDogKCdhLCAnYikgcHJlY2lzaW9uIC0+IHByZWNpc2lvbl9lYmJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb25zdGFudHMgKilcblxuKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIGZsb2F0IHByaW50aW5nLiAqKVxubGV0IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uID0gLTZcbiAgKCogRm9yICVoIGFuZCAlSCBmb3JtYXRzLCBhIG5lZ2F0aXZlIHByZWNpc2lvbiBtZWFucyBcImFzIG1hbnkgZGlnaXRzIGFzXG4gICAgIG5lY2Vzc2FyeVwiLiAgRm9yIHRoZSBvdGhlciBGUCBmb3JtYXRzLCB3ZSB0YWtlIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgICBvZiB0aGUgcHJlY2lzaW9uLCBoZW5jZSA2IGRpZ2l0cyBieSBkZWZhdWx0LiAqKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEV4dGVybmFscyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQ6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDMyOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfbmF0aXZlaW50OiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ2NDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuZXh0ZXJuYWwgaGV4c3RyaW5nX29mX2Zsb2F0OiBmbG9hdCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0XCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICgqIFRvb2xzIHRvIHByZXR0eS1wcmludCBmb3JtYXRzICopXG5cbigqIFR5cGUgb2YgZXh0ZW5zaWJsZSBjaGFyYWN0ZXIgYnVmZmVycy4gKilcbnR5cGUgYnVmZmVyID0ge1xuICBtdXRhYmxlIGluZCA6IGludDtcbiAgbXV0YWJsZSBieXRlcyA6IGJ5dGVzO1xufVxuXG4oKiBDcmVhdGUgYSBmcmVzaCBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NyZWF0ZSBpbml0X3NpemUgPSB7IGluZCA9IDA7IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGluaXRfc2l6ZSB9XG5cbigqIENoZWNrIHNpemUgb2YgdGhlIGJ1ZmZlciBhbmQgZ3JvdyBpdCBpZiBuZWVkZWQuICopXG5sZXQgYnVmZmVyX2NoZWNrX3NpemUgYnVmIG92ZXJoZWFkID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYuYnl0ZXMgaW5cbiAgbGV0IG1pbl9sZW4gPSBidWYuaW5kICsgb3ZlcmhlYWQgaW5cbiAgaWYgbWluX2xlbiA+IGxlbiB0aGVuIChcbiAgICBsZXQgbmV3X2xlbiA9IG1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIHwgSW50X0NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpXG4gIHwgSW50X0NpIC0+ICdpJyB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vXG4gIHwgSW50X0NvIC0+ICdvJyB8IEludF91IHwgSW50X0N1IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfZmNvbnYgZmNvbnYgPSBtYXRjaCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiB8IEZsb2F0X3BmIHwgRmxvYXRfc2YgLT4gJ2YnIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2UgLT4gJ2UnXG4gIHwgRmxvYXRfRSB8IEZsb2F0X3BFIHwgRmxvYXRfc0UgLT4gJ0UnIHwgRmxvYXRfZyB8IEZsb2F0X3BnIHwgRmxvYXRfc2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyB8IEZsb2F0X3BHIHwgRmxvYXRfc0cgLT4gJ0cnIHwgRmxvYXRfRiAtPiAnRidcbiAgfCBGbG9hdF9oIHwgRmxvYXRfcGggfCBGbG9hdF9zaCAtPiAnaCcgfCBGbG9hdF9IIHwgRmxvYXRfcEggfCBGbG9hdF9zSCAtPiAnSCdcblxuXG4oKiBDb252ZXJ0IGEgc2Nhbm5pbmcgY291bnRlciB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfY291bnRlciBjb3VudGVyID0gbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyICAtPiAnbCdcbiAgfCBDaGFyX2NvdW50ZXIgIC0+ICduJ1xuICB8IFRva2VuX2NvdW50ZXIgLT4gJ04nXG5cbigqKiopXG5cbigqIFByaW50IGEgY2hhcl9zZXQgaW4gYSBidWZmZXIgd2l0aCB0aGUgT0NhbWwgZm9ybWF0IGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0ID1cbiAgbGV0IHJlYyBwcmludF9zdGFydCBzZXQgPVxuICAgIGxldCBpc19hbG9uZSBjID1cbiAgICAgIGxldCBiZWZvcmUsIGFmdGVyID0gQ2hhci4oY2hyIChjb2RlIGMgLSAxKSwgY2hyIChjb2RlIGMgKyAxKSkgaW5cbiAgICAgIGlzX2luX2NoYXJfc2V0IHNldCBjXG4gICAgICAmJiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCBiZWZvcmUgJiYgaXNfaW5fY2hhcl9zZXQgc2V0IGFmdGVyKSBpblxuICAgIGlmIGlzX2Fsb25lICddJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nO1xuICAgIHByaW50X291dCBzZXQgMTtcbiAgICBpZiBpc19hbG9uZSAnLScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICctJztcbiAgYW5kIHByaW50X291dCBzZXQgaSA9XG4gICAgaWYgaSA8IDI1NiB0aGVuXG4gICAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW4gcHJpbnRfZmlyc3Qgc2V0IGlcbiAgICAgIGVsc2UgcHJpbnRfb3V0IHNldCAoaSArIDEpXG4gIGFuZCBwcmludF9maXJzdCBzZXQgaSA9XG4gICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnXFwyNTUnIC0+IHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICB8ICddJyB8ICctJyAtPiBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgfCBfIC0+IHByaW50X3NlY29uZCBzZXQgKGkgKyAxKTtcbiAgYW5kIHByaW50X3NlY29uZCBzZXQgaSA9XG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuXG4gICAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICAgIHwgJ1xcMjU1JyAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTQ7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICAgIHwgJ10nIHwgJy0nIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgICB8IF8gd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAyKTtcbiAgICAgIHwgXyAtPlxuICAgICAgICBwcmludF9pbiBzZXQgKGkgLSAxKSAoaSArIDIpO1xuICAgIGVsc2UgKFxuICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICApXG4gIGFuZCBwcmludF9pbiBzZXQgaSBqID1cbiAgICBpZiBqID0gMjU2IHx8IG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBqKSkgdGhlbiAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGludF9vZl9jaGFyICctJyk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaiAtIDEpO1xuICAgICAgaWYgaiA8IDI1NiB0aGVuIHByaW50X291dCBzZXQgKGogKyAxKTtcbiAgICApIGVsc2VcbiAgICAgIHByaW50X2luIHNldCBpIChqICsgMSk7XG4gIGFuZCBwcmludF9jaGFyIGJ1ZiBpID0gbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnJScgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIHwgJ0AnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICdAJztcbiAgICB8IGMgICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGluXG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1snO1xuICBwcmludF9zdGFydCAoXG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgJ1xcMDAwJ1xuICAgIHRoZW4gKCBidWZmZXJfYWRkX2NoYXIgYnVmICdeJzsgcmV2X2NoYXJfc2V0IGNoYXJfc2V0IClcbiAgICBlbHNlIGNoYXJfc2V0XG4gICk7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nXG5cbigqKiopXG5cbigqIFByaW50IGEgcGFkdHkgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWR0eSBidWYgcGFkdHkgPSBtYXRjaCBwYWR0eSB3aXRoXG4gIHwgTGVmdCAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSdcbiAgfCBSaWdodCAtPiAoKVxuICB8IFplcm9zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJzAnXG5cbigqIFByaW50IHRoZSAnXycgb2YgYW4gaWdub3JlZCBmbGFnIGlmIG5lZWRlZC4gKilcbmxldCBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZyA9XG4gIGlmIGlnbl9mbGFnIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXydcblxuKCoqKilcblxubGV0IGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgd2lkdGggLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHdpZHRoKVxuXG4oKioqKVxuXG4oKiBQcmludCBwYWRkaW5nIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkZGluZyA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwYWRkaW5nIC0+IHVuaXQgPVxuZnVuIGJ1ZiBwYWQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+ICgpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCBuKSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcqJ1xuXG4oKiBQcmludCBwcmVjaXNpb24gaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wcmVjaXNpb24gOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcHJlY2lzaW9uIC0+IHVuaXQgPVxuICBmdW4gYnVmIHByZWMgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uIC0+ICgpXG4gIHwgTGl0X3ByZWNpc2lvbiBuIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wcmVjaXNpb24gLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIuKlwiXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBvciAnIycgYXNzb2NpYXRlZCB0byBhbiBpbnQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X3BkIHwgSW50X3BpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgSW50X3NkIHwgSW50X3NpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgSW50X0N4IHwgSW50X0NYIHwgSW50X0NvIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEludF9kIHwgSW50X2kgfCBJbnRfeCB8IEludF9YIHwgSW50X28gfCBJbnRfdSAtPiAoKVxuXG4oKiBQcmludCBhbiBjb21wbGV0ZSBpbnQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlMy4qZFwiKS4gKilcbmxldCBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycgYXNzb2NpYXRlZCB0byBhIGZsb2F0IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252ID0gbWF0Y2ggZmNvbnYgd2l0aFxuICB8IEZsb2F0X3BmIHwgRmxvYXRfcGUgfCBGbG9hdF9wRVxuICB8IEZsb2F0X3BnIHwgRmxvYXRfcEcgfCBGbG9hdF9waCB8IEZsb2F0X3BIIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBGbG9hdF9zZiB8IEZsb2F0X3NlIHwgRmxvYXRfc0VcbiAgfCBGbG9hdF9zZyB8IEZsb2F0X3NHIHwgRmxvYXRfc2ggfCBGbG9hdF9zSCAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FXG4gIHwgRmxvYXRfZyB8IEZsb2F0X0cgfCBGbG9hdF9GIHwgRmxvYXRfaCB8IEZsb2F0X0ggLT5cbiAgICAoKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZsb2F0IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJSsqLjNmXCIpLiAqKVxubGV0IGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfZmNvbnYgZmNvbnYpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZm9ybWF0dGluZ19saXQuICopXG4oKiBBbHNvIHVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQgPSBtYXRjaCBmb3JtYXR0aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgLT4gXCJAXVwiXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgLT4gXCJAfVwiXG4gIHwgQnJlYWsgKHN0ciwgXywgXykgICAgLT4gc3RyXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgLT4gXCJAP1wiXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgLT4gXCJAXFxuXCJcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAtPiBcIkAuXCJcbiAgfCBNYWdpY19zaXplIChzdHIsIF8pICAtPiBzdHJcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAtPiBcIkBAXCJcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAtPiBcIkAlXCJcbiAgfCBTY2FuX2luZGljIGMgLT4gXCJAXCIgXiAoU3RyaW5nLm1ha2UgMSBjKVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZvcm1hdHRpbmcuICopXG4oKiBBbHNvIHVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT4gc3RyaW5nID1cbiAgZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChfLCBzdHIpKSAtPiBzdHJcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChfLCBzdHIpKSAtPiBzdHJcblxuKCoqKilcblxuKCogUHJpbnQgYSBsaXRlcmFsIGNoYXIgaW4gYSBidWZmZXIsIGVzY2FwZSAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNociA9IG1hdGNoIGNociB3aXRoXG4gIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUlXCJcbiAgfCBfIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgY2hyXG5cbigqIFByaW50IGEgbGl0ZXJhbCBzdHJpbmcgaW4gYSBidWZmZXIsIGVzY2FwZSBhbGwgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0ciA9XG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBzdHIuW2ldXG4gIGRvbmVcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHByZXR0eS1wcmludGluZyAqKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCB0eXBlIChhbiBmbXR0eSkgaW4gYSBidWZmZXIuICopXG5sZXQgcmVjIGJwcmludF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAgIGJ1ZmZlciAtPiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IHVuaXQgPVxuZnVuIGJ1ZiBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlc1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludF90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVpXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbmlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDY0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVMaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWZcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBCb29sX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlQlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFscGhhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVhXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXRcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlP1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFJlYWRlcl90eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVyXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJV9yXCI7XG4gICAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV7XCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV9XCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eSwgXywgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKFwiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBFbmRfb2ZfZm10dHkgLT4gKClcblxuKCoqKilcblxubGV0IHJlYyBpbnRfb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSBhIGIgYyAuXG4gIChhLCBiLCBjKSBjdXN0b21fYXJpdHkgLT4gaW50ID1cbiAgZnVuY3Rpb25cbiAgfCBDdXN0b21femVybyAtPiAwXG4gIHwgQ3VzdG9tX3N1Y2MgeCAtPiAxICsgaW50X29mX2N1c3RvbV9hcml0eSB4XG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9mbXQgYnVmIGZtdCA9XG4gIGxldCByZWMgZm10aXRlciA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBib29sIC0+IHVuaXQgPVxuICBmdW4gZm10IGlnbl9mbGFnIC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ24nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ0wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdjJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdCJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2EnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICd0JzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgIGZvciBfaSA9IDEgdG8gaW50X29mX2N1c3RvbV9hcml0eSBhcml0eSBkb1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJz8nO1xuICAgICAgZG9uZTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFJlYWRlciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdyJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSFcIjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3snO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ30nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICcoJztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICcpJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiB3aWR0aF9vcHQ7IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQ7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIpO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIjBjXCI7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgICAgZm10aXRlciBmbXQnIHRydWU7XG5cbiAgICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQpO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiQHtcIjtcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRW5kX29mX2Zvcm1hdCAtPiAoKVxuXG4gIGluIGZtdGl0ZXIgZm10IGZhbHNlXG5cbigqKiopXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdG8gc3RyaW5nLiAqKVxubGV0IHN0cmluZ19vZl9mbXQgZm10ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdCBidWYgZm10O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGUgZXh0cmFjdGlvbiAqKVxuXG50eXBlIChfLCBfKSBlcSA9IFJlZmwgOiAoJ2EsICdhKSBlcVxuXG4oKiBJbnZhcmlhbnQ6IHRoaXMgZnVuY3Rpb24gaXMgdGhlIGlkZW50aXR5IG9uIHZhbHVlcy5cblxuICAgSW4gcGFydGljdWxhciwgaWYgKHR5MSwgdHkyKSBoYXZlIGVxdWFsIHZhbHVlcywgdGhlblxuICAgKHRyYW5zIChzeW1tIHR5MSkgdHkyKSByZXNwZWN0cyB0aGUgJ3RyYW5zJyBwcmVjb25kaXRpb24uICopXG5sZXQgcmVjIHN5bW0gOiB0eXBlIGExIGIxIGMxIGQxIGUxIGYxIGEyIGIyIGMyIGQyIGUyIGYyIC5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10dHlfcmVsXG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+IENoYXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPiBJbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+IEludDMyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPiBJbnQ2NF90eSAoc3ltbSByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IE5hdGl2ZWludF90eSAoc3ltbSByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT4gRmxvYXRfdHkgKHN5bW0gcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT4gQm9vbF90eSAoc3ltbSByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+IFN0cmluZ190eSAoc3ltbSByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT4gVGhldGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+IEFscGhhX3R5IChzeW1tIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT4gQW55X3R5IChzeW1tIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT4gUmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPiBJZ25vcmVkX3JlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MiwgdHkxLCBzeW1tIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG5sZXQgcmVjIGZtdHR5X3JlbF9kZXQgOiB0eXBlIGExIGIgYyBkMSBlMSBmMSBhMiBkMiBlMiBmMiAuXG4gIChhMSwgYiwgYywgZDEsIGUxLCBmMSxcbiAgIGEyLCBiLCBjLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoKGYxLCBmMikgZXEgLT4gKGExLCBhMikgZXEpXG4gICogKChhMSwgYTIpIGVxIC0+IChmMSwgZjIpIGVxKVxuICAqICgoZTEsIGUyKSBlcSAtPiAoZDEsIGQyKSBlcSlcbiAgKiAoKGQxLCBkMikgZXEgLT4gKGUxLCBlMikgZXEpXG49IGZ1bmN0aW9uXG4gIHwgRW5kX29mX2ZtdHR5IC0+XG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcblxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IEZvcm1hdF9hcmdfdHkgKF90eSwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGxldCBhZywgZ2EsIGRqLCBqZCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIGxldCBSZWZsID0gYWcgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBnYSBSZWZsIGluIGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIGxldCBSZWZsID0gZGogUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBqZCBSZWZsIGluIGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuXG4oKiBQcmVjb25kaXRpb246IHdlIGFzc3VtZSB0aGF0IHRoZSB0d28gZm10dHlfcmVsIGFyZ3VtZW50cyBoYXZlIGVxdWFsXG4gICB2YWx1ZXMgKGF0IHBvc3NpYmx5IGRpc3RpbmN0IHR5cGVzKTsgdGhpcyBpbnZhcmlhbnQgY29tZXMgZnJvbSB0aGUgd2F5XG4gICBmbXR0eV9yZWwgd2l0bmVzc2VzIGFyZSBwcm9kdWNlZCBieSB0aGUgdHlwZS1jaGVja2VyXG5cbiAgIFRoZSBjb2RlIGJlbG93IHVzZXMgKGFzc2VydCBmYWxzZSkgd2hlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuLiBUaGVcbiAgIGNvZGUgcGF0dGVybiBpcyB0aGUgZm9sbG93aW5nOlxuXG4gICAgIHwgRm9vIHgsIEZvbyB5IC0+XG4gICAgICAgKCogY2FzZSB3aGVyZSBpbmRlZWQgYm90aCB2YWx1ZXNcbiAgICAgICAgICBzdGFydCB3aXRoIGNvbnN0cnVjdG9yIEZvbyAqKVxuICAgICB8IEZvbyBfLCBfXG4gICAgIHwgXywgRm9vIF8gLT5cbiAgICAgICAoKiBkaWZmZXJlbnQgaGVhZCBjb25zdHJ1Y3RvcnM6IGJyb2tlbiBwcmVjb25kaXRpb24gKilcbiAgICAgICBhc3NlcnQgZmFsc2VcbiopXG5hbmQgdHJhbnMgOiB0eXBlXG4gIGExIGIxIGMxIGQxIGUxIGYxXG4gIGEyIGIyIGMyIGQyIGUyIGYyXG4gIGEzIGIzIGMzIGQzIGUzIGYzXG4uXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG49IGZ1biB0eTEgdHkyIC0+IG1hdGNoIHR5MSwgdHkyIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QxLCBDaGFyX3R5IHJlc3QyIC0+IENoYXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFN0cmluZ190eSByZXN0MSwgU3RyaW5nX3R5IHJlc3QyIC0+IFN0cmluZ190eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQm9vbF90eSByZXN0MSwgQm9vbF90eSByZXN0MiAtPiBCb29sX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnRfdHkgcmVzdDEsIEludF90eSByZXN0MiAtPiBJbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDMyX3R5IHJlc3QxLCBJbnQzMl90eSByZXN0MiAtPiBJbnQzMl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50NjRfdHkgcmVzdDEsIEludDY0X3R5IHJlc3QyIC0+IEludDY0X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdDEsIE5hdGl2ZWludF90eSByZXN0MiAtPiBOYXRpdmVpbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZsb2F0X3R5IHJlc3QxLCBGbG9hdF90eSByZXN0MiAtPiBGbG9hdF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG5cbiAgfCBBbHBoYV90eSByZXN0MSwgQWxwaGFfdHkgcmVzdDIgLT4gQWxwaGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFscGhhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQWxwaGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFRoZXRhX3R5IHJlc3QxLCBUaGV0YV90eSByZXN0MiAtPiBUaGV0YV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgVGhldGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBUaGV0YV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgQW55X3R5IHJlc3QxLCBBbnlfdHkgcmVzdDIgLT4gQW55X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbnlfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbnlfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFJlYWRlcl90eSByZXN0MSwgUmVhZGVyX3R5IHJlc3QyIC0+IFJlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgUmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgUmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MSwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDIgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBJZ25vcmVkX3JlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X2FyZ190eSAodHkxLCByZXN0MSksIEZvcm1hdF9hcmdfdHkgKHR5MiwgcmVzdDIpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHJhbnMgdHkxIHR5MiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X2FyZ190eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9hcmdfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkxMiwgcmVzdDEpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyMSwgdHkyMiwgcmVzdDIpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxMikgdHkyMSBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTIyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfc3Vic3RfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEVuZF9vZl9mbXR0eSwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuICB8IEVuZF9vZl9mbXR0eSwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBFbmRfb2ZfZm10dHkgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCByZWMgZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogRXh0cmFjdCB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiAoYW4gZm10dHkpIG9mIGEgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcblxuICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50MzJfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKE5hdGl2ZWludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQ2NF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChGbG9hdF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcblxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgICAgICAgICAgIC0+XG4gICAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZvcm0gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgaWYgZmNvbnYgPSBGbG9hdF9GIHRoZW4gXCIlLjEyZ1wiIGVsc2VcbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbmxldCB0cmFuc2Zvcm1faW50X2FsdCBpY29udiBzID1cbiAgbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgIGxldCBkaWdpdHMgPVxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgfCAnMCcuLic5JyAtPiBpbmNyIG5cbiAgICAgICAgfCBfIC0+ICgpXG4gICAgICBkb25lO1xuICAgICAgIW5cbiAgICBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIChkaWdpdHMgLSAxKSAvIDMpIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgbGV0IHB1dCBjID0gQnl0ZXMuc2V0IGJ1ZiAhcG9zIGM7IGluY3IgcG9zIGluXG4gICAgbGV0IGxlZnQgPSByZWYgKChkaWdpdHMgLSAxKSBtb2QgMyArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICcwJy4uJzknIGFzIGMgLT5cbiAgICAgICAgICBpZiAhbGVmdCA9IDAgdGhlbiAocHV0ICdfJzsgbGVmdCA6PSAzKTsgZGVjciBsZWZ0OyBwdXQgY1xuICAgICAgfCBjIC0+IHB1dCBjXG4gICAgZG9uZTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZlxuICB8IF8gLT4gc1xuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgY29udmVyc2lvbi4gKilcbmxldCBjb252ZXJ0X2ludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQgKGZvcm1hdF9vZl9pY29udiBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDMyIChmb3JtYXRfb2ZfaWNvbnZsIGljb252KSBuKVxubGV0IGNvbnZlcnRfbmF0aXZlaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDY0IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDY0IChmb3JtYXRfb2ZfaWNvbnZMIGljb252KSBuKVxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbWF0Y2ggZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggLT5cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X3BoIHwgRmxvYXRfcEggLT4gJysnXG4gICAgICB8IEZsb2F0X3NoIHwgRmxvYXRfc0ggLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgbGV0IHN0ciA9IGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICAgIGJlZ2luIG1hdGNoIGZjb252IHdpdGhcbiAgICB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgc3RyXG4gICAgfCBfIC0+IHN0clxuICAgIGVuZFxuICB8IF8gLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGlmIGZjb252IDw+IEZsb2F0X0YgdGhlbiBzdHIgZWxzZVxuICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+XG4gICAgICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIlxuICAgICAgfCBGUF9pbmZpbml0ZSAtPlxuICAgICAgICBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgICAgfCBGUF9uYW4gLT4gXCJuYW5cIlxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2NhbWxfY2hhciBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ190b19jYW1sX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50IGljb252XG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9uYXRpdmVpbnQgaWNvbnZcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50NjQgaWNvbnZcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ19vZl9ib29sXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIGZ1biBmIHggLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGZ1biBvIC0+IGYgbyB4KSkgcmVzdFxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBmdW4gZiAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgKCkpXG4gIHwgUmVhZGVyIF8gLT5cbiAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICopXG4gICAgKCogSW5kZWVkLCBzaW5jZSBwcmludGYgYW5kIGNvLiB0YWtlIGEgZm9ybWF0NCBhcyBhcmd1bWVudCwgdGhlICdkIGFuZCAnZVxuICAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiBmbXQgYXJlIG9idmlvdXNseSBlcXVhbHMuIFRoZSBSZWFkZXIgaXMgdGhlXG4gICAgICAgb25seSBjb25zdHJ1Y3RvciB3aGljaCB0b3VjaCAnZCBhbmQgJ2UgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBmb3JtYXRcbiAgICAgICB0eXBlLCBpdCBhZGRzIGFuICgtPikgdG8gdGhlICdkIHBhcmFtZXRlcnMuIENvbnNlcXVlbnRseSwgYSBmb3JtYXQ0XG4gICAgICAgY2Fubm90IGNvbnRhaW4gYSBSZWFkZXIgbm9kZSwgZXhjZXB0IGluIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG9cbiAgICAgICBhbiAley4uLiV9LiBJdCdzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSBtYWtlX3ByaW50ZiBkbyBub3QgY2FsbFxuICAgICAgIGl0c2VsZiByZWN1cnNpdmVseSBvbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvICV7Li4uJX0uICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mbHVzaCBhY2MpIHJlc3RcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfY2hhcl9saXRlcmFsIChhY2MsIGNocikpIHJlc3RcblxuICB8IEZvcm1hdF9hcmcgKF8sIHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSBzdHJpbmdfb2ZfZm10dHkgc3ViX2ZtdHR5IGluXG4gICAgKGZ1biBzdHIgLT5cbiAgICAgIGlnbm9yZSBzdHI7XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHkpKSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+IG1ha2VfcHJpbnRmIGsgYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICgqIFRoaXMgY2FzZSBzaG91bGQgYmUgcmVmdXNlZCBmb3IgUHJpbnRmLiAqKVxuICAgICgqIEFjY2VwdGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiAqKVxuICAgICgqIEludGVycHJldCAlbCwgJW4gYW5kICVMIGFzICV1LiAqKVxuICAgIGZ1biBuIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfaW50IFwiJXVcIiBuKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgYWNjIGlnbiByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19saXQgKGFjYywgZm10aW5nX2xpdCkpIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl9ib3gga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIGFjY1xuXG4oKiBEZWxheSB0aGUgZXJyb3IgKEludmFsaWRfYXJndW1lbnQgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpLiAqKVxuKCogR2VuZXJhdGUgZnVuY3Rpb25zIHRvIHRha2UgcmVtYWluaW5nIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIFwiJV9cIikuICopXG5hbmQgbWFrZV9pZ25vcmVkX3BhcmFtIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgZm10dHkgZm10XG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcblxuXG4oKiBTcGVjaWFsIGNhc2Ugb2YgcHJpbnRmIFwiJV8oXCIuICopXG5hbmQgbWFrZV9mcm9tX2ZtdHR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIChBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpKSBmbXRcblxuKCogRml4IHBhZGRpbmcsIHRha2UgaXQgYXMgYW4gZXh0cmEgaW50ZWdlciBhcmd1bWVudCBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9wYWRkaW5nIDogdHlwZSB4IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCB0cmFucyAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHJhbnMgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcblxuKCogRml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBmb3IgaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0LiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyB0cmFucyBpY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gdHJhbnMgaWNvbnYgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuXG4oKiBDb252ZXJ0IGEgZmxvYXQsIGZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gaWYgbmVlZGVkLiAqKVxuKCogVGFrZSB0aGUgZmxvYXQgYXJndW1lbnQgYW5kIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgZmNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24geCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbmFuZCBtYWtlX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgYWNjIHJlc3QgYXJpdHkgZiAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuICBmdW4gayBvIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBDYW1sX3N0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBCb29sIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyByZXN0IGFyaXR5XG4gICAgfCBSZWFkZXIgXyAtPlxuICAgICAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICBTZWUgdGhlXG4gICAgICAgICAgIG5vdGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FzZSBmb3IgbWFrZV9wcmludGYuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+XG4gICAgICAgICAgbWFrZV9pcHJpbnRmIGsgb1xuICAgICAgICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG4gICAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pZ25vcmVkX3BhcmFtIChmdW4gXyAtPiBrIG8pIChFbmRfb2ZfYWNjKSBpZ24gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgICAgIGsgb1xuYW5kIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIDpcbiAgdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT5cbiAgc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHkgPVxuICBmdW4gayBvIGZtdCAtPiBmdW5jdGlvblxuICAgIHwgQ3VzdG9tX3plcm8gLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyBmbXRcbiAgICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgICAgIGNvbnN0IChmbl9vZl9jdXN0b21fYXJpdHkgayBvIGZtdCBhcml0eSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29udGludWF0aW9ucyBmb3IgbWFrZV9wcmludGYgKilcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBvIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQHtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQFtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X2NoYXIgbyBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmIG9cbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGZsdXNoIG9cbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBvIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIGJ1ZnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBmIGJcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IGJ1ZnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBidWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiAlYSBhbmQgJXQuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiAoKSlcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEVycm9yIG1hbmFnZW1lbnQgKilcblxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBwcmV0dHktcHJpbnRlZCBlcnJvciBtZXNzYWdlLiAqKVxubGV0IGZhaWx3aXRoX21lc3NhZ2UgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGsgYWNjID0gc3RycHV0X2FjYyBidWYgYWNjOyBmYWlsd2l0aCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdHRpbmcgdG9vbHMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhbiBvcGVuIGJsb2NrIGRlc2NyaXB0aW9uIChpbmRlbnQsIGJsb2NrX3R5cGUpICopXG5sZXQgb3Blbl9ib3hfb2Zfc3RyaW5nIHN0ciA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiAoMCwgUHBfYm94KSBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IGludmFsaWRfYm94ICgpID0gZmFpbHdpdGhfbWVzc2FnZSBcImludmFsaWQgYm94IGRlc2NyaXB0aW9uICVTXCIgc3RyIGluXG4gICAgbGV0IHJlYyBwYXJzZV9zcGFjZXMgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIC0+IHBhcnNlX3NwYWNlcyAoaSArIDEpXG4gICAgICAgIHwgXyAtPiBpXG4gICAgYW5kIHBhcnNlX2x3b3JkIGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICdhJyAuLiAneicgLT4gcGFyc2VfbHdvcmQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqXG4gICAgYW5kIHBhcnNlX2ludCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IHBhcnNlX2ludCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGogaW5cbiAgICBsZXQgd3N0YXJ0ID0gcGFyc2Vfc3BhY2VzIDAgaW5cbiAgICBsZXQgd2VuZCA9IHBhcnNlX2x3b3JkIHdzdGFydCB3c3RhcnQgaW5cbiAgICBsZXQgYm94X25hbWUgPSBTdHJpbmcuc3ViIHN0ciB3c3RhcnQgKHdlbmQgLSB3c3RhcnQpIGluXG4gICAgbGV0IG5zdGFydCA9IHBhcnNlX3NwYWNlcyB3ZW5kIGluXG4gICAgbGV0IG5lbmQgPSBwYXJzZV9pbnQgbnN0YXJ0IG5zdGFydCBpblxuICAgIGxldCBpbmRlbnQgPVxuICAgICAgaWYgbnN0YXJ0ID0gbmVuZCB0aGVuIDAgZWxzZVxuICAgICAgICB0cnkgaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiBzdHIgbnN0YXJ0IChuZW5kIC0gbnN0YXJ0KSlcbiAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICBsZXQgZXhwX2VuZCA9IHBhcnNlX3NwYWNlcyBuZW5kIGluXG4gICAgaWYgZXhwX2VuZCA8PiBsZW4gdGhlbiBpbnZhbGlkX2JveCAoKTtcbiAgICBsZXQgYm94X3R5cGUgPSBtYXRjaCBib3hfbmFtZSB3aXRoXG4gICAgICB8IFwiXCIgfCBcImJcIiAtPiBQcF9ib3hcbiAgICAgIHwgXCJoXCIgICAgICAtPiBQcF9oYm94XG4gICAgICB8IFwidlwiICAgICAgLT4gUHBfdmJveFxuICAgICAgfCBcImh2XCIgICAgIC0+IFBwX2h2Ym94XG4gICAgICB8IFwiaG92XCIgICAgLT4gUHBfaG92Ym94XG4gICAgICB8IF8gICAgICAgIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgKGluZGVudCwgYm94X3R5cGUpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUGFyc2luZyB0b29scyAqKVxuXG4oKiBDcmVhdGUgYSBwYWRkaW5nX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcgYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZGRpbmdfZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcGFkZGluZ19mbXRfZWJiID1cbmZ1biBwYWQgZm10IC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoTm9fcGFkZGluZywgZm10KVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRkaW5nX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgZm10KVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIGZtdClcblxuKCogQ3JlYXRlIGEgcHJlY2lzaW9uX2ZtdF9lYmIgZnJvbSBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wcmVjaXNpb25fZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcHJlY2lzaW9uIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwcmVjaXNpb25fZm10X2ViYiA9XG5mdW4gcHJlYyBmbXQgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uICAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChOb19wcmVjaXNpb24sIGZtdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKExpdF9wcmVjaXNpb24gcCwgZm10KVxuICB8IEFyZ19wcmVjaXNpb24gICAtPiBQcmVjaXNpb25fZm10X0VCQiAoQXJnX3ByZWNpc2lvbiwgZm10KVxuXG4oKiBDcmVhdGUgYSBwYWRwcmVjX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgYW5kIHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnRzXG4gICBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkcHJlY19mbXRfZWJiIDogdHlwZSB4IHkgeiB0IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+XG4gICAgKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgIChfLCBfLCBfLCBfLCBfKSBwYWRwcmVjX2ZtdF9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdCAtPlxuICBsZXQgUHJlY2lzaW9uX2ZtdF9FQkIgKHByZWMsIGZtdCcpID0gbWFrZV9wcmVjaXNpb25fZm10X2ViYiBwcmVjIGZtdCBpblxuICBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIHByZWMsIGZtdCcpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZHByZWNfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBwcmVjLCBmbXQnKVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIHByZWMsIGZtdCcpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwYXJzaW5nICopXG5cbigqIFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGZvcm1hdCBhbmQgY3JlYXRlIGEgZm10X2ViYi4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSBpbiBjYXNlIG9mIGludmFsaWQgZm9ybWF0LiAqKVxubGV0IGZtdF9lYmJfb2Zfc3RyaW5nID9sZWdhY3lfYmVoYXZpb3Igc3RyID1cbiAgKCogUGFyYW1ldGVycyBuYW1pbmcgY29udmVudGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gbGl0X3N0YXJ0OiBzdGFydCBvZiB0aGUgbGl0ZXJhbCBzZXF1ZW5jZS4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzdHJfaW5kOiBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGVuZF9pbmQ6IGVuZCBvZiB0aGUgY3VycmVudCAoc3ViLSlmb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcGN0X2luZDogaW5kZXggb2YgdGhlICclJyBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICopXG4gICgqICAgLSB6ZXJvOiAgaXMgdGhlICcwJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIG1pbnVzOiBpcyB0aGUgJy0nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGx1czogIGlzIHRoZSAnKycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBoYXNoOiAgaXMgdGhlICcjJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHNwYWNlOiBpcyB0aGUgJyAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaWduOiAgIGlzIHRoZSAnXycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwYWQ6IHBhZGRpbmcgb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHByZWM6IHByZWNpc2lvbiBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3ltYjogY2hhciByZXByZXNlbnRpbmcgdGhlIGNvbnZlcnNpb24gKCdjJywgJ3MnLCAnZCcsIC4uLikuICopXG4gICgqICAgLSBjaGFyX3NldDogc2V0IG9mIGNoYXJhY3RlcnMgYXMgYml0bWFwIChzZWUgc2NhbmYgJVsuLi5dKS4gICAgKilcblxuICBsZXQgbGVnYWN5X2JlaGF2aW9yID0gbWF0Y2ggbGVnYWN5X2JlaGF2aW9yIHdpdGhcbiAgICB8IFNvbWUgZmxhZyAtPiBmbGFnXG4gICAgfCBOb25lIC0+IHRydWVcbiAgKCogIFdoZW4gdGhpcyBmbGFnIGlzIGVuYWJsZWQsIHRoZSBmb3JtYXQgcGFyc2VyIHRyaWVzIHRvIGJlaGF2ZSBhc1xuICAgICAgdGhlIDw0LjAyIGltcGxlbWVudGF0aW9ucywgaW4gcGFydGljdWxhciBpdCBpZ25vcmVzIG1vc3QgYmVuaW5lXG4gICAgICBub25zZW5zaWNhbCBmb3JtYXQuIFdoZW4gdGhlIGZsYWcgaXMgZGlzYWJsZWQsIGl0IHdpbGwgcmVqZWN0IGFueVxuICAgICAgZm9ybWF0IHRoYXQgaXMgbm90IGFjY2VwdGVkIGJ5IHRoZSBzcGVjaWZpY2F0aW9uLlxuXG4gICAgICBBIHR5cGljYWwgZXhhbXBsZSB3b3VsZCBiZSBcIiUrIGRcIjogc3BlY2lmeWluZyBib3RoICcrJyAoaWYgdGhlXG4gICAgICBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoIGEgJysnIHRvIGdldCB0aGUgc2FtZSB3aWR0aCBhc1xuICAgICAgbmVnYXRpdmUgbnVtYmVycykgYW5kICcgJyAoaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGhcbiAgICAgIGEgc3BhY2UpIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIGJ1dCB0aGUgbGVnYWN5ICg8IDQuMDIpXG4gICAgICBpbXBsZW1lbnRhdGlvbiB3YXMgaGFwcHkgdG8ganVzdCBpZ25vcmUgdGhlIHNwYWNlLlxuICAqKVxuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZCBtc2cgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIG1zZ1xuICBpblxuXG4gICgqIFVzZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBmb3JtYXQgKG9yIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXQpIHdhcyBlbmNvdW50ZXJlZFxuICAgICAgdW5leHBlY3RlZGx5LiAqKVxuICBsZXQgdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2UgZW5kX2luZFxuICAgICAgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmb3JtYXRcIlxuICBpblxuXG4gICgqIFVzZWQgZm9yICUwYzogbm8gb3RoZXIgd2lkdGhzIGFyZSBpbXBsZW1lbnRlZCAqKVxuICBsZXQgaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kXG4gICAgICBcIm5vbi16ZXJvIHdpZHRocyBhcmUgdW5zdXBwb3J0ZWQgZm9yICVjIGNvbnZlcnNpb25zXCJcbiAgaW5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIG9wdGlvbiBkZXBlbmRlbmN5XG4gICAgIHByb2JsZW0uICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IHN0cl9pbmQgYyBzID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAnJWMnIHdpdGhvdXQgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgYyBzXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIHVuZXhwZWN0ZWRcbiAgICAgY2hhcmFjdGVyLiAqKVxuICBsZXQgZXhwZWN0ZWRfY2hhcmFjdGVyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZCA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlcyBleHBlY3RlZCwgcmVhZCAlQ1wiXG4gICAgICBzdHIgc3RyX2luZCBleHBlY3RlZCByZWFkXG4gIGluXG5cbiAgKCogUGFyc2UgdGhlIHN0cmluZyBmcm9tIGJlZ19pbmQgKGluY2x1ZGVkKSB0byBlbmRfaW5kIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgcGFyc2UgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gYmVnX2luZCBlbmRfaW5kIC0+IHBhcnNlX2xpdGVyYWwgYmVnX2luZCBiZWdfaW5kIGVuZF9pbmRcblxuICAoKiBSZWFkIGxpdGVyYWwgY2hhcmFjdGVycyB1cCB0byAnJScgb3IgJ0AnIHNwZWNpYWwgY2hhcmFjdGVycy4gKilcbiAgYW5kIHBhcnNlX2xpdGVyYWwgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIEVuZF9vZl9mb3JtYXQgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2Zvcm1hdCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfYWZ0ZXJfYXQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfbGl0ZXJhbCBsaXRfc3RhcnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgKCogUGFyc2UgYSBmb3JtYXQgYWZ0ZXIgJyUnICopXG4gIGFuZCBwYXJzZV9mb3JtYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBlbmRfaW5kIC0+IHBhcnNlX2lnbiBwY3RfaW5kIChwY3RfaW5kICsgMSkgZW5kX2luZFxuXG4gIGFuZCBwYXJzZV9pZ24gOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ18nIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgKHN0cl9pbmQrMSkgZW5kX2luZCB0cnVlXG4gICAgICB8IF8gLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgZmFsc2VcblxuICBhbmQgcGFyc2VfZmxhZ3MgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmJcbiAgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgaWduIC0+XG4gICAgbGV0IHplcm8gPSByZWYgZmFsc2UgYW5kIG1pbnVzID0gcmVmIGZhbHNlXG4gICAgYW5kIHBsdXMgPSByZWYgZmFsc2UgYW5kIHNwYWNlID0gcmVmIGZhbHNlXG4gICAgYW5kIGhhc2ggPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgc2V0X2ZsYWcgc3RyX2luZCBmbGFnID1cbiAgICAgICgqIGluIGxlZ2FjeSBtb2RlLCBkdXBsaWNhdGUgZmxhZ3MgYXJlIGFjY2VwdGVkICopXG4gICAgICBpZiAhZmxhZyAmJiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIGR1cGxpY2F0ZSBmbGFnICVDXCJcbiAgICAgICAgICBzdHIgc3RyX2luZCBzdHIuW3N0cl9pbmRdO1xuICAgICAgZmxhZyA6PSB0cnVlO1xuICAgIGluXG4gICAgbGV0IHJlYyByZWFkX2ZsYWdzIHN0cl9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnMCcgLT4gc2V0X2ZsYWcgc3RyX2luZCB6ZXJvOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICctJyAtPiBzZXRfZmxhZyBzdHJfaW5kIG1pbnVzOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJysnIC0+IHNldF9mbGFnIHN0cl9pbmQgcGx1czsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnIycgLT4gc2V0X2ZsYWcgc3RyX2luZCBoYXNoOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyAnIC0+IHNldF9mbGFnIHN0cl9pbmQgc3BhY2U7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmRcbiAgICAgICAgICAhemVybyAhbWludXMgIXBsdXMgIWhhc2ggIXNwYWNlIGlnblxuICAgICAgZW5kXG4gICAgaW5cbiAgICByZWFkX2ZsYWdzIHN0cl9pbmRcblxuICAoKiBUcnkgdG8gcmVhZCBhIGRpZ2l0YWwgb3IgYSAnKicgcGFkZGluZy4gKilcbiAgYW5kIHBhcnNlX3BhZGRpbmcgOiB0eXBlIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCB6ZXJvIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYWR0eSA9IG1hdGNoIHplcm8sIG1pbnVzIHdpdGhcbiAgICAgIHwgZmFsc2UsIGZhbHNlIC0+IFJpZ2h0XG4gICAgICB8IGZhbHNlLCB0cnVlICAtPiBMZWZ0XG4gICAgICB8ICB0cnVlLCBmYWxzZSAtPiBaZXJvc1xuICAgICAgfCAgdHJ1ZSwgdHJ1ZSAgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGVmdFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnLScgXCIwXCIgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgIGxldCBuZXdfaW5kLCB3aWR0aCA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgKExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gKEFyZ19wYWRkaW5nIHBhZHR5KVxuICAgIHwgXyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgICAgfCBMZWZ0ICAtPlxuICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy0nIFwicGFkZGluZ1wiO1xuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICB8IFplcm9zIC0+XG4gICAgICAgICAoKiBhICcwJyBwYWRkaW5nIGluZGljYXRpb24gbm90IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNob3VsZFxuICAgICAgICAgICBiZSBpbnRlcnByZXRlZCBhcyBhIFJpZ2h0IHBhZGRpbmcgb2Ygd2lkdGggMC4gVGhpcyBpcyB1c2VkXG4gICAgICAgICAgIGJ5IHNjYW5uaW5nIGNvbnZlcnNpb25zICUwcyBhbmQgJTBjICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIChMaXRfcGFkZGluZyAoUmlnaHQsIDApKVxuICAgICAgfCBSaWdodCAtPlxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICBlbmRcblxuICAoKiBJcyBwcmVjaXNpb24gZGVmaW5lZD8gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3BhZGRpbmcgOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnLicgLT5cbiAgICAgIHBhcnNlX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZFxuICAgIHwgc3ltYiAtPlxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBOb19wcmVjaXNpb24gcGFkIHN5bWJcblxuICAoKiBSZWFkIHRoZSBkaWdpdGFsIG9yICcqJyBwcmVjaXNpb24uICopXG4gIGFuZCBwYXJzZV9wcmVjaXNpb24gOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZCA9XG4gICAgICBsZXQgbmV3X2luZCwgcHJlYyA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gcHJlYykgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kXG4gICAgfCAoJysnIHwgJy0nKSBhcyBzeW1iIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+XG4gICAgICAoKiBMZWdhY3kgbW9kZSB3b3VsZCBhY2NlcHQgYW5kIGlnbm9yZSAnKycgb3IgJy0nIGJlZm9yZSB0aGVcbiAgICAgICAgIGludGVnZXIgZGVzY3JpYmluZyB0aGUgZGVzaXJlZCBwcmVjaXNpb247IG5vdGUgdGhhdCB0aGlzXG4gICAgICAgICBjYW5ub3QgaGFwcGVuIGZvciBwYWRkaW5nIHdpZHRoLCBhcyAnKycgYW5kICctJyBhbHJlYWR5IGhhdmVcbiAgICAgICAgIGEgc2VtYW50aWNzIHRoZXJlLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHRoZSBpZGVhIChzdXBwb3J0ZWQgYnkgdGhpcyB0d2VhaykgdGhhdCB3aWR0aCBhbmRcbiAgICAgICAgIHByZWNpc2lvbiBsaXRlcmFscyBhcmUgXCJpbnRlZ2VyIGxpdGVyYWxzXCIgaW4gdGhlIE9DYW1sIHNlbnNlIGlzXG4gICAgICAgICBzdGlsbCBibGF0YW50bHkgd3JvbmcsIGFzIDEyM180NTYgb3IgMHhGRiBhcmUgcmVqZWN0ZWQuICopXG4gICAgICBwYXJzZV9saXRlcmFsIChtaW51cyB8fCBzeW1iID0gJy0nKSAoc3RyX2luZCArIDEpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIHBhZCBBcmdfcHJlY2lzaW9uXG4gICAgfCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBub3RlIHRoYXQgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRpZCBub3QgaWdub3JlICcuJyB3aXRob3V0XG4gICAgICAgICAgIGEgbnVtYmVyIChhcyBpdCBkb2VzIGZvciBwYWRkaW5nIGluZGljYXRpb25zKSwgYnV0XG4gICAgICAgICAgIGludGVycHJldHMgaXQgYXMgJy4wJyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiAwKVxuICAgICAgZWxzZVxuICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy4nIFwicHJlY2lzaW9uXCJcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogdCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2NvbnYgKHR5cGUgdSkgKHR5cGUgdikgKHBhZHByZWMgOiAodSwgdikgcGFkZGluZykgPVxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBwcmVjIHBhZHByZWMgc3RyLltzdHJfaW5kXSBpblxuICAgICgqIGluIGxlZ2FjeSBtb2RlLCBzb21lIGZvcm1hdHMgKCVzIGFuZCAlUykgYWNjZXB0IGEgd2VpcmQgbWl4IG9mXG4gICAgICAgcGFkZGluZyBhbmQgcHJlY2lzaW9uLCB3aGljaCBpcyBtZXJnZWQgYXMgYSBzaW5nbGUgcGFkZGluZ1xuICAgICAgIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZSwgaW4gJS4xMHMgdGhlIHByZWNpc2lvbiBpcyBpbXBsaWNpdGx5XG4gICAgICAgdW5kZXJzdG9vZCBhcyBwYWRkaW5nICUxMHMsIGJ1dCB0aGUgbGVmdC1wYWRkaW5nIGNvbXBvbmVudCBtYXlcbiAgICAgICBiZSBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgbGVmdCBwYWRkaW5nIG9yIGEgbmVnYXRpdmUgcHJlY2lzaW9uOlxuICAgICAgICUtLjNzIGFuZCAlLi0zcyBhcmUgZXF1aXZhbGVudCB0byAlLTNzICopXG4gICAgbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgLT4gKFxuICAgICAgbWF0Y2ggbWludXMsIHByZWMgd2l0aFxuICAgICAgICB8IF8sIE5vX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IE5vX3BhZGRpbmdcbiAgICAgICAgfCBmYWxzZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChSaWdodCwgbikpXG4gICAgICAgIHwgdHJ1ZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChMZWZ0LCBuKSlcbiAgICAgICAgfCBmYWxzZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBSaWdodClcbiAgICAgICAgfCB0cnVlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIExlZnQpXG4gICAgKVxuICAgIHwgcGFkIC0+IHBhcnNlX2NvbnYgcGFkXG5cbiAgKCogQ2FzZSBhbmFseXNpcyBvbiBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfY29udmVyc2lvbiA6IHR5cGUgeCB5IHogdCB1IHYgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gKHgsIHkpIHBhZGRpbmcgLT5cbiAgICAgICAgKHosIHQpIHByZWNpc2lvbiAtPiAodSwgdikgcGFkZGluZyAtPiBjaGFyIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgcGFkcHJlYyBzeW1iIC0+XG4gICAgKCogRmxhZ3MgdXNlZCB0byBjaGVjayBvcHRpb24gdXNhZ2VzL2NvbXBhdGliaWxpdGllcy4gKilcbiAgICBsZXQgcGx1c191c2VkICA9IHJlZiBmYWxzZSBhbmQgaGFzaF91c2VkID0gcmVmIGZhbHNlXG4gICAgYW5kIHNwYWNlX3VzZWQgPSByZWYgZmFsc2UgYW5kIGlnbl91c2VkICAgPSByZWYgZmFsc2VcbiAgICBhbmQgcGFkX3VzZWQgICA9IHJlZiBmYWxzZSBhbmQgcHJlY191c2VkICA9IHJlZiBmYWxzZSBpblxuXG4gICAgKCogQWNjZXNzIHRvIG9wdGlvbnMsIHVwZGF0ZSBmbGFncy4gKilcbiAgICBsZXQgZ2V0X3BsdXMgICAgKCkgPSBwbHVzX3VzZWQgIDo9IHRydWU7IHBsdXNcbiAgICBhbmQgZ2V0X2hhc2ggICAoKSA9IGhhc2hfdXNlZCA6PSB0cnVlOyBoYXNoXG4gICAgYW5kIGdldF9zcGFjZSAgICgpID0gc3BhY2VfdXNlZCA6PSB0cnVlOyBzcGFjZVxuICAgIGFuZCBnZXRfaWduICAgICAoKSA9IGlnbl91c2VkICAgOj0gdHJ1ZTsgaWduXG4gICAgYW5kIGdldF9wYWQgICAgICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRcbiAgICBhbmQgZ2V0X3ByZWMgICAgKCkgPSBwcmVjX3VzZWQgIDo9IHRydWU7IHByZWNcbiAgICBhbmQgZ2V0X3BhZHByZWMgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZHByZWMgaW5cblxuICAgIGxldCBnZXRfaW50X3BhZCAoKSA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPSBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgYW5kIGNoZWNrX29wZW5fYm94IDogdHlwZSBhIGIgYyBkIGUgZiAuIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gdW5pdCA9XG4gIGZ1biBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIEVuZF9vZl9mb3JtYXQpIC0+IChcbiAgICAgIHRyeSBpZ25vcmUgKG9wZW5fYm94X29mX3N0cmluZyBzdHIpIHdpdGggRmFpbHVyZSBfIC0+XG4gICAgICAgICgoKiBFbWl0IHdhcm5pbmc6IGludmFsaWQgb3BlbiBib3ggKikpXG4gICAgKVxuICAgIHwgXyAtPiAoKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9IGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIChcbiAgICAgICAgICBjaGVja19vcGVuX2JveCBzdWJfZm10O1xuICAgICAgICAgIE9wZW5fYm94IHN1Yl9mb3JtYXQpIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBmbG9hdF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIHNwYWNlIHN5bWIgPVxuICBtYXRjaCBwbHVzLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsICdmJyAtPiBGbG9hdF9mICB8IGZhbHNlLCBmYWxzZSwgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ2YnIC0+IEZsb2F0X3NmIHwgZmFsc2UsICB0cnVlLCAnZScgLT4gRmxvYXRfc2VcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ2YnIC0+IEZsb2F0X3BmIHwgIHRydWUsIGZhbHNlLCAnZScgLT4gRmxvYXRfcGVcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0UnIC0+IEZsb2F0X0UgIHwgZmFsc2UsIGZhbHNlLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgZmFsc2UsICB0cnVlLCAnRScgLT4gRmxvYXRfc0UgfCBmYWxzZSwgIHRydWUsICdnJyAtPiBGbG9hdF9zZ1xuICAgIHwgIHRydWUsIGZhbHNlLCAnRScgLT4gRmxvYXRfcEUgfCAgdHJ1ZSwgZmFsc2UsICdnJyAtPiBGbG9hdF9wZ1xuICAgIHwgZmFsc2UsIGZhbHNlLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgZmFsc2UsICB0cnVlLCAnRycgLT4gRmxvYXRfc0dcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ0cnIC0+IEZsb2F0X3BHXG4gICAgfCBmYWxzZSwgZmFsc2UsICdoJyAtPiBGbG9hdF9oXG4gICAgfCBmYWxzZSwgIHRydWUsICdoJyAtPiBGbG9hdF9zaFxuICAgIHwgIHRydWUsIGZhbHNlLCAnaCcgLT4gRmxvYXRfcGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0gnIC0+IEZsb2F0X0hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ0gnIC0+IEZsb2F0X3NIXG4gICAgfCAgdHJ1ZSwgZmFsc2UsICdIJyAtPiBGbG9hdF9wSFxuICAgIHwgZmFsc2UsIGZhbHNlLCAnRicgLT4gRmxvYXRfRlxuICAgIHwgIHRydWUsICB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCJcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8ICB0cnVlLCBmYWxzZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2Ugc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbnR5cGUgdCA9IGV4biA9IC4uXG5cbmxldCBwcmludGVycyA9IHJlZiBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB0b19zdHJpbmcgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggdHJ5IGhkIHggd2l0aCBfIC0+IE5vbmUgd2l0aFxuICAgICAgICB8IFNvbWUgcyAtPiBzXG4gICAgICAgIHwgTm9uZSAtPiBjb252IHRsKVxuICAgIHwgW10gLT5cbiAgICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICAgIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICAgICAgICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICAgICAgICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgICAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICAgICAgICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICAgICAgICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgICAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpIGluXG4gIGNvbnYgIXByaW50ZXJzXG5cbmxldCBwcmludCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZmx1c2ggc3RkZXJyO1xuICAgIHJhaXNlIHhcblxubGV0IGNhdGNoIGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGZsdXNoIHN0ZG91dDtcbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZXhpdCAyXG5cbnR5cGUgcmF3X2JhY2t0cmFjZV9zbG90XG50eXBlIHJhd19iYWNrdHJhY2VcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2U6XG4gIHVuaXQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2VcIlxuXG5leHRlcm5hbCByYWlzZV93aXRoX2JhY2t0cmFjZTogZXhuIC0+IHJhd19iYWNrdHJhY2UgLT4gJ2FcbiAgPSBcIiVyYWlzZV93aXRoX2JhY2t0cmFjZVwiXG5cbnR5cGUgYmFja3RyYWNlX3Nsb3QgPVxuICB8IEtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlICAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgIDogc3RyaW5nO1xuICAgICAgbGluZV9udW1iZXIgOiBpbnQ7XG4gICAgICBzdGFydF9jaGFyICA6IGludDtcbiAgICAgIGVuZF9jaGFyICAgIDogaW50O1xuICAgICAgaXNfaW5saW5lICAgOiBib29sO1xuICAgIH1cbiAgfCBVbmtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlIDogYm9vbFxuICAgIH1cblxuKCogdG8gYXZvaWQgd2FybmluZyAqKVxubGV0IF8gPSBbS25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlOyBmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gMDsgc3RhcnRfY2hhciA9IDA7IGVuZF9jaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfaW5saW5lID0gZmFsc2UgfTtcbiAgICAgICAgIFVua25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlIH1dXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgKGluZm8gbC5pc19yYWlzZSkgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdHMgcmF3X2JhY2t0cmFjZSA9XG4gICgqIFRoZSBkb2N1bWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0aGF0IFNvbWUgaXNcbiAgICAgcmV0dXJuZWQgb25seSBpZiBhIHBhcnQgb2YgdGhlIHRyYWNlIGlzIHVzYWJsZS4gVGhpcyBnaXZlcyB1c1xuICAgICBhIGJpdCBtb3JlIHdvcmsgdGhhbiBqdXN0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSwgYnV0IGl0IG1ha2VzIHRoZVxuICAgICBBUEkgbW9yZSB1c2VyLWZyaWVuZGx5IC0tIG90aGVyd2lzZSBtb3N0IHVzZXJzIHdvdWxkIGhhdmUgdG9cbiAgICAgcmVpbXBsZW1lbnQgdGhlIFwiUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIHNvcnJ5XCIgbG9naWNcbiAgICAgdGhlbXNlbHZlcy4gKilcbiAgbWF0Y2ggY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGJhY2t0cmFjZSAtPlxuICAgICAgbGV0IHVzYWJsZV9zbG90ID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcbiAgICAgICAgfCBLbm93bl9sb2NhdGlvbiBfIC0+IHRydWUgaW5cbiAgICAgIGxldCByZWMgZXhpc3RzX3VzYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgKC0xKSAtPiBmYWxzZVxuICAgICAgICB8IGkgLT4gdXNhYmxlX3Nsb3QgYmFja3RyYWNlLihpKSB8fCBleGlzdHNfdXNhYmxlIChpIC0gMSkgaW5cbiAgICAgIGlmIGV4aXN0c191c2FibGUgKEFycmF5Lmxlbmd0aCBiYWNrdHJhY2UgLSAxKVxuICAgICAgdGhlbiBTb21lIGJhY2t0cmFjZVxuICAgICAgZWxzZSBOb25lXG5cbm1vZHVsZSBTbG90ID0gc3RydWN0XG4gIHR5cGUgdCA9IGJhY2t0cmFjZV9zbG90XG4gIGxldCBmb3JtYXQgPSBmb3JtYXRfYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGlzX3JhaXNlID0gYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2VcbiAgbGV0IGlzX2lubGluZSA9IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZVxuICBsZXQgbG9jYXRpb24gPSBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvblxuZW5kXG5cbmV4dGVybmFsIHJhd19iYWNrdHJhY2VfbGVuZ3RoIDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgcHJpbnRlcnMgOj0gZm4gOjogIXByaW50ZXJzXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5cbmxldCB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA9IHJlZiBOb25lXG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZm4gPSB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA6PSBTb21lIGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gT2JqLm9iaiAoT2JqLm5ld19ibG9jayBPYmouYWJzdHJhY3RfdGFnIDApXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtydW50aW1lL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBTdGRsaWIuZG9fYXRfZXhpdCAoKSB3aXRoIF8gLT4gKCkpO1xuICAgIG1hdGNoICF1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgICBmbHVzaCBzdGRlcnJcbiAgICB8IFNvbWUgaGFuZGxlciAtPlxuICAgICAgICB0cnlcbiAgICAgICAgICBoYW5kbGVyIGV4biByYXdfYmFja3RyYWNlXG4gICAgICAgIHdpdGggZXhuJyAtPlxuICAgICAgICAgIGxldCByYXdfYmFja3RyYWNlJyA9IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gICAgICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yIGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyOiBleGNlcHRpb24gJXNcXG5cIlxuICAgICAgICAgICAgKHRvX3N0cmluZyBleG4nKTtcbiAgICAgICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlJztcbiAgICAgICAgICBmbHVzaCBzdGRlcnJcbiAgd2l0aFxuICAgIHwgT3V0X29mX21lbW9yeSAtPlxuICAgICAgICBwcmVycl9lbmRsaW5lXG4gICAgICAgICAgXCJGYXRhbCBlcnJvcjogb3V0IG9mIG1lbW9yeSBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlclwiXG5cbigqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IFtjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbl0gaW5cbiAgIFtydW50aW1lL3ByaW50ZXhjLmNdIHdoaWNoIGV4cGVjdHMgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlXG4gIHdpdGggXyAtPlxuICAgICgqIFRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBhdCB0aGlzIHBvaW50ICopXG4gICAgKClcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiXG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIFhhdmllciBMZXJveSBhbmQgRGFtaWVuIERvbGlnZXosIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgZ2VuZXJpY19xdW90ZSBxdW90ZXF1b3RlIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIGlmIHMuW2ldID0gJ1xcJydcbiAgICB0aGVuIEJ1ZmZlci5hZGRfc3RyaW5nIGIgcXVvdGVxdW90ZVxuICAgIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGIgIHMuW2ldXG4gIGRvbmU7XG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzFdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvYmFzZW5hbWUuaHRtbFxuICBJbiBzdGVwIDEgb2YgW1sxXV0sIHdlIGNob29zZSB0byByZXR1cm4gXCIuXCIgZm9yIGVtcHR5IGlucHV0LlxuICAgIChmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIE9DYW1sKVxuICBJbiBzdGVwIDIsIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiAgU3RlcCA2IGlzIG5vdCBpbXBsZW1lbnRlZDogd2UgY29uc2lkZXIgdGhhdCB0aGUgW3N1ZmZpeF0gb3BlcmFuZCBpc1xuICAgIGFsd2F5cyBhYnNlbnQuICBTdWZmaXhlcyBhcmUgaGFuZGxlZCBieSBbY2hvcF9zdWZmaXhdIGFuZCBbY2hvcF9leHRlbnNpb25dLlxuKilcbmxldCBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyBmaW5kX2VuZCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gZmluZF9lbmQgKG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgbiAobiArIDEpXG4gIGFuZCBmaW5kX2JlZyBuIHAgPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgcFxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBTdHJpbmcuc3ViIG5hbWUgKG4gKyAxKSAocCAtIG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgKG4gLSAxKSBwXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIGZpbmRfZW5kIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzJdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvZGlybmFtZS5odG1sXG4gIEluIHN0ZXAgNiBvZiBbWzJdXSwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuKilcbmxldCBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIHRyYWlsaW5nX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gdHJhaWxpbmdfc2VwIChuIC0gMSlcbiAgICBlbHNlIGJhc2UgblxuICBhbmQgYmFzZSBuID1cbiAgICBpZiBuIDwgMCB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCBuXG4gICAgZWxzZSBiYXNlIChuIC0gMSlcbiAgYW5kIGludGVybWVkaWF0ZV9zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgKG4gLSAxKVxuICAgIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKG4gKyAxKVxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSB0cmFpbGluZ19zZXAgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbm1vZHVsZSBVbml4ID0gc3RydWN0XG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpID0gc3VmZlxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIHIgPSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRNUERJUlwiIHdpdGggTm90X2ZvdW5kIC0+IFwiL3RtcFwiXG4gIGxldCBxdW90ZSA9IGdlbmVyaWNfcXVvdGUgXCInXFxcXCcnXCJcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFdpbjMyID0gc3RydWN0XG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiXFxcXFwiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IGxldCBjID0gcy5baV0gaW4gYyA9ICcvJyB8fCBjID0gJ1xcXFwnIHx8IGMgPSAnOidcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPVxuICAgIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnXFxcXCcpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgbi5bMV0gPD4gJzonKVxuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuXFxcXFwiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi5cXFxcXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgIFN0cmluZy5sZW5ndGggbmFtZSA+PSBTdHJpbmcubGVuZ3RoIHN1ZmYgJiZcbiAgIChsZXQgcyA9IFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpIGluXG4gICAgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmKVxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgciA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZml4IHRoZW5cbiAgICAgICAgU29tZSAoU3RyaW5nLnN1YiBmaWxlbmFtZSAwIChsZW5fZiAtIGxlbl9zKSlcbiAgICAgIGVsc2VcbiAgICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRFTVBcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi5cIlxuICBsZXQgcXVvdGUgcyA9XG4gICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIicgZWxzZVxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnXFxcIicgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgYyAgICAtPiBCdWZmZXIuYWRkX2NoYXIgYiBjOyBsb29wIChpKzEpO1xuICAgIGFuZCBsb29wX2JzIG4gaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICAgICAgYWRkX2JzIG47XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAgIHwgJ1xcXCInIC0+IGFkZF9icyAoMipuKzEpOyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7IGxvb3AgKGkrMSk7XG4gICAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgKG4rMSkgKGkrMSk7XG4gICAgICAgIHwgXyAgICAtPiBhZGRfYnMgbjsgbG9vcCBpXG4gICAgICBlbmRcbiAgICBhbmQgYWRkX2JzIG4gPSBmb3IgX2ogPSAxIHRvIG4gZG8gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnOyBkb25lXG4gICAgaW5cbiAgICBsb29wIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luID0gc3RydWN0XG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgPSBXaW4zMi5jaG9wX3N1ZmZpeF9vcHRcbiAgbGV0IHRlbXBfZGlyX25hbWUgPSBVbml4LnRlbXBfZGlyX25hbWVcbiAgbGV0IHF1b3RlID0gVW5peC5xdW90ZVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5sZXQgKGN1cnJlbnRfZGlyX25hbWUsIHBhcmVudF9kaXJfbmFtZSwgZGlyX3NlcCwgaXNfZGlyX3NlcCxcbiAgICAgaXNfcmVsYXRpdmUsIGlzX2ltcGxpY2l0LCBjaGVja19zdWZmaXgsIGNob3Bfc3VmZml4X29wdCxcbiAgICAgdGVtcF9kaXJfbmFtZSwgcXVvdGUsIGJhc2VuYW1lLFxuICAgICBkaXJuYW1lKSA9XG4gIG1hdGNoIFN5cy5vc190eXBlIHdpdGhcbiAgfCBcIldpbjMyXCIgLT5cbiAgICAgIChXaW4zMi5jdXJyZW50X2Rpcl9uYW1lLCBXaW4zMi5wYXJlbnRfZGlyX25hbWUsIFdpbjMyLmRpcl9zZXAsXG4gICAgICAgV2luMzIuaXNfZGlyX3NlcCxcbiAgICAgICBXaW4zMi5pc19yZWxhdGl2ZSwgV2luMzIuaXNfaW1wbGljaXQsIFdpbjMyLmNoZWNrX3N1ZmZpeCxcbiAgICAgICBXaW4zMi5jaG9wX3N1ZmZpeF9vcHQsXG4gICAgICAgV2luMzIudGVtcF9kaXJfbmFtZSwgV2luMzIucXVvdGUsIFdpbjMyLmJhc2VuYW1lLCBXaW4zMi5kaXJuYW1lKVxuICB8IFwiQ3lnd2luXCIgLT5cbiAgICAgIChDeWd3aW4uY3VycmVudF9kaXJfbmFtZSwgQ3lnd2luLnBhcmVudF9kaXJfbmFtZSwgQ3lnd2luLmRpcl9zZXAsXG4gICAgICAgQ3lnd2luLmlzX2Rpcl9zZXAsXG4gICAgICAgQ3lnd2luLmlzX3JlbGF0aXZlLCBDeWd3aW4uaXNfaW1wbGljaXQsIEN5Z3dpbi5jaGVja19zdWZmaXgsXG4gICAgICAgQ3lnd2luLmNob3Bfc3VmZml4X29wdCxcbiAgICAgICBDeWd3aW4udGVtcF9kaXJfbmFtZSwgQ3lnd2luLnF1b3RlLCBDeWd3aW4uYmFzZW5hbWUsIEN5Z3dpbi5kaXJuYW1lKVxuICB8IF8gLT4gKCogbm9ybWFsbHkgXCJVbml4XCIgKilcbiAgICAgIChVbml4LmN1cnJlbnRfZGlyX25hbWUsIFVuaXgucGFyZW50X2Rpcl9uYW1lLCBVbml4LmRpcl9zZXAsXG4gICAgICAgVW5peC5pc19kaXJfc2VwLFxuICAgICAgIFVuaXguaXNfcmVsYXRpdmUsIFVuaXguaXNfaW1wbGljaXQsIFVuaXguY2hlY2tfc3VmZml4LFxuICAgICAgIFVuaXguY2hvcF9zdWZmaXhfb3B0LFxuICAgICAgIFVuaXgudGVtcF9kaXJfbmFtZSwgVW5peC5xdW90ZSwgVW5peC5iYXNlbmFtZSwgVW5peC5kaXJuYW1lKVxuXG5sZXQgY29uY2F0IGRpcm5hbWUgZmlsZW5hbWUgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggZGlybmFtZSBpblxuICBpZiBsID0gMCB8fCBpc19kaXJfc2VwIGRpcm5hbWUgKGwtMSlcbiAgdGhlbiBkaXJuYW1lIF4gZmlsZW5hbWVcbiAgZWxzZSBkaXJuYW1lIF4gZGlyX3NlcCBeIGZpbGVuYW1lXG5cbmxldCBjaG9wX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZiBpblxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIG5cblxubGV0IGV4dGVuc2lvbl9sZW4gbmFtZSA9XG4gIGxldCByZWMgY2hlY2sgaTAgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkwIChpIC0gMSlcbiAgICBlbHNlIFN0cmluZy5sZW5ndGggbmFtZSAtIGkwXG4gIGluXG4gIGxldCByZWMgc2VhcmNoX2RvdCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaSAoaSAtIDEpXG4gICAgZWxzZSBzZWFyY2hfZG90IChpIC0gMSlcbiAgaW5cbiAgc2VhcmNoX2RvdCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubGV0IGV4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBcIlwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKSBsXG5cbmxldCBjaG9wX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3BfZXh0ZW5zaW9uXCJcbiAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxubGV0IHJlbW92ZV9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gbmFtZSBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5leHRlcm5hbCBvcGVuX2Rlc2M6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcbmV4dGVybmFsIGNsb3NlX2Rlc2M6IGludCAtPiB1bml0ID0gXCJjYW1sX3N5c19jbG9zZVwiXG5cbmxldCBwcm5nID0gbGF6eShSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQgKCkpXG5cbmxldCB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJuZCA9IChSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSkgbGFuZCAweEZGRkZGRiBpblxuICBjb25jYXQgdGVtcF9kaXIgKFByaW50Zi5zcHJpbnRmIFwiJXMlMDZ4JXNcIiBwcmVmaXggcm5kIHN1ZmZpeClcblxuXG5sZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lID0gcmVmIHRlbXBfZGlyX25hbWVcblxubGV0IHNldF90ZW1wX2Rpcl9uYW1lIHMgPSBjdXJyZW50X3RlbXBfZGlyX25hbWUgOj0gc1xubGV0IGdldF90ZW1wX2Rpcl9uYW1lICgpID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZVxuXG5sZXQgdGVtcF9maWxlID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIGNsb3NlX2Rlc2Mob3Blbl9kZXNjIG5hbWUgW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX2V4Y2xdIDBvNjAwKTtcbiAgICAgIG5hbWVcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcblxubGV0IG9wZW5fdGVtcF9maWxlID8obW9kZSA9IFtPcGVuX3RleHRdKSA/KHBlcm1zID0gMG82MDApXG4gICAgICAgICAgICAgICAgICAgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgKG5hbWUsXG4gICAgICAgb3Blbl9vdXRfZ2VuIChPcGVuX3dyb25seTo6T3Blbl9jcmVhdDo6T3Blbl9leGNsOjptb2RlKSBwZXJtcyBuYW1lKVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDb21wbGV4IG51bWJlcnMgKilcblxudHlwZSB0ID0geyByZTogZmxvYXQ7IGltOiBmbG9hdCB9XG5cbmxldCB6ZXJvID0geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxubGV0IG9uZSA9IHsgcmUgPSAxLjA7IGltID0gMC4wIH1cbmxldCBpID0geyByZSA9IDAuMDsgaW0gPSAxLjAgfVxuXG5sZXQgYWRkIHggeSA9IHsgcmUgPSB4LnJlICsuIHkucmU7IGltID0geC5pbSArLiB5LmltIH1cblxubGV0IHN1YiB4IHkgPSB7IHJlID0geC5yZSAtLiB5LnJlOyBpbSA9IHguaW0gLS4geS5pbSB9XG5cbmxldCBuZWcgeCA9IHsgcmUgPSAtLiB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgY29uaiB4ID0geyByZSA9IHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBtdWwgeCB5ID0geyByZSA9IHgucmUgKi4geS5yZSAtLiB4LmltICouIHkuaW07XG4gICAgICAgICAgICAgICAgaW0gPSB4LnJlICouIHkuaW0gKy4geC5pbSAqLiB5LnJlIH1cblxubGV0IGRpdiB4IHkgPVxuICBpZiBhYnNfZmxvYXQgeS5yZSA+PSBhYnNfZmxvYXQgeS5pbSB0aGVuXG4gICAgbGV0IHIgPSB5LmltIC8uIHkucmUgaW5cbiAgICBsZXQgZCA9IHkucmUgKy4gciAqLiB5LmltIGluXG4gICAgeyByZSA9ICh4LnJlICsuIHIgKi4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHguaW0gLS4gciAqLiB4LnJlKSAvLiBkIH1cbiAgZWxzZVxuICAgIGxldCByID0geS5yZSAvLiB5LmltIGluXG4gICAgbGV0IGQgPSB5LmltICsuIHIgKi4geS5yZSBpblxuICAgIHsgcmUgPSAociAqLiB4LnJlICsuIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9IChyICouIHguaW0gLS4geC5yZSkgLy4gZCB9XG5cbmxldCBpbnYgeCA9IGRpdiBvbmUgeFxuXG5sZXQgbm9ybTIgeCA9IHgucmUgKi4geC5yZSArLiB4LmltICouIHguaW1cblxubGV0IG5vcm0geCA9XG4gICgqIFdhdGNoIG91dCBmb3Igb3ZlcmZsb3cgaW4gY29tcHV0aW5nIHJlXjIgKyBpbV4yICopXG4gIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICBpZiByID0gMC4wIHRoZW4gaVxuICBlbHNlIGlmIGkgPSAwLjAgdGhlbiByXG4gIGVsc2UgaWYgciA+PSBpIHRoZW5cbiAgICBsZXQgcSA9IGkgLy4gciBpbiByICouIHNxcnQoMS4wICsuIHEgKi4gcSlcbiAgZWxzZVxuICAgIGxldCBxID0gciAvLiBpIGluIGkgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuXG5sZXQgYXJnIHggPSBhdGFuMiB4LmltIHgucmVcblxubGV0IHBvbGFyIG4gYSA9IHsgcmUgPSBjb3MgYSAqLiBuOyBpbSA9IHNpbiBhICouIG4gfVxuXG5sZXQgc3FydCB4ID1cbiAgaWYgeC5yZSA9IDAuMCAmJiB4LmltID0gMC4wIHRoZW4geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gICAgbGV0IHcgPVxuICAgICAgaWYgciA+PSBpIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHEgPSBpIC8uIHIgaW5cbiAgICAgICAgc3FydChyKSAqLiBzcXJ0KDAuNSAqLiAoMS4wICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IHEgPSByIC8uIGkgaW5cbiAgICAgICAgc3FydChpKSAqLiBzcXJ0KDAuNSAqLiAocSArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBpblxuICAgIGlmIHgucmUgPj0gMC4wXG4gICAgdGhlbiB7IHJlID0gdzsgIGltID0gMC41ICouIHguaW0gLy4gdyB9XG4gICAgZWxzZSB7IHJlID0gMC41ICouIGkgLy4gdzsgIGltID0gaWYgeC5pbSA+PSAwLjAgdGhlbiB3IGVsc2UgLS4gdyB9XG4gIGVuZFxuXG5sZXQgZXhwIHggPVxuICBsZXQgZSA9IGV4cCB4LnJlIGluIHsgcmUgPSBlICouIGNvcyB4LmltOyBpbSA9IGUgKi4gc2luIHguaW0gfVxuXG5sZXQgbG9nIHggPSB7IHJlID0gbG9nIChub3JtIHgpOyBpbSA9IGF0YW4yIHguaW0geC5yZSB9XG5cbmxldCBwb3cgeCB5ID0gZXhwIChtdWwgeSAobG9nIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAgICAgICAoKiAgJSNkIHwgJSNpIHwgJSN1ICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2NvbnYgPVxuICB8IEZsb2F0X2YgfCBGbG9hdF9wZiB8IEZsb2F0X3NmICAoKiAgJWYgfCAlK2YgfCAlIGYgICopXG4gIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2UgICgqICAlZSB8ICUrZSB8ICUgZSAgKilcbiAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSAgKCogICVFIHwgJStFIHwgJSBFICAqKVxuICB8IEZsb2F0X2cgfCBGbG9hdF9wZyB8IEZsb2F0X3NnICAoKiAgJWcgfCAlK2cgfCAlIGcgICopXG4gIHwgRmxvYXRfRyB8IEZsb2F0X3BHIHwgRmxvYXRfc0cgICgqICAlRyB8ICUrRyB8ICUgRyAgKilcbiAgfCBGbG9hdF9GICAgICAgICAgICAgICAgICAgICAgICAgKCogICVGICAgICAgICAgICAgICAqKVxuICB8IEZsb2F0X2ggfCBGbG9hdF9waCB8IEZsb2F0X3NoICAoKiAgJWggfCAlK2ggfCAlIGggICopXG4gIHwgRmxvYXRfSCB8IEZsb2F0X3BIIHwgRmxvYXRfc0ggICgqICAlSCB8ICUrSCB8ICUgSCAgKilcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGXSAqKVxuICAgICAgZmxvYXRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGZsb2F0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtiQl0gKilcbiAgICAgICgneCwgYm9vbCAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsdXNoIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IFN0cmluZ19saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIGFiYyAqKVxuICAgICAgc3RyaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2hhcl9saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogeCAqKVxuICAgICAgY2hhciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgRm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IEFscGhhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ3ggLT4gJ2MpIC0+ICd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFRoZXRhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ2MpIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcjogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgZm9ybWF0dGluZ19saXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXR0aW5nX2dlbiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgICgnYTEsICdiLCAnYywgJ2QxLCAnZTEsICdmMSkgZm9ybWF0dGluZ19nZW4gKlxuICAgICAgKCdmMSwgJ2IsICdjLCAnZTEsICdlMiwgJ2YyKSBmbXQgLT4gKCdhMSwgJ2IsICdjLCAnZDEsICdlMiwgJ2YyKSBmbXRcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4IC0+ICdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVsuLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChzdHJpbmcgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtubE5MXSAqKVxuICAgICAgY291bnRlciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGludCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IElnbm9yZWRfcGFyYW0gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgaWdub3JlZCAqICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEN1c3RvbSBwcmludGluZyBmb3JtYXQgKFBSIzY0NTIsIEdQUiMxNDApXG5cbiAgICAgV2UgaW5jbHVkZSBhIHR5cGUgQ3VzdG9tIG9mIFwiY3VzdG9tIGNvbnZlcnRlcnNcIiwgd2hlcmUgYW5cbiAgICAgYXJiaXRyYXJ5IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNvbnZlcnQgb25lIG9yIG1vcmVcbiAgICAgYXJndW1lbnRzLiBUaGVyZSBpcyBubyBzeW50YXggZm9yIGN1c3RvbSBjb252ZXJ0ZXJzLCBpdCBpcyBvbmx5XG4gICAgIGludGVuZGVkIGZvciBjdXN0b20gcHJvY2Vzc29ycyB0aGF0IHdpc2ggdG8gcmVseSBvbiB0aGVcbiAgICAgc3RkbGliLWRlZmluZWQgZm9ybWF0IEdBRFRzLlxuXG4gICAgIEZvciBpbnN0YW5jZSBhIHByZS1wcm9jZXNzb3IgY291bGQgY2hvb3NlIHRvIGludGVycHJldCBzdHJpbmdzXG4gICAgIHByZWZpeGVkIHdpdGggW1wiIVwiXSBhcyBmb3JtYXQgc3RyaW5ncyB3aGVyZSBbJXt7IC4uLiB9fV0gaXNcbiAgICAgYSBzcGVjaWFsIGZvcm0gdG8gcGFzcyBhIHRvX3N0cmluZyBmdW5jdGlvbiwgc28gdGhhdCBvbmUgY291bGRcbiAgICAgd3JpdGU6XG5cbiAgICAge1tcbiAgICAgICB0eXBlIHQgPSB7IHggOiBpbnQ7IHkgOiBpbnQgfVxuXG4gICAgICAgbGV0IHN0cmluZ19vZl90IHQgPSBQcmludGYuc3ByaW50ZiBcInsgeCA9ICVkOyB5ID0gJWQgfVwiIHQueCB0LnlcblxuICAgICAgIFByaW50Zi5wcmludGYgIVwidCA9ICV7e3N0cmluZ19vZl90fX1cIiB7IHggPSA0MjsgeSA9IDQyIH1cbiAgICAgXX1cbiAgKilcbiAgfCBDdXN0b20gOlxuICAgICAgKCdhLCAneCwgJ3kpIGN1c3RvbV9hcml0eSAqICh1bml0IC0+ICd4KSAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBlbmQgb2YgYSBmb3JtYXQgc3BlY2lmaWNhdGlvbiAqKVxuICB8IEVuZF9vZl9mb3JtYXQgOlxuICAgICAgICAoJ2YsICdiLCAnYywgJ2UsICdlLCAnZikgZm10XG5cbigqKiopXG5cbigqIFR5cGUgZm9yIGlnbm9yZWQgcGFyYW1ldGVycyAoc2VlIFwiJV9cIikuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWQgPVxuICB8IElnbm9yZWRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9zICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9TICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX25kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2YgKilcbiAgICAgIHBhZF9vcHRpb24gKiBwcmVjX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfYm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQiAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfey4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8oLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3JlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgKilcbiAgICAgICgnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1suLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1tubE5MXSAqKVxuICAgICAgY291bnRlciAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG5cbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gIEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ICogc3RyaW5nXG5cbmxldCByZWMgZXJhc2VfcmVsIDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gIChhLCBiLCBjLCBkLCBlLCBmLFxuICAgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eVxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgX3R5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkxLCBlcmFzZV9yZWwgcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwZSBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXQgdHlwZXMuICopXG4oKiBVc2VkIGJ5OlxuICAgKiByZWFkZXJfbmJfdW5pZmllcl9vZl9mbXR0eSB0byBjb3VudCByZWFkZXJzIGluIGFuIGZtdHR5LFxuICAgKiBTY2FuZi50YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIHRvIGV4dHJhY3QgcmVhZGVycyBpbnNpZGUgJSguLi4lKSxcbiAgICogQ2FtbGludGVybmFsRm9ybWF0LmZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IHRvIGV4dHJhY3QgZm9ybWF0IHR5cGUuICopXG5cbigqXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10dHkgPVxuKilcbmxldCByZWMgY29uY2F0X2ZtdHR5IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gICAgICAgZzEgajEgZzIgajJcbiAgLlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZDEsIGExLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZDIsIGEyKSBmbXR0eV9yZWwgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKGcxLCBiMSwgYzEsIGoxLCBlMSwgZjEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBlMiwgZjIpIGZtdHR5X3JlbCA9XG5mdW4gZm10dHkxIGZtdHR5MiAtPiBtYXRjaCBmbXR0eTEgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IGZtdHR5MlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdHMuICopXG5sZXQgcmVjIGNvbmNhdF9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10ID1cbmZ1biBmbXQxIGZtdDIgLT4gbWF0Y2ggZm10MSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgU3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgQ2FtbF9zdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IENoYXIgKHJlc3QpIC0+XG4gICAgQ2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBDYW1sX2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBCb29sIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBBbHBoYSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIFRoZXRhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIEN1c3RvbSAoYXJpdHksIGYsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFJlYWRlciByZXN0IC0+XG4gICAgUmVhZGVyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgRmx1c2ggKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBDaGFyX2xpdGVyYWwgICAoY2hyLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdF9hcmcgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZyAgIChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX25leHRfY2hhciAocmVzdCkgLT5cbiAgICBTY2FuX25leHRfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIElnbm9yZWRfcGFyYW0gKGlnbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGZtdDJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBydW50aW1lL2ZhaWxfbmF0LmMgKilcbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmFycmF5X2JvdW5kX2Vycm9yXCJcbiAgICAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5leGNlcHRpb24gTWF0Y2hfZmFpbHVyZSA9IE1hdGNoX2ZhaWx1cmVcbmV4Y2VwdGlvbiBBc3NlcnRfZmFpbHVyZSA9IEFzc2VydF9mYWlsdXJlXG5leGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCA9IEludmFsaWRfYXJndW1lbnRcbmV4Y2VwdGlvbiBGYWlsdXJlID0gRmFpbHVyZVxuZXhjZXB0aW9uIE5vdF9mb3VuZCA9IE5vdF9mb3VuZFxuZXhjZXB0aW9uIE91dF9vZl9tZW1vcnkgPSBPdXRfb2ZfbWVtb3J5XG5leGNlcHRpb24gU3RhY2tfb3ZlcmZsb3cgPSBTdGFja19vdmVyZmxvd1xuZXhjZXB0aW9uIFN5c19lcnJvciA9IFN5c19lcnJvclxuZXhjZXB0aW9uIEVuZF9vZl9maWxlID0gRW5kX29mX2ZpbGVcbmV4Y2VwdGlvbiBEaXZpc2lvbl9ieV96ZXJvID0gRGl2aXNpb25fYnlfemVyb1xuZXhjZXB0aW9uIFN5c19ibG9ja2VkX2lvID0gU3lzX2Jsb2NrZWRfaW9cbmV4Y2VwdGlvbiBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSA9IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5cbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5cbigqIENvbXBhcmlzb25zICopXG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG5sZXQgbWluIHggeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuXG4oKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuXG4oKiBJbnRlZ2VyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5cbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxuXG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG5sZXQgbG5vdCB4ID0geCBseG9yICgtMSlcblxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuXG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcblxuKCogRmxvYXRpbmctcG9pbnQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmVnX2luZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweEZGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5hbiA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBtYXhfZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRUZfRkZfRkZfRkZfRkZfRkZfRkZMXG5sZXQgbWluX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDAwXzEwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IGVwc2lsb25fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4M0NfQjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5cbnR5cGUgZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4oKiBTdHJpbmcgYW5kIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZXMgU3RyaW5nIGFuZCBCeXRlcyAqKVxuXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgc3RyaW5nX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCAoIF4gKSBzMSBzMiA9XG4gIGxldCBsMSA9IHN0cmluZ19sZW5ndGggczEgYW5kIGwyID0gc3RyaW5nX2xlbmd0aCBzMiBpblxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAobDEgKyBsMikgaW5cbiAgc3RyaW5nX2JsaXQgczEgMCBzIDAgbDE7XG4gIHN0cmluZ19ibGl0IHMyIDAgcyBsMSBsMjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIENoYXIgKilcblxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaGFyX29mX2ludCA6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50IG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJjaGFyX29mX2ludFwiIGVsc2UgdW5zYWZlX2NoYXJfb2ZfaW50IG5cblxuKCogVW5pdCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcblxuKCogUmVmZXJlbmNlcyAqKVxuXG50eXBlICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcblxuKCogUmVzdWx0IHR5cGUgKilcblxudHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcblxuKCogU3RyaW5nIGNvbnZlcnNpb24gZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxubGV0IHN0cmluZ19vZl9ib29sIGIgPVxuICBpZiBiIHRoZW4gXCJ0cnVlXCIgZWxzZSBcImZhbHNlXCJcbmxldCBib29sX29mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IF8gLT4gaW52YWxpZF9hcmcgXCJib29sX29mX3N0cmluZ1wiXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdHJpbmdfb2ZfaW50IG4gPVxuICBmb3JtYXRfaW50IFwiJWRcIiBuXG5cbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5leHRlcm5hbCBzdHJpbmdfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcblxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IHN0cmluZ19sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBsIHRoZW4gcyBeIFwiLlwiIGVsc2VcbiAgICBtYXRjaCBzdHJpbmdfZ2V0IHMgaSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgIHwgXyAtPiBzXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3RyaW5nX29mX2Zsb2F0IGYgPSB2YWxpZF9mbG9hdF9sZXhlbSAoZm9ybWF0X2Zsb2F0IFwiJS4xMmdcIiBmKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBMaXN0ICopXG5cbmxldCByZWMgKCBAICkgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBoZCA6OiB0bCAtPiBoZCA6OiAodGwgQCBsMilcblxuKCogSS9PIG9wZXJhdGlvbnMgKilcblxudHlwZSBpbl9jaGFubmVsXG50eXBlIG91dF9jaGFubmVsXG5cbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9vdXQgOiBpbnQgLT4gb3V0X2NoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFwiXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3JfaW4gOiBpbnQgLT4gaW5fY2hhbm5lbCA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cIlxuXG5sZXQgc3RkaW4gPSBvcGVuX2Rlc2NyaXB0b3JfaW4gMFxubGV0IHN0ZG91dCA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMVxubGV0IHN0ZGVyciA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMlxuXG4oKiBHZW5lcmFsIG91dHB1dCBmdW5jdGlvbnMgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5IHwgT3Blbl93cm9ubHkgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXQgfCBPcGVuX3RydW5jIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnkgfCBPcGVuX3RleHQgfCBPcGVuX25vbmJsb2NrXG5cbmV4dGVybmFsIG9wZW5fZGVzYyA6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcblxuZXh0ZXJuYWwgc2V0X291dF9jaGFubmVsX25hbWU6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9vdXRfZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0KG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X291dF9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX291dCBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl90ZXh0XSAwbzY2NiBuYW1lXG5cbmxldCBvcGVuX291dF9iaW4gbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fYmluYXJ5XSAwbzY2NiBuYW1lXG5cbmV4dGVybmFsIGZsdXNoIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9mbHVzaFwiXG5cbmV4dGVybmFsIG91dF9jaGFubmVsc19saXN0IDogdW5pdCAtPiBvdXRfY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFwiXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgW10gLT4gKClcbiAgICB8IGE6OmwgLT5cbiAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBmbHVzaCBhXG4gICAgICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgICAgICAoKSAoKiBpZ25vcmUgY2hhbm5lbHMgY2xvc2VkIGR1cmluZyBhIHByZWNlZGluZyBmbHVzaC4gKilcbiAgICAgICAgZW5kO1xuICAgICAgICBpdGVyIGxcbiAgaW4gaXRlciAob3V0X2NoYW5uZWxzX2xpc3QgKCkpXG5cbmV4dGVybmFsIHVuc2FmZV9vdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0X2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9vdXRwdXRfc3RyaW5nIDogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgb3V0cHV0X2NoYXIgOiBvdXRfY2hhbm5lbCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuXG5sZXQgb3V0cHV0X2J5dGVzIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0IG9jIHMgMCAoYnl0ZXNfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXRfc3RyaW5nIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIDAgKHN0cmluZ19sZW5ndGggcylcblxubGV0IG91dHB1dCBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dFwiXG4gIGVsc2UgdW5zYWZlX291dHB1dCBvYyBzIG9mcyBsZW5cblxubGV0IG91dHB1dF9zdWJzdHJpbmcgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHN0cmluZ19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X3N1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyBvZnMgbGVuXG5cbmV4dGVybmFsIG91dHB1dF9ieXRlIDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuZXh0ZXJuYWwgb3V0cHV0X2JpbmFyeV9pbnQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfaW50XCJcblxuZXh0ZXJuYWwgbWFyc2hhbF90b19jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gdW5pdCBsaXN0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmxldCBvdXRwdXRfdmFsdWUgY2hhbiB2ID0gbWFyc2hhbF90b19jaGFubmVsIGNoYW4gdiBbXVxuXG5leHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XCJcbmV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX291dFwiXG5leHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX291dF9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9vdXQgb2MgPSBmbHVzaCBvYzsgY2xvc2Vfb3V0X2NoYW5uZWwgb2NcbmxldCBjbG9zZV9vdXRfbm9lcnIgb2MgPVxuICAodHJ5IGZsdXNoIG9jIHdpdGggXyAtPiAoKSk7XG4gICh0cnkgY2xvc2Vfb3V0X2NoYW5uZWwgb2Mgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX291dCA6IG91dF9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBHZW5lcmFsIGlucHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBzZXRfaW5fY2hhbm5lbF9uYW1lOiBpbl9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9pbl9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9pbihvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9pbl9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX2luIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fdGV4dF0gMCBuYW1lXG5cbmxldCBvcGVuX2luX2JpbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX2JpbmFyeV0gMCBuYW1lXG5cbmV4dGVybmFsIGlucHV0X2NoYXIgOiBpbl9jaGFubmVsIC0+IGNoYXIgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dCA6IGluX2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9pbnB1dFwiXG5cbmxldCBpbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcImlucHV0XCJcbiAgZWxzZSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBsZW4gPD0gMCB0aGVuICgpIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyAob2ZzICsgcikgKGxlbiAtIHIpXG4gIGVuZFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSBsZW4gaW5cbiAgcmVhbGx5X2lucHV0IGljIHMgMCBsZW47XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG5leHRlcm5hbCBpbnB1dF9zY2FuX2xpbmUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcIlxuXG5sZXQgaW5wdXRfbGluZSBjaGFuID1cbiAgbGV0IHJlYyBidWlsZF9yZXN1bHQgYnVmIHBvcyA9IGZ1bmN0aW9uXG4gICAgW10gLT4gYnVmXG4gIHwgaGQgOjogdGwgLT5cbiAgICAgIGxldCBsZW4gPSBieXRlc19sZW5ndGggaGQgaW5cbiAgICAgIGJ5dGVzX2JsaXQgaGQgMCBidWYgKHBvcyAtIGxlbikgbGVuO1xuICAgICAgYnVpbGRfcmVzdWx0IGJ1ZiAocG9zIC0gbGVuKSB0bCBpblxuICBsZXQgcmVjIHNjYW4gYWNjdSBsZW4gPVxuICAgIGxldCBuID0gaW5wdXRfc2Nhbl9saW5lIGNoYW4gaW5cbiAgICBpZiBuID0gMCB0aGVuIGJlZ2luICAgICAgICAgICAgICAgICAgICgqIG4gPSAwOiB3ZSBhcmUgYXQgRU9GICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICAgIHwgXyAgLT4gYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gYWNjdVxuICAgIGVuZCBlbHNlIGlmIG4gPiAwIHRoZW4gYmVnaW4gICAgICAgICAgKCogbiA+IDA6IG5ld2xpbmUgZm91bmQgaW4gYnVmZmVyICopXG4gICAgICBsZXQgcmVzID0gYnl0ZXNfY3JlYXRlIChuIC0gMSkgaW5cbiAgICAgIGlnbm9yZSAodW5zYWZlX2lucHV0IGNoYW4gcmVzIDAgKG4gLSAxKSk7XG4gICAgICBpZ25vcmUgKGlucHV0X2NoYXIgY2hhbik7ICAgICAgICAgICAoKiBza2lwIHRoZSBuZXdsaW5lICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmVzXG4gICAgICB8ICBfIC0+IGxldCBsZW4gPSBsZW4gKyBuIC0gMSBpblxuICAgICAgICAgICAgICBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiAocmVzIDo6IGFjY3UpXG4gICAgZW5kIGVsc2UgYmVnaW4gICAgICAgICAgICAgICAgICAgICAgICAoKiBuIDwgMDogbmV3bGluZSBub3QgZm91bmQgKilcbiAgICAgIGxldCBiZWcgPSBieXRlc19jcmVhdGUgKC1uKSBpblxuICAgICAgaWdub3JlKHVuc2FmZV9pbnB1dCBjaGFuIGJlZyAwICgtbikpO1xuICAgICAgc2NhbiAoYmVnIDo6IGFjY3UpIChsZW4gLSBuKVxuICAgIGVuZFxuICBpbiBieXRlc191bnNhZmVfdG9fc3RyaW5nIChzY2FuIFtdIDApXG5cbmV4dGVybmFsIGlucHV0X2J5dGUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcbmV4dGVybmFsIGlucHV0X2JpbmFyeV9pbnQgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9pbnRcIlxuZXh0ZXJuYWwgaW5wdXRfdmFsdWUgOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5cIlxuZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX2luXCJcbmV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX2luX25vZXJyIGljID0gKHRyeSBjbG9zZV9pbiBpYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfaW4gOiBpbl9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgb3V0cHV0ICopXG5cbmxldCBwcmludF9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRvdXQgY1xubGV0IHByaW50X3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgc1xubGV0IHByaW50X2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3Rkb3V0IHNcbmxldCBwcmludF9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJpbnRfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzOyBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxubGV0IHByaW50X25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGVycm9yICopXG5cbmxldCBwcmVycl9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRlcnIgY1xubGV0IHByZXJyX3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgc1xubGV0IHByZXJyX2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3RkZXJyIHNcbmxldCBwcmVycl9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJlcnJfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmVycl9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzOyBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxubGV0IHByZXJyX25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxuXG4oKiBJbnB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgaW5wdXQgKilcblxubGV0IHJlYWRfbGluZSAoKSA9IGZsdXNoIHN0ZG91dDsgaW5wdXRfbGluZSBzdGRpblxubGV0IHJlYWRfaW50ICgpID0gaW50X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2ludF9vcHQgKCkgPSBpbnRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0ICgpID0gZmxvYXRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXRfb3B0ICgpID0gZmxvYXRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcblxuKCogT3BlcmF0aW9ucyBvbiBsYXJnZSBmaWxlcyAqKVxuXG5tb2R1bGUgTGFyZ2VGaWxlID1cbiAgc3RydWN0XG4gICAgZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX291dF82NFwiXG4gICAgZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50NjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgICBleHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5fNjRcIlxuICAgIGV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX2luXzY0XCJcbiAgICBleHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgZW5kXG5cbigqIEZvcm1hdHMgKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbiAgID0gRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm10XG4gICAgICAgICAgICAgICAqIHN0cmluZ1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxuXG5sZXQgc3RyaW5nX29mX2Zvcm1hdCAoRm9ybWF0IChfZm10LCBzdHIpKSA9IHN0clxuXG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCBeXiApIChGb3JtYXQgKGZtdDEsIHN0cjEpKSAoRm9ybWF0IChmbXQyLCBzdHIyKSkgPVxuICBGb3JtYXQgKENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5jb25jYXRfZm10IGZtdDEgZm10MixcbiAgICAgICAgICBzdHIxIF4gXCIlLFwiIF4gc3RyMilcblxuKCogTWlzY2VsbGFuZW91cyAqKVxuXG5leHRlcm5hbCBzeXNfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF9zeXNfZXhpdFwiXG5cbmxldCBleGl0X2Z1bmN0aW9uID0gcmVmIGZsdXNoX2FsbFxuXG5sZXQgYXRfZXhpdCBmID1cbiAgbGV0IGcgPSAhZXhpdF9mdW5jdGlvbiBpblxuICAoKiBNUFIjNzI1MywgTVBSIzc3OTY6IG1ha2Ugc3VyZSBcImZcIiBpcyBleGVjdXRlZCBvbmx5IG9uY2UgKilcbiAgbGV0IGZfYWxyZWFkeV9yYW4gPSByZWYgZmFsc2UgaW5cbiAgZXhpdF9mdW5jdGlvbiA6PVxuICAgIChmdW4gKCkgLT5cbiAgICAgIGlmIG5vdCAhZl9hbHJlYWR5X3JhbiB0aGVuIGJlZ2luIGZfYWxyZWFkeV9yYW4gOj0gdHJ1ZTsgZigpIGVuZDtcbiAgICAgIGcoKSlcblxubGV0IGRvX2F0X2V4aXQgKCkgPSAoIWV4aXRfZnVuY3Rpb24pICgpXG5cbmxldCBleGl0IHJldGNvZGUgPVxuICBkb19hdF9leGl0ICgpO1xuICBzeXNfZXhpdCByZXRjb2RlXG5cbmxldCBfID0gcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmRvX2F0X2V4aXRcIiBkb19hdF9leGl0XG5cbigqTU9EVUxFX0FMSUFTRVMqKVxubW9kdWxlIEFyZyAgICAgICAgICA9IEFyZ1xubW9kdWxlIEFycmF5ICAgICAgICA9IEFycmF5XG5tb2R1bGUgQXJyYXlMYWJlbHMgID0gQXJyYXlMYWJlbHNcbm1vZHVsZSBCaWdhcnJheSAgICAgPSBCaWdhcnJheVxubW9kdWxlIEJvb2wgICAgICAgICA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgID0gQ29tcGxleFxubW9kdWxlIERpZ2VzdCAgICAgICA9IERpZ2VzdFxubW9kdWxlIEVwaGVtZXJvbiAgICA9IEVwaGVtZXJvblxubW9kdWxlIEZpbGVuYW1lICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgPSBGb3JtYXRcbm1vZHVsZSBGdW4gICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgPSBHY1xubW9kdWxlIEdlbmxleCAgICAgICA9IEdlbmxleFxubW9kdWxlIEhhc2h0YmwgICAgICA9IEhhc2h0Ymxcbm1vZHVsZSBJbnQgICAgICAgICAgPSBJbnRcbm1vZHVsZSBJbnQzMiAgICAgICAgPSBJbnQzMlxubW9kdWxlIEludDY0ICAgICAgICA9IEludDY0XG5tb2R1bGUgTGF6eSAgICAgICAgID0gTGF6eVxubW9kdWxlIExleGluZyAgICAgICA9IExleGluZ1xubW9kdWxlIExpc3QgICAgICAgICA9IExpc3Rcbm1vZHVsZSBMaXN0TGFiZWxzICAgPSBMaXN0TGFiZWxzXG5tb2R1bGUgTWFwICAgICAgICAgID0gTWFwXG5tb2R1bGUgTWFyc2hhbCAgICAgID0gTWFyc2hhbFxubW9kdWxlIE1vcmVMYWJlbHMgICA9IE1vcmVMYWJlbHNcbm1vZHVsZSBOYXRpdmVpbnQgICAgPSBOYXRpdmVpbnRcbm1vZHVsZSBPYmogICAgICAgICAgPSBPYmpcbm1vZHVsZSBPbyAgICAgICAgICAgPSBPb1xubW9kdWxlIE9wdGlvbiAgICAgICA9IE9wdGlvblxubW9kdWxlIFBhcnNpbmcgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQZXJ2YXNpdmVzICAgPSBQZXJ2YXNpdmVzXG5tb2R1bGUgUHJpbnRleGMgICAgID0gUHJpbnRleGNcbm1vZHVsZSBQcmludGYgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSAgICAgICA9IFJhbmRvbVxubW9kdWxlIFJlc3VsdCAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICA9IFNjYW5mXG5tb2R1bGUgU2VxICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgID0gU2V0XG5tb2R1bGUgU3BhY2V0aW1lICAgID0gU3BhY2V0aW1lXG5tb2R1bGUgU3RhY2sgICAgICAgID0gU3RhY2tcbm1vZHVsZSBTdGRMYWJlbHMgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJlYW0gICAgICAgPSBTdHJlYW1cbm1vZHVsZSBTdHJpbmcgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgPSBTdHJpbmdMYWJlbHNcbm1vZHVsZSBTeXMgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgPSBVY2hhclxubW9kdWxlIFVuaXQgICAgICAgICA9IFVuaXRcbm1vZHVsZSBXZWFrICAgICAgICAgPSBXZWFrXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgIE5pY29sYXMgT2plZGEgQmFyLCBMZXhpRmkgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIG5lZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgYWRkIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCBzdWIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsIG11bCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgZGl2IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCByZW0gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZtYSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2ZtYV9mbG9hdFwiIFwiY2FtbF9mbWFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IGluZmluaXR5ID0gU3RkbGliLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gU3RkbGliLm5lZ19pbmZpbml0eVxubGV0IG5hbiA9IFN0ZGxpYi5uYW5cbmxldCBpc19maW5pdGUgKHg6IGZsb2F0KSA9IHggLS4geCA9IDAuXG5sZXQgaXNfaW5maW5pdGUgKHg6IGZsb2F0KSA9IDEuIC8uIHggPSAwLlxubGV0IGlzX25hbiAoeDogZmxvYXQpID0geCA8PiB4XG5cbmxldCBwaSA9IDB4MS45MjFmYjU0NDQyZDE4cCsxXG5sZXQgbWF4X2Zsb2F0ID0gU3RkbGliLm1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IFN0ZGxpYi5taW5fZmxvYXRcbmxldCBlcHNpbG9uID0gU3RkbGliLmVwc2lsb25fZmxvYXRcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmdfb3B0ID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ19vcHRcbmxldCB0b19zdHJpbmcgPSBTdGRsaWIuc3RyaW5nX29mX2Zsb2F0XG50eXBlIGZwY2xhc3MgPSBTdGRsaWIuZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcG93IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdHJ1bmMgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90cnVuY19mbG9hdFwiIFwiY2FtbF90cnVuY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCByb3VuZCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3JvdW5kX2Zsb2F0XCIgXCJjYW1sX3JvdW5kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbltAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBpc19pbnRlZ2VyIHggPSB4ID0gdHJ1bmMgeCAmJiBpc19maW5pdGUgeFxuXG5leHRlcm5hbCBuZXh0X2FmdGVyIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmV4dGFmdGVyX2Zsb2F0XCIgXCJjYW1sX25leHRhZnRlclwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBzdWNjIHggPSBuZXh0X2FmdGVyIHggaW5maW5pdHlcbmxldCBwcmVkIHggPSBuZXh0X2FmdGVyIHggbmVnX2luZmluaXR5XG5cbmV4dGVybmFsIGNvcHlfc2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2lnbl9iaXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gYm9vbFxuICA9IFwiY2FtbF9zaWduYml0X2Zsb2F0XCIgXCJjYW1sX3NpZ25iaXRcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxudHlwZSB0ID0gZmxvYXRcbmV4dGVybmFsIGNvbXBhcmUgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmxldCBlcXVhbCB4IHkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0W0BpbmxpbmVdIG1pbiAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4ICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4ICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIGlzX25hbiB4IHx8IGlzX25hbiB5IHRoZW4gKG5hbiwgbmFuKVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCwgeSkgZWxzZSAoeSwgeClcblxubGV0W0BpbmxpbmVdIG1pbl9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIGlzX25hbiB4IHRoZW4gKHkseSlcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuICh4LHgpXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LHkpIGVsc2UgKHkseClcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+IGludCAtPiBmbG9hdCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG5cbiAgdHlwZSB0ID0gZmxvYXRhcnJheVxuXG4gIGV4dGVybmFsIGxlbmd0aCA6IHQgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiB0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGxldCB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgZm9yIGkgPSBvZnMgdG8gb2ZzICsgbGVuIC0gMSBkbyB1bnNhZmVfc2V0IGEgaSB2IGRvbmVcblxuICBsZXQgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRvZnMgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNvZnMgKyBpKSlcbiAgICBkb25lXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICBsZXQgbWFwMiBmIGEgYiA9XG4gICAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICAgIGlmIGxhIDw+IGxiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyaSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gIGxldCBtYXBpIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW05hdGl2ZWludF06IHByb2Nlc3Nvci1uYXRpdmUgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X25lZ1wiXG5leHRlcm5hbCBhZGQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FkZFwiXG5leHRlcm5hbCBzdWI6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3N1YlwiXG5leHRlcm5hbCBtdWw6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X211bFwiXG5leHRlcm5hbCBkaXY6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2RpdlwiXG5leHRlcm5hbCByZW06IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X21vZFwiXG5leHRlcm5hbCBsb2dhbmQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FuZFwiXG5leHRlcm5hbCBsb2dvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNyXCJcbmV4dGVybmFsIG9mX2ludDogaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50OiBuYXRpdmVpbnQgLT4gaW50ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBuYXRpdmVpbnQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzI6IG5hdGl2ZWludCAtPiBpbnQzMiA9IFwiJW5hdGl2ZWludF90b19pbnQzMlwiXG5cbmxldCB6ZXJvID0gMG5cbmxldCBvbmUgPSAxblxubGV0IG1pbnVzX29uZSA9IC0xblxubGV0IHN1Y2MgbiA9IGFkZCBuIDFuXG5sZXQgcHJlZCBuID0gc3ViIG4gMW5cbmxldCBhYnMgbiA9IGlmIG4gPj0gMG4gdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBzaXplID0gU3lzLndvcmRfc2l6ZVxubGV0IG1pbl9pbnQgPSBzaGlmdF9sZWZ0IDFuIChzaXplIC0gMSlcbmxldCBtYXhfaW50ID0gc3ViIG1pbl9pbnQgMW5cbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMW4pXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IG5hdGl2ZWludFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGxpc3RzLiAqKVxudHlwZSAnYSB0ID0gJ2EgbGlzdCA9IFtdIHwgKDo6KSBvZiAnYSAqICdhIGxpc3RcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCByZXZfaW5pdF90aHJlc2hvbGQgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDEwXzAwMFxuICAoKiBXZSBkb24ndCBrbm93IHRoZSBzaXplIG9mIHRoZSBzdGFjaywgYmV0dGVyIGJlIHNhZmUgYW5kIGFzc3VtZSBpdCdzXG4gICAgIHNtYWxsLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG5cbmxldCBpbml0IGxlbiBmID1cbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5pbml0XCIgZWxzZVxuICBpZiBsZW4gPiByZXZfaW5pdF90aHJlc2hvbGQgdGhlbiByZXYgKGluaXRfdGFpbHJlY19hdXggW10gMCBsZW4gZilcbiAgZWxzZSBpbml0X2F1eCAwIGxlbiBmXG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBsOjpyIC0+IGwgQCBmbGF0dGVuIHJcblxubGV0IGNvbmNhdCA9IGZsYXR0ZW5cblxubGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBhIGluIHIgOjogbWFwIGYgbFxuXG5sZXQgcmVjIG1hcGkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGkgYSBpbiByIDo6IG1hcGkgKGkgKyAxKSBmIGxcblxubGV0IG1hcGkgZiBsID0gbWFwaSAwIGYgbFxuXG5sZXQgcmV2X21hcCBmIGwgPVxuICBsZXQgcmVjIHJtYXBfZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGE6OmwgLT4gcm1hcF9mIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBybWFwX2YgW10gbFxuXG5cbmxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBhOyBpdGVyIGYgbFxuXG5sZXQgcmVjIGl0ZXJpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgaSBhOyBpdGVyaSAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmkgZiBsID0gaXRlcmkgMCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2N1IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmb2xkX2xlZnQgZiAoZiBhY2N1IGEpIGxcblxubGV0IHJlYyBmb2xkX3JpZ2h0IGYgbCBhY2N1ID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZiBhIChmb2xkX3JpZ2h0IGYgbCBhY2N1KVxuXG5sZXQgcmVjIG1hcDIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gbGV0IHIgPSBmIGExIGEyIGluIHIgOjogbWFwMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcblxubGV0IHJldl9tYXAyIGYgbDEgbDIgPVxuICBsZXQgcmVjIHJtYXAyX2YgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgKFtdLCBbXSkgLT4gYWNjdVxuICAgIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBybWFwMl9mIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgcm1hcDJfZiBbXSBsMSBsMlxuXG5cbmxldCByZWMgaXRlcjIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiAoKVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMjsgaXRlcjIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuXG5sZXQgcmVjIGZvbGRfbGVmdDIgZiBhY2N1IGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGZvbGRfbGVmdDIgZiAoZiBhY2N1IGExIGEyKSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG5cbmxldCByZWMgZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1ID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTIgKGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSlcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfcmlnaHQyXCJcblxubGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IHRydWVcbiAgfCBhOjpsIC0+IHAgYSAmJiBmb3JfYWxsIHAgbFxuXG5sZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gcCBhIHx8IGV4aXN0cyBwIGxcblxubGV0IHJlYyBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IHRydWVcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgJiYgZm9yX2FsbDIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuXG5sZXQgcmVjIGV4aXN0czIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBmYWxzZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiB8fCBleGlzdHMyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuXG5sZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbSB4IGxcblxubGV0IHJlYyBtZW1xIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBhID09IHggfHwgbWVtcSB4IGxcblxubGV0IHJlYyBhc3NvYyB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBiIGVsc2UgYXNzb2MgeCBsXG5cbmxldCByZWMgYXNzb2Nfb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBTb21lIGIgZWxzZSBhc3NvY19vcHQgeCBsXG5cbmxldCByZWMgYXNzcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBiIGVsc2UgYXNzcSB4IGxcblxubGV0IHJlYyBhc3NxX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gU29tZSBiIGVsc2UgYXNzcV9vcHQgeCBsXG5cbmxldCByZWMgbWVtX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbV9hc3NvYyB4IGxcblxubGV0IHJlYyBtZW1fYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGEgPT0geCB8fCBtZW1fYXNzcSB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+XG4gICAgICBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzb2MgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+IGlmIGEgPT0geCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NxIHggbFxuXG5sZXQgcmVjIGZpbmQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggZWxzZSBmaW5kIHAgbFxuXG5sZXQgcmVjIGZpbmRfb3B0IHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZF9vcHQgcCBsXG5cbmxldCBmaW5kX2FsbCBwID1cbiAgbGV0IHJlYyBmaW5kIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2N1XG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIGZpbmQgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgYWNjdSBsIGluXG4gIGZpbmQgW11cblxubGV0IGZpbHRlciA9IGZpbmRfYWxsXG5cbmxldCBmaWx0ZXJfbWFwIGYgPVxuICBsZXQgcmVjIGF1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGF1eCBhY2N1IGxcbiAgICAgICAgfCBTb21lIHYgLT4gYXV4ICh2IDo6IGFjY3UpIGxcbiAgaW5cbiAgYXV4IFtdXG5cbmxldCBwYXJ0aXRpb24gcCBsID1cbiAgbGV0IHJlYyBwYXJ0IHllcyBubyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiB5ZXMsIHJldiBubylcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gcGFydCAoeCA6OiB5ZXMpIG5vIGwgZWxzZSBwYXJ0IHllcyAoeCA6OiBubykgbCBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHJlYyBzcGxpdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKFtdLCBbXSlcbiAgfCAoeCx5KTo6bCAtPlxuICAgICAgbGV0IChyeCwgcnkpID0gc3BsaXQgbCBpbiAoeDo6cngsIHk6OnJ5KVxuXG5sZXQgcmVjIGNvbWJpbmUgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IChhMSwgYTIpIDo6IGNvbWJpbmUgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmNvbWJpbmVcIlxuXG4oKiogc29ydGluZyAqKVxuXG5sZXQgcmVjIG1lcmdlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwyIC0+IGwyXG4gIHwgbDEsIFtdIC0+IGwxXG4gIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgdGhlbiBoMSA6OiBtZXJnZSBjbXAgdDEgbDJcbiAgICAgIGVsc2UgaDIgOjogbWVyZ2UgY21wIGwxIHQyXG5cblxubGV0IHJlYyBjaG9wIGsgbCA9XG4gIGlmIGsgPSAwIHRoZW4gbCBlbHNlIGJlZ2luXG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBfOjp0IC0+IGNob3AgKGstMSkgdFxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgZW5kXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiBfIC0+XG4gICAgICAgaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiBfIC0+XG4gICAgICAgaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICAgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2VfcmV2IHMxIHMyIFtdXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiBfIC0+XG4gICAgICAgaWYgY21wIHgxIHgyID4gMCB0aGVuIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICBlbmRcbiAgICB8IG4sIGwgLT5cbiAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgbGV0IGwyID0gY2hvcCBuMSBsIGluXG4gICAgICAgbGV0IHMxID0gc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gc29ydCBuMiBsMiBpblxuICAgICAgIHJldl9tZXJnZSBzMSBzMiBbXVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBzb3J0IGxlbiBsXG5cblxubGV0IHNvcnQgPSBzdGFibGVfc29ydFxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbigqIE5vdGU6IG9uIGEgbGlzdCBvZiBsZW5ndGggYmV0d2VlbiBhYm91dCAxMDAwMDAgKGRlcGVuZGluZyBvbiB0aGUgbWlub3JcbiAgIGhlYXAgc2l6ZSBhbmQgdGhlIHR5cGUgb2YgdGhlIGxpc3QpIGFuZCBTeXMubWF4X2FycmF5X3NpemUsIGl0IGlzXG4gICBhY3R1YWxseSBmYXN0ZXIgdG8gdXNlIHRoZSBmb2xsb3dpbmcsIGJ1dCBpdCBtaWdodCBhbHNvIHVzZSBtb3JlIG1lbW9yeVxuICAgYmVjYXVzZSB0aGUgYXJndW1lbnQgbGlzdCBjYW5ub3QgYmUgZGVhbGxvY2F0ZWQgaW5jcmVtZW50YWxseS5cblxuICAgQWxzbywgdGhlcmUgc2VlbXMgdG8gYmUgYSBidWcgaW4gdGhpcyBjb2RlIG9yIGluIHRoZVxuICAgaW1wbGVtZW50YXRpb24gb2Ygb2JqX3RydW5jYXRlLlxuXG5leHRlcm5hbCBvYmpfdHJ1bmNhdGUgOiAnYSBhcnJheSAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfdHJ1bmNhdGVcIlxuXG5sZXQgYXJyYXlfdG9fbGlzdF9pbl9wbGFjZSBhID1cbiAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgYWNjdSBuIHAgPVxuICAgIGlmIHAgPD0gMCB0aGVuIGFjY3UgZWxzZSBiZWdpblxuICAgICAgaWYgcCA9IG4gdGhlbiBiZWdpblxuICAgICAgICBvYmpfdHJ1bmNhdGUgYSBwO1xuICAgICAgICBsb29wIChhLihwLTEpIDo6IGFjY3UpIChuLTEwMDApIChwLTEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsb29wIChhLihwLTEpIDo6IGFjY3UpIG4gKHAtMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpblxuICBsb29wIFtdIChsLTEwMDApIGxcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgYSA9IEFycmF5Lm9mX2xpc3QgbCBpblxuICBBcnJheS5zdGFibGVfc29ydCBjbXAgYTtcbiAgYXJyYXlfdG9fbGlzdF9pbl9wbGFjZSBhXG5cbiopXG5cblxuKCoqIHNvcnRpbmcgKyByZW1vdmluZyBkdXBsaWNhdGVzICopXG5cbmxldCBzb3J0X3VuaXEgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2UgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlX3JldiB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiBfIC0+XG4gICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICBpZiBjID0gMCB0aGVuIFt4MV1cbiAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXVxuICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuIGJlZ2luXG4gICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICBsZXQgczIgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgIHJldl9tZXJnZV9yZXYgczEgczIgW11cbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiBfIC0+XG4gICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICBpZiBjID0gMCB0aGVuIFt4MV1cbiAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXVxuICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBpZiBjID4gMCB0aGVuIGJlZ2luXG4gICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHNvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2UgczEgczIgW11cbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2Ugc29ydCBsZW4gbFxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuOztcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aF93aXRoIGwgbiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgaWYgbiA9IDAgdGhlbiAwIGVsc2VcbiAgICAgIGlmIG4gPiAwIHRoZW4gLTEgZWxzZSAxXG4gIHwgXyA6OiBsIC0+XG4gICAgaWYgbiA8PSAwIHRoZW4gMSBlbHNlXG4gICAgICBjb21wYXJlX2xlbmd0aF93aXRoIGwgKG4tMSlcbjs7XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgbCA9XG4gIGxldCByZWMgYXV4IGwgKCkgPSBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFNlcS5OaWxcbiAgICB8IHggOjogdGFpbCAtPiBTZXEuQ29ucyAoeCwgYXV4IHRhaWwpXG4gIGluXG4gIGF1eCBsXG5cbmxldCBvZl9zZXEgc2VxID1cbiAgbGV0IHJlYyBkaXJlY3QgZGVwdGggc2VxIDogXyBsaXN0ID1cbiAgICBpZiBkZXB0aD0wXG4gICAgdGhlblxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gc2VxXG4gICAgICB8PiByZXYgKCogdGFpbHJlYyAqKVxuICAgIGVsc2UgbWF0Y2ggc2VxKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IFtdXG4gICAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPiB4IDo6IGRpcmVjdCAoZGVwdGgtMSkgbmV4dFxuICBpblxuICBkaXJlY3QgNTAwIHNlcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFNpbW9uIENydWFuZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW1NlcV06IGZ1bmN0aW9uYWwgaXRlcmF0b3JzICopXG5cbnR5cGUgKydhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlXG5cbmxldCBlbXB0eSAoKSA9IE5pbFxuXG5sZXQgcmV0dXJuIHggKCkgPSBDb25zICh4LCBlbXB0eSlcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKGYgeCwgbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICAgIHwgU29tZSB5IC0+IENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlciBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGlmIGYgeFxuICAgICAgdGhlbiBDb25zICh4LCBmaWx0ZXIgZiBuZXh0KVxuICAgICAgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgZmxhdF9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIGZsYXRfbWFwX2FwcCBmIChmIHgpIG5leHQgKClcblxuKCogdGhpcyBpcyBbYXBwZW5kIHNlcSAoZmxhdF9tYXAgZiB0YWlsKV0gKilcbmFuZCBmbGF0X21hcF9hcHAgZiBzZXEgdGFpbCAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IGZsYXRfbWFwIGYgdGFpbCAoKVxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgQ29ucyAoeCwgZmxhdF9tYXBfYXBwIGYgbmV4dCB0YWlsKVxuXG5sZXQgZm9sZF9sZWZ0IGYgYWNjIHNlcSA9XG4gIGxldCByZWMgYXV4IGYgYWNjIHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBhdXggZiBhY2MgbmV4dFxuICBpblxuICBhdXggZiBhY2Mgc2VxXG5cbmxldCBpdGVyIGYgc2VxID1cbiAgbGV0IHJlYyBhdXggc2VxID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBhdXggbmV4dFxuICBpblxuICBhdXggc2VxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIG9wdGlvbiA9IE5vbmUgfCBTb21lIG9mICdhXG5cbmxldCBub25lID0gTm9uZVxubGV0IHNvbWUgdiA9IFNvbWUgdlxubGV0IHZhbHVlIG8gfmRlZmF1bHQgPSBtYXRjaCBvIHdpdGggU29tZSB2IC0+IHYgfCBOb25lIC0+IGRlZmF1bHRcbmxldCBnZXQgPSBmdW5jdGlvbiBTb21lIHYgLT4gdiB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJvcHRpb24gaXMgTm9uZVwiXG5sZXQgYmluZCBvIGYgPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IGYgdlxubGV0IGpvaW4gPSBmdW5jdGlvbiBTb21lIChTb21lIF8gYXMgbykgLT4gbyB8IF8gLT4gTm9uZVxubGV0IG1hcCBmIG8gPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IFNvbWUgKGYgdilcbmxldCBmb2xkIH5ub25lIH5zb21lID0gZnVuY3Rpb24gU29tZSB2IC0+IHNvbWUgdiB8IE5vbmUgLT4gbm9uZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBmIHYgfCBOb25lIC0+ICgpXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gdHJ1ZSB8IFNvbWUgXyAtPiBmYWxzZVxubGV0IGlzX3NvbWUgPSBmdW5jdGlvbiBOb25lIC0+IGZhbHNlIHwgU29tZSBfIC0+IHRydWVcblxubGV0IGVxdWFsIGVxIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBlcSB2MCB2MVxufCBOb25lLCBOb25lIC0+IHRydWVcbnwgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSBjbXAgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGNtcCB2MCB2MVxufCBOb25lLCBOb25lIC0+IDBcbnwgTm9uZSwgU29tZSBfIC0+IC0xXG58IFNvbWUgXywgTm9uZSAtPiAxXG5cbmxldCB0b19yZXN1bHQgfm5vbmUgPSBmdW5jdGlvbiBOb25lIC0+IEVycm9yIG5vbmUgfCBTb21lIHYgLT4gT2sgdlxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBOb25lIC0+IFtdIHwgU29tZSB2IC0+IFt2XVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE5vbmUgLT4gU2VxLmVtcHR5IHwgU29tZSB2IC0+IFNlcS5yZXR1cm4gdlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdlXG5cbmxldCBvayB2ID0gT2sgdlxubGV0IGVycm9yIGUgPSBFcnJvciBlXG5sZXQgdmFsdWUgciB+ZGVmYXVsdCA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGRlZmF1bHRcbmxldCBnZXRfb2sgPSBmdW5jdGlvbiBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIEVycm9yIF9cIlxubGV0IGdldF9lcnJvciA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZSB8IE9rIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgT2sgX1wiXG5sZXQgYmluZCByIGYgPSBtYXRjaCByIHdpdGggT2sgdiAtPiBmIHYgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IGpvaW4gPSBmdW5jdGlvbiBPayByIC0+IHIgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcCBmID0gZnVuY3Rpb24gT2sgdiAtPiBPayAoZiB2KSB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IEVycm9yIChmIGUpIHwgT2sgXyBhcyB2IC0+IHZcbmxldCBmb2xkIH5vayB+ZXJyb3IgPSBmdW5jdGlvbiBPayB2IC0+IG9rIHYgfCBFcnJvciBlIC0+IGVycm9yIGVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBPayB2IC0+IGYgdiB8IEVycm9yIF8gLT4gKClcbmxldCBpdGVyX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGYgZSB8IE9rIF8gLT4gKClcbmxldCBpc19vayA9IGZ1bmN0aW9uIE9rIF8gLT4gdHJ1ZSB8IEVycm9yIF8gLT4gZmFsc2VcbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uIEVycm9yIF8gLT4gdHJ1ZSB8IE9rIF8gLT4gZmFsc2VcblxubGV0IGVxdWFsIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IF8sIF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgT2sgXywgRXJyb3IgXyAtPiAtMVxufCBFcnJvciBfLCBPayBfIC0+IDFcblxubGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uIE9rIHYgLT4gU29tZSB2IHwgRXJyb3IgXyAtPiBOb25lXG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE9rIHYgLT4gW3ZdIHwgRXJyb3IgXyAtPiBbXVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE9rIHYgLT4gU2VxLnJldHVybiB2IHwgRXJyb3IgXyAtPiBTZXEuZW1wdHlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gYm9vbCA9IGZhbHNlIHwgdHJ1ZVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5sZXQgZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxubGV0IHRvX2ludCA9IGZ1bmN0aW9uIGZhbHNlIC0+IDAgfCB0cnVlIC0+IDFcbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uIGZhbHNlIC0+IDAuIHwgdHJ1ZSAtPiAxLlxuXG4oKlxubGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG58IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG58IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxufCBfIC0+IE5vbmVcbiopXG5cbmxldCB0b19zdHJpbmcgPSBmdW5jdGlvbiBmYWxzZSAtPiBcImZhbHNlXCIgfCB0cnVlIC0+IFwidHJ1ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlIGMgPVxuICBpZiAoYyA+PSAnQScgJiYgYyA8PSAnWicpXG4gIHx8IChjID49ICdcXDE5MicgJiYgYyA8PSAnXFwyMTQnKVxuICB8fCAoYyA+PSAnXFwyMTYnICYmIGMgPD0gJ1xcMjIyJylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICBlbHNlIGNcblxubGV0IHVwcGVyY2FzZSBjID1cbiAgaWYgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKVxuICB8fCAoYyA+PSAnXFwyMjQnICYmIGMgPD0gJ1xcMjQ2JylcbiAgfHwgKGMgPj0gJ1xcMjQ4JyAmJiBjIDw9ICdcXDI1NCcpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgZWxzZSBjXG5cbmxldCBsb3dlcmNhc2VfYXNjaWkgYyA9XG4gIGlmIChjID49ICdBJyAmJiBjIDw9ICdaJylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICBlbHNlIGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBjID1cbiAgaWYgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIGVsc2UgY1xuXG50eXBlIHQgPSBjaGFyXG5cbmxldCBjb21wYXJlIGMxIGMyID0gY29kZSBjMSAtIGNvZGUgYzJcbmxldCBlcXVhbCAoYzE6IHQpIChjMjogdCkgPSBjb21wYXJlIGMxIGMyID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBCeXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBzdHJpbmcubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZyA6IHN0cmluZyAtPiBieXRlcyA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgbWFrZSBuIGMgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIHVuc2FmZV9maWxsIHMgMCBuIGM7XG4gIHNcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHMgaSAoZiBpKVxuICBkb25lO1xuICBzXG5cbmxldCBlbXB0eSA9IGNyZWF0ZSAwXG5cbmxldCBjb3B5IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0IHMgMCByIDAgbGVuO1xuICByXG5cbmxldCB0b19zdHJpbmcgYiA9IHVuc2FmZV90b19zdHJpbmcgKGNvcHkgYilcbmxldCBvZl9zdHJpbmcgcyA9IGNvcHkgKHVuc2FmZV9vZl9zdHJpbmcgcylcblxubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5zdWIgLyBCeXRlcy5zdWJcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgICByXG4gIGVuZFxuXG5sZXQgc3ViX3N0cmluZyBiIG9mcyBsZW4gPSB1bnNhZmVfdG9fc3RyaW5nIChzdWIgYiBvZnMgbGVuKVxuXG4oKiBhZGRpdGlvbiB3aXRoIGFuIG92ZXJmbG93IGNoZWNrICopXG5sZXQgKCsrKSBhIGIgPVxuICBsZXQgYyA9IGEgKyBiIGluXG4gIG1hdGNoIGEgPCAwLCBiIDwgMCwgYyA8IDAgd2l0aFxuICB8IHRydWUgLCB0cnVlICwgZmFsc2VcbiAgfCBmYWxzZSwgZmFsc2UsIHRydWUgIC0+IGludmFsaWRfYXJnIFwiQnl0ZXMuZXh0ZW5kXCIgKCogb3ZlcmZsb3cgKilcbiAgfCBfIC0+IGNcblxubGV0IGV4dGVuZCBzIGxlZnQgcmlnaHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgKysgbGVmdCArKyByaWdodCBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgbGV0IChzcmNvZmYsIGRzdG9mZikgPSBpZiBsZWZ0IDwgMCB0aGVuIC1sZWZ0LCAwIGVsc2UgMCwgbGVmdCBpblxuICBsZXQgY3B5bGVuID0gbWluIChsZW5ndGggcyAtIHNyY29mZikgKGxlbiAtIGRzdG9mZikgaW5cbiAgaWYgY3B5bGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IHMgc3Jjb2ZmIHIgZHN0b2ZmIGNweWxlbjtcbiAgclxuXG5sZXQgZmlsbCBzIG9mcyBsZW4gYyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmZpbGwgLyBCeXRlcy5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBzIG9mcyBsZW4gY1xuXG5sZXQgYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG5sZXQgYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IHN0cmluZ19sZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuYmxpdCAvIEJ5dGVzLmJsaXRfc3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiQnl0ZXMuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBlbXB0eVxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChjcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCBzMSBzMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBzMSBpblxuICBsZXQgbDIgPSBsZW5ndGggczIgaW5cbiAgbGV0IHIgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gIHVuc2FmZV9ibGl0IHMxIDAgciAwIGwxO1xuICB1bnNhZmVfYmxpdCBzMiAwIHIgbDEgbDI7XG4gIHJcblxuXG5leHRlcm5hbCBjaGFyX2NvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgY2hhcl9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGxldCBqID0gcmVmIChsZW4gLSAxKSBpblxuICB3aGlsZSAhaiA+PSAhaSAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFqKSBkb1xuICAgIGRlY3IgalxuICBkb25lO1xuICBpZiAhaiA+PSAhaSB0aGVuXG4gICAgc3ViIHMgIWkgKCFqIC0gIWkgKyAxKVxuICBlbHNlXG4gICAgZW1wdHlcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIG4gOj0gIW4gK1xuICAgICAgKG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgIHwgXyAtPiA0KVxuICBkb25lO1xuICBpZiAhbiA9IGxlbmd0aCBzIHRoZW4gY29weSBzIGVsc2UgYmVnaW5cbiAgICBsZXQgcycgPSBjcmVhdGUgIW4gaW5cbiAgICBuIDo9IDA7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgYmVnaW4gbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgIHwgKCcgJyAuLiAnficpIGFzIGMgLT4gdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8IGMgLT5cbiAgICAgICAgICBsZXQgYSA9IGNoYXJfY29kZSBjIGluXG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgLyAxMDApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgKGEgLyAxMCkgbW9kIDEwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgbW9kIDEwKSk7XG4gICAgICBlbmQ7XG4gICAgICBpbmNyIG5cbiAgICBkb25lO1xuICAgIHMnXG4gIGVuZFxuXG5sZXQgbWFwIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcGkgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgYXBwbHkxIGYgcyA9XG4gIGlmIGxlbmd0aCBzID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY29weSBzIGluXG4gICAgdW5zYWZlX3NldCByIDAgKGYodW5zYWZlX2dldCBzIDApKTtcbiAgICByXG4gIGVuZFxuXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbnR5cGUgdCA9IGJ5dGVzXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2wgPSBcImNhbWxfYnl0ZXNfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgbG93ZXJjYXNlIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2Ugc1xuXG5sZXQgY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlIHNcbmxldCB1bmNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZSBzXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBsZXQgYnVmID0gcmVmIChtYWtlIDI1NiAnXFwwMDAnKSBpblxuICBsZXQgcmVzaXplICgpID1cbiAgICAoKiByZXNpemUgKilcbiAgICBsZXQgbmV3X2xlbiA9IG1pbiAoMiAqIGxlbmd0aCAhYnVmKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICBpZiBsZW5ndGggIWJ1ZiA9IG5ld19sZW4gdGhlbiBmYWlsd2l0aCBcIkJ5dGVzLm9mX3NlcTogY2Fubm90IGdyb3cgYnl0ZXNcIjtcbiAgICBsZXQgbmV3X2J1ZiA9IG1ha2UgbmV3X2xlbiAnXFwwMDAnIGluXG4gICAgYmxpdCAhYnVmIDAgbmV3X2J1ZiAwICFuO1xuICAgIGJ1ZiA6PSBuZXdfYnVmXG4gIGluXG4gIFNlcS5pdGVyXG4gICAgKGZ1biBjIC0+XG4gICAgICAgaWYgIW4gPSBsZW5ndGggIWJ1ZiB0aGVuIHJlc2l6ZSgpO1xuICAgICAgIHNldCAhYnVmICFuIGM7XG4gICAgICAgaW5jciBuKVxuICAgIGk7XG4gIHN1YiAhYnVmIDAgIW5cblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX2J5dGVzX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjRcIlxuZXh0ZXJuYWwgc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBzZXRfaW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2XCJcbmV4dGVybmFsIHNldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMlwiXG5leHRlcm5hbCBzZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjRcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0IGdldF9pbnQ4IGIgaSA9XG4gICgoZ2V0X3VpbnQ4IGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSA4KSkgYXNyIChTeXMuaW50X3NpemUgLSA4KVxuXG5sZXQgZ2V0X3VpbnQxNl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF91aW50MTZfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X2ludDE2X25lIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9uZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2xlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9sZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2JlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9iZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDMyX2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQzMl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgc2V0X2ludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQxNl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X3VpbnQ4ID0gc2V0X2ludDhcbmxldCBzZXRfdWludDE2X25lID0gc2V0X2ludDE2X25lXG5sZXQgc2V0X3VpbnQxNl9iZSA9IHNldF9pbnQxNl9iZVxubGV0IHNldF91aW50MTZfbGUgPSBzZXRfaW50MTZfbGVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU3RyaW5nIG9wZXJhdGlvbnMsIGJhc2VkIG9uIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gYnl0ZXMubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogc3RyaW5nIC0+IGludCAtPiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbm1vZHVsZSBCID0gQnl0ZXNcblxubGV0IGJ0cyA9IEIudW5zYWZlX3RvX3N0cmluZ1xubGV0IGJvcyA9IEIudW5zYWZlX29mX3N0cmluZ1xuXG5sZXQgbWFrZSBuIGMgPVxuICBCLm1ha2UgbiBjIHw+IGJ0c1xubGV0IGluaXQgbiBmID1cbiAgQi5pbml0IG4gZiB8PiBidHNcbmxldCBjb3B5IHMgPVxuICBCLmNvcHkgKGJvcyBzKSB8PiBidHNcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGZpbGwgPVxuICBCLmZpbGxcbmxldCBibGl0ID1cbiAgQi5ibGl0X3N0cmluZ1xuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IFwiXCJcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluIGJ0cyBAQFxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKEIuY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXJpIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG5sZXQgbWFwIGYgcyA9XG4gIEIubWFwIGYgKGJvcyBzKSB8PiBidHNcbmxldCBtYXBpIGYgcyA9XG4gIEIubWFwaSBmIChib3MgcykgfD4gYnRzXG5cbigqIEJld2FyZTogd2UgY2Fubm90IHVzZSBCLnRyaW0gb3IgQi5lc2NhcGUgYmVjYXVzZSB0aGV5IGFsd2F5cyBtYWtlIGFcbiAgIGNvcHksIGJ1dCBTdHJpbmcubWxpIHNwZWxscyBvdXQgc29tZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbm90IGFsbG93ZWRcbiAgIHRvIG1ha2UgYSBjb3B5LiAqKVxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGlmIHMgPSBcIlwiIHRoZW4gc1xuICBlbHNlIGlmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgMCkgfHwgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAobGVuZ3RoIHMgLSAxKSlcbiAgICB0aGVuIGJ0cyAoQi50cmltIChib3MgcykpXG4gIGVsc2Ugc1xuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IHJlYyBlc2NhcGVfaWZfbmVlZGVkIHMgbiBpID1cbiAgICBpZiBpID49IG4gdGhlbiBzIGVsc2VcbiAgICAgIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcMDAwJy4uJ1xcMDMxJyB8ICdcXDEyNycuLiAnXFwyNTUnIC0+XG4gICAgICAgICAgYnRzIChCLmVzY2FwZWQgKGJvcyBzKSlcbiAgICAgIHwgXyAtPiBlc2NhcGVfaWZfbmVlZGVkIHMgbiAoaSsxKVxuICBpblxuICBlc2NhcGVfaWZfbmVlZGVkIHMgKGxlbmd0aCBzKSAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID1cbiAgQi51cHBlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9XG4gIEIubG93ZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLnVuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3RyaW5nX2VxdWFsXCIgW0BAbm9hbGxvY11cblxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID1cbiAgQi51cHBlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2UgcyA9XG4gIEIubG93ZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZSBzID1cbiAgQi5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplIHMgPVxuICBCLnVuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBib3MgcyB8PiBCLnRvX3NlcVxuXG5sZXQgdG9fc2VxaSBzID0gYm9zIHMgfD4gQi50b19zZXFpXG5cbmxldCBvZl9zZXEgZyA9IEIub2Zfc2VxIGcgfD4gYnRzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IHVuaXQgPSAoKVxuXG5sZXQgZXF1YWwgKCkgKCkgPSB0cnVlXG5sZXQgY29tcGFyZSAoKSAoKSA9IDBcbmxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBleHRlcm5fZmxhZ3MgPVxuICAgIE5vX3NoYXJpbmdcbiAgfCBDbG9zdXJlc1xuICB8IENvbXBhdF8zMlxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAncnVudGltZS9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlc1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXNcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDIwXG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogT3BlcmF0aW9ucyBvbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbnMgb2YgdmFsdWVzICopXG5cbnR5cGUgdFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIlxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCBuZXdfYmxvY2sgOiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfb2JqX2Jsb2NrXCJcbmV4dGVybmFsIGR1cCA6IHQgLT4gdCA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIHRydW5jYXRlIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfdHJ1bmNhdGVcIlxuZXh0ZXJuYWwgYWRkX29mZnNldCA6IHQgLT4gSW50MzIudCAtPiB0ID0gXCJjYW1sX29ial9hZGRfb2Zmc2V0XCJcblxubGV0IG1hcnNoYWwgKG9iaiA6IHQpID1cbiAgTWFyc2hhbC50b19ieXRlcyBvYmogW11cbmxldCB1bm1hcnNoYWwgc3RyIHBvcyA9XG4gIChNYXJzaGFsLmZyb21fYnl0ZXMgc3RyIHBvcywgcG9zICsgTWFyc2hhbC50b3RhbF9zaXplIHN0ciBwb3MpXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBFeHRlbnNpb25fY29uc3RydWN0b3IgPVxuc3RydWN0XG4gIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuICBsZXQgb2ZfdmFsIHggPVxuICAgIGxldCB4ID0gcmVwciB4IGluXG4gICAgbGV0IHNsb3QgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHgpICYmICh0YWcgeCkgPD4gb2JqZWN0X3RhZyAmJiAoc2l6ZSB4KSA+PSAxIHRoZW4gZmllbGQgeCAwXG4gICAgICBlbHNlIHhcbiAgICBpblxuICAgIGxldCBuYW1lID1cbiAgICAgIGlmIChpc19ibG9jayBzbG90KSAmJiAodGFnIHNsb3QpID0gb2JqZWN0X3RhZyB0aGVuIGZpZWxkIHNsb3QgMFxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuICAgIGluXG4gICAgICBpZiAodGFnIG5hbWUpID0gc3RyaW5nX3RhZyB0aGVuIChvYmogc2xvdCA6IHQpXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gbmFtZSAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAwKSA6IHN0cmluZylcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBpZCAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAxKSA6IGludClcbmVuZFxuXG5sZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbFxubGV0IGV4dGVuc2lvbl9uYW1lID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm5hbWVcbmxldCBleHRlbnNpb25faWQgPSBFeHRlbnNpb25fY29uc3RydWN0b3IuaWRcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgICgqKiBUbyBjaGFuZ2UgaW4gc3luYyB3aXRoIHdlYWsuaCAqKVxuICBsZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG4gIGxldCBtYXhfZXBoZV9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZXBoZV9jcmVhdGVcIjs7XG4gIGxldCBjcmVhdGUgbCA9XG4gICAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBtYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5jcmVhdGVcIjtcbiAgICBjcmVhdGUgbFxuXG4gIGxldCBsZW5ndGggeCA9IHNpemUocmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgbGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICAgIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgbXNnXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleVwiXG4gIGxldCBnZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5XCI7XG4gICAgZ2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBnZXRfa2V5X2NvcHk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlfY29weVwiXG4gIGxldCBnZXRfa2V5X2NvcHkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlfY29weVwiO1xuICAgIGdldF9rZXlfY29weSBlIG9cblxuICBleHRlcm5hbCBzZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG4gIGxldCBzZXRfa2V5IGUgbyB4ID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnNldF9rZXlcIjtcbiAgICBzZXRfa2V5IGUgbyB4XG5cbiAgZXh0ZXJuYWwgdW5zZXRfa2V5OiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbiAgbGV0IHVuc2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24udW5zZXRfa2V5XCI7XG4gICAgdW5zZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGNoZWNrX2tleTogdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2tleVwiXG4gIGxldCBjaGVja19rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmNoZWNrX2tleVwiO1xuICAgIGNoZWNrX2tleSBlIG9cblxuICBleHRlcm5hbCBibGl0X2tleSA6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgPSBcImNhbWxfZXBoZV9ibGl0X2tleVwiXG5cbiAgbGV0IGJsaXRfa2V5IGUxIG8xIGUyIG8yIGwgPVxuICAgIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uYmxpdF9rZXlcIlxuICAgIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdF9rZXkgZTEgbzEgZTIgbzIgbFxuXG4gIGV4dGVybmFsIGdldF9kYXRhOiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhXCJcbiAgZXh0ZXJuYWwgZ2V0X2RhdGFfY29weTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2RhdGE6IHQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9kYXRhXCJcbiAgZXh0ZXJuYWwgdW5zZXRfZGF0YTogdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfZGF0YVwiXG4gIGV4dGVybmFsIGNoZWNrX2RhdGE6IHQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2RhdGFcIlxuICBleHRlcm5hbCBibGl0X2RhdGEgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX2JsaXRfZGF0YVwiXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5sZXQgbWFrZV9mbG9hdCA9IGNyZWF0ZV9mbG9hdFxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjcmVhdGVfbWF0cml4ID0gbWFrZV9tYXRyaXhcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0yKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbnRcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5leHRlcm5hbCBuZWcgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsIGFkZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIHN1YiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsIG11bCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsIGRpdiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsIHJlbSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcbmV4dGVybmFsIGxvZ2FuZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsIGxvZ29yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG9nbm90IHggPSBsb2d4b3IgeCAoLTEpXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5cbigqXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmcgcyA9IHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcbiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmxldCB0b19zdHJpbmcgeCA9IGZvcm1hdF9pbnQgXCIlZFwiIHhcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQzMl06IDMyLWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQzMiA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQzMiAtPiBpbnQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfdG9fZmxvYXRcIiBcImNhbWxfaW50MzJfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHplcm8gPSAwbFxubGV0IG9uZSA9IDFsXG5sZXQgbWludXNfb25lID0gLTFsXG5sZXQgc3VjYyBuID0gYWRkIG4gMWxcbmxldCBwcmVkIG4gPSBzdWIgbiAxbFxubGV0IGFicyBuID0gaWYgbiA+PSAwbCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwbFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGbFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbClcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIG1hdGNoIFN5cy53b3JkX3NpemUgd2l0aFxuICB8IDMyIC0+XG4gICAgICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICAgICAgZnVuIG4gLT5cbiAgICAgICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgICAgICBTb21lICh0b19pbnQgbilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE5vbmVcbiAgfCA2NCAtPlxuICAgICAgKCogU28gdGhhdCBpdCBjb21waWxlcyBpbiAzMi1iaXQgKilcbiAgICAgIGxldCBtb3ZlID0gaW50X29mX3N0cmluZyBcIjB4MV8wMDAwXzAwMDBcIiBpblxuICAgICAgZnVuIG4gLT4gbGV0IGkgPSB0b19pbnQgbiBpbiBTb21lIChpZiBpIDwgMCB0aGVuIGkgKyBtb3ZlIGVsc2UgaSlcbiAgfCBfIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZyA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMiA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gaW50MzJcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG5vcGVuIExleGluZ1xuXG4oKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gdGhlIHBhcnNpbmcgZW5naW5lICopXG5cbnR5cGUgcGFyc2VyX2VudiA9XG4gIHsgbXV0YWJsZSBzX3N0YWNrIDogaW50IGFycmF5OyAgICAgICAgKCogU3RhdGVzICopXG4gICAgbXV0YWJsZSB2X3N0YWNrIDogT2JqLnQgYXJyYXk7ICAgICAgKCogU2VtYW50aWMgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAoKiBTdGFydCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kX3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICAgKCogRW5kIHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3RhY2tzaXplIDogaW50OyAgICAgICAgICAgICgqIFNpemUgb2YgdGhlIHN0YWNrcyAqKVxuICAgIG11dGFibGUgc3RhY2tiYXNlIDogaW50OyAgICAgICAgICAgICgqIEJhc2Ugc3AgZm9yIGN1cnJlbnQgcGFyc2UgKilcbiAgICBtdXRhYmxlIGN1cnJfY2hhciA6IGludDsgICAgICAgICAgICAoKiBMYXN0IHRva2VuIHJlYWQgKilcbiAgICBtdXRhYmxlIGx2YWwgOiBPYmoudDsgICAgICAgICAgICAgICAoKiBJdHMgc2VtYW50aWMgYXR0cmlidXRlICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0IDogcG9zaXRpb247ICAgICAgKCogU3RhcnQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wqKVxuICAgIG11dGFibGUgc3ltYl9lbmQgOiBwb3NpdGlvbjsgICAgICAgICgqIEVuZCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCAqKVxuICAgIG11dGFibGUgYXNwIDogaW50OyAgICAgICAgICAgICAgICAgICgqIFRoZSBzdGFjayBwb2ludGVyIGZvciBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBydWxlX2xlbiA6IGludDsgICAgICAgICAgICAgKCogTnVtYmVyIG9mIHJocyBpdGVtcyBpbiB0aGUgcnVsZSAqKVxuICAgIG11dGFibGUgcnVsZV9udW1iZXIgOiBpbnQ7ICAgICAgICAgICgqIFJ1bGUgbnVtYmVyIHRvIHJlZHVjZSBieSAqKVxuICAgIG11dGFibGUgc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgICgqIFNhdmVkIHNwIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIHN0YXRlIDogaW50OyAgICAgICAgICAgICAgICAoKiBTYXZlZCBzdGF0ZSBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBlcnJmbGFnIDogaW50IH0gICAgICAgICAgICAgKCogU2F2ZWQgZXJyb3IgZmxhZyBmb3IgcGFyc2VfZW5naW5lICopXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogZWx0IFNlcS50IC0+IHQgLT4gdFxuICAgIHZhbCBvZl9zZXEgOiBlbHQgU2VxLnQgLT4gdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGVsdCA9IE9yZC50XG4gICAgdHlwZSB0ID0gRW1wdHkgfCBOb2RlIG9mIHtsOnQ7IHY6ZWx0OyByOnQ7IGg6aW50fVxuXG4gICAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGVcbiAgICAgICBjaGlsZHJlbiBkaWZmZXIgYnkgYXQgbW9zdCAyICopXG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgICBXZSBtdXN0IGhhdmUgYWxsIGVsZW1lbnRzIG9mIGwgPCB2IDwgYWxsIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgaGVpZ2h0IGZvciBiZXR0ZXIgc3BlZWQuICopXG5cbiAgICBsZXQgY3JlYXRlIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGNyZWF0ZSBmb3IgYmV0dGVyIHNwZWVkIGluIHRoZSBtb3N0IGZyZXF1ZW50IGNhc2VcbiAgICAgICB3aGVyZSBubyByZWJhbGFuY2luZyBpcyByZXF1aXJlZC4gKilcblxuICAgIGxldCBiYWwgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IChjcmVhdGUgbHIgdiByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxybCkgbHJ2IChjcmVhdGUgbHJyIHYgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmwpIHJ2IHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICAgIGxldCByZWMgYWRkIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdCBlbHNlXG4gICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHQgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHQgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgc2luZ2xldG9uIHggPSBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCB2IGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGVsZW1lbnRzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGVsZW1lbnQuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9lbGVtZW50IHggbCkgdiByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiAoYWRkX21heF9lbGVtZW50IHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2VsZW1lbnQgdiByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9lbGVtZW50IHYgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyByPWxyOyBoPWxofSwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgcmwpIHJ2IHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IHJcblxuICAgICgqIFNtYWxsZXN0IGFuZCBncmVhdGVzdCBlbGVtZW50IG9mIGEgc2V0ICopXG5cbiAgICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdCBsXG5cbiAgICBsZXQgcmVjIG1pbl9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHRfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0IHJcblxuICAgIGxldCByZWMgbWF4X2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdF9vcHQgclxuXG4gICAgKCogUmVtb3ZlIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBzZXQgKilcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgdiByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBiYWwgdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogU3BsaXR0aW5nLiAgc3BsaXQgeCBzIHJldHVybnMgYSB0cmlwbGUgKGwsIHByZXNlbnQsIHIpIHdoZXJlXG4gICAgICAgIC0gbCBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPCB4XG4gICAgICAgIC0gciBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPiB4XG4gICAgICAgIC0gcHJlc2VudCBpcyBmYWxzZSBpZiBzIGNvbnRhaW5zIG5vIGVsZW1lbnQgZXF1YWwgdG8geCxcbiAgICAgICAgICBvciB0cnVlIGlmIHMgY29udGFpbnMgYW4gZWxlbWVudCBlcXVhbCB0byB4LiAqKVxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIGZhbHNlLCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgdHJ1ZSwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgbHIsIHByZXMsIHJyKVxuXG4gICAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSBhcyB0KSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW5cbiAgICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0MikgLT4gdDJcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMTsgaD1oMX0sIE5vZGV7bD1sMjsgdj12Mjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxIHRoZW4gYWRkIHYyIHMxIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMiwgXywgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGgxID0gMSB0aGVuIGFkZCB2MSBzMiBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDEsIF8sIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MiAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8IChfLCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKVxuXG4gICAgKCogU2FtZSBhcyBzcGxpdCwgYnV0IGNvbXB1dGUgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzXG4gICAgICAgb25seSBpZiB0aGUgcGl2b3QgZWxlbWVudCBpcyBub3QgaW4gdGhlIHNldC4gIFRoZSByaWdodCBzdWJ0cmVlXG4gICAgICAgaXMgY29tcHV0ZWQgb24gZGVtYW5kLiAqKVxuXG4gICAgdHlwZSBzcGxpdF9iaXMgPVxuICAgICAgfCBGb3VuZFxuICAgICAgfCBOb3RGb3VuZCBvZiB0ICogKHVuaXQgLT4gdClcblxuICAgIGxldCByZWMgc3BsaXRfYmlzIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vdEZvdW5kIChFbXB0eSwgKGZ1biAoKSAtPiBFbXB0eSkpXG4gICAgICB8IE5vZGV7bDsgdjsgcjsgX30gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gRm91bmRcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IGwgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobGwsIHJsKSAtPiBOb3RGb3VuZCAobGwsIChmdW4gKCkgLT4gam9pbiAocmwgKCkpIHYgcikpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggciB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsciwgcnIpIC0+IE5vdEZvdW5kIChqb2luIGwgdiBsciwgcnIpXG5cbiAgICBsZXQgcmVjIGRpc2pvaW50IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSB8IChfLCBFbXB0eSkgLT4gdHJ1ZVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgaWYgczEgPT0gczIgdGhlbiBmYWxzZVxuICAgICAgICAgIGVsc2UgbWF0Y2ggc3BsaXRfYmlzIHYxIHQyIHdpdGhcbiAgICAgICAgICAgICAgTm90Rm91bmQobDIsIHIyKSAtPiBkaXNqb2ludCBsMSBsMiAmJiBkaXNqb2ludCByMSAocjIgKCkpXG4gICAgICAgICAgICB8IEZvdW5kIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKVxuXG4gICAgdHlwZSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2YgZWx0ICogdCAqIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCByLCBlKSlcblxuICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgfCAoTW9yZSh2MSwgcjEsIGUxKSwgTW9yZSh2MiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuXG4gICAgbGV0IGNvbXBhcmUgczEgczIgPVxuICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSBzMSBFbmQpIChjb25zX2VudW0gczIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIHMxIHMyID1cbiAgICAgIGNvbXBhcmUgczEgczIgPSAwXG5cbiAgICBsZXQgcmVjIHN1YnNldCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIEVtcHR5LCBfIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w9bDE7IHY9djE7IHI9cjF9LCAoTm9kZSB7bD1sMjsgdj12Mjsgcj1yMn0gYXMgdDIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCBsMSBsMiAmJiBzdWJzZXQgcjEgcjJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1sMTsgdj12MTsgcj1FbXB0eTsgaD0wfSkgbDIgJiYgc3Vic2V0IHIxIHQyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPUVtcHR5OyB2PXYxOyByPXIxOyBoPTB9KSByMiAmJiBzdWJzZXQgbDEgdDJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBpdGVyIGYgbDsgZiB2OyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBmb2xkIGYgcyBhY2N1ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZm9sZCBmIHIgKGYgdiAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSkgYXMgdCAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdiB0aGVuXG4gICAgICAgICAgICBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIHQgZWxzZSBqb2luIGwnIHYgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiByZilcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGV7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgZWxlbWVudHMgcyA9XG4gICAgICBlbGVtZW50c19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9lbHRcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2VsdF9vcHRcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdlxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgdlxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCB0cnlfam9pbiBsIHYgciA9XG4gICAgICAoKiBbam9pbiBsIHYgcl0gY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gKGVsZW1lbnRzIG9mIGwgPCB2IDxcbiAgICAgICAgIGVsZW1lbnRzIG9mIHIpOyB1c2UgW3RyeV9qb2luIGwgdiByXSB3aGVuIHRoaXMgcHJvcGVydHkgbWF5XG4gICAgICAgICBub3QgaG9sZCwgYnV0IHlvdSBob3BlIGl0IGRvZXMgaG9sZCBpbiB0aGUgY29tbW9uIGNhc2UgKilcbiAgICAgIGlmIChsID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgKG1heF9lbHQgbCkgdiA8IDApXG4gICAgICAmJiAociA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIHYgKG1pbl9lbHQgcikgPCAwKVxuICAgICAgdGhlbiBqb2luIGwgdiByXG4gICAgICBlbHNlIHVuaW9uIGwgKGFkZCB2IHIpXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcblxuICAgIGxldCBvZl9zb3J0ZWRfbGlzdCBsID1cbiAgICAgIGxldCByZWMgc3ViIG4gbCA9XG4gICAgICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgICAgICB8IDAsIGwgLT4gRW1wdHksIGxcbiAgICAgICAgfCAxLCB4MCA6OiBsIC0+IE5vZGUge2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX0sIGxcbiAgICAgICAgfCAyLCB4MCA6OiB4MSA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxOyByPUVtcHR5OyBoPTJ9LCBsXG4gICAgICAgIHwgMywgeDAgOjogeDEgOjogeDIgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTtcbiAgICAgICAgICAgICAgICAgcj1Ob2Rle2w9RW1wdHk7IHY9eDI7IHI9RW1wdHk7IGg9MX07IGg9Mn0sIGxcbiAgICAgICAgfCBuLCBsIC0+XG4gICAgICAgICAgbGV0IG5sID0gbiAvIDIgaW5cbiAgICAgICAgICBsZXQgbGVmdCwgbCA9IHN1YiBubCBsIGluXG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IG1pZCA6OiBsIC0+XG4gICAgICAgICAgICBsZXQgcmlnaHQsIGwgPSBzdWIgKG4gLSBubCAtIDEpIGwgaW5cbiAgICAgICAgICAgIGNyZWF0ZSBsZWZ0IG1pZCByaWdodCwgbFxuICAgICAgaW5cbiAgICAgIGZzdCAoc3ViIChMaXN0Lmxlbmd0aCBsKSBsKVxuXG4gICAgbGV0IG9mX2xpc3QgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gZW1wdHlcbiAgICAgIHwgW3gwXSAtPiBzaW5nbGV0b24geDBcbiAgICAgIHwgW3gwOyB4MV0gLT4gYWRkIHgxIChzaW5nbGV0b24geDApXG4gICAgICB8IFt4MDsgeDE7IHgyXSAtPiBhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzXSAtPiBhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzOyB4NF0gLT4gYWRkIHg0IChhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSkpXG4gICAgICB8IF8gLT4gb2Zfc29ydGVkX2xpc3QgKExpc3Quc29ydF91bmlxIE9yZC5jb21wYXJlIGwpXG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIHMgeCAtPiBhZGQgeCBzKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlICh4LCB0LCByZXN0KSAtPiBTZXEuQ29ucyAoeCwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgYyA9IHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBzID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBzIGMgPSBtYXRjaCBzIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgcjsgdjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBzIEVuZClcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgKydhIHRcbiAgICB2YWwgZW1wdHk6ICdhIHRcbiAgICB2YWwgaXNfZW1wdHk6ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBtZW06ICBrZXkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGFkZDoga2V5IC0+ICdhIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB1cGRhdGU6IGtleSAtPiAoJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHNpbmdsZXRvbjoga2V5IC0+ICdhIC0+ICdhIHRcbiAgICB2YWwgcmVtb3ZlOiBrZXkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG1lcmdlOlxuICAgICAgICAgIChrZXkgLT4gJ2Egb3B0aW9uIC0+ICdiIG9wdGlvbiAtPiAnYyBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdCAtPiAnYyB0XG4gICAgdmFsIHVuaW9uOiAoa2V5IC0+ICdhIC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgY29tcGFyZTogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgZm9yX2FsbDogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgKiAnYSB0XG4gICAgdmFsIGNhcmRpbmFsOiAnYSB0IC0+IGludFxuICAgIHZhbCBiaW5kaW5nczogJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgICB2YWwgbWluX2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtaW5fYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWF4X2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtYXhfYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgY2hvb3NlX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBzcGxpdDoga2V5IC0+ICdhIHQgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgICB2YWwgZmluZDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6IGtleSAtPiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWFwOiAoJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBtYXBpOiAoa2V5IC0+ICdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9mcm9tIDoga2V5IC0+ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBtIChrLHYpIC0+IGFkZCBrIHYgbSkgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT4gU2VxLkNvbnMgKChrLHYpLCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBtID1cbiAgICAgIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIG0gRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgKCogZG8gc2V0X2ZpZWxkIEJFRk9SRSBzZXRfdGFnICopXG4gICAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciByZXN1bHQpO1xuICAgIE9iai5zZXRfdGFnIChPYmoucmVwciBibGspIE9iai5mb3J3YXJkX3RhZztcbiAgICByZXN1bHRcbiAgd2l0aCBlIC0+XG4gICAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIGUpKTtcbiAgICByYWlzZSBlXG5cblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICgqIGRvIHNldF9maWVsZCBCRUZPUkUgc2V0X3RhZyAqKVxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIHJlc3VsdCk7XG4gIE9iai5zZXRfdGFnIChPYmoucmVwciBibGspIChPYmouZm9yd2FyZF90YWcpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudC4gIFRoaXMgZnVuY3Rpb24gaXNcbiAgIGhlcmUgZm9yIHRoZSBzYWtlIG9mIGNvbXBsZXRlbmVzcywgYW5kIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS4gKilcblxubGV0IGZvcmNlIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX2xhenlfYmxvY2sgbHp2XG5cblxubGV0IGZvcmNlX3ZhbCAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV92YWxfbGF6eV9ibG9jayBsenZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtMYXp5XTogZGVmZXJyZWQgY29tcHV0YXRpb25zICopXG5cblxuKCpcbiAgIFdBUk5JTkc6IHNvbWUgcHVycGxlIG1hZ2ljIGlzIGdvaW5nIG9uIGhlcmUuICBEbyBub3QgdGFrZSB0aGlzIGZpbGVcbiAgIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHByb2dyYW0gaW4gT0NhbWwuXG4qKVxuXG5cbigqIFdlIG1ha2UgdXNlIG9mIHR3byBzcGVjaWFsIHRhZ3MgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWU6XG4gICBbbGF6eV90YWddIGFuZCBbZm9yd2FyZF90YWddLlxuXG4gICBBIHZhbHVlIG9mIHR5cGUgWydhIExhenkudF0gY2FuIGJlIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAxLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbbGF6eV90YWddLiAgSXRzIGZpZWxkIGlzIGEgY2xvc3VyZSBvZlxuICAgICAgdHlwZSBbdW5pdCAtPiAnYV0gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAyLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbZm9yd2FyZF90YWddLiAgSXRzIGZpZWxkIGlzIHRoZSB2YWx1ZVxuICAgICAgb2YgdHlwZSBbJ2FdIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgMy4gQW55dGhpbmcgZWxzZSBleGNlcHQgYSBmbG9hdC4gIFRoaXMgaGFzIHR5cGUgWydhXSBhbmQgaXMgdGhlIHZhbHVlXG4gICAgICB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIEV4Y2VwdGlvbnMgYXJlIHN0b3JlZCBpbiBmb3JtYXQgKDEpLlxuICAgVGhlIEdDIHdpbGwgbWFnaWNhbGx5IGNoYW5nZSB0aGluZ3MgZnJvbSAoMikgdG8gKDMpIGFjY29yZGluZyB0byBpdHNcbiAgIGZhbmN5LlxuXG4gICBJZiBPQ2FtbCB3YXMgY29uZmlndXJlZCB3aXRoIHRoZSAtZmxhdC1mbG9hdC1hcnJheSBvcHRpb24gKHdoaWNoIGlzXG4gICBjdXJyZW50bHkgdGhlIGRlZmF1bHQpLCB0aGUgZm9sbG93aW5nIGlzIGFsc28gdHJ1ZTpcbiAgIFdlIGNhbm5vdCB1c2UgcmVwcmVzZW50YXRpb24gKDMpIGZvciBhIFtmbG9hdCBMYXp5LnRdIGJlY2F1c2VcbiAgIFtjYW1sX21ha2VfYXJyYXldIGFzc3VtZXMgdGhhdCBvbmx5IGEgW2Zsb2F0XSB2YWx1ZSBjYW4gaGF2ZSB0YWdcbiAgIFtEb3VibGVfdGFnXS5cblxuICAgV2UgaGF2ZSB0byB1c2UgdGhlIGJ1aWx0LWluIHR5cGUgY29uc3RydWN0b3IgW2xhenlfdF0gdG9cbiAgIGxldCB0aGUgY29tcGlsZXIgaW1wbGVtZW50IHRoZSBzcGVjaWFsIHR5cGluZyBhbmQgY29tcGlsYXRpb25cbiAgIHJ1bGVzIGZvciB0aGUgW2xhenldIGtleXdvcmQuXG4qKVxuXG50eXBlICdhIHQgPSAnYSBDYW1saW50ZXJuYWxMYXp5LnRcblxuZXhjZXB0aW9uIFVuZGVmaW5lZCA9IENhbWxpbnRlcm5hbExhenkuVW5kZWZpbmVkXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6ICdhIC0+ICdhIGxhenlfdCA9IFwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZFwiXG5cbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG4oKiBsZXQgZm9yY2UgPSBmb3JjZSAqKVxuXG5sZXQgZm9yY2VfdmFsID0gQ2FtbGludGVybmFsTGF6eS5mb3JjZV92YWxcblxubGV0IGZyb21fZnVuIChmIDogdW5pdCAtPiAnYXJnKSA9XG4gIGxldCB4ID0gT2JqLm5ld19ibG9jayBPYmoubGF6eV90YWcgMSBpblxuICBPYmouc2V0X2ZpZWxkIHggMCAoT2JqLnJlcHIgZik7XG4gIChPYmoub2JqIHggOiAnYXJnIHQpXG5cblxubGV0IGZyb21fdmFsICh2IDogJ2FyZykgPVxuICBsZXQgdCA9IE9iai50YWcgKE9iai5yZXByIHYpIGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgfHwgdCA9IE9iai5sYXp5X3RhZyB8fCB0ID0gT2JqLmRvdWJsZV90YWcgdGhlbiBiZWdpblxuICAgIG1ha2VfZm9yd2FyZCB2XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgKE9iai5tYWdpYyB2IDogJ2FyZyB0KVxuICBlbmRcblxuXG5sZXQgaXNfdmFsIChsIDogJ2FyZyB0KSA9IE9iai50YWcgKE9iai5yZXByIGwpIDw+IE9iai5sYXp5X3RhZ1xuXG5sZXQgbGF6eV9mcm9tX2Z1biA9IGZyb21fZnVuXG5cbmxldCBsYXp5X2Zyb21fdmFsID0gZnJvbV92YWxcblxubGV0IGxhenlfaXNfdmFsID0gaXNfdmFsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIERhbmllbCBkZSBSYXVnbGF1ZHJlLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIGNlbGwgb3B0aW9uXG5hbmQgJ2EgY2VsbCA9IHsgbXV0YWJsZSBjb3VudCA6IGludDsgbXV0YWJsZSBkYXRhIDogJ2EgZGF0YSB9XG5hbmQgJ2EgZGF0YSA9XG4gICAgU2VtcHR5XG4gIHwgU2NvbnMgb2YgJ2EgKiAnYSBkYXRhXG4gIHwgU2FwcCBvZiAnYSBkYXRhICogJ2EgZGF0YVxuICB8IFNsYXp5IG9mICdhIGRhdGEgTGF6eS50XG4gIHwgU2dlbiBvZiAnYSBnZW5cbiAgfCBTYnVmZmlvIDogYnVmZmlvIC0+IGNoYXIgZGF0YVxuYW5kICdhIGdlbiA9IHsgbXV0YWJsZSBjdXJyIDogJ2Egb3B0aW9uIG9wdGlvbjsgZnVuYyA6IGludCAtPiAnYSBvcHRpb24gfVxuYW5kIGJ1ZmZpbyA9XG4gIHsgaWMgOiBpbl9jaGFubmVsOyBidWZmIDogYnl0ZXM7IG11dGFibGUgbGVuIDogaW50OyBtdXRhYmxlIGluZCA6IGludCB9XG5cbmV4Y2VwdGlvbiBGYWlsdXJlXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBjb3VudCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSB7IGNvdW50IH0gLT4gY291bnRcbmxldCBkYXRhID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFNlbXB0eVxuICB8IFNvbWUgeyBkYXRhIH0gLT4gZGF0YVxuXG5sZXQgZmlsbF9idWZmIGIgPVxuICBiLmxlbiA8LSBpbnB1dCBiLmljIGIuYnVmZiAwIChCeXRlcy5sZW5ndGggYi5idWZmKTsgYi5pbmQgPC0gMFxuXG5cbmxldCByZWMgZ2V0X2RhdGEgOiB0eXBlIHYuIGludCAtPiB2IGRhdGEgLT4gdiBkYXRhID0gZnVuIGNvdW50IGQgLT4gbWF0Y2ggZCB3aXRoXG4gKCogUmV0dXJucyBlaXRoZXIgU2VtcHR5IG9yIFNjb25zKGEsIF8pIGV2ZW4gd2hlbiBkIGlzIGEgZ2VuZXJhdG9yXG4gICAgb3IgYSBidWZmZXIuIEluIHRob3NlIGNhc2VzLCB0aGUgaXRlbSBhIGlzIHNlZW4gYXMgZXh0cmFjdGVkIGZyb21cbiB0aGUgZ2VuZXJhdG9yL2J1ZmZlci5cbiBUaGUgY291bnQgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGNhbGxpbmcgYFNnZW4tZnVuY3Rpb25zJy4gICopXG4gICBTZW1wdHkgfCBTY29ucyAoXywgXykgLT4gZFxuIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBjb3VudCBkMSB3aXRoXG4gICAgICAgU2NvbnMgKGEsIGQxMSkgLT4gU2NvbnMgKGEsIFNhcHAgKGQxMSwgZDIpKVxuICAgICB8IFNlbXB0eSAtPiBnZXRfZGF0YSBjb3VudCBkMlxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2dlbiB7Y3VyciA9IFNvbWUgTm9uZX0gLT4gU2VtcHR5XG4gfCBTZ2VuICh7Y3VyciA9IFNvbWUoU29tZSBhKX0gYXMgZykgLT5cbiAgICAgZy5jdXJyIDwtIE5vbmU7IFNjb25zKGEsIGQpXG4gfCBTZ2VuIGcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZy5mdW5jIGNvdW50IHdpdGhcbiAgICAgICBOb25lIC0+IGcuY3VyciA8LSBTb21lKE5vbmUpOyBTZW1wdHlcbiAgICAgfCBTb21lIGEgLT4gU2NvbnMoYSwgZClcbiAgICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICBlbmRcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gU2VtcHR5IGVsc2VcbiAgICAgICBsZXQgciA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kIGluXG4gICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgICAgYi5pbmQgPC0gc3VjYyBiLmluZDsgU2NvbnMociwgZClcbiB8IFNsYXp5IGYgLT4gZ2V0X2RhdGEgY291bnQgKExhenkuZm9yY2UgZilcblxuXG5sZXQgcmVjIHBlZWtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHYgb3B0aW9uID0gZnVuIHMgLT5cbiAoKiBjb25zdWx0IHRoZSBmaXJzdCBpdGVtIG9mIHMgKilcbiBtYXRjaCBzLmRhdGEgd2l0aFxuICAgU2VtcHR5IC0+IE5vbmVcbiB8IFNjb25zIChhLCBfKSAtPiBTb21lIGFcbiB8IFNhcHAgKF8sIF8pIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIHMuY291bnQgcy5kYXRhIHdpdGhcbiAgICAgICBTY29ucyhhLCBfKSBhcyBkIC0+IHMuZGF0YSA8LSBkOyBTb21lIGFcbiAgICAgfCBTZW1wdHkgLT4gTm9uZVxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2xhenkgZiAtPiBzLmRhdGEgPC0gKExhenkuZm9yY2UgZik7IHBlZWtfZGF0YSBzXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBhfSAtPiBhXG4gfCBTZ2VuIGcgLT4gbGV0IHggPSBnLmZ1bmMgcy5jb3VudCBpbiBnLmN1cnIgPC0gU29tZSB4OyB4XG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIGJlZ2luIHMuZGF0YSA8LSBTZW1wdHk7IE5vbmUgZW5kXG4gICAgIGVsc2UgU29tZSAoQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQpXG5cblxubGV0IHBlZWsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgcyAtPiBwZWVrX2RhdGEgc1xuXG5cbmxldCByZWMganVua19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdW5pdCA9IGZ1biBzIC0+XG4gIG1hdGNoIHMuZGF0YSB3aXRoXG4gICAgU2NvbnMgKF8sIGQpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IHMuZGF0YSA8LSBkXG4gIHwgU2dlbiAoe2N1cnIgPSBTb21lIF99IGFzIGcpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGcuY3VyciA8LSBOb25lXG4gIHwgU2J1ZmZpbyBiIC0+XG4gICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIHMuZGF0YSA8LSBTZW1wdHlcbiAgICAgIGVsc2UgKHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGIuaW5kIDwtIHN1Y2MgYi5pbmQpXG4gIHwgXyAtPlxuICAgICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgICBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyAtPiBqdW5rX2RhdGEgc1xuXG5cbmxldCBqdW5rID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBkYXRhIC0+IGp1bmtfZGF0YSBkYXRhXG5cbmxldCByZWMgbmdldF9kYXRhIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuIFtdLCBzLmRhdGEsIDBcbiAgZWxzZVxuICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgIFNvbWUgYSAtPlxuICAgICAgICBqdW5rX2RhdGEgcztcbiAgICAgICAgbGV0IChhbCwgZCwgaykgPSBuZ2V0X2RhdGEgKHByZWQgbikgcyBpbiBhIDo6IGFsLCBTY29ucyAoYSwgZCksIHN1Y2Mga1xuICAgIHwgTm9uZSAtPiBbXSwgcy5kYXRhLCAwXG5cblxubGV0IG5wZWVrX2RhdGEgbiBzID1cbiAgbGV0IChhbCwgZCwgbGVuKSA9IG5nZXRfZGF0YSBuIHMgaW5cbiAgcy5jb3VudCA8LSAocy5jb3VudCAtIGxlbik7XG4gIHMuZGF0YSA8LSBkO1xuICBhbFxuXG5cbmxldCBucGVlayBuID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBkIC0+IG5wZWVrX2RhdGEgbiBkXG5cbmxldCBuZXh0IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgYSAtPiBqdW5rIHM7IGFcbiAgfCBOb25lIC0+IHJhaXNlIEZhaWx1cmVcblxuXG5sZXQgZW1wdHkgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBfIC0+IHJhaXNlIEZhaWx1cmVcbiAgfCBOb25lIC0+ICgpXG5cblxubGV0IGl0ZXIgZiBzdHJtID1cbiAgbGV0IHJlYyBkb19yZWMgKCkgPVxuICAgIG1hdGNoIHBlZWsgc3RybSB3aXRoXG4gICAgICBTb21lIGEgLT4ganVuayBzdHJtOyBpZ25vcmUoZiBhKTsgZG9fcmVjICgpXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIGRvX3JlYyAoKVxuXG5cbigqIFN0cmVhbSBidWlsZGluZyBmdW5jdGlvbnMgKilcblxubGV0IGZyb20gZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNnZW4ge2N1cnIgPSBOb25lOyBmdW5jID0gZn19XG5cbmxldCBvZl9saXN0IGwgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biB4IGwgLT4gU2NvbnMgKHgsIGwpKSBsIFNlbXB0eX1cblxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgICgqIFdlIGNhbm5vdCB1c2UgdGhlIGluZGV4IHBhc3NlZCBieSB0aGUgW2Zyb21dIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgYmVjYXVzZSBpdCByZXR1cm5zIHRoZSBjdXJyZW50IHN0cmVhbSBjb3VudCwgd2l0aCBhYnNvbHV0ZWx5IG5vXG4gICAgICAgZ3VhcmFudGVlIHRoYXQgaXQgd2lsbCBzdGFydCBmcm9tIDAuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAgICAgIG9mIFtTdHJlYW0uaWNvbnMgJ2MnIChTdHJlYW0uZnJvbV9zdHJpbmcgXCJhYlwiKV0sIHRoZSBmaXJzdFxuICAgICAgIGFjY2VzcyB0byB0aGUgc3RyaW5nIHdpbGwgYmUgbWFkZSB3aXRoIGNvdW50IFsxXSBhbHJlYWR5LlxuICAgICopXG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSBzLltjXSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2J5dGVzIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IEJ5dGVzLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSAoQnl0ZXMuZ2V0IHMgYykpXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9jaGFubmVsIGljID1cbiAgU29tZSB7Y291bnQgPSAwO1xuICAgICAgICBkYXRhID0gU2J1ZmZpbyB7aWMgPSBpYzsgYnVmZiA9IEJ5dGVzLmNyZWF0ZSA0MDk2OyBsZW4gPSAwOyBpbmQgPSAwfX1cblxuXG4oKiBTdHJlYW0gZXhwcmVzc2lvbnMgYnVpbGRlcnMgKilcblxubGV0IGlhcHAgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2FwcCAoZGF0YSBpLCBkYXRhIHMpfVxubGV0IGljb25zIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBkYXRhIHMpfVxubGV0IGlzaW5nIGkgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgU2VtcHR5KX1cblxubGV0IGxhcHAgZiBzID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2FwcCAoZGF0YSAoZiAoKSksIGRhdGEgcykpKX1cblxubGV0IGxjb25zIGYgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBkYXRhIHMpKSl9XG5sZXQgbHNpbmcgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBTZW1wdHkpKSl9XG5cbmxldCBzZW1wdHkgPSBOb25lXG5sZXQgc2xhenkgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KGRhdGEgKGYgKCkpKSl9XG5cbigqIEZvciBkZWJ1Z2dpbmcgdXNlICopXG5cbmxldCByZWMgZHVtcCA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiB0IC0+IHVuaXQgPSBmdW4gZiBzIC0+XG4gIHByaW50X3N0cmluZyBcIntjb3VudCA9IFwiO1xuICBwcmludF9pbnQgKGNvdW50IHMpO1xuICBwcmludF9zdHJpbmcgXCI7IGRhdGEgPSBcIjtcbiAgZHVtcF9kYXRhIGYgKGRhdGEgcyk7XG4gIHByaW50X3N0cmluZyBcIn1cIjtcbiAgcHJpbnRfbmV3bGluZSAoKVxuYW5kIGR1bXBfZGF0YSA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiBkYXRhIC0+IHVuaXQgPSBmdW4gZiAtPlxuICBmdW5jdGlvblxuICAgIFNlbXB0eSAtPiBwcmludF9zdHJpbmcgXCJTZW1wdHlcIlxuICB8IFNjb25zIChhLCBkKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2NvbnMgKFwiO1xuICAgICAgZiBhO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQ7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTYXBwIChcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQxO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQyO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2xhenkgXyAtPiBwcmludF9zdHJpbmcgXCJTbGF6eVwiXG4gIHwgU2dlbiBfIC0+IHByaW50X3N0cmluZyBcIlNnZW5cIlxuICB8IFNidWZmaW8gXyAtPiBwcmludF9zdHJpbmcgXCJTYnVmZmlvXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIFBpZXJyZSBXZWlzIGFuZCBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXh0ZW5zaWJsZSBidWZmZXJzICopXG5cbnR5cGUgdCA9XG4ge211dGFibGUgYnVmZmVyIDogYnl0ZXM7XG4gIG11dGFibGUgcG9zaXRpb24gOiBpbnQ7XG4gIG11dGFibGUgbGVuZ3RoIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuXG5sZXQgY3JlYXRlIG4gPVxuIGxldCBuID0gaWYgbiA8IDEgdGhlbiAxIGVsc2UgbiBpblxuIGxldCBuID0gaWYgbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBlbHNlIG4gaW5cbiBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4ge2J1ZmZlciA9IHM7IHBvc2l0aW9uID0gMDsgbGVuZ3RoID0gbjsgaW5pdGlhbF9idWZmZXIgPSBzfVxuXG5sZXQgY29udGVudHMgYiA9IEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5sZXQgdG9fYnl0ZXMgYiA9IEJ5dGVzLnN1YiBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IHN1YiBiIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYi5wb3NpdGlvbiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLnN1YlwiXG4gIGVsc2UgQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciBvZnMgbGVuXG5cblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmNvZmYgPiBzcmMucG9zaXRpb24gLSBsZW5cbiAgICAgICAgICAgICB8fCBkc3RvZmYgPCAwIHx8IGRzdG9mZiA+IChCeXRlcy5sZW5ndGggZHN0KSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmJsaXRcIlxuICBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXQgc3JjLmJ1ZmZlciBzcmNvZmYgZHN0IGRzdG9mZiBsZW5cblxuXG5sZXQgbnRoIGIgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPj0gYi5wb3NpdGlvbiB0aGVuXG4gICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5udGhcIlxuICBlbHNlIEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgb2ZzXG5cblxubGV0IGxlbmd0aCBiID0gYi5wb3NpdGlvblxuXG5sZXQgY2xlYXIgYiA9IGIucG9zaXRpb24gPC0gMFxuXG5sZXQgcmVzZXQgYiA9XG4gIGIucG9zaXRpb24gPC0gMDsgYi5idWZmZXIgPC0gYi5pbml0aWFsX2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXG5cbmxldCByZXNpemUgYiBtb3JlID1cbiAgbGV0IGxlbiA9IGIubGVuZ3RoIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIGxlbiBpblxuICB3aGlsZSBiLnBvc2l0aW9uICsgbW9yZSA+ICFuZXdfbGVuIGRvIG5ld19sZW4gOj0gMiAqICFuZXdfbGVuIGRvbmU7XG4gIGlmICFuZXdfbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBpZiBiLnBvc2l0aW9uICsgbW9yZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICB0aGVuIG5ld19sZW4gOj0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgZWxzZSBmYWlsd2l0aCBcIkJ1ZmZlci5hZGQ6IGNhbm5vdCBncm93IGJ1ZmZlclwiXG4gIGVuZDtcbiAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgIW5ld19sZW4gaW5cbiAgKCogUFIjNjE0ODogbGV0J3Mga2VlcCB1c2luZyBbYmxpdF0gcmF0aGVyIHRoYW4gW3Vuc2FmZV9ibGl0XSBpblxuICAgICB0aGlzIHRyaWNreSBmdW5jdGlvbiB0aGF0IGlzIHNsb3cgYW55d2F5LiAqKVxuICBCeXRlcy5ibGl0IGIuYnVmZmVyIDAgbmV3X2J1ZmZlciAwIGIucG9zaXRpb247XG4gIGIuYnVmZmVyIDwtIG5ld19idWZmZXI7XG4gIGIubGVuZ3RoIDwtICFuZXdfbGVuXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIHBvcyBjO1xuICBiLnBvc2l0aW9uIDwtIHBvcyArIDFcblxuIGxldCBhZGRfdXRmXzhfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+XG4gICAgIGFkZF9jaGFyIGIgKENoYXIudW5zYWZlX2NociB1KVxuIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhDMCBsb3IgKHUgbHNyIDYpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAzID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAzO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RTAgbG9yICh1IGxzciAxMikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgM1xuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEYwIGxvciAodSBsc3IgMTgpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciAxMikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZiZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGFkZF9zdWJzdHJpbmcgYiBzIG9mZnNldCBsZW4gPVxuICBpZiBvZmZzZXQgPCAwIHx8IGxlbiA8IDAgfHwgb2Zmc2V0ID4gU3RyaW5nLmxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX3N1YnN0cmluZy9hZGRfc3ViYnl0ZXNcIjtcbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLmJsaXRfc3RyaW5nIHMgb2Zmc2V0IGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX3N1YmJ5dGVzIGIgcyBvZmZzZXQgbGVuID1cbiAgYWRkX3N1YnN0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpIG9mZnNldCBsZW5cblxubGV0IGFkZF9zdHJpbmcgYiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMuYmxpdF9zdHJpbmcgcyAwIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2J5dGVzIGIgcyA9IGFkZF9zdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKVxuXG5sZXQgYWRkX2J1ZmZlciBiIGJzID1cbiAgYWRkX3N1YmJ5dGVzIGIgYnMuYnVmZmVyIDAgYnMucG9zaXRpb25cblxuKCogcmVhZCB1cCB0byBbbGVuXSBieXRlcyBmcm9tIFtpY10gaW50byBbYl0uICopXG5sZXQgcmVjIGFkZF9jaGFubmVsX3JlYyBiIGljIGxlbiA9XG4gIGlmIGxlbiA+IDAgdGhlbiAoXG4gICAgbGV0IG4gPSBpbnB1dCBpYyBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbiBpblxuICAgIGIucG9zaXRpb24gPC0gYi5wb3NpdGlvbiArIG47XG4gICAgaWYgbiA9IDAgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgIGVsc2UgYWRkX2NoYW5uZWxfcmVjIGIgaWMgKGxlbi1uKSAgICgqIG4gPD0gbGVuICopXG4gIClcblxubGV0IGFkZF9jaGFubmVsIGIgaWMgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBsZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiAgICgqIFBSIzUwMDQgKilcbiAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfY2hhbm5lbFwiO1xuICBpZiBiLnBvc2l0aW9uICsgbGVuID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIGFkZF9jaGFubmVsX3JlYyBiIGljIGxlblxuXG5sZXQgb3V0cHV0X2J1ZmZlciBvYyBiID1cbiAgb3V0cHV0IG9jIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgY2xvc2luZyA9IGZ1bmN0aW9uXG4gIHwgJygnIC0+ICcpJ1xuICB8ICd7JyAtPiAnfSdcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBvcGVuaW5nIGFuZCBjbG9zaW5nOiBvcGVuIGFuZCBjbG9zZSBjaGFyYWN0ZXJzLCB0eXBpY2FsbHkgKCBhbmQgKVxuICAgazogYmFsYW5jZSBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGNoYXJzXG4gICBzOiB0aGUgc3RyaW5nIHdoZXJlIHdlIGFyZSBzZWFyY2hpbmdcbiAgIHN0YXJ0OiB0aGUgaW5kZXggd2hlcmUgd2Ugc3RhcnQgdGhlIHNlYXJjaC4gKilcbmxldCBhZHZhbmNlX3RvX2Nsb3Npbmcgb3BlbmluZyBjbG9zaW5nIGsgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBrIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgaWYgcy5baV0gPSBvcGVuaW5nIHRoZW4gYWR2YW5jZSAoayArIDEpIChpICsgMSkgbGltIGVsc2VcbiAgICBpZiBzLltpXSA9IGNsb3NpbmcgdGhlblxuICAgICAgaWYgayA9IDAgdGhlbiBpIGVsc2UgYWR2YW5jZSAoayAtIDEpIChpICsgMSkgbGltXG4gICAgZWxzZSBhZHZhbmNlIGsgKGkgKyAxKSBsaW0gaW5cbiAgYWR2YW5jZSBrIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbmxldCBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIGxpbSBlbHNlXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIHwgJ18nIC0+IGFkdmFuY2UgKGkgKyAxKSBsaW1cbiAgICB8IF8gLT4gaSBpblxuICBhZHZhbmNlIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbigqIFdlIGFyZSBqdXN0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gaWRlbnQgaW4gcywgc3RhcnRpbmcgYXQgc3RhcnQuICopXG5sZXQgZmluZF9pZGVudCBzIHN0YXJ0IGxpbSA9XG4gIGlmIHN0YXJ0ID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIG1hdGNoIHMuW3N0YXJ0XSB3aXRoXG4gICgqIFBhcmVudGhlc2l6ZWQgaWRlbnQgPyAqKVxuICB8ICcoJyB8ICd7JyBhcyBjIC0+XG4gICAgIGxldCBuZXdfc3RhcnQgPSBzdGFydCArIDEgaW5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX2Nsb3NpbmcgYyAoY2xvc2luZyBjKSAwIHMgbmV3X3N0YXJ0IGluXG4gICAgIFN0cmluZy5zdWIgcyBuZXdfc3RhcnQgKHN0b3AgLSBzdGFydCAtIDEpLCBzdG9wICsgMVxuICAoKiBSZWd1bGFyIGlkZW50ICopXG4gIHwgXyAtPlxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgKHN0YXJ0ICsgMSkgaW5cbiAgICAgU3RyaW5nLnN1YiBzIHN0YXJ0IChzdG9wIC0gc3RhcnQpLCBzdG9wXG5cbigqIFN1YnN0aXR1dGUgJGlkZW50LCAkKGlkZW50KSwgb3IgJHtpZGVudH0gaW4gcyxcbiAgICBhY2NvcmRpbmcgdG8gdGhlIGZ1bmN0aW9uIG1hcHBpbmcgZi4gKilcbmxldCBhZGRfc3Vic3RpdHV0ZSBiIGYgcyA9XG4gIGxldCBsaW0gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBzdWJzdCBwcmV2aW91cyBpID1cbiAgICBpZiBpIDwgbGltIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJyQnIGFzIGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJyQnIC0+XG4gICAgICAgICBsZXQgaiA9IGkgKyAxIGluXG4gICAgICAgICBsZXQgaWRlbnQsIG5leHRfaSA9IGZpbmRfaWRlbnQgcyBqIGxpbSBpblxuICAgICAgICAgYWRkX3N0cmluZyBiIChmIGlkZW50KTtcbiAgICAgICAgIHN1YnN0ICcgJyBuZXh0X2lcbiAgICAgIHwgY3VycmVudCB3aGVuIHByZXZpb3VzID09ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnXFxcXCcgYXMgY3VycmVudCAtPlxuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgICB8IGN1cnJlbnQgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgIGVuZCBlbHNlXG4gICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzIGluXG4gIHN1YnN0ICcgJyAwXG5cbmxldCB0cnVuY2F0ZSBiIGxlbiA9XG4gICAgaWYgbGVuIDwgMCB8fCBsZW4gPiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci50cnVuY2F0ZVwiXG4gICAgZWxzZVxuICAgICAgYi5wb3NpdGlvbiA8LSBsZW5cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMuZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy5nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBhZGRfc2VxIGIgc2VxID0gU2VxLml0ZXIgKGFkZF9jaGFyIGIpIHNlcVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgYiA9IGNyZWF0ZSAzMiBpblxuICBhZGRfc2VxIGIgaTtcbiAgYlxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MTYgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMydVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5cbmxldCBhZGRfaW50OCBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDEgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICB1bnNhZmVfc2V0X2ludDggYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gIHVuc2FmZV9zZXRfaW50MTYgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDMyX25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgNCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gIHVuc2FmZV9zZXRfaW50MzIgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDY0X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgOCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDg7XG4gIHVuc2FmZV9zZXRfaW50NjQgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X2xlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQxNl9iZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDE2IHgpXG5cbmxldCBhZGRfaW50MzJfbGUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDMyX2JlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMzIgeClcblxubGV0IGFkZF9pbnQ2NF9sZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50NjRfYmUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXA2NCB4KVxuXG5sZXQgYWRkX3VpbnQ4ID0gYWRkX2ludDhcbmxldCBhZGRfdWludDE2X25lID0gYWRkX2ludDE2X25lXG5sZXQgYWRkX3VpbnQxNl9sZSA9IGFkZF9pbnQxNl9sZVxubGV0IGFkZF91aW50MTZfYmUgPSBhZGRfaW50MTZfYmVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgWGF2aWVyIExlcm95IGFuZCBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbmxldCBrZnByaW50ZiBrIG8gKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIG8gYWNjOyBrIG8pIEVuZF9vZl9hY2MgZm10XG5sZXQga2JwcmludGYgayBiIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gYnVmcHV0X2FjYyBiIGFjYzsgayBiKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGlrZnByaW50ZiBrIG9jIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgb2MgZm10XG5cbmxldCBmcHJpbnRmIG9jIGZtdCA9IGtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBicHJpbnRmIGIgZm10ID0ga2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgaWZwcmludGYgb2MgZm10ID0gaWtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRvdXQgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZGVyciBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgaycgYWNjID1cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSA2NCBpblxuICAgIHN0cnB1dF9hY2MgYnVmIGFjYztcbiAgICBrIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgLT4gcykgZm10XG5cbmxldCBrcHJpbnRmID0ga3NwcmludGZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBrZXkgPSBzdHJpbmdcbnR5cGUgZG9jID0gc3RyaW5nXG50eXBlIHVzYWdlX21zZyA9IHN0cmluZ1xudHlwZSBhbm9uX2Z1biA9IChzdHJpbmcgLT4gdW5pdClcblxudHlwZSBzcGVjID1cbiAgfCBVbml0IG9mICh1bml0IC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHVuaXQgYXJndW1lbnQgKilcbiAgfCBCb29sIG9mIChib29sIC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgYm9vbCBhcmd1bWVudCAqKVxuICB8IFNldCBvZiBib29sIHJlZiAgICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRydWUgKilcbiAgfCBDbGVhciBvZiBib29sIHJlZiAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byBmYWxzZSAqKVxuICB8IFN0cmluZyBvZiAoc3RyaW5nIC0+IHVuaXQpICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBTZXRfc3RyaW5nIG9mIHN0cmluZyByZWYgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgSW50IG9mIChpbnQgLT4gdW5pdCkgICAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhbiBpbnQgYXJndW1lbnQgKilcbiAgfCBTZXRfaW50IG9mIGludCByZWYgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgaW50IGFyZ3VtZW50ICopXG4gIHwgRmxvYXQgb2YgKGZsb2F0IC0+IHVuaXQpICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgU2V0X2Zsb2F0IG9mIGZsb2F0IHJlZiAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgVHVwbGUgb2Ygc3BlYyBsaXN0ICAgICAgICAgKCogVGFrZSBzZXZlcmFsIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYyBsaXN0ICopXG4gIHwgU3ltYm9sIG9mIHN0cmluZyBsaXN0ICogKHN0cmluZyAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFRha2Ugb25lIG9mIHRoZSBzeW1ib2xzIGFzIGFyZ3VtZW50IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN5bWJvbC4gKilcbiAgfCBSZXN0IG9mIChzdHJpbmcgLT4gdW5pdCkgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGVhY2ggcmVtYWluaW5nIGFyZ3VtZW50ICopXG4gIHwgRXhwYW5kIG9mIChzdHJpbmcgLT4gc3RyaW5nIGFycmF5KSAoKiBJZiB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbXCItZm9vXCI7IFwiYXJnXCJdIEAgcmVzdF0gd2hlcmUgXCJmb29cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcmVnaXN0ZXJlZCBhcyBbRXhwYW5kIGZdLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzIFtmIFwiYXJnXCIgQCByZXN0XSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC4gT25seSBhbGxvd2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNdLiAqKVxuXG5leGNlcHRpb24gQmFkIG9mIHN0cmluZ1xuZXhjZXB0aW9uIEhlbHAgb2Ygc3RyaW5nXG5cbnR5cGUgZXJyb3IgPVxuICB8IFVua25vd24gb2Ygc3RyaW5nXG4gIHwgV3Jvbmcgb2Ygc3RyaW5nICogc3RyaW5nICogc3RyaW5nICAoKiBvcHRpb24sIGFjdHVhbCwgZXhwZWN0ZWQgKilcbiAgfCBNaXNzaW5nIG9mIHN0cmluZ1xuICB8IE1lc3NhZ2Ugb2Ygc3RyaW5nXG5cbmV4Y2VwdGlvbiBTdG9wIG9mIGVycm9yICgqIHVzZWQgaW50ZXJuYWxseSAqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcmVjIGFzc29jMyB4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoeTEsIHkyLCBfKSA6OiBfIHdoZW4geTEgPSB4IC0+IHkyXG4gIHwgXyA6OiB0IC0+IGFzc29jMyB4IHRcblxuXG5sZXQgc3BsaXQgcyA9XG4gIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJz0nIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgU3RyaW5nLnN1YiBzIDAgaSwgU3RyaW5nLnN1YiBzIChpKzEpIChsZW4tKGkrMSkpXG5cblxubGV0IG1ha2Vfc3ltbGlzdCBwcmVmaXggc2VwIHN1ZmZpeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gXCI8bm9uZT5cIlxuICB8IGg6OnQgLT4gKExpc3QuZm9sZF9sZWZ0IChmdW4geCB5IC0+IHggXiBzZXAgXiB5KSAocHJlZml4IF4gaCkgdCkgXiBzdWZmaXhcblxuXG5sZXQgcHJpbnRfc3BlYyBidWYgKGtleSwgc3BlYywgZG9jKSA9XG4gIGlmIFN0cmluZy5sZW5ndGggZG9jID4gMCB0aGVuXG4gICAgbWF0Y2ggc3BlYyB3aXRoXG4gICAgfCBTeW1ib2wgKGwsIF8pIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlcyVzXFxuXCIga2V5IChtYWtlX3N5bWxpc3QgXCJ7XCIgXCJ8XCIgXCJ9XCIgbCkgZG9jXG4gICAgfCBfIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlc1xcblwiIGtleSBkb2NcblxuXG5sZXQgaGVscF9hY3Rpb24gKCkgPSByYWlzZSAoU3RvcCAoVW5rbm93biBcIi1oZWxwXCIpKVxuXG5sZXQgYWRkX2hlbHAgc3BlY2xpc3QgPVxuICBsZXQgYWRkMSA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgYW5kIGFkZDIgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi0taGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLS1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgaW5cbiAgc3BlY2xpc3QgQCAoYWRkMSBAIGFkZDIpXG5cblxubGV0IHVzYWdlX2IgYnVmIHNwZWNsaXN0IGVycm1zZyA9XG4gIGJwcmludGYgYnVmIFwiJXNcXG5cIiBlcnJtc2c7XG4gIExpc3QuaXRlciAocHJpbnRfc3BlYyBidWYpIChhZGRfaGVscCBzcGVjbGlzdClcblxuXG5sZXQgdXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZyA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgdXNhZ2VfYiBiIHNwZWNsaXN0IGVycm1zZztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgdXNhZ2Ugc3BlY2xpc3QgZXJybXNnID1cbiAgZXByaW50ZiBcIiVzXCIgKHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cpXG5cblxubGV0IGN1cnJlbnQgPSByZWYgMFxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoYm9vbF9vZl9zdHJpbmcgeClcbiAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGFsbG93X2V4cGFuZCBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJtc2cgPVxuICBsZXQgaW5pdHBvcyA9ICFjdXJyZW50IGluXG4gIGxldCBjb252ZXJ0X2Vycm9yIGVycm9yID1cbiAgICAoKiBjb252ZXJ0IGFuIGludGVybmFsIGVycm9yIHRvIGEgQmFkL0hlbHAgZXhjZXB0aW9uXG4gICAgICAgKm9yKiBhZGQgdGhlIHByb2dyYW0gbmFtZSBhcyBhIHByZWZpeCBhbmQgdGhlIHVzYWdlIG1lc3NhZ2UgYXMgYSBzdWZmaXhcbiAgICAgICB0byBhbiB1c2VyLXJhaXNlZCBCYWQgZXhjZXB0aW9uLlxuICAgICopXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICAgIGxldCBwcm9nbmFtZSA9XG4gICAgICBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPj0gMSAmJiBzLlswXSA9ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBub19hcmcgKCk7IGYgKCk7XG4gICAgICAgIHwgQm9vbCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggYm9vbF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBib29sZWFuXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSBzIC0+IGYgc1xuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0IHIgLT4gbm9fYXJnICgpOyByIDo9IHRydWU7XG4gICAgICAgIHwgQ2xlYXIgciAtPiBub19hcmcgKCk7IHIgOj0gZmFsc2U7XG4gICAgICAgIHwgU3RyaW5nIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFN5bWJvbCAoc3ltYiwgZikgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBpZiBMaXN0Lm1lbSBhcmcgc3ltYiB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm9uZSBvZjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gKG1ha2Vfc3ltbGlzdCBcIlwiIFwiIFwiIFwiXCIgc3ltYikpKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IFNldF9zdHJpbmcgciAtPlxuICAgICAgICAgICAgciA6PSBnZXRfYXJnICgpO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgSW50IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfaW50IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBGbG9hdCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfZmxvYXQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgVHVwbGUgc3BlY3MgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIExpc3QuaXRlciB0cmVhdF9hY3Rpb24gc3BlY3M7XG4gICAgICAgIHwgUmVzdCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIC0gMSBkb1xuICAgICAgICAgICAgICBmICFhcmd2LighY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgIHwgRXhwYW5kIGYgLT5cbiAgICAgICAgICAgIGlmIG5vdCBhbGxvd19leHBhbmQgdGhlblxuICAgICAgICAgICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkFyZy5FeHBhbmQgaXMgaXMgb25seSBhbGxvd2VkIHdpdGggXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5wYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY1wiKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBsZXQgbmV3YXJnID0gZiBhcmcgaW5cbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IEFycmF5LnN1YiAhYXJndiAwICghY3VycmVudCArIDEpXG4gICAgICAgICAgICBhbmQgYWZ0ZXIgPVxuICAgICAgICAgICAgICBBcnJheS5zdWIgIWFyZ3YgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICgoQXJyYXkubGVuZ3RoICFhcmd2KSAtICFjdXJyZW50IC0gMSkgaW5cbiAgICAgICAgICAgIGFyZ3Y6PSBBcnJheS5jb25jYXQgW2JlZm9yZTtuZXdhcmc7YWZ0ZXJdO1xuICAgICAgICBpblxuICAgICAgICB0cmVhdF9hY3Rpb24gYWN0aW9uIGVuZFxuICAgICAgZWxzZSBhbm9uZnVuIHNcbiAgICB3aXRoIHwgQmFkIG0gLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgKE1lc3NhZ2UgbSkpO1xuICAgICAgICAgfCBTdG9wIGUgLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgZSk7XG4gICAgZW5kO1xuICAgIGluY3IgY3VycmVudFxuICBkb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggdHJ1ZSBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2dcblxubGV0IHBhcnNlX2FyZ3ZfZHluYW1pYyA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBmYWxzZSBjdXJyZW50IChyZWYgYXJndikgc3BlY2xpc3QgYW5vbmZ1blxuICAgIGVycm1zZ1xuXG5cbmxldCBwYXJzZV9hcmd2ID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYXJndl9keW5hbWljIH5jdXJyZW50OmN1cnJlbnQgYXJndiAocmVmIHNwZWNsaXN0KSBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZSBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBwYXJzZV9keW5hbWljIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2X2R5bmFtaWMgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxubGV0IHBhcnNlX2V4cGFuZCBsIGYgbXNnID1cbiAgdHJ5XG4gICAgbGV0IGFyZ3YgPSByZWYgU3lzLmFyZ3YgaW5cbiAgICBsZXQgc3BlYyA9IHJlZiBsIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgKCFjdXJyZW50KSBpblxuICAgIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBzZWNvbmRfd29yZCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgbiA9XG4gICAgaWYgbiA+PSBsZW4gdGhlbiBsZW5cbiAgICBlbHNlIGlmIHMuW25dID0gJyAnIHRoZW4gbG9vcCAobisxKVxuICAgIGVsc2UgblxuICBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXggcyAnXFx0JyB3aXRoXG4gIHwgbiAtPiBsb29wIChuKzEpXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggU3RyaW5nLmluZGV4IHMgJyAnIHdpdGhcbiAgICAgIHwgbiAtPiBsb29wIChuKzEpXG4gICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gbGVuXG4gICAgICBlbmRcblxuXG5sZXQgbWF4X2FyZ19sZW4gY3VyIChrd2QsIHNwZWMsIGRvYykgPVxuICBtYXRjaCBzcGVjIHdpdGhcbiAgfCBTeW1ib2wgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IG1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKG1heCAwIChsZW4gLSBjdXRjb2wpKSArIDMpICcgJyBpblxuICAgICAgKGt3ZCwgc3BlYywgXCJcXG5cIiBeIHNwYWNlcyBeIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICB8IChrd2QsIHNwZWMsIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBrd2RfbGVuID0gU3RyaW5nLmxlbmd0aCBrd2QgaW5cbiAgICAgIGxldCBkaWZmID0gbGVuIC0ga3dkX2xlbiAtIGN1dGNvbCBpblxuICAgICAgaWYgZGlmZiA8PSAwIHRoZW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSBkaWZmICcgJyBpblxuICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLnN1YiAocmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpIDAgY3V0Y29sIGluXG4gICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuc3ViIG1zZyBjdXRjb2wgKFN0cmluZy5sZW5ndGggbXNnIC0gY3V0Y29sKSBpblxuICAgICAgICAoa3dkLCBzcGVjLCBwcmVmaXggXiBzcGFjZXMgXiBzdWZmaXgpXG5cblxubGV0IGFsaWduID8obGltaXQ9bWF4X2ludCkgc3BlY2xpc3QgPVxuICBsZXQgY29tcGxldGVkID0gYWRkX2hlbHAgc3BlY2xpc3QgaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IG1heF9hcmdfbGVuIDAgY29tcGxldGVkIGluXG4gIGxldCBsZW4gPSBtaW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmxldCBjb25zdCBjIF8gPSBjXG5sZXQgZmxpcCBmIHggeSA9IGYgeSB4XG5sZXQgbmVnYXRlIHAgdiA9IG5vdCAocCB2KVxuXG5leGNlcHRpb24gRmluYWxseV9yYWlzZWQgb2YgZXhuXG5cbmxldCBwcm90ZWN0IH4oZmluYWxseSA6IHVuaXQgLT4gdW5pdCkgd29yayA9XG4gIGxldCBmaW5hbGx5X25vX2V4biAoKSA9XG4gICAgdHJ5IGZpbmFsbHkgKCkgd2l0aCBlIC0+XG4gICAgICBsZXQgYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgKEZpbmFsbHlfcmFpc2VkIGUpIGJ0XG4gIGluXG4gIG1hdGNoIHdvcmsgKCkgd2l0aFxuICB8IHJlc3VsdCAtPiBmaW5hbGx5X25vX2V4biAoKSA7IHJlc3VsdFxuICB8IGV4Y2VwdGlvbiB3b3JrX2V4biAtPlxuICAgICAgbGV0IHdvcmtfYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZmluYWxseV9ub19leG4gKCkgO1xuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2Ugd29ya19leG4gd29ya19idFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHN0YXQgPSB7XG4gIG1pbm9yX3dvcmRzIDogZmxvYXQ7XG4gIHByb21vdGVkX3dvcmRzIDogZmxvYXQ7XG4gIG1ham9yX3dvcmRzIDogZmxvYXQ7XG4gIG1pbm9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBtYWpvcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgaGVhcF93b3JkcyA6IGludDtcbiAgaGVhcF9jaHVua3MgOiBpbnQ7XG4gIGxpdmVfd29yZHMgOiBpbnQ7XG4gIGxpdmVfYmxvY2tzIDogaW50O1xuICBmcmVlX3dvcmRzIDogaW50O1xuICBmcmVlX2Jsb2NrcyA6IGludDtcbiAgbGFyZ2VzdF9mcmVlIDogaW50O1xuICBmcmFnbWVudHMgOiBpbnQ7XG4gIGNvbXBhY3Rpb25zIDogaW50O1xuICB0b3BfaGVhcF93b3JkcyA6IGludDtcbiAgc3RhY2tfc2l6ZSA6IGludDtcbn1cblxudHlwZSBjb250cm9sID0ge1xuICBtdXRhYmxlIG1pbm9yX2hlYXBfc2l6ZSA6IGludDtcbiAgbXV0YWJsZSBtYWpvcl9oZWFwX2luY3JlbWVudCA6IGludDtcbiAgbXV0YWJsZSBzcGFjZV9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSB2ZXJib3NlIDogaW50O1xuICBtdXRhYmxlIG1heF9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSBzdGFja19saW1pdCA6IGludDtcbiAgbXV0YWJsZSBhbGxvY2F0aW9uX3BvbGljeSA6IGludDtcbiAgd2luZG93X3NpemUgOiBpbnQ7XG4gIGN1c3RvbV9tYWpvcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfbWF4X3NpemUgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2Nfc3RhdFwiXG5leHRlcm5hbCBxdWlja19zdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3F1aWNrX3N0YXRcIlxuZXh0ZXJuYWwgY291bnRlcnMgOiB1bml0IC0+IChmbG9hdCAqIGZsb2F0ICogZmxvYXQpID0gXCJjYW1sX2djX2NvdW50ZXJzXCJcbmV4dGVybmFsIG1pbm9yX3dvcmRzIDogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSlcbiAgPSBcImNhbWxfZ2NfbWlub3Jfd29yZHNcIiBcImNhbWxfZ2NfbWlub3Jfd29yZHNfdW5ib3hlZFwiXG5leHRlcm5hbCBnZXQgOiB1bml0IC0+IGNvbnRyb2wgPSBcImNhbWxfZ2NfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGNvbnRyb2wgLT4gdW5pdCA9IFwiY2FtbF9nY19zZXRcIlxuZXh0ZXJuYWwgbWlub3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWlub3JcIlxuZXh0ZXJuYWwgbWFqb3Jfc2xpY2UgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2djX21ham9yX3NsaWNlXCJcbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIGZ1bGxfbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfZnVsbF9tYWpvclwiXG5leHRlcm5hbCBjb21wYWN0IDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2NvbXBhY3Rpb25cIlxuZXh0ZXJuYWwgZ2V0X21pbm9yX2ZyZWUgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWlub3JfZnJlZVwiXG5leHRlcm5hbCBnZXRfYnVja2V0IDogaW50IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfYnVja2V0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGdldF9jcmVkaXQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGh1Z2VfZmFsbGJhY2tfY291bnQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XCJcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICVkXFxuXCIgc3QubWlub3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIm1ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0Lm1ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJjb21wYWN0aW9uczogICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIHJlZlxudHlwZSBhbGFybV9yZWMgPSB7YWN0aXZlIDogYWxhcm07IGYgOiB1bml0IC0+IHVuaXR9XG5cbmxldCByZWMgY2FsbF9hbGFybSBhcmVjID1cbiAgaWYgIShhcmVjLmFjdGl2ZSkgdGhlbiBiZWdpblxuICAgIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgICBhcmVjLmYgKCk7XG4gIGVuZFxuXG5cbmxldCBjcmVhdGVfYWxhcm0gZiA9XG4gIGxldCBhcmVjID0geyBhY3RpdmUgPSByZWYgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gYSA6PSBmYWxzZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXNzYWdlIGRpZ2VzdCAoTUQ1KSAqKVxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgPSBTdHJpbmcuY29tcGFyZVxubGV0IGVxdWFsID0gU3RyaW5nLmVxdWFsXG5cbmV4dGVybmFsIHVuc2FmZV9zdHJpbmc6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X3N0cmluZ1wiXG5leHRlcm5hbCBjaGFubmVsOiBpbl9jaGFubmVsIC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9jaGFuXCJcblxubGV0IHN0cmluZyBzdHIgPVxuICB1bnNhZmVfc3RyaW5nIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxubGV0IGJ5dGVzIGIgPSBzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYilcblxubGV0IHN1YnN0cmluZyBzdHIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBTdHJpbmcubGVuZ3RoIHN0ciAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnN1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX3N0cmluZyBzdHIgb2ZzIGxlblxuXG5sZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID0gc3Vic3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpIG9mcyBsZW5cblxubGV0IGZpbGUgZmlsZW5hbWUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlbmFtZSBpblxuICBtYXRjaCBjaGFubmVsIGljICgtMSkgd2l0aFxuICAgIHwgZCAtPiBjbG9zZV9pbiBpYzsgZFxuICAgIHwgZXhjZXB0aW9uIGUgLT4gY2xvc2VfaW4gaWM7IHJhaXNlIGVcblxubGV0IG91dHB1dCBjaGFuIGRpZ2VzdCA9XG4gIG91dHB1dF9zdHJpbmcgY2hhbiBkaWdlc3RcblxubGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gMTZcblxubGV0IGNoYXJfaGV4IG4gPVxuICBDaGFyLnVuc2FmZV9jaHIgKG4gKyBpZiBuIDwgMTAgdGhlbiBDaGFyLmNvZGUgJzAnIGVsc2UgKENoYXIuY29kZSAnYScgLSAxMCkpXG5cbmxldCB0b19oZXggZCA9XG4gIGlmIFN0cmluZy5sZW5ndGggZCA8PiAxNiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDMyIGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIGxldCB4ID0gQ2hhci5jb2RlIGQuW2ldIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMikgKGNoYXJfaGV4ICh4IGxzciA0KSk7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMisxKSAoY2hhcl9oZXggKHggbGFuZCAweDBmKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG5cbmxldCBmcm9tX2hleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IDMyIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QuZnJvbV9oZXhcIjtcbiAgbGV0IGRpZ2l0IGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJzAnLi4nOScgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnQScuLidGJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgJ2EnLi4nZicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJEaWdlc3QuZnJvbV9oZXhcIilcbiAgaW5cbiAgbGV0IGJ5dGUgaSA9IGRpZ2l0IHMuW2ldIGxzbCA0ICsgZGlnaXQgcy5baSsxXSBpblxuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIEJ5dGVzLnNldCByZXN1bHQgaSAoQ2hhci5jaHIgKGJ5dGUgKDIgKiBpKSkpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgIFRoaXMgaXMgYSBsYWdnZWQtRmlib25hY2NpIEYoNTUsIDI0LCArKSB3aXRoIGEgbW9kaWZpZWQgYWRkaXRpb25cbiAgIGZ1bmN0aW9uIHRvIGVuaGFuY2UgdGhlIG1peGluZyBvZiBiaXRzLlxuICAgSWYgd2UgdXNlIG5vcm1hbCBhZGRpdGlvbiwgdGhlIGxvdy1vcmRlciBiaXQgZmFpbHMgdGVzdHMgMSBhbmQgN1xuICAgb2YgdGhlIERpZWhhcmQgdGVzdCBzdWl0ZSwgYW5kIGJpdHMgMSBhbmQgMiBhbHNvIGZhaWwgdGVzdCA3LlxuICAgSWYgd2UgdXNlIG11bHRpcGxpY2F0aW9uIGFzIHN1Z2dlc3RlZCBieSBNYXJzYWdsaWEsIGl0IGRvZXNuJ3QgZmFyZVxuICAgbXVjaCBiZXR0ZXIuXG4gICBCeSBtaXhpbmcgdGhlIGJpdHMgb2Ygb25lIG9mIHRoZSBudW1iZXJzIGJlZm9yZSBhZGRpdGlvbiAoWE9SIHRoZVxuICAgNSBoaWdoLW9yZGVyIGJpdHMgaW50byB0aGUgbG93LW9yZGVyIGJpdHMpLCB3ZSBnZXQgYSBnZW5lcmF0b3IgdGhhdFxuICAgcGFzc2VzIGFsbCB0aGUgRGllaGFyZCB0ZXN0cy5cbiopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSB7IHN0IDogaW50IGFycmF5OyBtdXRhYmxlIGlkeCA6IGludCB9XG5cbiAgbGV0IG5ld19zdGF0ZSAoKSA9IHsgc3QgPSBBcnJheS5tYWtlIDU1IDA7IGlkeCA9IDAgfVxuICBsZXQgYXNzaWduIHN0MSBzdDIgPVxuICAgIEFycmF5LmJsaXQgc3QyLnN0IDAgc3QxLnN0IDAgNTU7XG4gICAgc3QxLmlkeCA8LSBzdDIuaWR4XG5cblxuICBsZXQgZnVsbF9pbml0IHMgc2VlZCA9XG4gICAgbGV0IGNvbWJpbmUgYWNjdSB4ID0gRGlnZXN0LnN0cmluZyAoYWNjdSBeIEludC50b19zdHJpbmcgeCkgaW5cbiAgICBsZXQgZXh0cmFjdCBkID1cbiAgICAgIENoYXIuY29kZSBkLlswXSArIChDaGFyLmNvZGUgZC5bMV0gbHNsIDgpICsgKENoYXIuY29kZSBkLlsyXSBsc2wgMTYpXG4gICAgICArIChDaGFyLmNvZGUgZC5bM10gbHNsIDI0KVxuICAgIGluXG4gICAgbGV0IHNlZWQgPSBpZiBBcnJheS5sZW5ndGggc2VlZCA9IDAgdGhlbiBbfCAwIHxdIGVsc2Ugc2VlZCBpblxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgZG9cbiAgICAgIHMuc3QuKGkpIDwtIGk7XG4gICAgZG9uZTtcbiAgICBsZXQgYWNjdSA9IHJlZiBcInhcIiBpblxuICAgIGZvciBpID0gMCB0byA1NCArIG1heCA1NSBsIGRvXG4gICAgICBsZXQgaiA9IGkgbW9kIDU1IGluXG4gICAgICBsZXQgayA9IGkgbW9kIGwgaW5cbiAgICAgIGFjY3UgOj0gY29tYmluZSAhYWNjdSBzZWVkLihrKTtcbiAgICAgIHMuc3QuKGopIDwtIChzLnN0LihqKSBseG9yIGV4dHJhY3QgIWFjY3UpIGxhbmQgMHgzRkZGRkZGRjsgICgqIFBSIzU1NzUgKilcbiAgICBkb25lO1xuICAgIHMuaWR4IDwtIDBcblxuXG4gIGxldCBtYWtlIHNlZWQgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBmdWxsX2luaXQgcmVzdWx0IHNlZWQ7XG4gICAgcmVzdWx0XG5cblxuICBsZXQgbWFrZV9zZWxmX2luaXQgKCkgPSBtYWtlIChyYW5kb21fc2VlZCAoKSlcblxuICBsZXQgY29weSBzID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgYXNzaWduIHJlc3VsdCBzO1xuICAgIHJlc3VsdFxuXG5cbiAgKCogUmV0dXJucyAzMCByYW5kb20gYml0cyBhcyBhbiBpbnRlZ2VyIDAgPD0geCA8IDEwNzM3NDE4MjQgKilcbiAgbGV0IGJpdHMgcyA9XG4gICAgcy5pZHggPC0gKHMuaWR4ICsgMSkgbW9kIDU1O1xuICAgIGxldCBjdXJ2YWwgPSBzLnN0LihzLmlkeCkgaW5cbiAgICBsZXQgbmV3dmFsID0gcy5zdC4oKHMuaWR4ICsgMjQpIG1vZCA1NSlcbiAgICAgICAgICAgICAgICAgKyAoY3VydmFsIGx4b3IgKChjdXJ2YWwgbHNyIDI1KSBsYW5kIDB4MUYpKSBpblxuICAgIGxldCBuZXd2YWwzMCA9IG5ld3ZhbCBsYW5kIDB4M0ZGRkZGRkYgaW4gICgqIFBSIzU1NzUgKilcbiAgICBzLnN0LihzLmlkeCkgPC0gbmV3dmFsMzA7XG4gICAgbmV3dmFsMzBcblxuXG4gIGxldCByZWMgaW50YXV4IHMgbiA9XG4gICAgbGV0IHIgPSBiaXRzIHMgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IDB4M0ZGRkZGRkYgLSBuICsgMSB0aGVuIGludGF1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludGF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50MzIub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50MzIuc2hpZnRfbGVmdCAoSW50MzIub2ZfaW50IChiaXRzIHMgbGFuZCAxKSkgMzAgaW5cbiAgICBsZXQgciA9IEludDMyLmxvZ29yIGIxIGIyIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgaWYgSW50MzIuc3ViIHIgdiA+IEludDMyLmFkZCAoSW50MzIuc3ViIEludDMyLm1heF9pbnQgbikgMWxcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDY0Lm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzKSkgMzAgaW5cbiAgICBsZXQgYjMgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcyBsYW5kIDcpKSA2MCBpblxuICAgIGxldCByID0gSW50NjQubG9nb3IgYjEgKEludDY0LmxvZ29yIGIyIGIzKSBpblxuICAgIGxldCB2ID0gSW50NjQucmVtIHIgbiBpblxuICAgIGlmIEludDY0LnN1YiByIHYgPiBJbnQ2NC5hZGQgKEludDY0LnN1YiBJbnQ2NC5tYXhfaW50IG4pIDFMXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuXG4gICgqIFJldHVybnMgYSBmbG9hdCAwIDw9IHggPD0gMSB3aXRoIGF0IG1vc3QgNjAgYml0cyBvZiBwcmVjaXNpb24uICopXG4gIGxldCByYXdmbG9hdCBzID1cbiAgICBsZXQgc2NhbGUgPSAxMDczNzQxODI0LjAgICgqIDJeMzAgKilcbiAgICBhbmQgcjEgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBhbmQgcjIgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IHNlZWRcbmxldCBpbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBNYW5pcHVsYXRpbmcgdGhlIGN1cnJlbnQgc3RhdGUuICopXG5cbmxldCBnZXRfc3RhdGUgKCkgPSBTdGF0ZS5jb3B5IGRlZmF1bHRcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiBkZWZhdWx0IHNcblxuKCoqKioqKioqKioqKioqKioqKioqXG5cbigqIFRlc3QgZnVuY3Rpb25zLiAgTm90IGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICAgVGhlIFtjaGlzcXVhcmVdIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBuID4gMTByLlxuICAgSXQgcmV0dXJucyBhIHRyaXBsZSAobG93LCBhY3R1YWwsIGhpZ2gpLlxuICAgSWYgbG93IDw9IGFjdHVhbCA8PSBoaWdoLCB0aGUgW2ddIGZ1bmN0aW9uIHBhc3NlZCB0aGUgdGVzdCxcbiAgIG90aGVyd2lzZSBpdCBmYWlsZWQuXG5cbiAgU29tZSByZXN1bHRzOlxuXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDUwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI5OTc5MjY0MzsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAxNDE0MjEzNjsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMjQ7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAwOyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMjQ7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDE0MTQyMTM2OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMjk5NzkyNjQzOyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbi0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTk3LjUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4OS43NDAwMDAwMDAwMDUyMzg3LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDQ4NTguNTc4NjQzNzYyNjksIDUwNDUuNSwgNTE0MS40MjEzNTYyMzczMSlcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9XG4oOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTQ0LjgwNTk5OTk5OTk4MjMwNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDE5LjE5NzQ0MDAwMDAwMzU1LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU5LjMxNzc2MDAwMDAwNTM2LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDM5Ljk4NDYzOTk5OTk5NTEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU0LjM4MjA3OTk5OTk5NTc3LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDkwLjA5NjAwMDAwMDAwNSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDc2Ljc4NzIwMDAwMDAwNjEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjE3NjAwMDAwMDAwNjc1MjEsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4yMTYwMDAwMDAwMDAzNDkyLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODAuNjIyMDAwMDAwMDAzMDI2OCwgMTIwLilcblxuKilcblxuKCogUmV0dXJuIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdltpMCxpMVsgKilcbmxldCByZWMgc3Vtc3EgdiBpMCBpMSA9XG4gIGlmIGkwID49IGkxIHRoZW4gMC4wXG4gIGVsc2UgaWYgaTEgPSBpMCArIDEgdGhlbiBTdGRsaWIuZmxvYXQgdi4oaTApICouIFN0ZGxpYi5mbG9hdCB2LihpMClcbiAgZWxzZSBzdW1zcSB2IGkwICgoaTAraTEpLzIpICsuIHN1bXNxIHYgKChpMCtpMSkvMikgaTFcblxuXG5sZXQgY2hpc3F1YXJlIGcgbiByID1cbiAgaWYgbiA8PSAxMCAqIHIgdGhlbiBpbnZhbGlkX2FyZyBcImNoaXNxdWFyZVwiO1xuICBsZXQgZiA9IEFycmF5Lm1ha2UgciAwIGluXG4gIGZvciBpID0gMSB0byBuIGRvXG4gICAgbGV0IHQgPSBnIHIgaW5cbiAgICBmLih0KSA8LSBmLih0KSArIDFcbiAgZG9uZTtcbiAgbGV0IHQgPSBzdW1zcSBmIDAgclxuICBhbmQgciA9IFN0ZGxpYi5mbG9hdCByXG4gIGFuZCBuID0gU3RkbGliLmZsb2F0IG4gaW5cbiAgbGV0IHNyID0gMi4wICouIHNxcnQgciBpblxuICAociAtLiBzciwgICAociAqLiB0IC8uIG4pIC0uIG4sICAgciArLiBzcilcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIGxpbmVhciBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbSBudW1iZXJzLlxuKilcbmxldCBzdCA9IHJlZiAwXG5sZXQgaW5pdF9kaWZmIHIgPSBzdCA6PSBpbnQgclxubGV0IGRpZmYgciA9XG4gIGxldCB4MSA9ICFzdFxuICBhbmQgeDIgPSBpbnQgclxuICBpblxuICBzdCA6PSB4MjtcbiAgaWYgeDEgPj0geDIgdGhlblxuICAgIHgxIC0geDJcbiAgZWxzZVxuICAgIHIgKyB4MSAtIHgyXG5cblxubGV0IHN0MSA9IHJlZiAwXG5hbmQgc3QyID0gcmVmIDBcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIHF1YWRyYXRpYyBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbVxuICAgbnVtYmVycy5cbiopXG5sZXQgaW5pdF9kaWZmMiByID0gc3QxIDo9IGludCByOyBzdDIgOj0gaW50IHJcbmxldCBkaWZmMiByID1cbiAgbGV0IHgxID0gIXN0MVxuICBhbmQgeDIgPSAhc3QyXG4gIGFuZCB4MyA9IGludCByXG4gIGluXG4gIHN0MSA6PSB4MjtcbiAgc3QyIDo9IHgzO1xuICAoeDMgLSB4MiAtIHgyICsgeDEgKyAyKnIpIG1vZCByXG5cblxuKioqKioqKioqKioqKioqKioqKiopXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEhhc2ggdGFibGVzICopXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2xkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoX3VuaXZfcGFyYW1cIiBbQEBub2FsbG9jXVxuXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxubGV0IGhhc2hfcGFyYW0gbjEgbjIgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIG4xIG4yIDAgeFxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcblxuKCogV2UgZG8gZHluYW1pYyBoYXNoaW5nLCBhbmQgcmVzaXplIHRoZSB0YWJsZSBhbmQgcmVoYXNoIHRoZSBlbGVtZW50c1xuICAgd2hlbiBidWNrZXRzIGJlY29tZSB0b28gbG9uZy4gKilcblxudHlwZSAoJ2EsICdiKSB0ID1cbiAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgIG11dGFibGUgZGF0YTogKCdhLCAnYikgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgfVxuXG5hbmQgKCdhLCAnYikgYnVja2V0bGlzdCA9XG4gICAgRW1wdHlcbiAgfCBDb25zIG9mIHsgbXV0YWJsZSBrZXk6ICdhO1xuICAgICAgICAgICAgICBtdXRhYmxlIGRhdGE6ICdiO1xuICAgICAgICAgICAgICBtdXRhYmxlIG5leHQ6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgfVxuXG4oKiBUaGUgc2lnbiBvZiBpbml0aWFsX3NpemUgZW5jb2RlcyB0aGUgZmFjdCB0aGF0IGEgdHJhdmVyc2FsIGlzXG4gICBvbmdvaW5nIG9yIG5vdC5cblxuICAgVGhpcyBkaXNhYmxlcyB0aGUgZWZmaWNpZW50IGluIHBsYWNlIGltcGxlbWVudGF0aW9uIG9mIHJlc2l6aW5nLlxuKilcblxubGV0IG9uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgfHwgaC5pbml0aWFsX3NpemUgPCAwXG5cbmxldCBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBoLmluaXRpYWxfc2l6ZSA8LSAtIGguaW5pdGlhbF9zaXplXG5cbigqIFRvIHBpY2sgcmFuZG9tIHNlZWRzIGlmIHJlcXVlc3RlZCAqKVxuXG5sZXQgcmFuZG9taXplZF9kZWZhdWx0ID1cbiAgbGV0IHBhcmFtcyA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT5cbiAgICB0cnkgU3lzLmdldGVudiBcIkNBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+IFwiXCIgaW5cbiAgU3RyaW5nLmNvbnRhaW5zIHBhcmFtcyAnUidcblxubGV0IHJhbmRvbWl6ZWQgPSByZWYgcmFuZG9taXplZF9kZWZhdWx0XG5cbmxldCByYW5kb21pemUgKCkgPSByYW5kb21pemVkIDo9IHRydWVcbmxldCBpc19yYW5kb21pemVkICgpID0gIXJhbmRvbWl6ZWRcblxubGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaW5pdGlhbF9zaXplID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaC5zaXplIDwtIDA7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgaC5kYXRhLihpKSA8LSBFbXB0eVxuICBkb25lXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gYXMgY2VsbCAtPlxuICAgICAgICAgIGxldCBjZWxsID1cbiAgICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgICBlbHNlIENvbnMge2tleTsgZGF0YTsgbmV4dCA9IEVtcHR5fVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBoIGtleSBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIG5kYXRhX3RhaWwuKG5pZHgpIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBjZWxsO1xuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICAgIGluc2VydF9idWNrZXQgbmV4dFxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIGlucGxhY2UgdGhlblxuICAgICAgZm9yIGkgPSAwIHRvIG5zaXplIC0gMSBkb1xuICAgICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIEVtcHR5XG4gICAgICBkb25lO1xuICBlbmRcblxubGV0IGtleV9pbmRleCBoIGtleSA9XG4gICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDNcbiAgdGhlbiAoc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuICBlbHNlIChvbGRfaGFzaF9wYXJhbSAxMCAxMDAga2V5KSBtb2QgKEFycmF5Lmxlbmd0aCBoLmRhdGEpXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBbXVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBkYXRhIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxubGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBsID0gaC5kYXRhLihpKSBpblxuICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgZW5kXG5cbmxldCBtZW0gaCBrZXkgPVxuICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBmYWxzZVxuICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICBjb21wYXJlIGsga2V5ID0gMCB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lXG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZm9sZCBmIGggaW5pdCA9XG4gIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgICBFbXB0eSAtPlxuICAgICAgICBhY2N1XG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZG9fYnVja2V0IG5leHQgKGYga2V5IGRhdGEgYWNjdSkgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgIWFjY3VcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgc3RhdGlzdGljcyA9IHtcbiAgbnVtX2JpbmRpbmdzOiBpbnQ7XG4gIG51bV9idWNrZXRzOiBpbnQ7XG4gIG1heF9idWNrZXRfbGVuZ3RoOiBpbnQ7XG4gIGJ1Y2tldF9oaXN0b2dyYW06IGludCBhcnJheVxufVxuXG5sZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYWNjdVxuICB8IENvbnN7bmV4dH0gLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIG5leHRcblxubGV0IHN0YXRzIGggPVxuICBsZXQgbWJsID1cbiAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICBBcnJheS5pdGVyXG4gICAgKGZ1biBiIC0+XG4gICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICBoLmRhdGE7XG4gIHsgbnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHRibCA9XG4gICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICBpblxuICBhdXggMCBFbXB0eVxuXG5sZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxubGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxubGV0IGFkZF9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbmxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gIHRibFxuXG4oKiBGdW5jdG9yaWFsIGludGVyZmFjZSAqKVxuXG5tb2R1bGUgdHlwZSBIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdhIHRcbiAgICB2YWwgY3JlYXRlOiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5OiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZTogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdhIHRcbiAgICB2YWwgY3JlYXRlIDogP3JhbmRvbTpib29sIC0+IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2VTZWVkZWQoSDogU2VlZGVkSGFzaGVkVHlwZSk6IChTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBrZXkgPSBILnRcbiAgICB0eXBlICdhIGhhc2h0YmwgPSAoa2V5LCAnYSkgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGhhc2h0YmxcbiAgICBsZXQgY3JlYXRlID0gY3JlYXRlXG4gICAgbGV0IGNsZWFyID0gY2xlYXJcbiAgICBsZXQgcmVzZXQgPSByZXNldFxuICAgIGxldCBjb3B5ID0gY29weVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGtleSA9XG4gICAgICAoSC5oYXNoIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGFkZCBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIFtdXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE9ZDsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBkIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgICAgIGVuZFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICAgICAgSC5lcXVhbCBrIGtleSB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gICAgbGV0IGl0ZXIgPSBpdGVyXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgc3RhdHMgPSBzdGF0c1xuICAgIGxldCB0b19zZXEgPSB0b19zZXFcbiAgICBsZXQgdG9fc2VxX2tleXMgPSB0b19zZXFfa2V5c1xuICAgIGxldCB0b19zZXFfdmFsdWVzID0gdG9fc2VxX3ZhbHVlc1xuICBlbmRcblxubW9kdWxlIE1ha2UoSDogSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbmxldCBjcmVhdGUgbCA9XG4gIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gT2JqLkVwaGVtZXJvbi5tYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhcIldlYWsuY3JlYXRlXCIpO1xuICBjcmVhdGUgbFxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyICopXG5sZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG5cbmxldCBsZW5ndGggeCA9IE9iai5zaXplKE9iai5yZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxubGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhtc2cpXG5cbmV4dGVybmFsIHNldCcgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG5leHRlcm5hbCB1bnNldCA6ICdhIHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxubGV0IHNldCBlIG8geCA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuc2V0XCI7XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gdW5zZXQgZSBvXG4gIHwgU29tZSB4IC0+IHNldCcgZSBvIHhcblxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0XCJcbmxldCBnZXQgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRcIjtcbiAgZ2V0IGUgb1xuXG5leHRlcm5hbCBnZXRfY29weSA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldF9jb3B5XCJcbmxldCBnZXRfY29weSBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldF9jb3B5XCI7XG4gIGdldF9jb3B5IGUgb1xuXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5sZXQgY2hlY2sgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5jaGVja1wiO1xuICBjaGVjayBlIG9cblxuZXh0ZXJuYWwgYmxpdCA6ICdhIHQgLT4gaW50IC0+ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3dlYWtfYmxpdFwiXG5cbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcbmxldCBibGl0IGUxIG8xIGUyIG8yIGwgPVxuICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIldlYWsuYmxpdFwiXG4gIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdCBlMSBvMSBlMiBvMiBsXG5cbmxldCBmaWxsIGFyIG9mcyBsZW4geCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYXIgLSBsZW5cbiAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldlYWsuZmlsbFwiKVxuICBlbHNlIGJlZ2luXG4gICAgZm9yIGkgPSBvZnMgdG8gKG9mcyArIGxlbiAtIDEpIGRvXG4gICAgICBzZXQgYXIgaSB4XG4gICAgZG9uZVxuICBlbmRcblxuXG4oKiogV2VhayBoYXNoIHRhYmxlcyAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZGF0YVxuICB0eXBlIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiB0XG4gIHZhbCBjbGVhciA6IHQgLT4gdW5pdFxuICB2YWwgbWVyZ2UgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgYWRkIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCBmaW5kIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGZpbmRfb3B0IDogdCAtPiBkYXRhIC0+IGRhdGEgb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6IHQgLT4gZGF0YSAtPiBkYXRhIGxpc3RcbiAgdmFsIG1lbSA6IHQgLT4gZGF0YSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGRhdGEgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBmb2xkIDogKGRhdGEgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IG1pbiAoMyAqIG4gLyAyICsgMykgU3lzLm1heF9hcnJheV9sZW5ndGhcbiAgbGV0IHByZXZfc3ogbiA9ICgobiAtIDMpICogMiArIDIpIC8gM1xuXG4gIGxldCB0ZXN0X3Nocmlua19idWNrZXQgdCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKHQucm92ZXIpIGluXG4gICAgbGV0IGhidWNrZXQgPSB0Lmhhc2hlcy4odC5yb3ZlcikgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCBwcmV2X2xlbiA9IHByZXZfc3ogbGVuIGluXG4gICAgbGV0IGxpdmUgPSBjb3VudF9idWNrZXQgMCBidWNrZXQgMCBpblxuICAgIGlmIGxpdmUgPD0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IHJlYyBsb29wIGkgaiA9XG4gICAgICAgIGlmIGogPj0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgICAgIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gbG9vcCAoaSArIDEpIGpcbiAgICAgICAgICBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBqIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGJsaXQgYnVja2V0IGogYnVja2V0IGkgMTtcbiAgICAgICAgICAgIGhidWNrZXQuKGkpIDwtIGhidWNrZXQuKGopO1xuICAgICAgICAgICAgbG9vcCAoaSArIDEpIChqIC0gMSk7XG4gICAgICAgICAgZW5kIGVsc2UgbG9vcCBpIChqIC0gMSk7XG4gICAgICAgIGVuZDtcbiAgICAgIGluXG4gICAgICBsb29wIDAgKGxlbmd0aCBidWNrZXQgLSAxKTtcbiAgICAgIGlmIHByZXZfbGVuID0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gW3wgfF07XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBPYmoudHJ1bmNhdGUgKE9iai5yZXByIGJ1Y2tldCkgKHByZXZfbGVuICsgYWRkaXRpb25hbF92YWx1ZXMpO1xuICAgICAgICBPYmoudHJ1bmNhdGUgKE9iai5yZXByIGhidWNrZXQpIHByZXZfbGVuO1xuICAgICAgZW5kO1xuICAgICAgaWYgbGVuID4gdC5saW1pdCAmJiBwcmV2X2xlbiA8PSB0LmxpbWl0IHRoZW4gdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplIC0gMTtcbiAgICBlbmQ7XG4gICAgdC5yb3ZlciA8LSAodC5yb3ZlciArIDEpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cblxuICBsZXQgcmVjIHJlc2l6ZSB0ID1cbiAgICBsZXQgb2xkbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbmV3bGVuID0gbmV4dF9zeiBvbGRsZW4gaW5cbiAgICBpZiBuZXdsZW4gPiBvbGRsZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IG5ld3QgPSBjcmVhdGUgbmV3bGVuIGluXG4gICAgICBsZXQgYWRkX3dlYWsgb2Igb2ggb2kgPVxuICAgICAgICBsZXQgc2V0dGVyIG5iIG5pIF8gPSBibGl0IG9iIG9pIG5iIG5pIDEgaW5cbiAgICAgICAgbGV0IGggPSBvaC4ob2kpIGluXG4gICAgICAgIGFkZF9hdXggbmV3dCBzZXR0ZXIgTm9uZSBoIChnZXRfaW5kZXggbmV3dCBoKTtcbiAgICAgIGluXG4gICAgICBpdGVyX3dlYWsgYWRkX3dlYWsgdDtcbiAgICAgIHQudGFibGUgPC0gbmV3dC50YWJsZTtcbiAgICAgIHQuaGFzaGVzIDwtIG5ld3QuaGFzaGVzO1xuICAgICAgdC5saW1pdCA8LSBuZXd0LmxpbWl0O1xuICAgICAgdC5vdmVyc2l6ZSA8LSBuZXd0Lm92ZXJzaXplO1xuICAgICAgdC5yb3ZlciA8LSB0LnJvdmVyIG1vZCBBcnJheS5sZW5ndGggbmV3dC50YWJsZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgdC5saW1pdCA8LSBtYXhfaW50OyAgICAgICAgICAgICAoKiBtYXhpbXVtIHNpemUgYWxyZWFkeSByZWFjaGVkICopXG4gICAgICB0Lm92ZXJzaXplIDwtIDA7XG4gICAgZW5kXG5cbiAgYW5kIGFkZF9hdXggdCBzZXR0ZXIgZCBoIGluZGV4ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZXdzeiA9XG4gICAgICAgICAgbWluICgzICogc3ogLyAyICsgMykgKFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXMpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5ld3N6IDw9IHN6IHRoZW4gZmFpbHdpdGggXCJXZWFrLk1ha2U6IGhhc2ggYnVja2V0IGNhbm5vdCBncm93IG1vcmVcIjtcbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIG5ld3N6IGluXG4gICAgICAgIGxldCBuZXdoYXNoZXMgPSBBcnJheS5tYWtlIG5ld3N6IDAgaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBzejtcbiAgICAgICAgQXJyYXkuYmxpdCBoYXNoZXMgMCBuZXdoYXNoZXMgMCBzejtcbiAgICAgICAgc2V0dGVyIG5ld2J1Y2tldCBzeiBkO1xuICAgICAgICBuZXdoYXNoZXMuKHN6KSA8LSBoO1xuICAgICAgICB0LnRhYmxlLihpbmRleCkgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4oaW5kZXgpIDwtIG5ld2hhc2hlcztcbiAgICAgICAgaWYgc3ogPD0gdC5saW1pdCAmJiBuZXdzeiA+IHQubGltaXQgdGhlbiBiZWdpblxuICAgICAgICAgIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSArIDE7XG4gICAgICAgICAgZm9yIF9pID0gMCB0byBvdmVyX2xpbWl0IGRvIHRlc3Rfc2hyaW5rX2J1Y2tldCB0IGRvbmU7XG4gICAgICAgIGVuZDtcbiAgICAgICAgaWYgdC5vdmVyc2l6ZSA+IEFycmF5Lmxlbmd0aCB0LnRhYmxlIC8gb3Zlcl9saW1pdCB0aGVuIHJlc2l6ZSB0O1xuICAgICAgZW5kIGVsc2UgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBiZWdpblxuICAgICAgICBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldHRlciBidWNrZXQgaSBkO1xuICAgICAgICBoYXNoZXMuKGkpIDwtIGg7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBhZGQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIChnZXRfaW5kZXggdCBoKVxuXG5cbiAgbGV0IGZpbmRfb3IgdCBkIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kIGggaW5kZXhcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IG1lcmdlIHQgZCA9XG4gICAgZmluZF9vciB0IGQgKGZ1biBoIGluZGV4IC0+IGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCBpbmRleDsgZClcblxuXG4gIGxldCBmaW5kIHQgZCA9IGZpbmRfb3IgdCBkIChmdW4gX2ggX2luZGV4IC0+IHJhaXNlIE5vdF9mb3VuZClcblxuICBsZXQgZmluZF9vcHQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gTm9uZVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBmaW5kX3NoYWRvdyB0IGQgaWZmb3VuZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZCAtPiBpZmZvdW5kIGJ1Y2tldCBpXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgcmVtb3ZlIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIHcgaSAtPiBzZXQgdyBpIE5vbmUpICgpXG5cblxuICBsZXQgbWVtIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIF93IF9pIC0+IHRydWUpIGZhbHNlXG5cblxuICBsZXQgZmluZF9hbGwgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2N1ID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBhY2N1XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGxvb3AgKGkgKyAxKSAodiA6OiBhY2N1KVxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpIGFjY3VcbiAgICBpblxuICAgIGxvb3AgMCBbXVxuXG5cbiAgbGV0IHN0YXRzIHQgPVxuICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBsZW5zID0gQXJyYXkubWFwIGxlbmd0aCB0LnRhYmxlIGluXG4gICAgQXJyYXkuc29ydCBjb21wYXJlIGxlbnM7XG4gICAgbGV0IHRvdGxlbiA9IEFycmF5LmZvbGRfbGVmdCAoICsgKSAwIGxlbnMgaW5cbiAgICAobGVuLCBjb3VudCB0LCB0b3RsZW4sIGxlbnMuKDApLCBsZW5zLihsZW4vMiksIGxlbnMuKGxlbi0xKSlcblxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQSBwcmV0dHktcHJpbnRpbmcgZmFjaWxpdHkgYW5kIGRlZmluaXRpb24gb2YgZm9ybWF0dGVycyBmb3IgJ3BhcmFsbGVsJ1xuICAgKGkuZS4gdW5yZWxhdGVkIG9yIGluZGVwZW5kZW50KSBwcmV0dHktcHJpbnRpbmcgb24gbXVsdGlwbGUgb3V0IGNoYW5uZWxzLiAqKVxuXG4oKlxuICAgVGhlIHByZXR0eS1wcmludGluZyBlbmdpbmUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuKilcblxubGV0IGlkIHggPSB4XG5cbigqIEEgZGV2b3RlZCB0eXBlIGZvciBzaXplcyB0byBhdm9pZCBjb25mdXNpb25cbiAgIGJldHdlZW4gc2l6ZXMgYW5kIG1lcmUgaW50ZWdlcnMuICopXG5tb2R1bGUgU2l6ZSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgdW5rbm93biA6IHRcbiAgdmFsIGlzX2tub3duIDogdCAtPiBib29sXG5lbmQgID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB0b19pbnQgPSBpZFxuICBsZXQgb2ZfaW50ID0gaWRcbiAgbGV0IHplcm8gPSAwXG4gIGxldCB1bmtub3duID0gLTFcbiAgbGV0IGlzX2tub3duIG4gPSBuID49IDBcbmVuZFxuXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgeyAgICAgICAgICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgICAgIGZpdHM6IHN0cmluZyAqIGludCAqIHN0cmluZzsgICAoKiBsaW5lIGlzIG5vdCBzcGxpdCAqKVxuICAgICAgYnJlYWtzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICgqIGxpbmUgaXMgc3BsaXQgKilcbiAgICB9XG4gIHwgUHBfdGJyZWFrIG9mIGludCAqIGludCAgICAgKCogZ28gdG8gbmV4dCB0YWJ1bGF0aW9uICopXG4gIHwgUHBfc3RhYiAgICAgICAgICAgICAgICAgICAgKCogc2V0IGEgdGFidWxhdGlvbiAqKVxuICB8IFBwX2JlZ2luIG9mIGludCAqIGJveF90eXBlICgqIGJlZ2lubmluZyBvZiBhIGJveCAqKVxuICB8IFBwX2VuZCAgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIGJveCAqKVxuICB8IFBwX3RiZWdpbiBvZiB0Ym94ICAgICAgICAgICgqIGJlZ2lubmluZyBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfdGVuZCAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF9uZXdsaW5lICAgICAgICAgICAgICAgICAoKiB0byBmb3JjZSBhIG5ld2xpbmUgaW5zaWRlIGEgYm94ICopXG4gIHwgUHBfaWZfbmV3bGluZSAgICAgICAgICAgICAgKCogdG8gZG8gc29tZXRoaW5nIG9ubHkgaWYgdGhpcyB2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSBoYXMgYmVlbiBicm9rZW4gKilcbiAgfCBQcF9vcGVuX3RhZyBvZiBzdGFnICAgICAgICAgKCogb3BlbmluZyBhIHRhZyBuYW1lICopXG4gIHwgUHBfY2xvc2VfdGFnICAgICAgICAgICAgICAgKCogY2xvc2luZyB0aGUgbW9zdCByZWNlbnRseSBvcGVuIHRhZyAqKVxuXG5hbmQgc3RhZyA9IC4uXG5cbmFuZCB0Ym94ID0gUHBfdGJveCBvZiBpbnQgbGlzdCByZWYgICgqIFRhYnVsYXRpb24gYm94ICopXG5cbnR5cGUgdGFnID0gc3RyaW5nXG50eXBlIHN0YWcgKz0gU3RyaW5nX3RhZyBvZiB0YWdcblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6XG4gICBwcmV0dHktcHJpbnRpbmcgbWF0ZXJpYWwgaXMgbm90IHdyaXR0ZW4gaW4gdGhlIG91dHB1dCBhcyBzb29uIGFzIGVtaXR0ZWQ7XG4gICBpbnN0ZWFkLCB0aGUgbWF0ZXJpYWwgaXMgc2ltcGx5IHJlY29yZGVkIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSxcbiAgIHVudGlsIHRoZSBlbmNsb3NpbmcgYm94IGhhcyBhIGtub3duIGNvbXB1dGVkIHNpemUgYW5kIHByb3BlciBzcGxpdHRpbmdcbiAgIGRlY2lzaW9ucyBjYW4gYmUgbWFkZS5cblxuICAgVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGNvbnRhaW5zIGZvcm1hdHRpbmcgZWxlbWVudHMgdG8gYmUgcHJpbnRlZC5cbiAgIEVhY2ggZm9ybWF0dGluZyBlbGVtZW50IGlzIGEgdHVwbGUgKHNpemUsIHRva2VuLCBsZW5ndGgpLCB3aGVyZVxuICAgLSBsZW5ndGggaXMgdGhlIGRlY2xhcmVkIGxlbmd0aCBvZiB0aGUgdG9rZW4sXG4gICAtIHNpemUgaXMgZWZmZWN0aXZlIHNpemUgb2YgdGhlIHRva2VuIHdoZW4gaXQgaXMgcHJpbnRlZFxuICAgICAoc2l6ZSBpcyBzZXQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgYm94IGlzIGtub3duLCBzbyB0aGF0IHNpemUgb2YgYnJlYWtcbiAgICAgIGhpbnRzIGFyZSBkZWZpbml0aXZlKS4gKilcbnR5cGUgcHBfcXVldWVfZWxlbSA9IHtcbiAgbXV0YWJsZSBzaXplIDogU2l6ZS50O1xuICB0b2tlbiA6IHBwX3Rva2VuO1xuICBsZW5ndGggOiBpbnQ7XG59XG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGRlZmluaXRpb24uICopXG50eXBlIHBwX3F1ZXVlID0gcHBfcXVldWVfZWxlbSBRdWV1ZS50XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrOiBzY2FubmluZyBlbGVtZW50IGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fZWxlbSA9IHtcbiAgbGVmdF90b3RhbCA6IGludDsgKCogVmFsdWUgb2YgcHBfbGVmdF90b3RhbCB3aGVuIHRoZSBlbGVtZW50IHdhcyBlbnF1ZXVlZC4gKilcbiAgcXVldWVfZWxlbSA6IHBwX3F1ZXVlX2VsZW1cbn1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6XG4gICB0aGUgZm9ybWF0dGluZyBzdGFjayBjb250YWlucyB0aGUgZGVzY3JpcHRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICBib3hlczsgdGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2sgaXMgdXNlZCB0byBzcGxpdCB0aGUgbGluZXNcbiAgIHdoaWxlIHByaW50aW5nIHRva2Vucy4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6IGZvcm1hdHRpbmcgc3RhY2sgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgRWFjaCBzdGFjayBlbGVtZW50IGRlc2NyaWJlcyBhIHByZXR0eS1wcmludGluZyBib3guICopXG50eXBlIHBwX2Zvcm1hdF9lbGVtID0geyBib3hfdHlwZSA6IGJveF90eXBlOyB3aWR0aCA6IGludCB9XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuICBwcF9zY2FuX3N0YWNrIDogcHBfc2Nhbl9lbGVtIFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrLiAqKVxuICBwcF9mb3JtYXRfc3RhY2sgOiBwcF9mb3JtYXRfZWxlbSBTdGFjay50O1xuICBwcF90Ym94X3N0YWNrIDogdGJveCBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2VtYW50aWNzIHRhZyBzdGFjay4gKilcbiAgcHBfdGFnX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICBwcF9tYXJrX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX21hcmtfY2xvc2VfdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfcHJpbnRfb3Blbl90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogc3RhZyAtPiB1bml0O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG4gIHBwX3F1ZXVlIDogcHBfcXVldWU7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBzcGVjaWZpYyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zLiAqKVxudHlwZSBmb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBmdW5jdGlvbnMgdG8gb3V0cHV0IG1hdGVyaWFsLiAqKVxudHlwZSBmb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9IHtcbiAgb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gIG91dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xufVxuXG5cbigqXG5cbiAgQXV4aWxpYXJpZXMgYW5kIGJhc2ljIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRW50ZXIgYSB0b2tlbiBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbiA9XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgdG9rZW4ubGVuZ3RoO1xuICBRdWV1ZS5hZGQgdG9rZW4gc3RhdGUucHBfcXVldWVcblxuXG5sZXQgcHBfY2xlYXJfcXVldWUgc3RhdGUgPVxuICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIDE7IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIDE7XG4gIFF1ZXVlLmNsZWFyIHN0YXRlLnBwX3F1ZXVlXG5cblxuKCogUHBfaW5maW5pdHk6IGxhcmdlIHZhbHVlIGZvciBkZWZhdWx0IHRva2VucyBzaXplLlxuXG4gICBQcF9pbmZpbml0eSBpcyBkb2N1bWVudGVkIGFzIGJlaW5nIGdyZWF0ZXIgdGhhbiAxZTEwOyB0byBhdm9pZFxuICAgY29uZnVzaW9uIGFib3V0IHRoZSB3b3JkICdncmVhdGVyJywgd2UgY2hvb3NlIHBwX2luZmluaXR5IGdyZWF0ZXJcbiAgIHRoYW4gMWUxMCArIDE7IGZvciBjb3JyZWN0IGhhbmRsaW5nIG9mIHRlc3RzIGluIHRoZSBhbGdvcml0aG0sXG4gICBwcF9pbmZpbml0eSBtdXN0IGJlIGV2ZW4gb25lIG1vcmUgdGhhbiAxZTEwICsgMTsgbGV0J3Mgc3RhbmQgb24gdGhlXG4gICBzYWZlIHNpZGUgYnkgY2hvb3NpbmcgMS5lMTArMTAuXG5cbiAgIFBwX2luZmluaXR5IGNvdWxkIHByb2JhYmx5IGJlIDEwNzM3NDE4MjMgdGhhdCBpcyAyXjMwIC0gMSwgdGhhdCBpc1xuICAgdGhlIG1pbmltYWwgdXBwZXIgYm91bmQgZm9yIGludGVnZXJzOyBub3cgdGhhdCBtYXhfaW50IGlzIGRlZmluZWQsXG4gICB0aGlzIGxpbWl0IGNvdWxkIGFsc28gYmUgZGVmaW5lZCBhcyBtYXhfaW50IC0gMS5cblxuICAgSG93ZXZlciwgYmVmb3JlIHNldHRpbmcgcHBfaW5maW5pdHkgdG8gc29tZXRoaW5nIGFyb3VuZCBtYXhfaW50LCB3ZVxuICAgbXVzdCBjYXJlZnVsbHkgZG91YmxlLWNoZWNrIGFsbCB0aGUgaW50ZWdlciBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgIHRoYXQgaW52b2x2ZSBwcF9pbmZpbml0eSwgc2luY2UgYW55IG92ZXJmbG93IHdvdWxkIHdyZWNrIGhhdm9jIHRoZVxuICAgcHJldHR5LXByaW50aW5nIGFsZ29yaXRobSdzIGludmFyaWFudHMuIEdpdmVuIHRoYXQgdGhpcyBhcml0aG1ldGljXG4gICBjb3JyZWN0bmVzcyBjaGVjayBpcyBkaWZmaWN1bHQgYW5kIGVycm9yIHByb25lIGFuZCBnaXZlbiB0aGF0IDFlMTBcbiAgICsgMSBpcyBpbiBwcmFjdGljZSBsYXJnZSBlbm91Z2gsIHRoZXJlIGlzIG5vIG5lZWQgdG8gYXR0ZW1wdCB0byBzZXRcbiAgIHBwX2luZmluaXR5IHRvIHRoZSB0aGVvcmV0aWNhbGx5IG1heGltdW0gbGltaXQuIEl0IGlzIG5vdCB3b3J0aCB0aGVcbiAgIGJ1cmRlbiAhICopXG5sZXQgcHBfaW5maW5pdHkgPSAxMDAwMDAwMDEwXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgZm9yIHRoZSBmb3JtYXR0ZXIuICopXG5sZXQgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBzID0gc3RhdGUucHBfb3V0X3N0cmluZyBzIDAgKFN0cmluZy5sZW5ndGggcylcbmFuZCBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lICgpXG5hbmQgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X3NwYWNlcyBuXG5hbmQgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X2luZGVudCBuXG5cbigqIEZvcm1hdCBhIHRleHR1YWwgdG9rZW4gKilcbmxldCBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHRleHQgPVxuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHRleHQ7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIGZhbHNlXG5cbigqIEZvcm1hdCBhIHN0cmluZyBieSBpdHMgbGVuZ3RoLCBpZiBub3QgZW1wdHkgKilcbmxldCBmb3JtYXRfc3RyaW5nIHN0YXRlIHMgPVxuICBpZiBzIDw+IFwiXCIgdGhlbiBmb3JtYXRfcHBfdGV4dCBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrLCBpbmRlbnRpbmcgYSBuZXcgbGluZS4gKilcbmxldCBicmVha19uZXdfbGluZSBzdGF0ZSAoYmVmb3JlLCBvZmZzZXQsIGFmdGVyKSB3aWR0aCA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gdHJ1ZTtcbiAgbGV0IGluZGVudCA9IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2Zmc2V0IGluXG4gICgqIERvbid0IGluZGVudCBtb3JlIHRoYW4gcHBfbWF4X2luZGVudC4gKilcbiAgbGV0IHJlYWxfaW5kZW50ID0gbWluIHN0YXRlLnBwX21heF9pbmRlbnQgaW5kZW50IGluXG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIHJlYWxfaW5kZW50O1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gZm9yY2UgYSBsaW5lIGJyZWFrIGluc2lkZSBhIGJveDogbm8gb2Zmc2V0IGlzIGFkZGVkLiAqKVxubGV0IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGggPSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgMCwgXCJcIikgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIChiZWZvcmUsIHdpZHRoLCBhZnRlcikgPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGg7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlXG4gIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgaWYgd2lkdGggPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW5cbiAgICAgIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfZml0cyB8IFBwX2hib3ggLT4gKClcbiAgICAgIHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBza2lwIGEgdG9rZW4sIGlmIHRoZSBwcmV2aW91cyBsaW5lIGhhcyBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9za2lwX3Rva2VuIHN0YXRlID1cbiAgbWF0Y2ggUXVldWUudGFrZV9vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogcHJpbnRfaWZfbmV3bGluZSBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBwcmludGluZyBjb21tYW5kICopXG4gIHwgU29tZSB7IHNpemU7IGxlbmd0aDsgXyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuZ3RoO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIFNpemUudG9faW50IHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHNcblxuICB8IFBwX2JlZ2luIChvZmYsIHR5KSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgaWYgaW5zZXJ0aW9uX3BvaW50ID4gc3RhdGUucHBfbWF4X2luZGVudCB0aGVuXG4gICAgICAoKiBjYW4gbm90IG9wZW4gYSBib3ggcmlnaHQgdGhlcmUuICopXG4gICAgICBiZWdpbiBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlIGVuZDtcbiAgICBsZXQgd2lkdGggPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJveF90eXBlID1cbiAgICAgIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfdmJveCAtPiBQcF92Ym94XG4gICAgICB8IFBwX2hib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHMgLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiB0eSBlbHNlIFBwX2ZpdHMgaW5cbiAgICBTdGFjay5wdXNoIHsgYm94X3R5cGU7IHdpZHRoIH0gc3RhdGUucHBfZm9ybWF0X3N0YWNrXG5cbiAgfCBQcF9lbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3RiZWdpbiAoUHBfdGJveCBfIGFzIHRib3gpIC0+XG4gICAgU3RhY2sucHVzaCB0Ym94IHN0YXRlLnBwX3Rib3hfc3RhY2tcblxuICB8IFBwX3RlbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCByZWMgYWRkX3RhYiBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPiBbbl1cbiAgICAgICAgfCB4IDo6IGwgYXMgbHMgLT4gaWYgbiA8IHggdGhlbiBuIDo6IGxzIGVsc2UgeCA6OiBhZGRfdGFiIG4gbCBpblxuICAgICAgdGFicyA6PSBhZGRfdGFiIChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSAhdGFic1xuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBpbnNlcnRpb25fcG9pbnRcbiAgICAgICAgfCBmaXJzdCA6OiBfIC0+XG4gICAgICAgICAgbGV0IHJlYyBmaW5kID0gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgICAgICAgIGlmIGhlYWQgPj0gaW5zZXJ0aW9uX3BvaW50IHRoZW4gaGVhZCBlbHNlIGZpbmQgdGFpbFxuICAgICAgICAgICAgfCBbXSAtPiBmaXJzdCBpblxuICAgICAgICAgIGZpbmQgIXRhYnMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSB0YWIgLSBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoXCJcIiwgb2Zmc2V0ICsgbiwgXCJcIilcbiAgICAgIGVsc2UgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIHRhYiArIG9mZiwgXCJcIikgc3RhdGUucHBfbWFyZ2luXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyB3aWR0aDsgX30gLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuICAgIGVuZFxuXG4gIHwgUHBfaWZfbmV3bGluZSAtPlxuICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ICE9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICB0aGVuIHBwX3NraXBfdG9rZW4gc3RhdGVcblxuICB8IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gLT5cbiAgICBsZXQgYmVmb3JlLCBvZmYsIF8gPSBicmVha3MgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgICBiZWdpbiBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfYm94IC0+XG4gICAgICAgICgqIEhhdmUgdGhlIGxpbmUganVzdCBiZWVuIGJyb2tlbiBoZXJlID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfaXNfbmV3X2xpbmUgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0cyBlbHNlXG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aCBlbHNlXG4gICAgICAgICgqIGJyZWFrIHRoZSBsaW5lIGhlcmUgbGVhZHMgdG8gbmV3IGluZGVudGF0aW9uID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPiBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZlxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2h2Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9maXRzIC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX3Zib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2hib3ggLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9tYXJrX3N0YWNrIHdpdGhcbiAgICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19jbG9zZV90YWcgdGFnX25hbWUgaW5cbiAgICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlclxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFByaW50aW5nIGlzIGRlbGF5ZWQgd2hlbiB0aGUgdGV4dCB3YWl0aW5nIGluIHRoZSBxdWV1ZSByZXF1aXJlc1xuICAgbW9yZSByb29tIHRvIGZvcm1hdCB0aGFuIGV4aXN0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IHJlYyBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS5wZWVrX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBObyB0b2tlbnMgdG8gcHJpbnQgKilcbiAgfCBTb21lIHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IC0+XG4gICAgbGV0IHBlbmRpbmdfY291bnQgPSBzdGF0ZS5wcF9yaWdodF90b3RhbCAtIHN0YXRlLnBwX2xlZnRfdG90YWwgaW5cbiAgICBpZiBTaXplLmlzX2tub3duIHNpemUgfHwgcGVuZGluZ19jb3VudCA+PSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gYmVnaW5cbiAgICAgIFF1ZXVlLnRha2Ugc3RhdGUucHBfcXVldWUgfD4gaWdub3JlOyAoKiBOb3QgZW1wdHk6IHdlIHBlZWsgaW50byBpdCAqKVxuICAgICAgbGV0IHNpemUgPSBpZiBTaXplLmlzX2tub3duIHNpemUgdGhlbiBTaXplLnRvX2ludCBzaXplIGVsc2UgcHBfaW5maW5pdHkgaW5cbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplIHRva2VuO1xuICAgICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBsZW5ndGggKyBzdGF0ZS5wcF9sZWZ0X3RvdGFsO1xuICAgICAgKGFkdmFuY2VfbGVmdCBbQHRhaWxjYWxsXSkgc3RhdGVcbiAgICBlbmRcblxuXG4oKiBUbyBlbnF1ZXVlIGEgdG9rZW4gOiB0cnkgdG8gYWR2YW5jZS4gKilcbmxldCBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgdG9rID0gcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7IGFkdmFuY2VfbGVmdCBzdGF0ZVxuXG5cbigqIFRvIGVucXVldWUgc3RyaW5ncy4gKilcbmxldCBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHMgPVxuICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplOyB0b2tlbiA9IFBwX3RleHQgczsgbGVuZ3RoID0gU2l6ZS50b19pbnQgc2l6ZSB9XG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSAoU2l6ZS5vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGFjayA9XG4gIFN0YWNrLmNsZWFyIHN0YWNrO1xuICBsZXQgcXVldWVfZWxlbSA9IHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF90ZXh0IFwiXCI7IGxlbmd0aCA9IDAgfSBpblxuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IC0xOyBxdWV1ZV9lbGVtIH0gc3RhY2tcblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG4gIHwgU29tZSB7IGxlZnRfdG90YWw7IHF1ZXVlX2VsZW0gfSAtPlxuICAgIGxldCBzaXplID0gU2l6ZS50b19pbnQgcXVldWVfZWxlbS5zaXplIGluXG4gICAgKCogdGVzdCBpZiBzY2FuIHN0YWNrIGNvbnRhaW5zIGFueSBkYXRhIHRoYXQgaXMgbm90IG9ic29sZXRlLiAqKVxuICAgIGlmIGxlZnRfdG90YWwgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW5cbiAgICAgIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggcXVldWVfZWxlbS50b2tlbiB3aXRoXG4gICAgICB8IFBwX2JyZWFrIF8gfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfYmVnaW4gKF8sIF8pIC0+XG4gICAgICAgIGlmIG5vdCB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX3RleHQgXyB8IFBwX3N0YWIgfCBQcF90YmVnaW4gXyB8IFBwX3RlbmQgfCBQcF9lbmRcbiAgICAgIHwgUHBfbmV3bGluZSB8IFBwX2lmX25ld2xpbmUgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG5cblxuKCogUHVzaCBhIHRva2VuIG9uIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLlxuICAgSWYgYiBpcyB0cnVlIHNldF9zaXplIGlzIGNhbGxlZC4gKilcbmxldCBzY2FuX3B1c2ggc3RhdGUgYiB0b2tlbiA9XG4gIHBwX2VucXVldWUgc3RhdGUgdG9rZW47XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBsZXQgZWxlbSA9IHsgbGVmdF90b3RhbCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsOyBxdWV1ZV9lbGVtID0gdG9rZW4gfSBpblxuICBTdGFjay5wdXNoIGVsZW0gc3RhdGUucHBfc2Nhbl9zdGFja1xuXG5cbigqIFRvIG9wZW4gYSBuZXcgYm94IDpcbiAgIHRoZSB1c2VyIG1heSBzZXQgdGhlIGRlcHRoIGJvdW5kIHBwX21heF9ib3hlc1xuICAgYW55IHRleHQgbmVzdGVkIGRlZXBlciBpcyBwcmludGVkIGFzIHRoZSBlbGxpcHNpcyBzdHJpbmcuICopXG5sZXQgcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBicl90eSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfYmVnaW4gKGluZGVudCwgYnJfdHkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDAgfTtcbiAgICAgIHNldF9zaXplIHN0YXRlIHRydWU7IHNldF9zaXplIHN0YXRlIGZhbHNlXG4gICAgZW5kO1xuICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDE7XG4gIGVuZFxuXG5cbigqIE9wZW4gYSB0YWcsIHB1c2hpbmcgaXQgb24gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9vcGVuX3N0YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyB0YWdfbmFtZVxuICBlbmQ7XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgbGV0IHRva2VuID0gUHBfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW47IGxlbmd0aCA9IDAgfVxuXG5cbigqIENsb3NlIGEgdGFnLCBwb3BwaW5nIGl0IGZyb20gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9jbG9zZV9zdGFnIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9jbG9zZV90YWc7IGxlbmd0aCA9IDAgfTtcbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gICAgbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90YWdfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyB0YWdfbmFtZVxuXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgcyA9IHBwX29wZW5fc3RhZyBzdGF0ZSAoU3RyaW5nX3RhZyBzKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKClcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV90YWcgc3RhdGUgKCkpIHN0YXRlLnBwX3RhZ19zdGFja1xuXG5cbigqIEZsdXNoaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGIgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGIgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoU2l6ZS5vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKEludC50b19zdHJpbmcgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgdHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZVxuICAgICAgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2lmX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIEdlbmVyYWxpemVkIGJyZWFrIGhpbnQgdGhhdCBhbGxvd3MgcHJpbnRpbmcgc3RyaW5ncyBiZWZvcmUvYWZ0ZXJcbiAgIHNhbWUtbGluZSBvZmZzZXQgKHdpZHRoKSBvciBuZXctbGluZSBvZmZzZXQgKilcbmxldCBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGUgfmZpdHMgfmJyZWFrcyA9XG4gIGxldCBiZWZvcmUsIHdpZHRoLCBhZnRlciA9IGZpdHMgaW5cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgdG9rZW4gPSBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IGluXG4gICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggYmVmb3JlICsgd2lkdGggKyBTdHJpbmcubGVuZ3RoIGFmdGVyIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGVcbiAgICB+Zml0czooXCJcIiwgd2lkdGgsIFwiXCIpIH5icmVha3M6KFwiXCIsIG9mZnNldCwgXCJcIilcblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUuemVybyBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3RlbmQ7IGxlbmd0aCA9IDAgfSBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KTsgbGVuZ3RoID0gd2lkdGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3N0YWI7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgaWYgbiA+IDEgdGhlblxuICAgIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBtYXggKG1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxuKCoqIEdlb21ldHJ5IGZ1bmN0aW9ucyBhbmQgdHlwZXMgKilcbnR5cGUgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ6aW50OyBtYXJnaW46IGludH1cblxubGV0IGNoZWNrX2dlb21ldHJ5IGdlb21ldHJ5ID1cbiAgZ2VvbWV0cnkubWF4X2luZGVudCA+IDFcbiAgJiYgIGdlb21ldHJ5Lm1hcmdpbiA+IGdlb21ldHJ5Lm1heF9pbmRlbnRcblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxubGV0IHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgaWYgbWF4X2luZGVudCA8IDIgdGhlblxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRm9ybWF0LnBwX3NldF9nZW9tZXRyeTogbWF4X2luZGVudCA8IDJcIilcbiAgZWxzZSBpZiBtYXJnaW4gPD0gbWF4X2luZGVudCB0aGVuXG4gICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IG1hcmdpbiA8PSBtYXhfaW5kZW50XCIpXG4gIGVsc2VcbiAgICBwcF9zZXRfbWFyZ2luIHN0YXRlIG1hcmdpbjsgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbWF4X2luZGVudFxuXG5sZXQgcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGlmIGNoZWNrX2dlb21ldHJ5IHttYXhfaW5kZW50O21hcmdpbn0gdGhlblxuICAgIHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luXG4gIGVsc2VcbiAgICAoKVxuXG5sZXQgcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpID1cbiAgeyBtYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0YXRlICgpOyBtYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgfVxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPFwiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPC9cIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgeyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpOyBsZW5ndGggPSAwIH0gaW5cbiAgUXVldWUuYWRkIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzY2FuX3N0YWNrID0gU3RhY2suY3JlYXRlICgpIGluXG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzY2FuX3N0YWNrO1xuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IDE7IHF1ZXVlX2VsZW0gPSBzeXNfdG9rIH0gc2Nhbl9zdGFjaztcbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGJveF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90YWdfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFya19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtTdGRsaWIuc3Rkb3V0XSwgW1N0ZGxpYi5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cblxuKCogRmx1c2ggW3N0cl9mb3JtYXR0ZXJdIGFuZCBnZXQgdGhlIGNvbnRlbnRzIG9mIFtzdGRidWZdLiAqKVxubGV0IGZsdXNoX3N0cl9mb3JtYXR0ZXIgKCkgPSBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIHN0ZGJ1ZiBzdHJfZm9ybWF0dGVyXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZ1xuKilcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nIGlzIHByZXR0eS1wcmludGluZyB3aXRoIG5vIGxvdyBsZXZlbCBvdXRwdXQuXG5cbiAgV2hlbiB1c2luZyBhIHN5bWJvbGljIGZvcm1hdHRlciwgYWxsIHJlZ3VsYXIgcHJldHR5LXByaW50aW5nIGFjdGl2aXRpZXNcbiAgb2NjdXIgYnV0IG91dHB1dCBtYXRlcmlhbCBpcyBzeW1ib2xpYyBhbmQgc3RvcmVkIGluIGEgYnVmZmVyIG9mIG91dHB1dFxuICBpdGVtcy4gQXQgdGhlIGVuZCBvZiBwcmV0dHktcHJpbnRpbmcsIGZsdXNoaW5nIHRoZSBvdXRwdXQgYnVmZmVyIGFsbG93c1xuICBwb3N0LXByb2Nlc3Npbmcgb2Ygc3ltYm9saWMgb3V0cHV0IGJlZm9yZSBsb3cgbGV2ZWwgb3V0cHV0IG9wZXJhdGlvbnMuXG4qKVxuXG50eXBlIHN5bWJvbGljX291dHB1dF9pdGVtID1cbiAgfCBPdXRwdXRfZmx1c2hcbiAgfCBPdXRwdXRfbmV3bGluZVxuICB8IE91dHB1dF9zdHJpbmcgb2Ygc3RyaW5nXG4gIHwgT3V0cHV0X3NwYWNlcyBvZiBpbnRcbiAgfCBPdXRwdXRfaW5kZW50IG9mIGludFxuXG50eXBlIHN5bWJvbGljX291dHB1dF9idWZmZXIgPSB7XG4gIG11dGFibGUgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDogc3ltYm9saWNfb3V0cHV0X2l0ZW0gbGlzdDtcbn1cblxubGV0IG1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciAoKSA9XG4gIHsgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzID0gW10gfVxuXG5sZXQgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIFtdXG5cbmxldCBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBMaXN0LnJldiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBpdGVtcyA9IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiBpblxuICBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYjtcbiAgaXRlbXNcblxubGV0IGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgaXRlbSA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gaXRlbSA6OiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgc3ltYm9saWNfZmx1c2ggc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9mbHVzaFxuICBhbmQgc3ltYm9saWNfbmV3bGluZSBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X25ld2xpbmVcbiAgYW5kIHN5bWJvbGljX3N0cmluZyBzb2IgcyBpIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zdHJpbmcgKFN0cmluZy5zdWIgcyBpIG4pKVxuICBhbmQgc3ltYm9saWNfc3BhY2VzIHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3BhY2VzIG4pXG4gIGFuZCBzeW1ib2xpY19pbmRlbnQgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9pbmRlbnQgbikgaW5cblxuICBsZXQgZiA9IHN5bWJvbGljX3N0cmluZyBzb2JcbiAgYW5kIGcgPSBzeW1ib2xpY19mbHVzaCBzb2JcbiAgYW5kIGggPSBzeW1ib2xpY19uZXdsaW5lIHNvYlxuICBhbmQgaSA9IHN5bWJvbGljX3NwYWNlcyBzb2JcbiAgYW5kIGogPSBzeW1ib2xpY19pbmRlbnQgc29iIGluXG4gIHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgalxuXG4oKlxuXG4gIEJhc2ljIGZ1bmN0aW9ucyBvbiB0aGUgJ3N0YW5kYXJkJyBmb3JtYXR0ZXJcbiAgKHRoZSBmb3JtYXR0ZXIgdGhhdCBwcmludHMgdG8gW1N0ZGxpYi5zdGRvdXRdKS5cblxuKilcblxubGV0IG9wZW5faGJveCA9IHBwX29wZW5faGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl92Ym94ID0gcHBfb3Blbl92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2h2Ym94ID0gcHBfb3Blbl9odmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ob3Zib3ggPSBwcF9vcGVuX2hvdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ib3ggPSBwcF9vcGVuX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfYm94ID0gcHBfY2xvc2VfYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3RhZyA9IHBwX29wZW5fdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90YWcgPSBwcF9jbG9zZV90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fc3RhZyA9IHBwX29wZW5fc3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2Vfc3RhZyA9IHBwX2Nsb3NlX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2FzID0gcHBfcHJpbnRfYXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3N0cmluZyA9IHBwX3ByaW50X3N0cmluZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaW50ID0gcHBfcHJpbnRfaW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbG9hdCA9IHBwX3ByaW50X2Zsb2F0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jaGFyID0gcHBfcHJpbnRfY2hhciBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYm9vbCA9IHBwX3ByaW50X2Jvb2wgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2JyZWFrID0gcHBfcHJpbnRfYnJlYWsgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2N1dCA9IHBwX3ByaW50X2N1dCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3BhY2UgPSBwcF9wcmludF9zcGFjZSBzdGRfZm9ybWF0dGVyXG5hbmQgZm9yY2VfbmV3bGluZSA9IHBwX2ZvcmNlX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ZsdXNoID0gcHBfcHJpbnRfZmx1c2ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X25ld2xpbmUgPSBwcF9wcmludF9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pZl9uZXdsaW5lID0gcHBfcHJpbnRfaWZfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBvcGVuX3Rib3ggPSBwcF9vcGVuX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3Rib3ggPSBwcF9jbG9zZV90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YnJlYWsgPSBwcF9wcmludF90YnJlYWsgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X3RhYiA9IHBwX3NldF90YWIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RhYiA9IHBwX3ByaW50X3RhYiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWFyZ2luID0gcHBfc2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9pbmRlbnQgPSBwcF9zZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZ2VvbWV0cnkgPSBwcF9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHNhZmVfc2V0X2dlb21ldHJ5ID0gcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9nZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2JveGVzID0gcHBfc2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9ib3hlcyA9IHBwX2dldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIG92ZXJfbWF4X2JveGVzID0gcHBfb3Zlcl9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2VsbGlwc2lzX3RleHQgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2VsbGlwc2lzX3RleHQgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9wcmludF90YWdzID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9wcmludF90YWdzID1cbiAgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9tYXJrX3RhZ3MgPVxuICBwcF9zZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFya190YWdzID1cbiAgcHBfZ2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3RhZ3MgPVxuICBwcF9zZXRfdGFncyBzdGRfZm9ybWF0dGVyXG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCByZWMgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgW3ZdIC0+IHBwX3YgcHBmIHZcbiAgfCB2IDo6IHZzIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3ByaW50X2xpc3QgfnBwX3NlcCBwcF92IHBwZiB2c1xuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgY29tcHV0ZV90YWcgb3V0cHV0IHRhZ19hY2MgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgb3V0cHV0IHBwZiB0YWdfYWNjO1xuICBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIGxldCBsZW4gPSBCdWZmZXIubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPCAyIHRoZW4gQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICBlbHNlIEJ1ZmZlci5zdWIgYnVmIDEgKGxlbiAtIDIpXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBEZWZpbmluZyBjb250aW51YXRpb25zIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgb2ZcbiAgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogSW50ZXJwcmV0IGEgZm9ybWF0dGluZyBlbnRpdHkgb24gYSBmb3JtYXR0ZXIuICopXG5sZXQgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmbXRpbmdfbGl0ID0gbWF0Y2ggZm10aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV90YWcgcHBmICgpXG4gIHwgQnJlYWsgKF8sIHdpZHRoLCBvZmZzZXQpICAtPiBwcF9wcmludF9icmVhayBwcGYgd2lkdGggb2Zmc2V0XG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9mbHVzaCBwcGYgKClcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9wcmludF9uZXdsaW5lIHBwZiAoKVxuICB8IE1hZ2ljX3NpemUgKF8sIF8pICAgICAgICAgLT4gKClcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJ1xuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJyUnXG4gIHwgU2Nhbl9pbmRpYyBjICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCc7IHBwX3ByaW50X2NoYXIgcHBmIGNcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLm91dHB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgZiBwcGY7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLmJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZGVsYXkgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChmICgpKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIHBwZiBhY2M7IGsgcHBmKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmFuZCBpa2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBwcGYgZm10XG5cbmxldCBpZnByaW50ZiBfcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGlnbm9yZSAoKSBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZF9mb3JtYXR0ZXIgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIGVycl9mb3JtYXR0ZXIgZm10XG5cbmxldCBrZHByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBrIChmdW4gcHBmIC0+IG91dHB1dF9hY2MgcHBmIGFjYykpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGRwcmludGYgZm10ID0ga2RwcmludGYgKGZ1biBpIC0+IGkpIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIHN0cnB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgaWQgZm10XG5cbmxldCBrYXNwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IGFzcHJpbnRmIGZtdCA9IGthc3ByaW50ZiBpZCBmbXRcblxuKCogRmx1c2hpbmcgc3RhbmRhcmQgZm9ybWF0dGVycyBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxuXG5sZXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKSA9XG4gIHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXIgKCk7XG4gIHBwX3ByaW50X2ZsdXNoIGVycl9mb3JtYXR0ZXIgKClcblxubGV0ICgpID0gYXRfZXhpdCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzXG5cbigqXG5cbiAgRGVwcmVjYXRlZCBzdHVmZi5cblxuKilcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGVcbiAgICB+b3V0OmYgfmZsdXNoOmcgfm5ld2xpbmU6aCB+c3BhY2VzOmkgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGlcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoLFxuICAgc3RhdGUucHBfb3V0X25ld2xpbmUsIHN0YXRlLnBwX291dF9zcGFjZXMpXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBlcnJvciBwcm9uZSBmdW5jdGlvbiwgZG8gbm90IHVzZSBpdC5cbiAgIFRoaXMgZnVuY3Rpb24gaXMgbmVpdGhlciBjb21wb3NpdGlvbmFsIG5vciBpbmNyZW1lbnRhbCwgc2luY2UgaXQgZmx1c2hlc1xuICAgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGF0IGVhY2ggY2FsbC5cbiAgIFRvIGdldCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LCBkZWZpbmUgYSBmb3JtYXR0ZXIgb2YgeW91ciBvd24gd3JpdGluZyB0b1xuICAgdGhlIGJ1ZmZlciBhcmd1bWVudCwgYXMgaW5cbiAgIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJcbiAgIHRoZW4gdXNlIHshZnByaW50ZiBwcGZ9IGFzIHVzdWFsLiAqKVxubGV0IGJwcmludGYgYiAoRm9ybWF0IChmbXQsIF8pIDogKCdhLCBmb3JtYXR0ZXIsIHVuaXQpIGZvcm1hdCkgPVxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9IG91dHB1dF9hY2MgcHBmIGFjYzsgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG4oKiBEZXByZWNhdGVkIDogYWxpYXMgZm9yIGtzcHJpbnRmLiAqKVxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuXG5cblxuKCogRGVwcmVjYXRlZCB0YWcgZnVuY3Rpb25zICopXG5cbnR5cGUgZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl90YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3RhZyA9IHBjdDtcbiAgIH0gPVxuICBsZXQgc3RyaW5naWZ5IGYgZSA9IGZ1bmN0aW9uIFN0cmluZ190YWcgcyAtPiBmIHMgfCBfIC0+IGUgaW5cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBzdHJpbmdpZnkgbW90IFwiXCI7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBtY3QgXCJcIjtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gc3RyaW5naWZ5IHBvdCAoKTtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBwY3QgKClcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBmbXQgKCkgPVxuICBsZXQgZnVucyA9IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgZm10ICgpIGluXG4gIGxldCBtYXJrX29wZW5fdGFnIHMgPSBmdW5zLm1hcmtfb3Blbl9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBtYXJrX2Nsb3NlX3RhZyBzID0gZnVucy5tYXJrX2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X29wZW5fdGFnIHMgPSBmdW5zLnByaW50X29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgcHJpbnRfY2xvc2VfdGFnIHMgPSBmdW5zLnByaW50X2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAge21hcmtfb3Blbl90YWc7IG1hcmtfY2xvc2VfdGFnOyBwcmludF9vcGVuX3RhZzsgcHJpbnRfY2xvc2VfdGFnfVxuXG5sZXQgc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogYWxpYXMgdG8gYXZvaWQgd2FybmluZyBmb3IgYW1iaWd1aXR5IGJldHdlZW5cbiAgIFN0ZGxpYi5mb3JtYXQ2XG4gICBhbmQgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcblxuICAgKHRoZSBmb3JtZXIgaXMgaW4gZmFjdCBhbiBhbGlhcyBmb3IgdGhlIGxhdHRlcixcbiAgICBidXQgdGhlIGFtYmlndWl0eSB3YXJuaW5nIGRvZXNuJ3QgY2FyZSlcbiopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIFN0ZGxpYi5mb3JtYXQ2XG5cblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5uZXJzLiAqKVxuXG4oKiBTY2FubmluZyBidWZmZXJzLiAqKVxubW9kdWxlIHR5cGUgU0NBTk5JTkcgPSBzaWdcblxuICB0eXBlIGluX2NoYW5uZWxcblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB2YWwgc3RkaW4gOiBpbl9jaGFubmVsXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBbc3RkaWJdIGlzIGVxdWl2YWxlbnQgdG8gW1NjYW5uaW5nLmZyb21fY2hhbm5lbCBTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBzdGRpYiA6IGluX2NoYW5uZWxcbiAgKCogQW4gYWxpYXMgZm9yIFtTY2FuZi5zdGRpbl0sIHRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tXG4gICAgIFtTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBuZXh0X2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLm5leHRfY2hhciBpYl0gYWR2YW5jZSB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyLlxuICAgICBJZiBubyBtb3JlIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJdIG1hcmsgdGhlIGN1cnJlbnRfY2hhciBhcyBhbHJlYWR5XG4gICAgIHNjYW5uZWQuICopXG5cbiAgdmFsIHBlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcucGVla19jaGFyIGliXSByZXR1cm5zIHRoZSBjdXJyZW50IGNoYXIgYXZhaWxhYmxlIGluXG4gICAgIHRoZSBidWZmZXIgb3IgcmVhZHMgb25lIGlmIG5lY2Vzc2FyeSAod2hlbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXNcbiAgICAgYWxyZWFkeSBzY2FubmVkKS5cbiAgICAgSWYgbm8gY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGFuIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBjaGVja2VkX3BlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBTYW1lIGFzIFtTY2FubmluZy5wZWVrX2NoYXJdIGFib3ZlIGJ1dCBhbHdheXMgcmV0dXJucyBhIHZhbGlkIGNoYXIgb3JcbiAgICAgZmFpbHM6IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgbnVsbCBjaGFyIHdoZW4gdGhlIHJlYWRpbmcgbWV0aG9kIG9mIHRoZVxuICAgICBpbnB1dCBidWZmZXIgaGFzIHJlYWNoZWQgYW4gZW5kIG9mIGZpbGUsIHRoZSBmdW5jdGlvbiByYWlzZXMgZXhjZXB0aW9uXG4gICAgIFtFbmRfb2ZfZmlsZV0uICopXG5cbiAgdmFsIHN0b3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBjaGFyIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc3RvcmVfY2hhciBsaW0gaWIgY10gYWRkcyBbY10gdG8gdGhlIHRva2VuIGJ1ZmZlclxuICAgICBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyIFtpYl0uIEl0IGFsc28gYWR2YW5jZXMgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3RlciBhbmQgcmV0dXJucyBbbGltIC0gMV0sIGluZGljYXRpbmcgdGhlIG5ldyBsaW1pdCBmb3IgdGhlXG4gICAgIGxlbmd0aCBvZiB0aGUgY3VycmVudCB0b2tlbi4gKilcblxuICB2YWwgc2tpcF9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5za2lwX2NoYXIgbGltIGliXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci4gKilcblxuICB2YWwgaWdub3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmlnbm9yZV9jaGFyIGliIGxpbV0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIgYW5kXG4gICAgIGRlY3JlbWVudHMgdGhlIGxpbWl0LiAqKVxuXG4gIHZhbCB0b2tlbiA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy50b2tlbiBpYl0gcmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbnRvIHRoZSB0b2tlblxuICAgICBidWZmZXIgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlcjogaXQgcmV0dXJucyB0aGUgdG9rZW4gbWF0Y2hlZCBieSB0aGVcbiAgICAgZm9ybWF0LiAqKVxuXG4gIHZhbCByZXNldF90b2tlbiA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWJdIHJlc2V0cyB0aGUgdG9rZW4gYnVmZmVyIG9mXG4gICAgIHRoZSBnaXZlbiBzY2FubmluZyBidWZmZXIuICopXG5cbiAgdmFsIGNoYXJfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuY2hhcl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBsaW5lX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmxpbmVfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBuZXcgbGluZVxuICAgICBjaGFyYWN0ZXJzIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgdG9rZW5fY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcudG9rZW5fY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiB0b2tlbnMgcmVhZFxuICAgICBzbyBmYXIgZnJvbSBbaWJdLiAqKVxuXG4gIHZhbCBlb2YgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVvZiBpYl0gcmV0dXJucyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBlbmRfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlciAoaWYgbm8gY2hhciBoYXMgZXZlciBiZWVuIHJlYWQsIGFuIGF0dGVtcHQgdG9cbiAgICAgcmVhZCBvbmUgaXMgcGVyZm9ybWVkKS4gKilcblxuICB2YWwgYmVnaW5uaW5nX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5iZWdpbm5pbmdfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBiZWdpbm5pbmcgb2YgaW5wdXRcbiAgICAgY29uZGl0aW9uIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIG5hbWVfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcubmFtZV9vZl9pbnB1dCBpYl0gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgIHNvdXJjZSBmb3IgaW5wdXQgYnVmZmVyIFtpYl0uICopXG5cbiAgdmFsIG9wZW5faW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgb3Blbl9pbl9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZV9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9zdHJpbmcgOiBzdHJpbmcgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9mdW5jdGlvbiA6ICh1bml0IC0+IGNoYXIpIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcblxuICB2YWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXRcblxuICB2YWwgbWVtb19mcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG4gICgqIE9ic29sZXRlLiAqKVxuXG5lbmRcblxuXG5tb2R1bGUgU2Nhbm5pbmcgOiBTQ0FOTklORyA9IHN0cnVjdFxuXG4gICgqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FuZi4gKilcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbF9uYW1lID1cbiAgICB8IEZyb21fY2hhbm5lbCBvZiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9maWxlIG9mIGZpbGVfbmFtZSAqIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2Z1bmN0aW9uXG4gICAgfCBGcm9tX3N0cmluZ1xuXG5cbiAgdHlwZSBpbl9jaGFubmVsID0ge1xuICAgIG11dGFibGUgaWNfZW9mIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhciA6IGNoYXI7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgOiBib29sO1xuICAgIG11dGFibGUgaWNfY2hhcl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2xpbmVfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY190b2tlbl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2dldF9uZXh0X2NoYXIgOiB1bml0IC0+IGNoYXI7XG4gICAgaWNfdG9rZW5fYnVmZmVyIDogQnVmZmVyLnQ7XG4gICAgaWNfaW5wdXRfbmFtZSA6IGluX2NoYW5uZWxfbmFtZTtcbiAgfVxuXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIGxldCBudWxsX2NoYXIgPSAnXFwwMDAnXG5cbiAgKCogUmVhZHMgYSBuZXcgY2hhcmFjdGVyIGZyb20gaW5wdXQgYnVmZmVyLlxuICAgICBOZXh0X2NoYXIgbmV2ZXIgZmFpbHMsIGV2ZW4gaW4gY2FzZSBvZiBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IHRoZW4gc2ltcGx5IHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbi4gKilcbiAgbGV0IG5leHRfY2hhciBpYiA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGliLmljX2dldF9uZXh0X2NoYXIgKCkgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIHRydWU7XG4gICAgICBpYi5pY19jaGFyX2NvdW50IDwtIHN1Y2MgaWIuaWNfY2hhcl9jb3VudDtcbiAgICAgIGlmIGMgPSAnXFxuJyB0aGVuIGliLmljX2xpbmVfY291bnQgPC0gc3VjYyBpYi5pY19saW5lX2NvdW50O1xuICAgICAgYyB3aXRoXG4gICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgbGV0IGMgPSBudWxsX2NoYXIgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlO1xuICAgICAgaWIuaWNfZW9mIDwtIHRydWU7XG4gICAgICBjXG5cblxuICBsZXQgcGVla19jaGFyIGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2N1cnJlbnRfY2hhclxuICAgIGVsc2UgbmV4dF9jaGFyIGliXG5cblxuICAoKiBSZXR1cm5zIGEgdmFsaWQgY3VycmVudCBjaGFyIGZvciB0aGUgaW5wdXQgYnVmZmVyLiBJbiBwYXJ0aWN1bGFyXG4gICAgIG5vIGlycmVsZXZhbnQgbnVsbCBjaGFyYWN0ZXIgKGFzIHNldCBieSBbbmV4dF9jaGFyXSBpbiBjYXNlIG9mIGVuZFxuICAgICBvZiBpbnB1dCkgaXMgcmV0dXJuZWQsIHNpbmNlIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW5cbiAgICAgW25leHRfY2hhcl0gc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uIHdoaWxlIHRyeWluZyB0byByZWFkIGFcbiAgICAgbmV3IGNoYXJhY3Rlci4gKilcbiAgbGV0IGNoZWNrZWRfcGVla19jaGFyIGliID1cbiAgICBsZXQgYyA9IHBlZWtfY2hhciBpYiBpblxuICAgIGlmIGliLmljX2VvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAgIGNcblxuXG4gIGxldCBlbmRfb2ZfaW5wdXQgaWIgPVxuICAgIGlnbm9yZSAocGVla19jaGFyIGliKTtcbiAgICBpYi5pY19lb2ZcblxuXG4gIGxldCBlb2YgaWIgPSBpYi5pY19lb2ZcblxuICBsZXQgYmVnaW5uaW5nX29mX2lucHV0IGliID0gaWIuaWNfY2hhcl9jb3VudCA9IDBcblxuICBsZXQgbmFtZV9vZl9pbnB1dCBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgX2ljIC0+IFwidW5uYW1lZCBTdGRsaWIgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gU3RkbGliLmNsb3NlX2luIGljOyByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gICgqIFRoZSBzY2FubmVyIGRvZXMgbm90IGNsb3NlIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dDpcbiAgICAgaXQganVzdCByYWlzZXMgW0VuZF9vZl9maWxlXS4gKilcbiAgbGV0IHNjYW5fcmFpc2VfYXRfZW5kIF9pYyA9IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgbGV0IGZyb21faWMgc2Nhbl9jbG9zZV9pYyBpbmFtZSBpYyA9XG4gICAgbGV0IGxlbiA9ICFmaWxlX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxpbSA9IHJlZiAwIGluXG4gICAgbGV0IGVvZiA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpIDwgIWxpbSB0aGVuIGJlZ2luIGxldCBjID0gQnl0ZXMuZ2V0IGJ1ZiAhaSBpbiBpbmNyIGk7IGMgZW5kIGVsc2VcbiAgICAgIGlmICFlb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIGJlZ2luXG4gICAgICAgIGxpbSA6PSBpbnB1dCBpYyBidWYgMCBsZW47XG4gICAgICAgIGlmICFsaW0gPSAwIHRoZW4gYmVnaW4gZW9mIDo9IHRydWU7IHNjYW5fY2xvc2VfaWMgaWMgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBpIDo9IDE7XG4gICAgICAgICAgQnl0ZXMuZ2V0IGJ1ZiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGluXG4gICAgY3JlYXRlIGluYW1lIG5leHRcblxuXG4gIGxldCBmcm9tX2ljX2Nsb3NlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9jbG9zZV9hdF9lbmRcbiAgbGV0IGZyb21faWNfcmFpc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBPbmUgY291bGQgdHJ5IHRvIGRlZmluZSBbc3RkaWJdIGFzIGEgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgYXQgYSB0aW1lIChubyBidWZmZXJpemF0aW9uIGF0IGFsbCksIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoZSB0b3AtbGV2ZWxcbiAgICAgaW50ZXJhY3Rpb24gd291bGQgYmUgd3JvbmcuIFRoaXMgaXMgZHVlIHRvIHNvbWUga2luZCBvZlxuICAgICAncmFjZSBjb25kaXRpb24nIHdoZW4gcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbU3RkbGliLnN0ZGluXTsgdGhlbiwgY29uZnVzaW9uXG4gICAgIHdpbGwgcmVzdWx0IGZyb20gd2hhdCBzaG91bGQgYmUgcmVhZCBieSB0aGUgdG9wLWxldmVsIGFuZCB3aGF0IHNob3VsZCBiZVxuICAgICByZWFkIGJ5IFtTY2FuZi5zY2FuZl0uXG4gICAgIFRoaXMgaXMgZXZlbiBtb3JlIGNvbXBsaWNhdGVkIGJ5IHRoZSBvbmUgY2hhcmFjdGVyIGxvb2thaGVhZCB0aGF0XG4gICAgIFtTY2FuZi5zY2FuZl0gaXMgc29tZXRpbWVzIG9ibGlnZWQgdG8gbWFpbnRhaW46IHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyXG4gICAgIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCBbU2NhbmYuc2NhbmZdIGVudHJ5LCBzZWVtaW5nbHkgY29taW5nIGZyb21cbiAgICAgbm93aGVyZS5cbiAgICAgQWxzbyBubyBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuIHJlYWRpbmcgZnJvbSBzdGRpbjogaWYgbm90IGVub3VnaFxuICAgICBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZWFkLCB3ZSBzaW1wbHkgYXNrIHRvIHJlYWQgbW9yZS4gKilcbiAgbGV0IHN0ZGluID1cbiAgICBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG4gICAgICAoRnJvbV9maWxlIChcIi1cIiwgU3RkbGliLnN0ZGluKSkgU3RkbGliLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5cbiAgbGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2ZpbGUgPSBvcGVuX2luXG4gIGxldCBmcm9tX2ZpbGVfYmluID0gb3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBmcm9tX2ljX3JhaXNlX2F0X2VuZCAoRnJvbV9jaGFubmVsIGljKSBpY1xuXG5cbiAgbGV0IGNsb3NlX2luIGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBpYyAtPlxuICAgICAgU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9mdW5jdGlvbiB8IEZyb21fc3RyaW5nIC0+ICgpXG5cblxuICAoKlxuICAgICBPYnNvbGV0ZTogYSBtZW1vIFtmcm9tX2NoYW5uZWxdIHZlcnNpb24gdG8gYnVpbGQgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF1cbiAgICAgc2Nhbm5pbmcgYnVmZmVyIG91dCBvZiBhIFtTdGRsaWIuaW5fY2hhbm5lbF0uXG4gICAgIFRoaXMgZnVuY3Rpb24gd2FzIHVzZWQgdG8gdHJ5IHRvIHByZXNlcnZlIHRoZSBzY2FubmluZ1xuICAgICBzZW1hbnRpY3MgZm9yIHRoZSAobm93IG9ic29sZXRlKSBmdW5jdGlvbiBbZnNjYW5mXS5cbiAgICAgR2l2ZW4gdGhhdCBhbGwgc2Nhbm5lciBtdXN0IHJlYWQgZnJvbSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBzY2FubmluZ1xuICAgICBidWZmZXIsIFtmc2NhbmZdIG11c3QgcmVhZCBmcm9tIG9uZSFcbiAgICAgTW9yZSBwcmVjaXNlbHksIGdpdmVuIFtpY10sIGFsbCBzdWNjZXNzaXZlIGNhbGxzIFtmc2NhbmYgaWNdIG11c3QgcmVhZFxuICAgICBmcm9tIHRoZSBzYW1lIHNjYW5uaW5nIGJ1ZmZlci5cbiAgICAgVGhpcyBvYmxpZ2VkIHRoaXMgbGlicmFyeSB0byBhbGxvY2F0ZWQgc2Nhbm5pbmcgYnVmZmVycyB0aGF0IHdlcmVcbiAgICAgbm90IHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGFibGUsIGhlbmNlIGxlYWRpbmcgdG8gbWVtb3J5IGxlYWtzLlxuICAgICBJZiB5b3UgbmVlZCB0byByZWFkIGZyb20gYSBbU3RkbGliLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgU3RkbGliLippbnQqX29mX3N0cmluZyBkbyBub3QgYWNjZXB0IGEgbGVhZGluZyArLFxuICAgd2Ugc2tpcCBpdCBpZiBuZWNlc3NhcnkuICopXG5sZXQgdG9rZW5faW50X2xpdGVyYWwgY29udiBpYiA9XG4gIGxldCB0b2sgPVxuICAgIG1hdGNoIGNvbnYgd2l0aFxuICAgIHwgRF9jb252ZXJzaW9uIHwgSV9jb252ZXJzaW9uIC0+IFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBVX2NvbnZlcnNpb24gLT4gXCIwdVwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IE9fY29udmVyc2lvbiAtPiBcIjBvXCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgWF9jb252ZXJzaW9uIC0+IFwiMHhcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBCX2NvbnZlcnNpb24gLT4gXCIwYlwiIF4gU2Nhbm5pbmcudG9rZW4gaWIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHRvayBpblxuICBpZiBsID0gMCB8fCB0b2suWzBdIDw+ICcrJyB0aGVuIHRvayBlbHNlIFN0cmluZy5zdWIgdG9rIDEgKGwgLSAxKVxuXG5cbigqIEFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHN0cmluZyB0byBhIG51bWJlciByYWlzZSB0aGUgZXhjZXB0aW9uXG4gICBGYWlsdXJlIHdoZW4gdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgVGhpcyBleGNlcHRpb24gaXMgdGhlbiB0cmFwcGVkIGluIFtrc2NhbmZdLiAqKVxubGV0IHRva2VuX2ludCBjb252IGliID0gaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxubGV0IHRva2VuX2Zsb2F0IGliID0gZmxvYXRfb2Zfc3RyaW5nIChTY2FubmluZy50b2tlbiBpYilcblxuKCogVG8gc2NhbiBuYXRpdmUgaW50cywgaW50MzIgYW5kIGludDY0IGludGVnZXJzLlxuICAgV2UgY2Fubm90IGFjY2VzcyB0byBjb252ZXJzaW9ucyB0by9mcm9tIHN0cmluZ3MgZm9yIHRob3NlIHR5cGVzLFxuICAgTmF0aXZlaW50Lm9mX3N0cmluZywgSW50MzIub2Zfc3RyaW5nLCBhbmQgSW50NjQub2Zfc3RyaW5nLFxuICAgc2luY2UgdGhvc2UgbW9kdWxlcyBhcmUgbm90IGF2YWlsYWJsZSB0byBbU2NhbmZdLlxuICAgSG93ZXZlciwgd2UgY2FuIGJpbmQgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZyBwcmltaXRpdmVzIHRoYXQgYXJlXG4gICBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUuICopXG5leHRlcm5hbCBuYXRpdmVpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50MzJfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDY0X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5cbmxldCB0b2tlbl9uYXRpdmVpbnQgY29udiBpYiA9IG5hdGl2ZWludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50MzIgY29udiBpYiA9IGludDMyX29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQ2NCBjb252IGliID0gaW50NjRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG4oKiBTY2FubmluZyBudW1iZXJzLiAqKVxuXG4oKiBEaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHN1cHBvc2UgdGhhdCBvbmUgY2hhcmFjdGVyIGhhcyBiZWVuIGNoZWNrZWQgYW5kXG4gICBpcyBhdmFpbGFibGUsIHNpbmNlIHRoZXkgcmV0dXJuIGF0IGVuZCBvZiBmaWxlIHdpdGggdGhlIGN1cnJlbnRseSBmb3VuZFxuICAgdG9rZW4gc2VsZWN0ZWQuXG5cbiAgIFB1dCBpdCBpbiBhbm90aGVyIHdheSwgdGhlIGRpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc2NhbiBmb3IgYSBwb3NzaWJseVxuICAgZW1wdHkgc2VxdWVuY2Ugb2YgZGlnaXRzLCAoaGVuY2UsIGEgc3VjY2Vzc2Z1bCBzY2FubmluZyBmcm9tIG9uZSBvZiB0aG9zZVxuICAgZnVuY3Rpb25zIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIHRva2VuIGlzIGEgd2VsbC1mb3JtZWQgbnVtYmVyOiB0byBnZXQgYVxuICAgdHJ1ZSBudW1iZXIsIGl0IGlzIG1hbmRhdG9yeSB0byBjaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB2YWxpZCBkaWdpdCBpc1xuICAgYXZhaWxhYmxlIGJlZm9yZSBjYWxsaW5nIG9uZSBvZiB0aGUgZGlnaXQgc2Nhbm5pbmcgZnVuY3Rpb25zKS4gKilcblxuKCogVGhlIGRlY2ltYWwgY2FzZSBpcyB0cmVhdGVkIGVzcGVjaWFsbHkgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gKilcbmxldCByZWMgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCAnXycgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkZWNpbWFsIGRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSBkZWNpbWFsIGRpZ2l0XCIgYylcblxuXG4oKiBUbyBzY2FuIG51bWJlcnMgZnJvbSBvdGhlciBiYXNlcywgd2UgdXNlIGEgcHJlZGljYXRlIGFyZ3VtZW50IHRvXG4gICBzY2FuIGRpZ2l0cy4gKilcbmxldCBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2RpZ2l0cyB3aWR0aCBpYiA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgYyB3aGVuIGRpZ2l0cCBjIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCAnXycgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgXyAtPiB3aWR0aCBpblxuICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2RpZ2l0X3BsdXMgYmFzaXMgZGlnaXRwIHdpZHRoIGliID1cbiAgKCogRW5zdXJlIHdlIGhhdmUgZ290IGVub3VnaCB3aWR0aCBsZWZ0LFxuICAgICBhbmQgcmVhZCBhdCBsZWFzdCBvbmUgZGlnaXQuICopXG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgZGlnaXRwIGMgdGhlblxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWJcbiAgZWxzZVxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgdmFsaWQgJXMgZGlnaXRcIiBjIGJhc2lzKVxuXG5cbmxldCBpc19iaW5hcnlfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnMScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9iaW5hcnlfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiYmluYXJ5XCIgaXNfYmluYXJ5X2RpZ2l0XG5cbmxldCBpc19vY3RhbF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc3JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX29jdGFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcIm9jdGFsXCIgaXNfb2N0YWxfZGlnaXRcblxubGV0IGlzX2hleGFfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2hleGFkZWNpbWFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImhleGFkZWNpbWFsXCIgaXNfaGV4YV9kaWdpdFxuXG4oKiBTY2FuIGEgZGVjaW1hbCBpbnRlZ2VyLiAqKVxubGV0IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgPSBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1c1xuXG5sZXQgc2Nhbl9zaWduIHdpZHRoIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnKycgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgJy0nIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2NhbiBhbiB1bnNpZ25lZCBpbnRlZ2VyIHRoYXQgY291bGQgYmUgZ2l2ZW4gaW4gYW55IChjb21tb24pIGJhc2lzLlxuICAgSWYgZGlnaXRzIGFyZSBwcmVmaXhlZCBieSBvbmUgb2YgMHgsIDBYLCAwbywgb3IgMGIsIHRoZSBudW1iZXIgaXNcbiAgIGFzc3VtZWQgdG8gYmUgd3JpdHRlbiByZXNwZWN0aXZlbHkgaW4gaGV4YWRlY2ltYWwsIGhleGFkZWNpbWFsLFxuICAgb2N0YWwsIG9yIGJpbmFyeS4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICB8ICd4JyB8ICdYJyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ28nIC0+IHNjYW5fb2N0YWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnYicgLT4gc2Nhbl9iaW5hcnlfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCBfIC0+IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGVuZFxuICB8IF8gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2ludF9jb252ZXJzaW9uIGNvbnYgd2lkdGggaWIgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBCX2NvbnZlcnNpb24gLT4gc2Nhbl9iaW5hcnlfaW50IHdpZHRoIGliXG4gIHwgRF9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBJX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWJcbiAgfCBPX2NvbnZlcnNpb24gLT4gc2Nhbl9vY3RhbF9pbnQgd2lkdGggaWJcbiAgfCBVX2NvbnZlcnNpb24gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IFhfY29udmVyc2lvbiAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW5uaW5nIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuICopXG5cbigqIEZyYWN0aW9uYWwgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9mcmFjdGlvbmFsX3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogRXhwIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnZScgfCAnRScgYXMgYyAtPlxuICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogU2NhbiB0aGUgaW50ZWdlciBwYXJ0IG9mIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCAobm90IHVzaW5nIHRoZVxuICAgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uIHNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgY2FuIGJlIGVtcHR5KTpcbiAgIGFuIG9wdGlvbmFsIHNpZ24sIGZvbGxvd2VkIGJ5IGEgcG9zc2libHkgZW1wdHkgc2VxdWVuY2Ugb2YgZGVjaW1hbFxuICAgZGlnaXRzIChlLmcuIC0uMSkuICopXG5sZXQgc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcblxuXG4oKlxuICAgRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGhhdmUgKGFzIGZvdW5kIGluIHNjYW5mLm1saSk6XG4gICB0aGUgZmllbGQgd2lkdGggaXMgY29tcG9zZWQgb2YgYW4gb3B0aW9uYWwgaW50ZWdlciBsaXRlcmFsXG4gICBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsIHdpZHRoIG9mIHRoZSB0b2tlbiB0byByZWFkLlxuICAgVW5mb3J0dW5hdGVseSwgdGhlIHR5cGUtY2hlY2tlciBsZXQgdGhlIHVzZXIgd3JpdGUgYW4gb3B0aW9uYWwgcHJlY2lzaW9uLFxuICAgc2luY2UgdGhpcyBpcyB2YWxpZCBmb3IgcHJpbnRmIGZvcm1hdCBzdHJpbmdzLlxuXG4gICBUaHVzLCB0aGUgbmV4dCBzdGVwIGZvciBTY2FuZiBpcyB0byBzdXBwb3J0IGEgZnVsbCB3aWR0aCBhbmQgcHJlY2lzaW9uXG4gICBpbmRpY2F0aW9uLCBtb3JlIG9yIGxlc3Mgc2ltaWxhciB0byB0aGUgb25lIGZvciBwcmludGYsIHBvc3NpYmx5IGV4dGVuZGVkXG4gICB0byB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIFttYXgsIG1pbl0gcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZFxuICAgZm9yIHN0cmluZ3MuIFNvbWV0aGluZyBsaWtlIHRoZSBmb2xsb3dpbmcgc3BlYyBmb3Igc2NhbmYubWxpOlxuXG4gICBUaGUgb3B0aW9uYWwgW3dpZHRoXSBpcyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltYWxcbiAgIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLiBGb3IgaW5zdGFuY2UsIFslNmRdIHJlYWRzIGFuIGludGVnZXIsXG4gICBoYXZpbmcgYXQgbW9zdCA2IGNoYXJhY3RlcnMuXG5cbiAgIFRoZSBvcHRpb25hbCBbcHJlY2lzaW9uXSBpcyBhIGRvdCBbLl0gZm9sbG93ZWQgYnkgYW4gaW50ZWdlcjpcblxuICAgLSBpbiB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGNvbnZlcnNpb25zIChbJWZdLCBbJWVdLCBbJWddLCBbJUZdLCBbJUVdLFxuICAgYW5kIFslRl0gY29udmVyc2lvbnMsIHRoZSBbcHJlY2lzaW9uXSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICBkaWdpdHMgdGhhdCBtYXkgZm9sbG93IHRoZSBkZWNpbWFsIHBvaW50LiBGb3IgaW5zdGFuY2UsIFslLjRmXSByZWFkcyBhXG4gICBbZmxvYXRdIHdpdGggYXQgbW9zdCA0IGZyYWN0aW9uYWwgZGlnaXRzLFxuXG4gICAtIGluIHRoZSBzdHJpbmcgY29udmVyc2lvbnMgKFslc10sIFslU10sIFslXFxbIHJhbmdlIFxcXV0pLCBhbmQgaW4gdGhlXG4gICBpbnRlZ2VyIG51bWJlciBjb252ZXJzaW9ucyAoWyVpXSwgWyVkXSwgWyV1XSwgWyV4XSwgWyVvXSwgYW5kIHRoZWlyXG4gICBbaW50MzJdLCBbaW50NjRdLCBhbmQgW25hdGl2ZV9pbnRdIGNvcnJlc3BvbmRlbnQpLCB0aGUgW3ByZWNpc2lvbl1cbiAgIGluZGljYXRlcyB0aGUgcmVxdWlyZWQgbWluaW11bSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZCxcblxuICAgLSBvbiBhbGwgb3RoZXIgY29udmVyc2lvbnMsIHRoZSB3aWR0aCBhbmQgcHJlY2lzaW9uIHNwZWNpZnkgdGhlIFttYXgsIG1pbl1cbiAgIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuXG4qKVxubGV0IHNjYW5fZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYikgaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuICB8IF8gLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuXG5cbmxldCBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBlcnJvciBzdHIgPVxuICBsZXQgbG93ZXJjYXNlIGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ0EnIC4uICdaJyAtPlxuICAgICAgY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKyBpbnRfb2ZfY2hhciAnYScpXG4gICAgfCBfIC0+IGMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCA9IHJlZiB3aWR0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgbG93ZXJjYXNlIGMgPD4gbG93ZXJjYXNlIHN0ci5baV0gdGhlbiBlcnJvciAoKTtcbiAgICBpZiAhd2lkdGggPSAwIHRoZW4gZXJyb3IgKCk7XG4gICAgd2lkdGggOj0gU2Nhbm5pbmcuc3RvcmVfY2hhciAhd2lkdGggaWIgYztcbiAgZG9uZTtcbiAgIXdpZHRoXG5cblxubGV0IHNjYW5faGV4X2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGxldCB3aWR0aCA9IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJ4XCIgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgICApXG4gICAgICAgICAgfCBfIC0+IHdpZHRoIGluXG4gICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICAgIHwgXyAtPiB3aWR0aFxuICApXG4gIHwgJ24nIHwgJ04nIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwiYW5cIlxuICB8ICdpJyB8ICdJJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcIm5maW5pdHlcIlxuICB8IF8gLT4gYmFkX2hleF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAoKiBUaGUgZWZmZWN0aXZlIHdpZHRoIGF2YWlsYWJsZSBmb3Igc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCBpc1xuICAgICAgIHRoZSBtaW5pbXVtIG9mIGRlY2xhcmVkIHByZWNpc2lvbiBhbmQgd2lkdGggbGVmdC4gKilcbiAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICgqIEFmdGVyIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBbcHJlY2lzaW9uXSBwcm92aXNpb25hbCB3aWR0aCxcbiAgICAgICBbd2lkdGhfcHJlY2lzaW9uXSBpcyBsZWZ0LiAqKVxuICAgIGxldCB3aWR0aF9wcmVjaXNpb24gPSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIgaW5cbiAgICAoKiBIZW5jZSwgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB0b29rIGV4YWN0bHlcbiAgICAgICBbcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uXSBjaGFycy4gKilcbiAgICBsZXQgZnJhY193aWR0aCA9IHByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbiBpblxuICAgICgqIEFuZCBuZXcgcHJvdmlzaW9uYWwgd2lkdGggaXMgW3dpZHRoIC0gd2lkdGhfcHJlY2lzaW9uLiAqKVxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gZnJhY193aWR0aCBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8ICdlJyB8ICdFJyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIGFzIGMgLT4gKFxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICApXG4gICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBiYWRfZmxvYXQgKCkgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgIHwgXyAtPiB3aWR0aFxuICAgIClcbiAgICB8IF8gLT5cbiAgICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuICApXG4gIHwgJzEnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbigqIFNwZWNpYWwgY2FzZSBvZiBuYW4gYW5kIGluZmluaXR5OlxuICB8ICdpJyAtPlxuICB8ICduJyAtPlxuKilcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbigqIFNjYW4gYSByZWd1bGFyIHN0cmluZzpcbiAgIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIGEgc3BhY2UsIGlmIG5vIHNjYW5uaW5nIGluZGljYXRpb24gaGFzIGJlZW4gZ2l2ZW47XG4gICBvdGhlcndpc2UsIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzY2FubmluZ1xuICAgaW5kaWNhdGlvbiBbc3RwXS5cbiAgIEl0IGFsc28gc3RvcHMgYXQgZW5kIG9mIGZpbGUgb3Igd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBoYXNcbiAgIGJlZW4gcmVhZC4gKilcbmxldCBzY2FuX3N0cmluZyBzdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIGxvb3Agd2lkdGggPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIG1hdGNoIHN0cCB3aXRoXG4gICAgICB8IFNvbWUgYycgd2hlbiBjID0gYycgLT4gU2Nhbm5pbmcuc2tpcF9jaGFyIHdpZHRoIGliXG4gICAgICB8IFNvbWUgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGluXG4gIGxvb3Agd2lkdGhcblxuXG4oKiBTY2FuIGEgY2hhcjogcGVlayBzdHJpY3RseSBvbmUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCwgd2hhdHNvZXZlci4gKilcbmxldCBzY2FuX2NoYXIgd2lkdGggaWIgPVxuICAoKiBUaGUgY2FzZSB3aWR0aCA9IDAgY291bGQgbm90IGhhcHBlbiBoZXJlLCBzaW5jZSBpdCBpcyB0ZXN0ZWQgYmVmb3JlXG4gICAgIGNhbGxpbmcgc2Nhbl9jaGFyLCBpbiB0aGUgbWFpbiBzY2FubmluZyBmdW5jdGlvbi5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiYSBjaGFyYWN0ZXJcIiBlbHNlICopXG4gIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliKVxuXG5cbmxldCBjaGFyX2Zvcl9iYWNrc2xhc2ggPSBmdW5jdGlvblxuICB8ICduJyAtPiAnXFwwMTAnXG4gIHwgJ3InIC0+ICdcXDAxMydcbiAgfCAnYicgLT4gJ1xcMDA4J1xuICB8ICd0JyAtPiAnXFwwMDknXG4gIHwgYyAtPiBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID0gaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJ1xuXG5sZXQgY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDEwMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMCArXG4gICAgIDEwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgICBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiYmFkIGNoYXJhY3RlciBkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjJWNcIiBjMCBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGhleGFkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPVxuICBsZXQgZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgKCogQ291bGQgYWxzbyBiZTpcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICc5JyB0aGVuIGQgLSBpbnRfb2ZfY2hhciAnMCcgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ0YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ0EnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdmJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdhJyBlbHNlIGFzc2VydCBmYWxzZVxuICAqKVxuICBpZiBkID49IGludF9vZl9jaGFyICdhJyB0aGVuXG4gICAgZCAtIDg3ICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdhJyAqKSBlbHNlXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ0EnIHRoZW5cbiAgICBkIC0gNTUgICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyAqKSBlbHNlXG4gICAgZCAtIGludF9vZl9jaGFyICcwJ1xuXG5cbmxldCBjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDE2ICogaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiYmFkIGNoYXJhY3RlciBoZXhhZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlY1wiIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBDYWxsZWQgaW4gcGFydGljdWxhciB3aGVuIGVuY291bnRlcmluZyAnXFxcXCcgYXMgc3RhcnRlciBvZiBhIGNoYXIuXG4gICBTdG9wcyBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmcgJ1xcJycuICopXG5sZXQgY2hlY2tfbmV4dF9jaGFyIG1lc3NhZ2Ugd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgZWxzZVxuICBjXG5cblxubGV0IGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciA9IGNoZWNrX25leHRfY2hhciBcImEgQ2hhclwiXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgPSBjaGVja19uZXh0X2NoYXIgXCJhIFN0cmluZ1wiXG5cbmxldCBzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliID1cbiAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgfCAnXFxcXCcgfCAnXFwnJyB8ICdcXFwiJyB8ICduJyB8ICd0JyB8ICdiJyB8ICdyJyBhcyBjIC0+XG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoY2hhcl9mb3JfYmFja3NsYXNoIGMpXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMwID0gYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMilcbiAgfCAneCcgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIpXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dF9lc2NhcGUgY1xuXG5cbigqIFNjYW4gYSBjaGFyYWN0ZXIgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfY2hhciB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBmaW5kX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgY1xuXG4gIGFuZCBmaW5kX2NoYXIgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcXCcgLT5cbiAgICAgIGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpIGliKVxuICAgIHwgYyAtPlxuICAgICAgZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBkZWxpbWl0ZWQgc3RyaW5nIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gZmluZF9zdG9wIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXFwiJyBjXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCAnXFxcXCcgLT4gc2Nhbl9iYWNrc2xhc2ggKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgc2Nhbl9iYWNrc2xhc2ggd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXHInIC0+IHNraXBfbmV3bGluZSAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYilcblxuICBhbmQgc2tpcF9uZXdsaW5lIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAnXFxyJylcblxuICBhbmQgc2tpcF9zcGFjZXMgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICcgJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCB3aWR0aCBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgYm9vbGVhbiAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fYm9vbCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbGV0IG0gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3QnIC0+IDRcbiAgICB8ICdmJyAtPiA1XG4gICAgfCBjIC0+XG4gICAgICBiYWRfaW5wdXRcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwidGhlIGNoYXJhY3RlciAlQyBjYW5ub3Qgc3RhcnQgYSBib29sZWFuXCIgYykgaW5cbiAgc2Nhbl9zdHJpbmcgTm9uZSBtIGliXG5cblxuKCogU2NhbiBhIHN0cmluZyBjb250YWluaW5nIGVsZW1lbnRzIGluIGNoYXJfc2V0IGFuZCB0ZXJtaW5hdGVkIGJ5IHNjYW5faW5kaWNcbiAgIGlmIHByb3ZpZGVkLiAqKVxubGV0IHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgc2Nhbl9pbmRpYyB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9jaGFycyBpIHN0cCA9XG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpID4gMCAmJiBub3QgKFNjYW5uaW5nLmVvZiBpYikgJiZcbiAgICAgICBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjICYmXG4gICAgICAgaW50X29mX2NoYXIgYyA8PiBzdHAgdGhlblxuICAgICAgbGV0IF8gPSBTY2FubmluZy5zdG9yZV9jaGFyIG1heF9pbnQgaWIgYyBpblxuICAgICAgc2Nhbl9jaGFycyAoaSAtIDEpIHN0cCBpblxuICBtYXRjaCBzY2FuX2luZGljIHdpdGhcbiAgfCBOb25lIC0+IHNjYW5fY2hhcnMgd2lkdGggKC0xKTtcbiAgfCBTb21lIGMgLT5cbiAgICBzY2FuX2NoYXJzIHdpZHRoIChpbnRfb2ZfY2hhciBjKTtcbiAgICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlblxuICAgICAgbGV0IGNpID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgICBpZiBjID0gY2lcbiAgICAgIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgICAgIGVsc2UgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuXG4oKiBUaGUgZ2xvYmFsIGVycm9yIHJlcG9ydCBmdW5jdGlvbiBmb3IgW1NjYW5mXS4gKilcbmxldCBzY2FuZl9iYWRfaW5wdXQgaWIgPSBmdW5jdGlvblxuICB8IFNjYW5fZmFpbHVyZSBzIHwgRmFpbHVyZSBzIC0+XG4gICAgbGV0IGkgPSBTY2FubmluZy5jaGFyX2NvdW50IGliIGluXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcInNjYW5mOiBiYWQgaW5wdXQgYXQgY2hhciBudW1iZXIgJWk6ICVzXCIgaSBzKVxuICB8IHggLT4gcmFpc2UgeFxuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiBhIGNvdW50ZXIgZnJvbSBhbiBpbnB1dCBidWZmZXIuICopXG5sZXQgZ2V0X2NvdW50ZXIgaWIgY291bnRlciA9XG4gIG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAtPiBTY2FubmluZy5saW5lX2NvdW50IGliXG4gIHwgQ2hhcl9jb3VudGVyIC0+IFNjYW5uaW5nLmNoYXJfY291bnQgaWJcbiAgfCBUb2tlbl9jb3VudGVyIC0+IFNjYW5uaW5nLnRva2VuX2NvdW50IGliXG5cblxuKCogQ29tcHV0ZSB0aGUgd2lkdGggb2YgYSBwYWRkaW5nIG9wdGlvbiAoc2VlIFwiJTQye1wiIGFuZCBcIiUxMjMoXCIpLiAqKVxubGV0IHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gbWF4X2ludFxuICB8IFNvbWUgd2lkdGggLT4gd2lkdGhcblxuXG5sZXQgc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgPVxuICBpZiBmbXRpbmcgPSBFc2NhcGVkX3BlcmNlbnQgdGhlbiAnJScsIFwiXCIgZWxzZVxuICAgIGxldCBzdHIgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nIGluXG4gICAgbGV0IHN0cCA9IHN0ci5bMV0gaW5cbiAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIDIgKFN0cmluZy5sZW5ndGggc3RyIC0gMikgaW5cbiAgICBzdHAsIHN1Yl9zdHJcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUmVhZGVyIG1hbmFnZW1lbnQgKilcblxuKCogQSBjYWxsIHRvIHRha2VfZm9ybWF0X3JlYWRlcnMgb24gYSBmb3JtYXQgaXMgZXZhbHVhdGVkIGludG8gZnVuY3Rpb25zXG4gICB0YWtpbmcgcmVhZGVycyBhcyBhcmd1bWVudHMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYW4gaGV0ZXJvZ2VuZW91cyBsaXN0ICopXG4oKiBXaGVuIGFsbCByZWFkZXJzIGFyZSB0YWtlbiwgZmluYWxseSBwYXNzIHRoZSBsaXN0IG9mIHRoZSByZWFkZXJzIHRvIHRoZVxuICAgY29udGludWF0aW9uIGsuICopXG5sZXQgcmVjIHRha2VfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICBkID1cbmZ1biBrIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0XG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9zdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDMyIChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgTmF0aXZlaW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQ2NCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsb2F0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQm9vbCAoXywgcmVzdCkgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ3VzdG9tIChfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAgICAtPlxuICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAgICAgICAtPiB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgayBpZ24gcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgICAgICAgLT4gayBOaWxcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gZm10dHkgY29taW5nIGZyb20gYSBGb3JtYXRfc3Vic3QgXCIlKC4uLiUpXCIuICopXG5hbmQgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBmbXR0eSAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgUmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gaWdub3JlZCBwYXJhbWV0ZXIuICopXG5hbmQgdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGlnbm9yZWQgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBzY2FubmluZyAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBzY2FubmluZyBmdW5jdGlvbi4gKilcbigqIFNjYW4gYSBzdHJlYW0gYWNjb3JkaW5nIHRvIGEgZm9ybWF0IGFuZCByZWFkZXJzIG9idGFpbmVkIGJ5XG4gICB0YWtlX2Zvcm1hdF9yZWFkZXJzLCBhbmQgYWdncmVnYXRlIHNjYW5uZWQgdmFsdWVzIGludG8gYW5cbiAgIGhldGVyb2dlbmVvdXMgbGlzdC4gKilcbigqIFJldHVybiB0aGUgaGV0ZXJvZ2VuZW91cyBsaXN0IG9mIHNjYW5uZWQgdmFsdWVzLiAqKVxubGV0IHJlYyBtYWtlX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoYSwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lIHN0cCkgd2lkdGggaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ3snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICdbJykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIE5vbmUgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQgYylcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50MzIgYylcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX25hdGl2ZWludCBjKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQ2NCBjKVxuICB8IEZsb2F0IChGbG9hdF9GLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoRmxvYXRfZiB8IEZsb2F0X3BmIHwgRmxvYXRfc2YgfCBGbG9hdF9lIHwgRmxvYXRfcGUgfCBGbG9hdF9zZVxuICAgICAgICAgICAgICAgfCBGbG9hdF9FIHwgRmxvYXRfcEUgfCBGbG9hdF9zRSB8IEZsb2F0X2cgfCBGbG9hdF9wZyB8IEZsb2F0X3NnXG4gICAgICAgICAgICAgICB8IEZsb2F0X0cgfCBGbG9hdF9wRyB8IEZsb2F0X3NHKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChGbG9hdF9oIHwgRmxvYXRfcGggfCBGbG9hdF9zaCB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIKSxcbiAgICAgICAgICAgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2hleF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiBfIF8gaWIgPSBzY2FuX2Jvb2wgaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX2Jvb2xcbiAgfCBBbHBoYSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiVhXFxcIlwiXG4gIHwgVGhldGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIldFxcXCJcIlxuICB8IEN1c3RvbSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiU/XFxcIiAoY3VzdG9tIGNvbnZlcnRlcilcIlxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGJlZ2luIG1hdGNoIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpIC0+XG4gICAgICAgIGxldCB4ID0gcmVhZGVyIGliIGluXG4gICAgICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10X3Jlc3QgcmVhZGVyc19yZXN0KVxuICAgIHwgTmlsIC0+XG4gICAgICAgIGludmFsaWRfYXJnIFwic2NhbmY6IG1pc3NpbmcgcmVhZGVyXCJcbiAgICBlbmRcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgaWYgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgICBlbHNlIGJhZF9pbnB1dCBcImVuZCBvZiBpbnB1dCBub3QgZm91bmRcIlxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgc3RyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiBjaHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzIGZtdHR5XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKGZtdCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQsIGZtdCcgPVxuICAgICAgdHJ5XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10JyA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgKCogVE9ETzogZmluZCBhIHdheSB0byBhdm9pZCByZXBhcnNpbmcgdHdpY2UgKilcblxuICAgICAgICAoKiBUT0RPOiB0aGVzZSB0eXBlLWNoZWNrcyBiZWxvdyAqY2FuKiBmYWlsIGJlY2F1c2Ugb2YgdHlwZVxuICAgICAgICAgICBhbWJpZ3VpdHkgaW4gcHJlc2VuY2Ugb2YgaWdub3JlZC1yZWFkZXJzOiBcIiVfciVkXCIgYW5kIFwiJWQlX3JcIlxuICAgICAgICAgICBhcmUgdHlwZWQgaW4gdGhlIHNhbWUgd2F5LlxuXG4gICAgICAgICAgICMgU2NhbmYuc3NjYW5mIFwiXFxcIiVfciVkXFxcIjNcIiBcIiUoJWQlX3IlKVwiIGlnbm9yZVxuICAgICAgICAgICAgIChmdW4gZm10IG4gLT4gc3RyaW5nX29mX2Zvcm1hdCBmbXQsIG4pXG4gICAgICAgICAgIEV4Y2VwdGlvbjogQ2FtbGludGVybmFsRm9ybWF0LlR5cGVfbWlzbWF0Y2guXG5cbiAgICAgICAgICAgV2Ugc2hvdWxkIHByb3Blcmx5IGNhdGNoIHRoaXMgZXhjZXB0aW9uLlxuICAgICAgICAqKVxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCBmbXR0eSksXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCcgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKEZvcm1hdCAoZm10LCBzKSxcbiAgICAgICAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycylcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKFNvbWUgc3RwKSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IE5vbmUgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIGxldCBjb3VudCA9IGdldF9jb3VudGVyIGliIGNvdW50ZXIgaW5cbiAgICBDb25zIChjb3VudCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCk7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICd7JztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ1snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG5cbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgIGJlZ2luIG1hdGNoIG1ha2Vfc2NhbmYgaWIgZm10JyByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKF8sIGFyZ19yZXN0KSAtPiBhcmdfcmVzdFxuICAgIHwgTmlsIC0+IGFzc2VydCBmYWxzZVxuICAgIGVuZFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIE5pbFxuXG4oKiBDYXNlIGFuYWx5c2lzIG9uIHBhZGRpbmcgYW5kIHByZWNpc2lvbi4gKilcbigqIFJlamVjdCBmb3JtYXRzIGNvbnRhaW5pbmcgXCIlKlwiIG9yIFwiJS4qXCIuICopXG4oKiBQYXNzIHBhZGRpbmcgYW5kIHByZWNpc2lvbiB0byB0aGUgZ2VuZXJpYyBzY2FubmVyIGBzY2FuJy4gKilcbmFuZCBwYWRfcHJlY19zY2FuZiA6IHR5cGUgYSBjIGQgZSBmIHggeSB6IHQgLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+XG4gICAgICAoaW50IC0+IGludCAtPiBTY2FubmluZy5pbl9jaGFubmVsIC0+IHQpIC0+XG4gICAgICAoU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB6KSAtPlxuICAgICAgKHgsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gdG9rZW4gLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiB3IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoTGVmdCwgXyksIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJS1cXFwiXCJcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCBfKSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IEFyZ19wYWRkaW5nIF8sIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAoKiBEZWZpbmluZyBbc2NhbmZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW3NjYW5mXSAqKVxuXG50eXBlICdhIGtzY2FuZl9yZXN1bHQgPSBBcmdzIG9mICdhIHwgRXhjIG9mIGV4blxuXG5sZXQga3NjYW5mIGliIGVmIChGb3JtYXQgKGZtdCwgc3RyKSkgPVxuICBsZXQgcmVjIGFwcGx5IDogdHlwZSBhIGIgLiBhIC0+IChhLCBiKSBoZXRlcl9saXN0IC0+IGIgPVxuICAgIGZ1biBmIGFyZ3MgLT4gbWF0Y2ggYXJncyB3aXRoXG4gICAgfCBDb25zICh4LCByKSAtPiBhcHBseSAoZiB4KSByXG4gICAgfCBOaWwgLT4gZlxuICBpblxuICBsZXQgayByZWFkZXJzIGYgPVxuICAgIFNjYW5uaW5nLnJlc2V0X3Rva2VuIGliO1xuICAgIG1hdGNoIHRyeSBBcmdzIChtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKSB3aXRoXG4gICAgICB8IChTY2FuX2ZhaWx1cmUgXyB8IEZhaWx1cmUgXyB8IEVuZF9vZl9maWxlKSBhcyBleGMgLT4gRXhjIGV4Y1xuICAgICAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPlxuICAgICAgICBpbnZhbGlkX2FyZyAobXNnIF4gXCIgaW4gZm9ybWF0IFxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHN0ciBeIFwiXFxcIlwiKVxuICAgIHdpdGhcbiAgICAgIHwgQXJncyBhcmdzIC0+IGFwcGx5IGYgYXJnc1xuICAgICAgfCBFeGMgZXhjIC0+IGVmIGliIGV4Y1xuICBpblxuICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKiopXG5cbmxldCBrYnNjYW5mID0ga3NjYW5mXG5sZXQgYnNjYW5mIGliIGZtdCA9IGtic2NhbmYgaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQga3NzY2FuZiBzIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGVmIGZtdFxubGV0IHNzY2FuZiBzIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IHNjYW5mIGZtdCA9IGtzY2FuZiBTY2FubmluZy5zdGRpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbigqKiopXG5cbigqIFNjYW5uaW5nIGZvcm1hdCBzdHJpbmdzLiAqKVxubGV0IGJzY2FuZl9mb3JtYXQgOlxuICBTY2FubmluZy5pbl9jaGFubmVsIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gaWIgZm9ybWF0IGYgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgbWF4X2ludCBpYiBpblxuICAgIGxldCBzdHIgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10JyA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIGZvcm1hdFxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnIGluXG4gICAgZiBmbXQnXG5cblxubGV0IHNzY2FuZl9mb3JtYXQgOlxuICBzdHJpbmcgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBzIGZvcm1hdCBmIC0+IGJzY2FuZl9mb3JtYXQgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGZvcm1hdCBmXG5cblxubGV0IGZvcm1hdF9mcm9tX3N0cmluZyBzIGZtdCA9XG4gIHNzY2FuZl9mb3JtYXQgKFwiXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgcyBeIFwiXFxcIlwiKSBmbXQgKGZ1biB4IC0+IHgpXG5cblxubGV0IHVuZXNjYXBlZCBzID1cbiAgc3NjYW5mIChcIlxcXCJcIiBeIHMgXiBcIlxcXCJcIikgXCIlUyUhXCIgKGZ1biB4IC0+IHgpXG5cblxuKCogRGVwcmVjYXRlZCAqKVxubGV0IGtmc2NhbmYgaWMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIGVmIGZtdFxubGV0IGZzY2FuZiBpYyBmbXQgPSBrc2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBzY2FuZl9iYWRfaW5wdXQgZm10XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFJlZ2lzdGVyaW5nIE9DYW1sIHZhbHVlcyB3aXRoIHRoZSBDIHJ1bnRpbWUgZm9yIGxhdGVyIGNhbGxiYWNrcyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiBPYmoudCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCByZWdpc3RlciBuYW1lIHYgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIChPYmoucmVwciB2KVxuXG5sZXQgcmVnaXN0ZXJfZXhjZXB0aW9uIG5hbWUgKGV4biA6IGV4bikgPVxuICBsZXQgZXhuID0gT2JqLnJlcHIgZXhuIGluXG4gIGxldCBzbG90ID0gaWYgT2JqLnRhZyBleG4gPSBPYmoub2JqZWN0X3RhZyB0aGVuIGV4biBlbHNlIE9iai5maWVsZCBleG4gMCBpblxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIHNsb3RcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIEplcm9tZSBWb3VpbGxvbiwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBPYmpcblxuKCoqKiogT2JqZWN0IHJlcHJlc2VudGF0aW9uICoqKiopXG5cbmV4dGVybmFsIHNldF9pZDogJ2EgLT4gJ2EgPSBcImNhbWxfc2V0X29vX2lkXCIgW0BAbm9hbGxvY11cblxuKCoqKiogT2JqZWN0IGNvcHkgKioqKilcblxubGV0IGNvcHkgbyA9XG4gIGxldCBvID0gKE9iai5vYmogKE9iai5kdXAgKE9iai5yZXByIG8pKSkgaW5cbiAgc2V0X2lkIG9cblxuKCoqKiogQ29tcHJlc3Npb24gb3B0aW9ucyAqKioqKVxuKCogUGFyYW1ldGVycyAqKVxudHlwZSBwYXJhbXMgPSB7XG4gICAgbXV0YWJsZSBjb21wYWN0X3RhYmxlIDogYm9vbDtcbiAgICBtdXRhYmxlIGNvcHlfcGFyZW50IDogYm9vbDtcbiAgICBtdXRhYmxlIGNsZWFuX3doZW5fY29weWluZyA6IGJvb2w7XG4gICAgbXV0YWJsZSByZXRyeV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGJ1Y2tldF9zbWFsbF9zaXplIDogaW50XG4gIH1cblxubGV0IHBhcmFtcyA9IHtcbiAgY29tcGFjdF90YWJsZSA9IHRydWU7XG4gIGNvcHlfcGFyZW50ID0gdHJ1ZTtcbiAgY2xlYW5fd2hlbl9jb3B5aW5nID0gdHJ1ZTtcbiAgcmV0cnlfY291bnQgPSAzO1xuICBidWNrZXRfc21hbGxfc2l6ZSA9IDE2XG59XG5cbigqKioqIFBhcmFtZXRlcnMgKioqKilcblxubGV0IGluaXRpYWxfb2JqZWN0X3NpemUgPSAyXG5cbigqKioqIEl0ZW1zICoqKiopXG5cbnR5cGUgaXRlbSA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxubGV0IGR1bW15X2l0ZW0gPSAobWFnaWMgKCkgOiBpdGVtKVxuXG4oKioqKiBUeXBlcyAqKioqKVxuXG50eXBlIHRhZ1xudHlwZSBsYWJlbCA9IGludFxudHlwZSBjbG9zdXJlID0gaXRlbVxudHlwZSB0ID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG50eXBlIG9iaiA9IHQgYXJyYXlcbmV4dGVybmFsIHJldCA6IChvYmogLT4gJ2EpIC0+IGNsb3N1cmUgPSBcIiVpZGVudGl0eVwiXG5cbigqKioqIExhYmVscyAqKioqKVxuXG5sZXQgcHVibGljX21ldGhvZF9sYWJlbCBzIDogdGFnID1cbiAgbGV0IGFjY3UgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgIGFjY3UgOj0gMjIzICogIWFjY3UgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgxIGxzbCAzMSAtIDEpO1xuICAoKiBtYWtlIGl0IHNpZ25lZCBmb3IgNjQgYml0cyBhcmNoaXRlY3R1cmVzICopXG4gIGxldCB0YWcgPSBpZiAhYWNjdSA+IDB4M0ZGRkZGRkYgdGhlbiAhYWNjdSAtICgxIGxzbCAzMSkgZWxzZSAhYWNjdSBpblxuICAoKiBQcmludGYuZXByaW50ZiBcIiVzID0gJWRcXG5cIiBzIHRhZzsgZmx1c2ggc3RkZXJyOyAqKVxuICBtYWdpYyB0YWdcblxuKCoqKiogU3BhcnNlIGFycmF5ICoqKiopXG5cbm1vZHVsZSBWYXJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSB2YXJzID0gaW50IFZhcnMudFxuXG5tb2R1bGUgTWV0aHMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIG1ldGhzID0gbGFiZWwgTWV0aHMudFxubW9kdWxlIExhYnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gbGFiZWwgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbGFicyA9IGJvb2wgTGFicy50XG5cbigqIFRoZSBjb21waWxlciBhc3N1bWVzIHRoYXQgdGhlIGZpcnN0IGZpZWxkIG9mIHRoaXMgc3RydWN0dXJlIGlzIFtzaXplXS4gKilcbnR5cGUgdGFibGUgPVxuIHsgbXV0YWJsZSBzaXplOiBpbnQ7XG4gICBtdXRhYmxlIG1ldGhvZHM6IGNsb3N1cmUgYXJyYXk7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbmFtZTogbWV0aHM7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbGFiZWw6IGxhYnM7XG4gICBtdXRhYmxlIHByZXZpb3VzX3N0YXRlczpcbiAgICAgKG1ldGhzICogbGFicyAqIChsYWJlbCAqIGl0ZW0pIGxpc3QgKiB2YXJzICpcbiAgICAgIGxhYmVsIGxpc3QgKiBzdHJpbmcgbGlzdCkgbGlzdDtcbiAgIG11dGFibGUgaGlkZGVuX21ldGhzOiAobGFiZWwgKiBpdGVtKSBsaXN0O1xuICAgbXV0YWJsZSB2YXJzOiB2YXJzO1xuICAgbXV0YWJsZSBpbml0aWFsaXplcnM6IChvYmogLT4gdW5pdCkgbGlzdCB9XG5cbmxldCBkdW1teV90YWJsZSA9XG4gIHsgbWV0aG9kcyA9IFt8IGR1bW15X2l0ZW0gfF07XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IDAgfVxuXG5sZXQgdGFibGVfY291bnQgPSByZWYgMFxuXG4oKiBkdW1teV9tZXQgc2hvdWxkIGJlIGEgcG9pbnRlciwgc28gdXNlIGFuIGF0b20gKilcbmxldCBkdW1teV9tZXQgOiBpdGVtID0gb2JqIChPYmoubmV3X2Jsb2NrIDAgMClcbigqIGlmIGRlYnVnZ2luZyBpcyBuZWVkZWQsIHRoaXMgY291bGQgYmUgYSBnb29kIGlkZWE6ICopXG4oKiBsZXQgZHVtbXlfbWV0ICgpID0gZmFpbHdpdGggXCJVbmRlZmluZWQgbWV0aG9kXCIgKilcblxubGV0IHJlYyBmaXRfc2l6ZSBuID1cbiAgaWYgbiA8PSAyIHRoZW4gbiBlbHNlXG4gIGZpdF9zaXplICgobisxKS8yKSAqIDJcblxubGV0IG5ld190YWJsZSBwdWJfbGFiZWxzID1cbiAgaW5jciB0YWJsZV9jb3VudDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBwdWJfbGFiZWxzIGluXG4gIGxldCBtZXRob2RzID0gQXJyYXkubWFrZSAobGVuKjIrMikgZHVtbXlfbWV0IGluXG4gIG1ldGhvZHMuKDApIDwtIG1hZ2ljIGxlbjtcbiAgbWV0aG9kcy4oMSkgPC0gbWFnaWMgKGZpdF9zaXplIGxlbiAqIFN5cy53b3JkX3NpemUgLyA4IC0gMSk7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvIG1ldGhvZHMuKGkqMiszKSA8LSBtYWdpYyBwdWJfbGFiZWxzLihpKSBkb25lO1xuICB7IG1ldGhvZHMgPSBtZXRob2RzO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSBpbml0aWFsX29iamVjdF9zaXplIH1cblxubGV0IHJlc2l6ZSBhcnJheSBuZXdfc2l6ZSA9XG4gIGxldCBvbGRfc2l6ZSA9IEFycmF5Lmxlbmd0aCBhcnJheS5tZXRob2RzIGluXG4gIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlbiBiZWdpblxuICAgIGxldCBuZXdfYnVjayA9IEFycmF5Lm1ha2UgbmV3X3NpemUgZHVtbXlfbWV0IGluXG4gICAgQXJyYXkuYmxpdCBhcnJheS5tZXRob2RzIDAgbmV3X2J1Y2sgMCBvbGRfc2l6ZTtcbiAgICBhcnJheS5tZXRob2RzIDwtIG5ld19idWNrXG4gZW5kXG5cbmxldCBwdXQgYXJyYXkgbGFiZWwgZWxlbWVudCA9XG4gIHJlc2l6ZSBhcnJheSAobGFiZWwgKyAxKTtcbiAgYXJyYXkubWV0aG9kcy4obGFiZWwpIDwtIGVsZW1lbnRcblxuKCoqKiogQ2xhc3NlcyAqKioqKVxuXG5sZXQgbWV0aG9kX2NvdW50ID0gcmVmIDBcbmxldCBpbnN0X3Zhcl9jb3VudCA9IHJlZiAwXG5cbigqIHR5cGUgdCAqKVxudHlwZSBtZXRoID0gaXRlbVxuXG5sZXQgbmV3X21ldGhvZCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IEFycmF5Lmxlbmd0aCB0YWJsZS5tZXRob2RzIGluXG4gIHJlc2l6ZSB0YWJsZSAoaW5kZXggKyAxKTtcbiAgaW5kZXhcblxubGV0IGdldF9tZXRob2RfbGFiZWwgdGFibGUgbmFtZSA9XG4gIHRyeVxuICAgIE1ldGhzLmZpbmQgbmFtZSB0YWJsZS5tZXRob2RzX2J5X25hbWVcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgbGFiZWwgPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gICAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIE1ldGhzLmFkZCBuYW1lIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYmVsIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbDtcbiAgICBsYWJlbFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbHMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIG5hbWVzXG5cbmxldCBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGVsZW1lbnQgPVxuICBpbmNyIG1ldGhvZF9jb3VudDtcbiAgaWYgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgdGhlblxuICAgIHB1dCB0YWJsZSBsYWJlbCBlbGVtZW50XG4gIGVsc2VcbiAgICB0YWJsZS5oaWRkZW5fbWV0aHMgPC0gKGxhYmVsLCBlbGVtZW50KSA6OiB0YWJsZS5oaWRkZW5fbWV0aHNcblxubGV0IGdldF9tZXRob2QgdGFibGUgbGFiZWwgPVxuICB0cnkgTGlzdC5hc3NvYyBsYWJlbCB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgd2l0aCBOb3RfZm91bmQgLT4gdGFibGUubWV0aG9kcy4obGFiZWwpXG5cbmxldCB0b19saXN0IGFyciA9XG4gIGlmIGFyciA9PSBtYWdpYyAwIHRoZW4gW10gZWxzZSBBcnJheS50b19saXN0IGFyclxuXG5sZXQgbmFycm93IHRhYmxlIHZhcnMgdmlydF9tZXRocyBjb25jcl9tZXRocyA9XG4gIGxldCB2YXJzID0gdG9fbGlzdCB2YXJzXG4gIGFuZCB2aXJ0X21ldGhzID0gdG9fbGlzdCB2aXJ0X21ldGhzXG4gIGFuZCBjb25jcl9tZXRocyA9IHRvX2xpc3QgY29uY3JfbWV0aHMgaW5cbiAgbGV0IHZpcnRfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIHZpcnRfbWV0aHMgaW5cbiAgbGV0IGNvbmNyX21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBjb25jcl9tZXRocyBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC1cbiAgICAgKHRhYmxlLm1ldGhvZHNfYnlfbmFtZSwgdGFibGUubWV0aG9kc19ieV9sYWJlbCwgdGFibGUuaGlkZGVuX21ldGhzLFxuICAgICAgdGFibGUudmFycywgdmlydF9tZXRoX2xhYnMsIHZhcnMpXG4gICAgIDo6IHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgIFZhcnMuZm9sZFxuICAgICAgKGZ1biBsYWIgaW5mbyB0dmFycyAtPlxuICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmFycyB0aGVuIFZhcnMuYWRkIGxhYiBpbmZvIHR2YXJzIGVsc2UgdHZhcnMpXG4gICAgICB0YWJsZS52YXJzIFZhcnMuZW1wdHk7XG4gIGxldCBieV9uYW1lID0gcmVmIE1ldGhzLmVtcHR5IGluXG4gIGxldCBieV9sYWJlbCA9IHJlZiBMYWJzLmVtcHR5IGluXG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PVxuICAgICAgICAgIExhYnMuYWRkIGxhYmVsXG4gICAgICAgICAgICAodHJ5IExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHdpdGggTm90X2ZvdW5kIC0+IHRydWUpXG4gICAgICAgICAgICAhYnlfbGFiZWwpXG4gICAgY29uY3JfbWV0aHMgY29uY3JfbWV0aF9sYWJzO1xuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj0gTGFicy5hZGQgbGFiZWwgZmFsc2UgIWJ5X2xhYmVsKVxuICAgIHZpcnRfbWV0aHMgdmlydF9tZXRoX2xhYnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSAhYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSAhYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aF9sYWJzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIFtdXG5cbmxldCB3aWRlbiB0YWJsZSA9XG4gIGxldCAoYnlfbmFtZSwgYnlfbGFiZWwsIHNhdmVkX2hpZGRlbl9tZXRocywgc2F2ZWRfdmFycywgdmlydF9tZXRocywgdmFycykgPVxuICAgIExpc3QuaGQgdGFibGUucHJldmlvdXNfc3RhdGVzXG4gIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LSBMaXN0LnRsIHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgIChmdW4gcyB2IC0+IFZhcnMuYWRkIHYgKFZhcnMuZmluZCB2IHRhYmxlLnZhcnMpIHMpXG4gICAgICAgc2F2ZWRfdmFycyB2YXJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRocyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBzYXZlZF9oaWRkZW5fbWV0aHNcblxubGV0IG5ld19zbG90IHRhYmxlID1cbiAgbGV0IGluZGV4ID0gdGFibGUuc2l6ZSBpblxuICB0YWJsZS5zaXplIDwtIGluZGV4ICsgMTtcbiAgaW5kZXhcblxubGV0IG5ld192YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnNcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgaW5kZXggPSBuZXdfc2xvdCB0YWJsZSBpblxuICAgIGlmIG5hbWUgPD4gXCJcIiB0aGVuIHRhYmxlLnZhcnMgPC0gVmFycy5hZGQgbmFtZSBpbmRleCB0YWJsZS52YXJzO1xuICAgIGluZGV4XG5cbmxldCB0b19hcnJheSBhcnIgPVxuICBpZiBhcnIgPSBPYmoubWFnaWMgMCB0aGVuIFt8fF0gZWxzZSBhcnJcblxubGV0IG5ld19tZXRob2RzX3ZhcmlhYmxlcyB0YWJsZSBtZXRocyB2YWxzID1cbiAgbGV0IG1ldGhzID0gdG9fYXJyYXkgbWV0aHMgaW5cbiAgbGV0IG5tZXRocyA9IEFycmF5Lmxlbmd0aCBtZXRocyBhbmQgbnZhbHMgPSBBcnJheS5sZW5ndGggdmFscyBpblxuICBsZXQgcmVzID0gQXJyYXkubWFrZSAobm1ldGhzICsgbnZhbHMpIDAgaW5cbiAgZm9yIGkgPSAwIHRvIG5tZXRocyAtIDEgZG9cbiAgICByZXMuKGkpIDwtIGdldF9tZXRob2RfbGFiZWwgdGFibGUgbWV0aHMuKGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBudmFscyAtIDEgZG9cbiAgICByZXMuKGkrbm1ldGhzKSA8LSBuZXdfdmFyaWFibGUgdGFibGUgdmFscy4oaSlcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBnZXRfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzIHdpdGggTm90X2ZvdW5kIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZ2V0X3ZhcmlhYmxlcyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIHRhYmxlKSBuYW1lc1xuXG5sZXQgYWRkX2luaXRpYWxpemVyIHRhYmxlIGYgPVxuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gZjo6dGFibGUuaW5pdGlhbGl6ZXJzXG5cbigqXG5tb2R1bGUgS2V5cyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSB0YWcgYXJyYXkgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbmxldCBrZXlfbWFwID0gcmVmIEtleXMuZW1wdHlcbmxldCBnZXRfa2V5IHRhZ3MgOiBpdGVtID1cbiAgdHJ5IG1hZ2ljIChLZXlzLmZpbmQgdGFncyAha2V5X21hcCA6IHRhZyBhcnJheSlcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBrZXlfbWFwIDo9IEtleXMuYWRkIHRhZ3MgdGFncyAha2V5X21hcDtcbiAgICBtYWdpYyB0YWdzXG4qKVxuXG5sZXQgY3JlYXRlX3RhYmxlIHB1YmxpY19tZXRob2RzID1cbiAgaWYgcHVibGljX21ldGhvZHMgPT0gbWFnaWMgMCB0aGVuIG5ld190YWJsZSBbfHxdIGVsc2VcbiAgKCogW3B1YmxpY19tZXRob2RzXSBtdXN0IGJlIGluIGFzY2VuZGluZyBvcmRlciBmb3IgYnl0ZWNvZGUgKilcbiAgbGV0IHRhZ3MgPSBBcnJheS5tYXAgcHVibGljX21ldGhvZF9sYWJlbCBwdWJsaWNfbWV0aG9kcyBpblxuICBsZXQgdGFibGUgPSBuZXdfdGFibGUgdGFncyBpblxuICBBcnJheS5pdGVyaVxuICAgIChmdW4gaSBtZXQgLT5cbiAgICAgIGxldCBsYWIgPSBpKjIrMiBpblxuICAgICAgdGFibGUubWV0aG9kc19ieV9uYW1lICA8LSBNZXRocy5hZGQgbWV0IGxhYiB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYiB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwpXG4gICAgcHVibGljX21ldGhvZHM7XG4gIHRhYmxlXG5cbmxldCBpbml0X2NsYXNzIHRhYmxlID1cbiAgaW5zdF92YXJfY291bnQgOj0gIWluc3RfdmFyX2NvdW50ICsgdGFibGUuc2l6ZSAtIDE7XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBMaXN0LnJldiB0YWJsZS5pbml0aWFsaXplcnM7XG4gIHJlc2l6ZSB0YWJsZSAoMyArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplKVxuXG5sZXQgaW5oZXJpdHMgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocyAoXywgc3VwZXIsIF8sIGVudikgdG9wID1cbiAgbmFycm93IGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHM7XG4gIGxldCBpbml0ID1cbiAgICBpZiB0b3AgdGhlbiBzdXBlciBjbGEgZW52IGVsc2UgT2JqLnJlcHIgKHN1cGVyIGNsYSkgaW5cbiAgd2lkZW4gY2xhO1xuICBBcnJheS5jb25jYXRcbiAgICBbW3wgcmVwciBpbml0IHxdO1xuICAgICBtYWdpYyAoQXJyYXkubWFwIChnZXRfdmFyaWFibGUgY2xhKSAodG9fYXJyYXkgdmFscykgOiBpbnQgYXJyYXkpO1xuICAgICBBcnJheS5tYXBcbiAgICAgICAoZnVuIG5tIC0+IHJlcHIgKGdldF9tZXRob2QgY2xhIChnZXRfbWV0aG9kX2xhYmVsIGNsYSBubSkgOiBjbG9zdXJlKSlcbiAgICAgICAodG9fYXJyYXkgY29uY3JfbWV0aHMpIF1cblxubGV0IG1ha2VfY2xhc3MgcHViX21ldGhzIGNsYXNzX2luaXQgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgKGVudl9pbml0IChPYmoucmVwciAwKSwgY2xhc3NfaW5pdCwgZW52X2luaXQsIE9iai5yZXByIDApXG5cbnR5cGUgaW5pdF90YWJsZSA9IHsgbXV0YWJsZSBlbnZfaW5pdDogdDsgbXV0YWJsZSBjbGFzc19pbml0OiB0YWJsZSAtPiB0IH1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0b2tlbiA9XG4gICAgS3dkIG9mIHN0cmluZ1xuICB8IElkZW50IG9mIHN0cmluZ1xuICB8IEludCBvZiBpbnRcbiAgfCBGbG9hdCBvZiBmbG9hdFxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBDaGFyIG9mIGNoYXJcblxuKCogVGhlIHN0cmluZyBidWZmZXJpbmcgbWFjaGluZXJ5ICopXG5cbmxldCBpbml0aWFsX2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAzMlxuXG5sZXQgYnVmZmVyID0gcmVmIGluaXRpYWxfYnVmZmVyXG5sZXQgYnVmcG9zID0gcmVmIDBcblxubGV0IHJlc2V0X2J1ZmZlciAoKSA9IGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgYnVmcG9zIDo9IDBcblxubGV0IHN0b3JlIGMgPVxuICBpZiAhYnVmcG9zID49IEJ5dGVzLmxlbmd0aCAhYnVmZmVyIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3YnVmZmVyID0gQnl0ZXMuY3JlYXRlICgyICogIWJ1ZnBvcykgaW5cbiAgICBCeXRlcy5ibGl0ICFidWZmZXIgMCBuZXdidWZmZXIgMCAhYnVmcG9zO1xuICAgIGJ1ZmZlciA6PSBuZXdidWZmZXJcbiAgZW5kO1xuICBCeXRlcy5zZXQgIWJ1ZmZlciAhYnVmcG9zIGM7XG4gIGluY3IgYnVmcG9zXG5cbmxldCBnZXRfc3RyaW5nICgpID1cbiAgbGV0IHMgPSBCeXRlcy5zdWJfc3RyaW5nICFidWZmZXIgMCAhYnVmcG9zIGluIGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgc1xuXG4oKiBUaGUgbGV4ZXIgKilcblxubGV0IG1ha2VfbGV4ZXIga2V5d29yZHMgPVxuICBsZXQga3dkX3RhYmxlID0gSGFzaHRibC5jcmVhdGUgMTcgaW5cbiAgTGlzdC5pdGVyIChmdW4gcyAtPiBIYXNodGJsLmFkZCBrd2RfdGFibGUgcyAoS3dkIHMpKSBrZXl3b3JkcztcbiAgbGV0IGlkZW50X29yX2tleXdvcmQgaWQgPVxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIGlkIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiBJZGVudCBpZFxuICBhbmQga2V5d29yZF9vcl9lcnJvciBjID1cbiAgICBsZXQgcyA9IFN0cmluZy5tYWtlIDEgYyBpblxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIHMgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgKFwiSWxsZWdhbCBjaGFyYWN0ZXIgXCIgXiBzKSlcbiAgaW5cbiAgbGV0IHJlYyBuZXh0X3Rva2VuIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcgJyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDA5JyB8ICdcXDAyNicgfCAnXFwwMTInKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IG5leHRfdG9rZW4gc3RybV9fXG4gICAgfCBTb21lICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ18nIHwgJ1xcMTkyJy4uJ1xcMjU1JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHwgJz4nIHxcbiAgICAgICAgICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnXFwnJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgY2hhciBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgJ1xcJycgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChDaGFyIGMpXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSAnXFxcIicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IFNvbWUgKFN0cmluZyAoc3RyaW5nIHMpKVxuICAgIHwgU29tZSAnLScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBuZWdfbnVtYmVyIHN0cm1fX1xuICAgIHwgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoa2V5d29yZF9vcl9lcnJvciBjKVxuICAgIHwgXyAtPiBOb25lXG4gIGFuZCBpZGVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ1xcMTkyJy4uJ1xcMjU1JyB8ICcwJy4uJzknIHwgJ18nIHwgJ1xcJycgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgaWRlbnQyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICctJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8XG4gICAgICAgICAnPicgfCAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIG5lZ19udW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IF8gLT4gbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IGlkZW50MiBzXG4gIGFuZCBudW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnLicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnLic7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoSW50IChpbnRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBkZWNpbWFsX3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGV4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJysnIHwgJy0nIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBlbmRfZXhwb25lbnRfcGFydCBzdHJtX19cbiAgYW5kIGVuZF9leHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBzdHJpbmcgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcIicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBnZXRfc3RyaW5nICgpXG4gICAgfCBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgY2hhciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgZXNjYXBlIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ24nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcbidcbiAgICB8IFNvbWUgJ3InIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xccidcbiAgICB8IFNvbWUgJ3QnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcdCdcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMxKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzIpIC0+XG4gICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMykgLT5cbiAgICAgICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICAgICAgQ2hhci5jaHJcbiAgICAgICAgICAgICAgICAgICgoQ2hhci5jb2RlIGMxIC0gNDgpICogMTAwICsgKENoYXIuY29kZSBjMiAtIDQ4KSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgIChDaGFyLmNvZGUgYzMgLSA0OCkpXG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgbmV4dF90b2tlbiBzXG4gICAgfCBfIC0+IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgJygnKVxuICBhbmQgY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX25lc3RlZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9uZXN0ZWRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgY29tbWVudCBzXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfZW5kX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAoKVxuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGluXG4gIGZ1biBpbnB1dCAtPiBTdHJlYW0uZnJvbSAoZnVuIF9jb3VudCAtPiBuZXh0X3Rva2VuIGlucHV0KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TZWVkZWRTXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgR2VuSGFzaFRhYmxlID0gc3RydWN0XG5cbiAgdHlwZSBlcXVhbCA9XG4gIHwgRVRydWUgfCBFRmFsc2VcbiAgfCBFRGVhZCAoKiogdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHJlY2xhaW1lZCB0aGUgZGF0YSAqKVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkKEg6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgJ2EgY29udGFpbmVyXG4gICAgdmFsIGNyZWF0ZTogdCAtPiAnYSAtPiAnYSBjb250YWluZXJcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAnYSBjb250YWluZXIgLT4gdCAtPiBlcXVhbFxuICAgIHZhbCBnZXRfZGF0YTogJ2EgY29udGFpbmVyIC0+ICdhIG9wdGlvblxuICAgIHZhbCBnZXRfa2V5OiAnYSBjb250YWluZXIgLT4gdCBvcHRpb25cbiAgICB2YWwgc2V0X2tleV9kYXRhOiAnYSBjb250YWluZXIgLT4gdCAtPiAnYSAtPiB1bml0XG4gICAgdmFsIGNoZWNrX2tleTogJ2EgY29udGFpbmVyIC0+IGJvb2xcbiAgZW5kKSA6IFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudFxuICA9IHN0cnVjdFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICAgICAgbXV0YWJsZSBkYXRhOiAnYSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICAgICAgbXV0YWJsZSBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICAgICAgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gICAgICB9XG5cbiAgICBhbmQgJ2EgYnVja2V0bGlzdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgQ29ucyBvZiBpbnQgKCogaGFzaCBvZiB0aGUga2V5ICopICogJ2EgSC5jb250YWluZXIgKiAnYSBidWNrZXRsaXN0XG5cbiAgICAoKiogdGhlIGhhc2ggb2YgdGhlIGtleSBpcyBrZXB0IGluIG9yZGVyIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHRoZSBoYXNoXG4gICAgICBiZWZvcmUgdGhlIGtleS4gU2FtZSByZWFzb24gYXMgZm9yIFdlYWsuTWFrZSAqKVxuXG4gICAgdHlwZSBrZXkgPSBILnRcblxuICAgIGxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICAgICAgaWYgeCA+PSBuIHRoZW4geFxuICAgICAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICAgICAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG4gICAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuICAgIGxldCBjcmVhdGUgPyhyYW5kb20gPSAoSGFzaHRibC5pc19yYW5kb21pemVkICgpKSkgaW5pdGlhbF9zaXplID1cbiAgICAgIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgICAgIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gICAgICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbiAgICBsZXQgY2xlYXIgaCA9XG4gICAgICBoLnNpemUgPC0gMDtcbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICBkb25lXG5cbiAgICBsZXQgcmVzZXQgaCA9XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgaWYgbGVuID0gaC5pbml0aWFsX3NpemUgdGhlblxuICAgICAgICBjbGVhciBoXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSBoLmluaXRpYWxfc2l6ZSBFbXB0eVxuICAgICAgZW5kXG5cbiAgICBsZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5LmNvcHkgaC5kYXRhIH1cblxuICAgIGxldCBrZXlfaW5kZXggaCBoa2V5ID1cbiAgICAgIGhrZXkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgY2xlYW4gaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIG5vdCAoSC5jaGVja19rZXkgYykgLT5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgfCBDb25zKGhrZXksIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBDb25zKGhrZXksIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgKCoqIHJlc2l6ZSBpcyB0aGUgb25seSBmdW5jdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNsZWFuaW5nIG9mIGRlYWQga2V5c1xuICAgICAgICAocmVtb3ZlIGRvZXMgaXQganVzdCBiZWNhdXNlIGl0IGNvdWxkKS5cblxuICAgICAgICBUaGUgZ29hbCBpcyB0bzpcblxuICAgICAgICAtIG5vdCByZXNpemUgaW5maW5pdGVseSB3aGVuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGFsaXZlIGtleXMgaXNcbiAgICAgICAgYm91bmRlZCBidXQga2V5cyBhcmUgY29udGludW91c2x5IGFkZGVkLiBUaGF0IHdvdWxkIGhhcHBlbiBpZlxuICAgICAgICB0aGlzIGZ1bmN0aW9uIGFsd2F5cyByZXNpemUuXG4gICAgICAgIC0gbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBlYWNoIGFkZGl0aW9uLCB0aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGlzXG4gICAgICAgIGZ1bmN0aW9uIGRvbid0IHJlc2l6ZSBldmVuIHdoZW4gb25seSBvbmUga2V5IGlzIGRlYWQuXG5cbiAgICAgICAgU28gdGhlIGFsZ29yaXRobTpcbiAgICAgICAgLSBjbGVhbiB0aGUga2V5cyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgLSBpZiB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIGlzIGxlc3MgdGhhbiBoYWxmIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICBhcnJheSwgZG9uJ3QgcmVzaXplLlxuICAgICAgICAtIGlmIGl0IGlzIG1vcmUsIHJlc2l6ZS5cblxuICAgICAgICBUaGUgc2Vjb25kIHByb2JsZW0gcmVtYWlucyBpZiB0aGUgdGFibGUgcmVhY2hlcyB7IVN5cy5tYXhfYXJyYXlfbGVuZ3RofS5cblxuICAgICopXG4gICAgbGV0IHJlc2l6ZSBoID1cbiAgICAgIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICAgICAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gICAgICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgICAgIGNsZWFuIGg7XG4gICAgICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoICYmIGguc2l6ZSA+PSBvc2l6ZSBsc3IgMSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICAgICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAoKiBzbyB0aGF0IGtleV9pbmRleCBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgICAgIHwgQ29ucyhoa2V5LCBkYXRhLCByZXN0KSAtPlxuICAgICAgICAgICAgICBpbnNlcnRfYnVja2V0IHJlc3Q7ICgqIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIG9mIGVsZW1lbnRzICopXG4gICAgICAgICAgICAgIGxldCBuaWR4ID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgICAgICAgICBuZGF0YS4obmlkeCkgPC0gQ29ucyhoa2V5LCBkYXRhLCBuZGF0YS4obmlkeCkpIGluXG4gICAgICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgICAgICBkb25lXG4gICAgICBlbmRcblxuICAgIGxldCBhZGQgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnMoaGtleSwgY29udGFpbmVyLCBoLmRhdGEuKGkpKSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBoLnNpemUgPC0gaC5zaXplIC0gMTsgbmV4dFxuICAgICAgICAgICAgfCBFRmFsc2UgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KVxuICAgICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICAgICgqIFRoZSBkZWFkIGtleSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuIEl0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgYWxyZWFkeSByZW1vdmVzIGEgYmluZGluZyAqKVxuICAgICAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgIHJlbW92ZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhoayxjLG5leHQpIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dCkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgaC5kYXRhLihpKSA8LSByZW1vdmVfYnVja2V0IGguZGF0YS4oaSlcblxuICAgICgqKiB7IWZpbmR9IGRvbid0IHJlbW92ZSBkZWFkIGtleXMgYmVjYXVzZSBpdCB3b3VsZCBiZSBzdXJwcmlzaW5nIGZvclxuICAgICAgICB0aGUgdXNlciB0aGF0IGEgcmVhZC1vbmx5IGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHN0YXRlIChlZy4gY29uY3VycmVudFxuICAgICAgICBhY2Nlc3MpLiBTYW1lIGZvciB7IWl0ZXJ9LCB7IWZvbGR9LCB7IW1lbX0uXG4gICAgKilcbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlYyBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gW11cbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZDo6ZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gSC5zZXRfa2V5X2RhdGEgYyBrZXkgaW5mb1xuICAgICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKF8sXyxuZXh0KSAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIHRyeVxuICAgICAgICByZXBsYWNlX2J1Y2tldCBsXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25zKGhrZXksIGNvbnRhaW5lciwgbCk7XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrID0gaGtleSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gdHJ1ZVxuICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gbWVtX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoX2hrLCBfYywgcmVzdCkgLT4gbWVtX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuICAgIGxldCBpdGVyIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgICgpXG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+ICgpXG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkXG4gICAgICAgICAgICBlbmQ7IGRvX2J1Y2tldCByZXN0IGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBmb2xkIGYgaCBpbml0ID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgICAgIG1hdGNoIGIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgICBhY2N1XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbGV0IGFjY3UgPSBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGQgYWNjdVxuICAgICAgICAgICAgZW5kIGluXG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdCBhY2N1ICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICAgIGRvbmU7XG4gICAgICAhYWNjdVxuXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT5cbiAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIGYgayBkIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgICB8IFNvbWUgbmV3X2QgLT5cbiAgICAgICAgICAgICAgICAgICAgSC5zZXRfa2V5X2RhdGEgYyBrIG5ld19kO1xuICAgICAgICAgICAgICAgICAgICBDb25zKGhrLCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIHJlc3RcblxuICAgIGxldCBzdGF0cyBoID1cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiIGluXG4gICAgICAgICAgIHNpemUgOj0gIXNpemUgKyBsO1xuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9ICFzaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHRvX3NlcSB0YmwgPVxuICAgICAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAgICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gICAgICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAgICAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgICAgIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgICAgIHwgQ29ucyAoXywgYywgbmV4dCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGF1eCBpIG5leHQgKClcbiAgICAgICAgICAgICAgfCBTb21lIGtleSwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBhdXggMCBFbXB0eVxuXG4gICAgbGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgT2JqRXBoID0gT2JqLkVwaGVtZXJvblxuXG5sZXQgX29ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT5cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB4XG4gIHwgU29tZSB2IC0+IFNvbWUgKE9iai5vYmogdilcblxuKCoqIFRoZSBwcmV2aW91cyBmdW5jdGlvbiBpcyB0eXBlZCBzbyB0aGlzIG9uZSBpcyBhbHNvIGNvcnJlY3QgKilcbmxldCBvYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+IE9iai5tYWdpYyB4XG5cblxubW9kdWxlIEsxID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAxXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKGs6J2spIDogdW5pdCA9IE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAodDI6KCdrLCdkKSB0KTogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCA9IEguaGFzaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgICgqIHshZ2V0X2tleV9jb3B5fSBpcyBub3QgdXNlZCBiZWNhdXNlIHRoZSBlcXVhbGl0eSBvZiB0aGUgdXNlciBjYW4gYmVcbiAgICAgICAgICAgIHRoZSBwaHlzaWNhbCBlcXVhbGl0eSAqKVxuICAgICAgICBtYXRjaCBnZXRfa2V5IGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrJyAtPlxuICAgICAgICAgICAgaWYgSC5lcXVhbCBrIGsnIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5ID0gZ2V0X2tleVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSA9IGNoZWNrX2tleVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLMiA9IHN0cnVjdFxuICB0eXBlICgnazEsICdrMiwgJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2sxLCdrMiwnZCkgdCA9IE9iakVwaC5jcmVhdGUgMlxuXG4gIGxldCBnZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleTFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSAoazonazEpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDEpXG4gIGxldCBnZXRfa2V5Ml9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAxKVxuICBsZXQgc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMikgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDEgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMVxuICBsZXQgY2hlY2tfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDFcblxuXG4gIGxldCBibGl0X2tleTEgKHQxOignazEsXyxfKSB0KSAodDI6KCdrMSxfLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG4gIGxldCBibGl0X2tleTIgKHQxOihfLCdrMixfKSB0KSAodDI6KF8sJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDEgdDIgMSAxXG4gIGxldCBibGl0X2tleTEyICh0MTooJ2sxLCdrMixfKSB0KSAodDI6KCdrMSwnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDJcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSAoZDonZCkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sXywnZCkgdCkgKHQyOihfLF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZFxuICAgICAgKEgxOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSlcbiAgICAgIChIMjpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgxLnQsSDIudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSDEudCAqIEgyLnRcbiAgICAgIGxldCBjcmVhdGUgKGsxLGsyKSBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIChrMSxrMikgPVxuICAgICAgICBIMS5oYXNoIHNlZWQgazEgKyBIMi5oYXNoIHNlZWQgazIgKiA2NTU5OVxuICAgICAgbGV0IGVxdWFsIGMgKGsxLGsyKSA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT5cbiAgICAgICAgICAgIGlmIEgxLmVxdWFsIGsxIGsxJyAmJiBIMi5lcXVhbCBrMiBrMidcbiAgICAgICAgICAgIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPiBTb21lIChrMScsIGsyJylcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyAoazEsazIpIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID0gY2hlY2tfa2V5MSBjICYmIGNoZWNrX2tleTIgY1xuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIMTogSGFzaHRibC5IYXNoZWRUeXBlKShIMjogSGFzaHRibC5IYXNoZWRUeXBlKTpcbiAgICAoUyB3aXRoIHR5cGUga2V5ID0gSDEudCAqIEgyLnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMS50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDEuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgxLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMi50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDIuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgyLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEtuID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlIG4gOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIG5cbiAgbGV0IGxlbmd0aCAoazooJ2ssJ2QpIHQpIDogaW50ID0gT2JqRXBoLmxlbmd0aCBrXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCBuKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IG4pXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSAoazonaykgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IG4gKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCBuXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCBuXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpIChvMTppbnQpICh0MjooJ2ssJ2QpIHQpIChvMjppbnQpIChsOmludCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgbzEgdDIgbzIgbFxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnQgYXJyYXlcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKEFycmF5Lmxlbmd0aCBrKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCBrID1cbiAgICAgICAgbGV0IGggPSByZWYgMCBpblxuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgaCA6PSBILmhhc2ggc2VlZCBrLihpKSAqIDY1NTk5ICsgIWg7XG4gICAgICAgIGRvbmU7XG4gICAgICAgICFoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgbGV0IGxlbiAgPSBBcnJheS5sZW5ndGggayBpblxuICAgICAgICBsZXQgbGVuJyA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiAhPSBsZW4nIHRoZW4gR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHJlYyBlcXVhbF9hcnJheSBrIGMgaSA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGsuKGkpIGtpXG4gICAgICAgICAgICAgICAgICB0aGVuIGVxdWFsX2FycmF5IGsgYyAoaS0xKVxuICAgICAgICAgICAgICAgICAgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICBlcXVhbF9hcnJheSBrIGMgKGxlbi0xKVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBsZXQgbGVuID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuID0gMCB0aGVuIFNvbWUgW3x8XVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIDAgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIGswIC0+XG4gICAgICAgICAgICAgIGxldCByZWMgZmlsbCBhIGkgPVxuICAgICAgICAgICAgICAgIGlmIGkgPCAxIHRoZW4gU29tZSBhXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgICAgIGEuKGkpIDwtIGtpO1xuICAgICAgICAgICAgICAgICAgICAgIGZpbGwgYSAoaS0xKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYSA9IEFycmF5Lm1ha2UgbGVuIGswIGluXG4gICAgICAgICAgICAgIGZpbGwgYSAobGVuLTEpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID1cbiAgICAgICAgbGV0IHJlYyBjaGVjayBjIGkgPVxuICAgICAgICAgIGkgPCAwIHx8IChjaGVja19rZXkgYyBpICYmIGNoZWNrIGMgKGktMSkpIGluXG4gICAgICAgIGNoZWNrIGMgKGxlbmd0aCBjIC0gMSlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCBhcnJheSkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYXJrIFNoaW53ZWxsIGFuZCBMZW8gV2hpdGUsIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTUtLTIwMTYgSmFuZSBTdHJlZXQgR3JvdXAgTExDICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgc3BhY2V0aW1lX2VuYWJsZWQgOiB1bml0IC0+IGJvb2xcbiAgPSBcImNhbWxfc3BhY2V0aW1lX2VuYWJsZWRcIiBbQEBub2FsbG9jXVxuXG5sZXQgZW5hYmxlZCA9IHNwYWNldGltZV9lbmFibGVkICgpXG5cbmxldCBpZl9zcGFjZXRpbWVfZW5hYmxlZCBmID1cbiAgaWYgZW5hYmxlZCB0aGVuIGYgKCkgZWxzZSAoKVxuXG5tb2R1bGUgU2VyaWVzID0gc3RydWN0XG4gIHR5cGUgdCA9IHtcbiAgICBjaGFubmVsIDogb3V0X2NoYW5uZWw7XG4gICAgbXV0YWJsZSBjbG9zZWQgOiBib29sO1xuICB9XG5cbiAgZXh0ZXJuYWwgd3JpdGVfbWFnaWNfbnVtYmVyIDogb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3dyaXRlX21hZ2ljX251bWJlclwiXG5cbiAgZXh0ZXJuYWwgcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIDogb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZVwiXG5cbiAgbGV0IGNyZWF0ZSB+cGF0aCA9XG4gICAgaWYgc3BhY2V0aW1lX2VuYWJsZWQgKCkgdGhlbiBiZWdpblxuICAgICAgbGV0IGNoYW5uZWwgPSBvcGVuX291dCBwYXRoIGluXG4gICAgICByZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY2hhbm5lbDtcbiAgICAgIGxldCB0ID1cbiAgICAgICAgeyBjaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgICBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgaW5cbiAgICAgIHdyaXRlX21hZ2ljX251bWJlciB0LmNoYW5uZWw7XG4gICAgICB0XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHsgY2hhbm5lbCA9IHN0ZG91dDsgICgqIGFyYml0cmFyeSB2YWx1ZSAqKVxuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gIGV4dGVybmFsIHNhdmVfZXZlbnQgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiBldmVudF9uYW1lOnN0cmluZyAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfc2F2ZV9ldmVudFwiXG5cbiAgbGV0IHNhdmVfZXZlbnQgP3RpbWUgdCB+ZXZlbnRfbmFtZSA9XG4gICAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgICAgc2F2ZV9ldmVudCA/dGltZSB0LmNoYW5uZWwgfmV2ZW50X25hbWUpXG5cbiAgZXh0ZXJuYWwgc2F2ZV90cmllIDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfdHJpZVwiXG5cbiAgbGV0IHNhdmVfYW5kX2Nsb3NlID90aW1lIHQgPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIGlmIHQuY2xvc2VkIHRoZW4gZmFpbHdpdGggXCJTZXJpZXMgaXMgY2xvc2VkXCI7XG4gICAgICBzYXZlX3RyaWUgP3RpbWUgdC5jaGFubmVsO1xuICAgICAgY2xvc2Vfb3V0IHQuY2hhbm5lbDtcbiAgICAgIHQuY2xvc2VkIDwtIHRydWUpXG5lbmRcblxubW9kdWxlIFNuYXBzaG90ID0gc3RydWN0XG4gIGV4dGVybmFsIHRha2UgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfdGFrZV9zbmFwc2hvdFwiXG5cbiAgbGV0IHRha2UgP3RpbWUgeyBTZXJpZXMuY2xvc2VkOyBjaGFubmVsIH0gPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIGlmIGNsb3NlZCB0aGVuIGZhaWx3aXRoIFwiU2VyaWVzIGlzIGNsb3NlZFwiO1xuICAgICAgR2MubWlub3IgKCk7XG4gICAgICB0YWtlID90aW1lIGNoYW5uZWwpXG5lbmRcblxuZXh0ZXJuYWwgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyA6IGV2ZW50X25hbWU6c3RyaW5nIC0+IHVuaXRcbiAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHNcIlxuXG5sZXQgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyB+ZXZlbnRfbmFtZSA9XG4gIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICBzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIH5ldmVudF9uYW1lKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIE1hbnVlbCBTZXJyYW5vIGV0IFhhdmllciBMZXJveSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0JpZ2FycmF5XTogbGFyZ2UsIG11bHRpLWRpbWVuc2lvbmFsLCBudW1lcmljYWwgYXJyYXlzICopXG5cbigqIFRoZXNlIHR5cGVzIGluIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHRhYmxlcyBpblxuICAgLi4vdHlwaW5nL3R5cGVvcHQubWwgKilcblxudHlwZSBmbG9hdDMyX2VsdCA9IEZsb2F0MzJfZWx0XG50eXBlIGZsb2F0NjRfZWx0ID0gRmxvYXQ2NF9lbHRcbnR5cGUgaW50OF9zaWduZWRfZWx0ID0gSW50OF9zaWduZWRfZWx0XG50eXBlIGludDhfdW5zaWduZWRfZWx0ID0gSW50OF91bnNpZ25lZF9lbHRcbnR5cGUgaW50MTZfc2lnbmVkX2VsdCA9IEludDE2X3NpZ25lZF9lbHRcbnR5cGUgaW50MTZfdW5zaWduZWRfZWx0ID0gSW50MTZfdW5zaWduZWRfZWx0XG50eXBlIGludDMyX2VsdCA9IEludDMyX2VsdFxudHlwZSBpbnQ2NF9lbHQgPSBJbnQ2NF9lbHRcbnR5cGUgaW50X2VsdCA9IEludF9lbHRcbnR5cGUgbmF0aXZlaW50X2VsdCA9IE5hdGl2ZWludF9lbHRcbnR5cGUgY29tcGxleDMyX2VsdCA9IENvbXBsZXgzMl9lbHRcbnR5cGUgY29tcGxleDY0X2VsdCA9IENvbXBsZXg2NF9lbHRcblxudHlwZSAoJ2EsICdiKSBraW5kID1cbiAgICBGbG9hdDMyIDogKGZsb2F0LCBmbG9hdDMyX2VsdCkga2luZFxuICB8IEZsb2F0NjQgOiAoZmxvYXQsIGZsb2F0NjRfZWx0KSBraW5kXG4gIHwgSW50OF9zaWduZWQgOiAoaW50LCBpbnQ4X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3Vuc2lnbmVkIDogKGludCwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl9zaWduZWQgOiAoaW50LCBpbnQxNl9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfdW5zaWduZWQgOiAoaW50LCBpbnQxNl91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQzMiA6IChpbnQzMiwgaW50MzJfZWx0KSBraW5kXG4gIHwgSW50NjQgOiAoaW50NjQsIGludDY0X2VsdCkga2luZFxuICB8IEludCA6IChpbnQsIGludF9lbHQpIGtpbmRcbiAgfCBOYXRpdmVpbnQgOiAobmF0aXZlaW50LCBuYXRpdmVpbnRfZWx0KSBraW5kXG4gIHwgQ29tcGxleDMyIDogKENvbXBsZXgudCwgY29tcGxleDMyX2VsdCkga2luZFxuICB8IENvbXBsZXg2NCA6IChDb21wbGV4LnQsIGNvbXBsZXg2NF9lbHQpIGtpbmRcbiAgfCBDaGFyIDogKGNoYXIsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG5cbnR5cGUgY19sYXlvdXQgPSBDX2xheW91dF90eXBcbnR5cGUgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dF90eXAgKCoqKVxuXG50eXBlICdhIGxheW91dCA9XG4gICAgQ19sYXlvdXQ6IGNfbGF5b3V0IGxheW91dFxuICB8IEZvcnRyYW5fbGF5b3V0OiBmb3J0cmFuX2xheW91dCBsYXlvdXRcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2tpbmQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGZsb2F0MzIgPSBGbG9hdDMyXG5sZXQgZmxvYXQ2NCA9IEZsb2F0NjRcbmxldCBpbnQ4X3NpZ25lZCA9IEludDhfc2lnbmVkXG5sZXQgaW50OF91bnNpZ25lZCA9IEludDhfdW5zaWduZWRcbmxldCBpbnQxNl9zaWduZWQgPSBJbnQxNl9zaWduZWRcbmxldCBpbnQxNl91bnNpZ25lZCA9IEludDE2X3Vuc2lnbmVkXG5sZXQgaW50MzIgPSBJbnQzMlxubGV0IGludDY0ID0gSW50NjRcbmxldCBpbnQgPSBJbnRcbmxldCBuYXRpdmVpbnQgPSBOYXRpdmVpbnRcbmxldCBjb21wbGV4MzIgPSBDb21wbGV4MzJcbmxldCBjb21wbGV4NjQgPSBDb21wbGV4NjRcbmxldCBjaGFyID0gQ2hhclxuXG5sZXQga2luZF9zaXplX2luX2J5dGVzIDogdHlwZSBhIGIuIChhLCBiKSBraW5kIC0+IGludCA9IGZ1bmN0aW9uXG4gIHwgRmxvYXQzMiAtPiA0XG4gIHwgRmxvYXQ2NCAtPiA4XG4gIHwgSW50OF9zaWduZWQgLT4gMVxuICB8IEludDhfdW5zaWduZWQgLT4gMVxuICB8IEludDE2X3NpZ25lZCAtPiAyXG4gIHwgSW50MTZfdW5zaWduZWQgLT4gMlxuICB8IEludDMyIC0+IDRcbiAgfCBJbnQ2NCAtPiA4XG4gIHwgSW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgTmF0aXZlaW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgQ29tcGxleDMyIC0+IDhcbiAgfCBDb21wbGV4NjQgLT4gMTZcbiAgfCBDaGFyIC0+IDFcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2xheW91dCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgY19sYXlvdXQgPSBDX2xheW91dFxubGV0IGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRcblxubW9kdWxlIEdlbmFycmF5ID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcbiAgZXh0ZXJuYWwgY3JlYXRlOiAoJ2EsICdiKSBraW5kIC0+ICdjIGxheW91dCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgPSBcImNhbWxfYmFfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2FcbiAgICAgPSBcImNhbWxfYmFfZ2V0X2dlbmVyaWNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYSAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX3NldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgbnVtX2RpbXM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiY2FtbF9iYV9udW1fZGltc1wiXG4gIGV4dGVybmFsIG50aF9kaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfYmFfZGltXCJcbiAgbGV0IGRpbXMgYSA9XG4gICAgbGV0IG4gPSBudW1fZGltcyBhIGluXG4gICAgbGV0IGQgPSBBcnJheS5tYWtlIG4gMCBpblxuICAgIGZvciBpID0gMCB0byBuLTEgZG8gZC4oaSkgPC0gbnRoX2RpbSBhIGkgZG9uZTtcbiAgICBkXG5cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChBcnJheS5mb2xkX2xlZnQgKCAqICkgMSAoZGltcyBhcnIpKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzbGljZV9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBzbGljZV9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbmVuZFxuXG5tb2R1bGUgQXJyYXkwID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0ID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3x8XVxuICBsZXQgZ2V0IGFyciA9IEdlbmFycmF5LmdldCBhcnIgW3x8XVxuICBsZXQgc2V0IGFyciA9IEdlbmFycmF5LnNldCBhcnIgW3x8XVxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9IGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpXG5cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcblxuICBsZXQgb2ZfdmFsdWUga2luZCBsYXlvdXQgdiA9XG4gICAgbGV0IGEgPSBjcmVhdGUga2luZCBsYXlvdXQgaW5cbiAgICBzZXQgYSB2O1xuICAgIGFcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8xXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzFcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzFcIlxuICBleHRlcm5hbCBkaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0gYXJyKVxuXG4gIGV4dGVybmFsIHN1YjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCAnYykgdCA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2UgKHR5cGUgdCkgKGEgOiAoXywgXywgdCkgR2VuYXJyYXkudCkgbiA9XG4gICAgbWF0Y2ggbGF5b3V0IGEgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XSA6IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF06IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IChBcnJheS5sZW5ndGggZGF0YSkgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkYXRhIC0gMSBkbyB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSBkYXRhLihpKSBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTJ8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8yXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzJcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdCBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0IGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkyLm9mX2FycmF5OiBub24tcmVjdGFuZ3VsYXIgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgcm93LihqKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkzID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yOyBkaW0zfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3NldF8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfM1wiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwgZGltMzogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fM1wiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycikgKiAoZGltMyBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9sZWZ0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBkaW0zID0gaWYgZGltMiA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIGxldCBjb2wgPSByb3cuKGopIGluXG4gICAgICAgIGlmIEFycmF5Lmxlbmd0aCBjb2wgPD4gZGltMyB0aGVuXG4gICAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgICBmb3IgayA9IDAgdG8gZGltMyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgKGsgKyBvZnMpIGNvbC4oaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTA6ICgnYSwgJ2IsICdjKSBBcnJheTAudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTE6ICgnYSwgJ2IsICdjKSBBcnJheTEudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTI6ICgnYSwgJ2IsICdjKSBBcnJheTIudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTM6ICgnYSwgJ2IsICdjKSBBcnJheTMudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5sZXQgYXJyYXkwX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMCB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MF9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkxX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMSB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MV9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkyX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMiB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5Ml9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkzX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMyB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5M19vZl9nZW5hcnJheVwiXG5cbmV4dGVybmFsIHJlc2hhcGU6XG4gICAoJ2EsICdiLCAnYykgR2VuYXJyYXkudCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCJjYW1sX2JhX3Jlc2hhcGVcIlxubGV0IHJlc2hhcGVfMCBhID0gcmVzaGFwZSBhIFt8fF1cbmxldCByZXNoYXBlXzEgYSBkaW0xID0gcmVzaGFwZSBhIFt8ZGltMXxdXG5sZXQgcmVzaGFwZV8yIGEgZGltMSBkaW0yID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yfF1cbmxldCByZXNoYXBlXzMgYSBkaW0xIGRpbTIgZGltMyA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMjtkaW0zfF1cblxuKCogRm9yY2UgY2FtbF9iYV9nZXRfezEsMiwzLE59IHRvIGJlIGxpbmtlZCBpbiwgc2luY2Ugd2UgZG9uJ3QgcmVmZXJcbiAgIHRvIHRob3NlIHByaW1pdGl2ZXMgZGlyZWN0bHkgaW4gdGhpcyBmaWxlICopXG5cbmxldCBfID1cbiAgbGV0IF8gPSBHZW5hcnJheS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTEuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkyLmdldCBpblxuICBsZXQgXyA9IEFycmF5My5nZXQgaW5cbiAgKClcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbmV4dGVybmFsIGdldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMVwiXG5leHRlcm5hbCBnZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzJcIlxuZXh0ZXJuYWwgZ2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8zXCJcbmV4dGVybmFsIHNldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMVwiXG5leHRlcm5hbCBzZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzJcIlxuZXh0ZXJuYWwgc2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8zXCJcbiIsIlxuKCogVGhpcyBnZW5lcmF0ZWQgY29kZSByZXF1aXJlcyB0aGUgZm9sbG93aW5nIHZlcnNpb24gb2YgTWVuaGlyTGliOiAqKVxuXG5sZXQgKCkgPVxuICBNZW5oaXJMaWIuU3RhdGljVmVyc2lvbi5yZXF1aXJlXzIwMTkwOTI0XG5cbm1vZHVsZSBNZW5oaXJCYXNpY3MgPSBzdHJ1Y3RcbiAgXG4gIGV4Y2VwdGlvbiBFcnJvclxuICBcbiAgdHlwZSB0b2tlbiA9IFxuICAgIHwgVkFSSUFCTEUgb2YgKFxuIyAxIFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDE2IFwibGliL3BhcnNlci5tbFwiXG4gIClcbiAgICB8IFVOU0VBTFxuICAgIHwgVU5QQUNLXG4gICAgfCBUWVBFX1ZBUklBQkxFIG9mIChcbiMgMiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMyBcImxpYi9wYXJzZXIubWxcIlxuICApXG4gICAgfCBUUlVFXG4gICAgfCBUSElOX0FSUk9XXG4gICAgfCBUSEVOXG4gICAgfCBTRUFMXG4gICAgfCBSSUdIVF9QQVJFTlxuICAgIHwgUklHSFRfQlJBQ0VcbiAgICB8IFJJR0hUX0FOR0xFXG4gICAgfCBRVUVTVElPTl9NQVJLXG4gICAgfCBQTFVTXG4gICAgfCBQRVJJT0RcbiAgICB8IFBBQ0tcbiAgICB8IE5VTUJFUiBvZiAoXG4jIDMgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgICAgKGludClcbiMgMzkgXCJsaWIvcGFyc2VyLm1sXCJcbiAgKVxuICAgIHwgTEVUXG4gICAgfCBMRUZUX1BBUkVOXG4gICAgfCBMRUZUX0JSQUNFXG4gICAgfCBMRUZUX0FOR0xFXG4gICAgfCBJTlRcbiAgICB8IElOXG4gICAgfCBJRlxuICAgIHwgRlVOXG4gICAgfCBGT1JBTExcbiAgICB8IEZBTFNFXG4gICAgfCBFWElTVFNcbiAgICB8IEVRVUlWXG4gICAgfCBFUVVBTFxuICAgIHwgRU9GXG4gICAgfCBFTFNFXG4gICAgfCBET1VCTEVfQ09MT05cbiAgICB8IENPTU1BXG4gICAgfCBDT0xPTlxuICAgIHwgQk9PTFxuICAgIHwgQklHX0xBTUJEQVxuICAgIHwgQVNURVJJU0tcbiAgXG5lbmRcblxuaW5jbHVkZSBNZW5oaXJCYXNpY3NcblxubGV0IF9lUlIgPVxuICBNZW5oaXJCYXNpY3MuRXJyb3JcblxuIyA0OCBcImxpYi9wYXJzZXIubWx5XCJcbiAgIG9wZW4gU3VyZlxuXG4gICBsZXQgY3BvcyB7IExleGluZy5wb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2w7IF8gfSA9XG4gICAgIGxldCBsaW5lID0gcG9zX2xudW0gaW5cbiAgICAgbGV0IGNvbCA9IHBvc19jbnVtIC0gcG9zX2JvbCBpblxuICAgICB7bGluZSA9IGxpbmU7IGNvbCA9IGNvbH1cblxuIyA3OCBcImxpYi9wYXJzZXIubWxcIlxuXG5tb2R1bGUgVGFibGVzID0gc3RydWN0XG4gIFxuICBpbmNsdWRlIE1lbmhpckJhc2ljc1xuICBcbiAgbGV0IHRva2VuMnRlcm1pbmFsIDogdG9rZW4gLT4gaW50ID1cbiAgICBmdW4gX3RvayAtPlxuICAgICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgICB8IEFTVEVSSVNLIC0+XG4gICAgICAgICAgMzdcbiAgICAgIHwgQklHX0xBTUJEQSAtPlxuICAgICAgICAgIDM2XG4gICAgICB8IEJPT0wgLT5cbiAgICAgICAgICAzNVxuICAgICAgfCBDT0xPTiAtPlxuICAgICAgICAgIDM0XG4gICAgICB8IENPTU1BIC0+XG4gICAgICAgICAgMzNcbiAgICAgIHwgRE9VQkxFX0NPTE9OIC0+XG4gICAgICAgICAgMzJcbiAgICAgIHwgRUxTRSAtPlxuICAgICAgICAgIDMxXG4gICAgICB8IEVPRiAtPlxuICAgICAgICAgIDMwXG4gICAgICB8IEVRVUFMIC0+XG4gICAgICAgICAgMjlcbiAgICAgIHwgRVFVSVYgLT5cbiAgICAgICAgICAyOFxuICAgICAgfCBFWElTVFMgLT5cbiAgICAgICAgICAyN1xuICAgICAgfCBGQUxTRSAtPlxuICAgICAgICAgIDI2XG4gICAgICB8IEZPUkFMTCAtPlxuICAgICAgICAgIDI1XG4gICAgICB8IEZVTiAtPlxuICAgICAgICAgIDI0XG4gICAgICB8IElGIC0+XG4gICAgICAgICAgMjNcbiAgICAgIHwgSU4gLT5cbiAgICAgICAgICAyMlxuICAgICAgfCBJTlQgLT5cbiAgICAgICAgICAyMVxuICAgICAgfCBMRUZUX0FOR0xFIC0+XG4gICAgICAgICAgMjBcbiAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgIDE5XG4gICAgICB8IExFRlRfUEFSRU4gLT5cbiAgICAgICAgICAxOFxuICAgICAgfCBMRVQgLT5cbiAgICAgICAgICAxN1xuICAgICAgfCBOVU1CRVIgXyAtPlxuICAgICAgICAgIDE2XG4gICAgICB8IFBBQ0sgLT5cbiAgICAgICAgICAxNVxuICAgICAgfCBQRVJJT0QgLT5cbiAgICAgICAgICAxNFxuICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgMTNcbiAgICAgIHwgUVVFU1RJT05fTUFSSyAtPlxuICAgICAgICAgIDEyXG4gICAgICB8IFJJR0hUX0FOR0xFIC0+XG4gICAgICAgICAgMTFcbiAgICAgIHwgUklHSFRfQlJBQ0UgLT5cbiAgICAgICAgICAxMFxuICAgICAgfCBSSUdIVF9QQVJFTiAtPlxuICAgICAgICAgIDlcbiAgICAgIHwgU0VBTCAtPlxuICAgICAgICAgIDhcbiAgICAgIHwgVEhFTiAtPlxuICAgICAgICAgIDdcbiAgICAgIHwgVEhJTl9BUlJPVyAtPlxuICAgICAgICAgIDZcbiAgICAgIHwgVFJVRSAtPlxuICAgICAgICAgIDVcbiAgICAgIHwgVFlQRV9WQVJJQUJMRSBfIC0+XG4gICAgICAgICAgNFxuICAgICAgfCBVTlBBQ0sgLT5cbiAgICAgICAgICAzXG4gICAgICB8IFVOU0VBTCAtPlxuICAgICAgICAgIDJcbiAgICAgIHwgVkFSSUFCTEUgXyAtPlxuICAgICAgICAgIDFcbiAgXG4gIGFuZCBlcnJvcl90ZXJtaW5hbCA9XG4gICAgMFxuICBcbiAgYW5kIHRva2VuMnZhbHVlIDogdG9rZW4gLT4gT2JqLnQgPVxuICAgIGZ1biBfdG9rIC0+XG4gICAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICAgIHwgQVNURVJJU0sgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBCSUdfTEFNQkRBIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgQk9PTCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IENPTE9OIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgQ09NTUEgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBET1VCTEVfQ09MT04gLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBFTFNFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgRU9GIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgRVFVQUwgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBFUVVJViAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEVYSVNUUyAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IEZBTFNFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgRk9SQUxMIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgRlVOIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgSUYgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBJTiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IElOVCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExFRlRfQU5HTEUgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgTEVGVF9QQVJFTiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IExFVCAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgIE9iai5yZXByIF92XG4gICAgICB8IFBBQ0sgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBQRVJJT0QgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgUVVFU1RJT05fTUFSSyAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFJJR0hUX0FOR0xFIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgUklHSFRfQlJBQ0UgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBSSUdIVF9QQVJFTiAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFNFQUwgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBUSEVOIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgVEhJTl9BUlJPVyAtPlxuICAgICAgICAgIE9iai5yZXByICgpXG4gICAgICB8IFRSVUUgLT5cbiAgICAgICAgICBPYmoucmVwciAoKVxuICAgICAgfCBUWVBFX1ZBUklBQkxFIF92IC0+XG4gICAgICAgICAgT2JqLnJlcHIgX3ZcbiAgICAgIHwgVU5QQUNLIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgVU5TRUFMIC0+XG4gICAgICAgICAgT2JqLnJlcHIgKClcbiAgICAgIHwgVkFSSUFCTEUgX3YgLT5cbiAgICAgICAgICBPYmoucmVwciBfdlxuICBcbiAgYW5kIGRlZmF1bHRfcmVkdWN0aW9uID1cbiAgICAoOCwgXCJcXDAwMFxcclxcMDAwXFwwMDBcXDAxNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcIiNcXDAwMCFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDAnXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDEyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxNVxcMDAwXFwwMDBcXDAwMFxcMDI3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA2XFwwMDBcXDAwMFxcMDA1XFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDI2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyOVxcMDAwXFwwMDBcXDAyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAzMFxcMDAwXFwwMTFcXDAwMFxcMDAwXFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAzMVxcMDAwXFwwMTdcXDAwMFxcMDAwXFwwMThcXDAwMVwiKVxuICBcbiAgYW5kIGVycm9yID1cbiAgICAoMzgsIFwidFxcMTI5XFwyMjVcXDE2MFxcYlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDE3XFwwMDBoXFxiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCBcXDAwMFxcMDAwXFwxMjhcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFxiXFxiJFBcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDJcXHRcXDAyMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwIFxcMDAwXFwwMDBcXDAwMlxcMDAyXFx0XFwwMjBcXDAwNFxcYlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXGJcXDAwMFxcMDAwXFwwMDBcXDEyOFxcMTMwRVxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzclxcMDAyXFwwMDNcXDE5NiAgXFwxNDVAQDcgIDxCXFwwMDJcXHRcXDAyMFxcMDA0XFwwMDNyXFwwMDJcXDAwM1xcMTk2XFxyXFwyMDBcXGJcXDAxNVxcMDE2JFxcMDAwXFwwMDBcXDAwMEBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwRVxcMjEwXFwwMDdcXDEzNFxcMTI4IFxcMDAwXFwwMDBcXDEyOFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwQVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDB0XFwxMjlcXDIyNVxcMTYwXFxiIFxcMDAwXFwwMDBcXDAwMFxcMDA0QFxcMDI2XFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDB0XFwxMjlcXDIyNVxcMTYwXFx0XFwwMDBcXDAwMFxcMTI4XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEBcXDAyOSB4aFxcMDAydFxcMTI5XFwyMjVcXDE2MFxcdFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAyXFwwMDJcXHRcXDAyMFxcMDA0XFwwMDJcXDAwMlxcMDAwXFwwMDBcXDAwNVxcMjEwXFwwMDdcXDEzNFxcMTI4IFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDFcXDIxMFxcMDA3XFwxMzRcXDEyOCBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE3VWxcXDEzNlxcMjQwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMVxcMTQ2XFwwMDZcXDEyOFxcMTI4XFwwMDBcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDE3XFwwMDBoXFxiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwIFxcMDAwXFwwMDBcXDAwMFxcMDA0QFxcMDI2XFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVQXFxiXFxyXFwwMDZIXFwwMjZcXDAwMlxcMDAwXFwwMDBVXFwwMDBcXDEyOFxcMjA4RVVcXDE3OCNAIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxMjhcXDAwMlxcMDAyXFx0XFwwMjBcXDAwNFxcMDAyIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE3XFwwMDFsXFxiXFwwMDBcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMCBcXDAwMFxcMTI4XFwxMzBFXFwwMDFcXDAwMFxcMTM2XFwwMDBcXDAwMFxcMDAxRVVcXDE3OCNBXFwwMjFWXFwyMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFxiXFwwMDJcXDAwMlxcdFxcMDIwXFwwMDRcXDAwM1BcXDAwMlxcMDAzXFwxOTZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTZcXDAwMFxcMDAwXFwwMDBcXDAyOSB4aFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMVxcMjEwXFwwMDdcXDEzNFxcMTI4IFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxMjhcXDAwMHRcXDEyOVxcMjI1XFwxNjBcXGJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE2QFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMEBcXDAyOSB4aFxcMDAyXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMVxcMjEwXFwwMDdcXDEzNFxcMTI4IFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxNlxcMDAwXFwwMDBcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDIxMFxcMDA3XFwxMzRcXDEyOCBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBFVVxcMTc4I0BcXDAwMFxcMDAwXFxiXFwwMDBcXDAwN0hcXDAzMFxcMDI2XFwwMDBcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRVW1xcXCI0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDEyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXCIpXG4gIFxuICBhbmQgc3RhcnQgPVxuICAgIDFcbiAgXG4gIGFuZCBhY3Rpb24gPVxuICAgICgoMTYsIFwiXFwwMDFaXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMEBcXDAwMFxcMDAwXFwwMDAlXFwwMDBcXDAwNlxcMDAwJ1xcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAyNFxcMDAwXFwwMThcXDAwMFxcMDAyXFwwMDBQXFwwMDBAXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwMVpcXDAwMFxcMDAyXFwwMDFcXDE1NFxcMDAwXFwwMDJcXDAwMVxcMTgyXFwwMDFcXDI0MFxcMDAwJFxcMDAwXFwwMDBcXDAwMFxcblxcMDAxWlxcMDAwUlxcMDAwflxcMDAwSFxcMDAwXFwxNDBcXDAwMHxcXDAwMF5cXDAwMVpcXDAwMFxcMTUwXFwwMDBAXFwwMDBcXDAwMFxcMDAxWlxcMDAwXFwwMDRcXDAwMGpcXDAwMVpcXDAwMVpcXDAwMFxcMTY2XFwwMDBoXFwwMDBcXDAwMlxcMDAwVlxcMDAxWlxcMDAwXFwwMDBcXDAwMFxcMTY4XFwwMDBcXDE2MFxcMDAxWlxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDE2NlxcMDAwQFxcMDAwXFwxODhcXDAwMEBcXDAwMFxcMDAwXFwwMDBcXDE5MlxcMDAwQFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDI+XFwwMDBAXFwwMDJIXFwwMDBAXFwwMDBcXDE5OFxcMDAwXFwxNTZcXDAwMFxcMDAyXFwwMDBWXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMVpcXDAwMFxcMjA2XFwwMDBcXDE2MlxcMDAwXFwwMDJcXDAwMFxcXFxcXDAwMHZcXDAwMFxcMTcyXFwwMDBcXDE1NlxcMDAwXFwwMDJcXDAwMlxcYlxcMDAwXFwwMDBcXDAwMFxcMjA4XFwwMDFaXFwwMDBcXDE2NFxcMDAxWlxcMDAwXFwwMDBcXDAwMFxcMTg2XFwwMDFaXFwwMDBcXDAwMFxcMDAwXFwyNDBcXDAwMFxcMTgwXFwwMDBcXDI0OFxcMDAwXFwyMzZcXDAwMFxcMjAyXFwwMDFaXFwwMDBcXDIyMlxcMDAxWlxcMDAwXFwwMDBcXDAwMDRcXDAwMFxcMDAwXFwwMDFaXFwwMDBcXDI1MFxcMDAwXFwwMDBcXDAwMFxcMjI2XFwwMDBcXDIyOFxcMDAxWlxcMDAwXFwwMDBcXDAwMFxcMjUyXFwwMDBcXDAwMFxcMDAxXFwwMjRcXDAwMFxcMjE2XFwwMDBcXDAwMFxcMDAwXFwwMDBcIiksICgxNiwgXCJcXDAwMFxcclxcMDAwXFwwMTRcXDAwMFxcMDI2XFwwMDBcXDE3MFxcMDAwXFxyXFwwMDAmXFwwMDBJXFwwMDBcXDAzMFxcMDAwSVxcMDAwXFxcIlxcMDAwSVxcMDAwVlxcMDAwXFxyXFwwMDAqXFwwMDBcXHJcXDAwMFxcclxcMDAwOlxcMDAwXFxyXFwwMDBcXHJcXDAwMC5cXDAwMXpcXDAwMElcXDAwMDJcXDAwMD5cXDAwMFZcXDAwMFxcclxcMDAwNlxcMDAwblxcMDAwQlxcMDAwSVxcMDAwSVxcMDAwXFwwMDVcXDAwMElcXDAwMFxcMDA2XFwwMDBcXDIzNFxcMDAxXFwxNjJcXDAwME5cXDAwMFxcMDE4XFwwMDB2XFwwMDAhXFwwMDBcXDI0NlxcMDAwIVxcMDAwXlxcMDAwIVxcMDAwRlxcMDAwIVxcMDAwSlxcMDAwXFwwMjJcXDAwMFxcMTU4XFwwMDBWXFwwMDBcXDE2MlxcMDAxXFwwMjJcXDAwMFZcXDAwMSZcXDAwMCFcXDAwMF5cXDAwMUJcXDAwMFxcMTk4XFwwMDBcXDIwMlxcMDAxXFwxNjZcXDAwMFxcMDI5XFwwMDB+XFwwMDAhXFwwMDAhXFwwMDBcXDAyOVxcMDAwIVxcMDAwXVxcMDAwXFwxMzBcXDAwMF1cXDAwMFxcMTM0XFwwMDBdXFwwMDBcXDEzOFxcMDAwXFwwMjlcXDAwMFxcMTQyXFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMTQ2XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMTU0XFwwMDBeXFwwMDBdXFwwMDBcXDE3NFxcMDAwXlxcMDAwXFwxODZcXDAwMFxcMDI5XFwwMDBcXDE5MFxcMDAwXFwwMjVcXDAwMFxcMjEwXFwwMDBdXFwwMDBdXFwwMDBcXDAyNVxcMDAwXVxcMDAwWVxcMDAwXFwyMTRcXDAwMFlcXDAwMFxcMjMwXFwwMDBZXFwwMDBcXDIzOFxcMDAwXFwwMjVcXDAwMFxcMjUwXFwwMDBcXDAyNVxcMDAwXFwwMjVcXDAwMVxcMDI2XFwwMDBcXDAyNVxcMDAwXFwwMjVcXDAwMVxcMDMwXFwwMDE2XFwwMDBZXFwwMDE6XFwwMDFOXFwwMDFeXFwwMDBcXDAyNVxcMDAxZlxcMDAwXFwwMTdcXDAwMXJcXDAwMFlcXDAwMFlcXDAwMFxcMDE3XFwwMDBZXFwwMDBRXFwwMDF+XFwwMDBRXFwwMDFcXDEzMFxcMDAwUVxcMDAxXFwxMzRcXDAwMFxcMDE3XFwwMDFcXDEzOFxcMDAwXFwwMTdcXDAwMFxcMDE3XFwwMDFcXDE0MlxcMDAwXFwwMTdcXDAwMFxcMDE3XFwwMDFcXDE1MFxcMDAxXFwxNzRcXDAwMFFcXDAwMVxcMTg2XFwwMDFcXDE5OFxcMDAxXFwyMTFcXDAwMFxcMDE3XFwwMDBcXDAwMFxcMDAwXFwwMjFcXDAwMFxcMDAwXFwwMDBRXFwwMDBRXFwwMDBcXDAyMVxcMDAwUVxcMDAwVVxcMDAwXFwwMDBcXDAwMFVcXDAwMFxcMDAwXFwwMDBVXFwwMDBcXDAwMFxcMDAwXFwwMjFcXDAwMFxcMDAwXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDAwXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwVVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFVcXDAwMFVcXDAwMFxcMDAwXFwwMDBVXFwwMDBcXDAwNlxcMDAwXFxuXFwwMDB6XFwwMDBcXDAwMFxcMDAwXFwwMThcXDAwMFZcXDAwMFxcMTQ5XFwwMDBcXDE1MFxcMDAwXFwxNDlcXDAwMFxcMTQ5XFwwMDBcXDE0OVxcMDAwXFwwMDBcXDAwMCFcXDAwMFxcMTQ5XFwwMDBcXDAyMlxcMDAwXFwxNThcXDAwMFxcMTY2XFwwMDBcXDE2MlxcMDAxMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0OVxcMDAwXFwxNzhcXDAwMFxcMTgyXFwwMDBcXDAwMFxcMDAwXFwyMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTQ5XFwwMDBcXDE0OVxcMDAwXFwxNDlcXDAwMFxcMTQ5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjA2XFwwMDBeXFwwMDBWXFwwMDBcXDE0NVxcMDAwXFwwMDBcXDAwMFxcMTQ1XFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDE0NVxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFxcMTQ1XFwwMDBcXDE0NVxcMDAwXFwxNDVcXDAwMFxcMTQ1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTQxXFwwMDBeXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE0MVxcMDAwXFwxNDFcXDAwMFxcMTQxXFwwMDBcXDE0MVxcMDAwXFwwMDBcXDAwMFZcXDAwMFxcMTU3XFwwMDBeXFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTU3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBWXFwwMDBNXFwwMDBcXDAwMFxcMDAwTVxcMDAwXFwxNTdcXDAwME1cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTU3XFwwMDBcXDE1N1xcMDAwXFwxNTdcXDAwMFxcMTU3XFwwMDBNXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMF5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBNXFwwMDBNXFwwMDBcXHRcXDAwME1cXDAwMGFcXDAwMFxcMDAwXFwwMDBhXFwwMDBeXFwwMDBhXFwwMDAlXFwwMDFcXG5cXDAwMCVcXDAwMFxcMDAwXFwwMDAlXFwwMDBcXDAwMFxcMDAxXFxuXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBhXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwJVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBhXFwwMDBhXFwwMDBcXDAwMFxcMDAwYVxcMDAwXFwwMDBcXDAwMCVcXDAwMCVcXDAwMFxcMDAwXFwwMDAlXCIpKVxuICBcbiAgYW5kIGxocyA9XG4gICAgKDQsIFwiXFwwMDd2ZmZVREREQ1xcXCJcXFwiXFxcIlxcXCJcXFwiXFxcIiFcXDAxN1xcMDE3XFwwMTdcXDAxN1wiKVxuICBcbiAgYW5kIGdvdG8gPVxuICAgICgoOCwgXCJcXDAwNVxcMDAwXFwwMDBcXDAwNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjRcXDAwMFxcMDAwJFxcMDAwXFwwMDBcXDAwMDBcXDAwMFxcMDAwPFxcMDAwXFwwMDBIXFwwMDBUXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcYlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDIwXFwwMDBaXFwwMDAgXFwwMDBcXDAwMCw4XFwwMDBcXDAwMGxcXDAwMERcXDAwMFxcMDAwXFwwMDBQXFwwMDBcXDAwMFxcMDAwXFwxNzJcXDAwMHJcXDAwMFxcMDAwflxcMDAwXFwwMDBcXDAwMFxcMTc4XFwwMDBcXDEzOFxcMDAwXFwwMDBcXDE1NlxcMDAwXFwwMDBcXDAwMFxcMTYyXFwwMDBcXDAwMFxcMTkwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE5MlxcMDAwXFwwMDBcXDAwMFxcXFxcXDAwMGhcXDAwMFxcMDAwdFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMTI4XFwwMDBcXDE0MFxcMDAwXFwwMDBcXDAwMFxcMTUyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDE2NFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXCIpLCAoOCwgXCJ0djg5TFNxczg5TFNuXFwwMjk4OUxTaFxcMDI3ODlMU1xcXFxcXDAyNjg5TFNXXFwwMjE4OUxTVlxcMDIzODlMUzdcXDAyNTg5TFNZbTg5TFNbMTg5TFNePTg5TFNlQDg5TFNnSzg5TFNrSTg5TFNwUjg5TFNBQkVBREVQVVwiKSlcbiAgXG4gIGFuZCBzZW1hbnRpY19hY3Rpb24gPVxuICAgIFt8XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0IDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBcbiMgNzkgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCB0IClcbiMgMjc5IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdHk7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190eV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHR5IDogKEd0eXBlcy5ndHlwZSkgPSBPYmoubWFnaWMgdHkgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgdCA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdHlfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgXG4jIDgyIFwibGliL3BhcnNlci5tbHlcIlxuICAgICggKGNwb3MgX3N0YXJ0cG9zLCBTdXJmLkFubiAodHksIHQpKSApXG4jIDMxOSBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0IDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBcbiMgODYgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCB0IClcbiMgMzQ0IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5WDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHlYXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190eVhfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHQgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgdHlYIDogKFxuIyAyIFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDM3OCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHR5WCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3RfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyA4OSBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIChjcG9zIF9zdGFydHBvcywgU3VyZi5TZWFsaW5qICh0eVgsIHQpKSApXG4jIDM4OCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eVg7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5WF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlYXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0IDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IHR5WCA6IChcbiMgMiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA0MjIgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0eVggaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgOTIgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuU2VhbHByaiAodHlYLCB0KSkgKVxuIyA0MzIgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0YTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RhXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdGFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0ZjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGZfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RmXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdGEgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdGEgaW5cbiAgICAgICAgbGV0IHRmIDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHRmIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190Zl8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3RhXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RmXyBpblxuICAgICAgICBcbiMgOTUgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuRnVuQXBwICh0ZiwgdGEpKSApXG4jIDQ2NSBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF82O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzZfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBhO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19hXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19hXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX180XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5WDtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5WF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5WF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdGY7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGZfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdGZfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfNiA6IHVuaXQgPSBPYmoubWFnaWMgXzYgaW5cbiAgICAgICAgbGV0IGEgOiAoR3R5cGVzLmd0eXBlKSA9IE9iai5tYWdpYyBhIGluXG4gICAgICAgIGxldCBfNCA6IHVuaXQgPSBPYmoubWFnaWMgXzQgaW5cbiAgICAgICAgbGV0IHR5WCA6IChcbiMgMiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA1MTkgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0eVggaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgdGYgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdGYgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RmXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzZfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdGZfIGluXG4gICAgICAgIFxuIyA5OCBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIChjcG9zIF9zdGFydHBvcywgU3VyZi5JbnN0ICh0ZiwgdHlYLCBhKSkgKVxuIyA1MzAgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdCA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0IGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190XyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdF8gaW5cbiAgICAgICAgbGV0IF92IDogKFN1cmYudG0pID0gXG4jIDEwMiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIHQgKVxuIyA1NTUgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0cjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHRsO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RsXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RsXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdHIgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdHIgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgdGwgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdGwgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RsXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdHJfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdGxfIGluXG4gICAgICAgIFxuIyAxMDQgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuUGx1cyAodGwsIHRyKSkgKVxuIyA1OTUgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB0IDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fM18gaW5cbiAgICAgICAgbGV0IF92IDogKFN1cmYudG0pID0gXG4jIDYyIFwibGliL3BhcnNlci5tbHlcIlxuICAgICggdCApXG4jIDYzNCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gbjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX25fO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19uXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBuIDogKFxuIyAzIFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQpXG4jIDY1NSBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIG4gaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX25fIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19uXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX25fIGluXG4gICAgICAgIFxuIyA2NCBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIChjcG9zIF9zdGFydHBvcyAsIFN1cmYuSW50IG4pIClcbiMgNjY0IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHggOiAoXG4jIDEgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgNjg1IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3hfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfeF8gaW5cbiAgICAgICAgXG4jIDY2IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggKGNwb3MgX3N0YXJ0cG9zLCBTdXJmLlRtVmFyIHgpIClcbiMgNjk0IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKFN1cmYudG0pID0gbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDY4IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggKGNwb3MgX3N0YXJ0cG9zLCBTdXJmLkJvb2xsaXQgdHJ1ZSkgKVxuIyA3MjAgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgNzAgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuQm9vbGxpdCBmYWxzZSkgKVxuIyA3NDYgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX181XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzVfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDI7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3QyXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190Ml87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0MTtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3QxXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdDFfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzUgOiB1bml0ID0gT2JqLm1hZ2ljIF81IGluXG4gICAgICAgIGxldCB0MiA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0MiBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB0MSA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0MSBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX181XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgNzIgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuUGFpciAodDEsIHQyKSkgKVxuIyA4MDAgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfODtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX184XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzhfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdGJvZDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGJvZF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdGJvZF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNjtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNl87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eTtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzQ7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eXg7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHl4XztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5eF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzggOiB1bml0ID0gT2JqLm1hZ2ljIF84IGluXG4gICAgICAgIGxldCB0Ym9kIDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHRib2QgaW5cbiAgICAgICAgbGV0IF82IDogdW5pdCA9IE9iai5tYWdpYyBfNiBpblxuICAgICAgICBsZXQgdHkgOiAoR3R5cGVzLmd0eXBlKSA9IE9iai5tYWdpYyB0eSBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCB0eXggOiAoXG4jIDIgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgODY4IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdHl4IGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fOF8gaW5cbiAgICAgICAgbGV0IF92IDogKFN1cmYudG0pID0gbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDc0IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggKGNwb3MgX3N0YXJ0cG9zLCBTdXJmLlBhY2sgKHR5eCwgdHksIHRib2QpKSApXG4jIDg3OSBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHQgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18yXyBpblxuICAgICAgICBsZXQgX3YgOiAoXG4jIDQ2IFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChTdXJmLnRtKVxuIyA5MTEgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IFxuIyA1OCBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICggdCApXG4jIDkxNSBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0IDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBcbiMgMTA4IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggdCApXG4jIDk0MCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190eV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0eSA6IChHdHlwZXMuZ3R5cGUpID0gT2JqLm1hZ2ljIHR5IGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IHQgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3R5XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RfIGluXG4gICAgICAgIFxuIyAxMTAgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuQW5uICh0eSwgdCkpIClcbiMgOTgwIFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5WDtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHlYXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190eVhfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHQgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgdHlYIDogKFxuIyAyIFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDEwMTQgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0eVggaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190XyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTEzIFwibGliL3BhcnNlci5tbHlcIlxuICAgICggKGNwb3MgX3N0YXJ0cG9zLCBTdXJmLlNlYWxpbmogKHR5WCwgdCkpIClcbiMgMTAyNCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eVg7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5WF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlYXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0IDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IHR5WCA6IChcbiMgMiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxMDU4IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdHlYIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdF8gaW5cbiAgICAgICAgbGV0IF92IDogKFN1cmYudG0pID0gbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDExNiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIChjcG9zIF9zdGFydHBvcywgU3VyZi5TZWFscHJqICh0eVgsIHQpKSApXG4jIDEwNjggXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0YTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RhXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdGFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0ZjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGZfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RmXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdGEgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdGEgaW5cbiAgICAgICAgbGV0IHRmIDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHRmIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190Zl8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3RhXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RmXyBpblxuICAgICAgICBcbiMgMTE5IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggKGNwb3MgX3N0YXJ0cG9zLCBTdXJmLkZ1bkFwcCAodGYsIHRhKSkgKVxuIyAxMTAxIFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzY7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX182XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IGE7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX2FfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX2FfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzQ7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdHlYO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHlYXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlYXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0ZjtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190Zl87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190Zl87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF82IDogdW5pdCA9IE9iai5tYWdpYyBfNiBpblxuICAgICAgICBsZXQgYSA6IChHdHlwZXMuZ3R5cGUpID0gT2JqLm1hZ2ljIGEgaW5cbiAgICAgICAgbGV0IF80IDogdW5pdCA9IE9iai5tYWdpYyBfNCBpblxuICAgICAgICBsZXQgdHlYIDogKFxuIyAyIFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDExNTUgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0eVggaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgdGYgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdGYgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3RmXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfXzZfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdGZfIGluXG4gICAgICAgIFxuIyAxMjIgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuSW5zdCAodGYsIHR5WCwgYSkpIClcbiMgMTE2NiBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHRyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHJfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190cl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdGw7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGxfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdGxfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0ciA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0ciBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB0bCA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0bCBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfdGxfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190cl8gaW5cbiAgICAgICAgbGV0IF92IDogKFN1cmYudG0pID0gbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190bF8gaW5cbiAgICAgICAgXG4jIDEyNSBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIChjcG9zIF9zdGFydHBvcywgU3VyZi5QbHVzICh0bCwgdHIpKSApXG4jIDEyMDYgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0Ym9kO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGJvZF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3Rib2RfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzU7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX181XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190eV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190eV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzNfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0geDtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeF87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdGJvZCA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0Ym9kIGluXG4gICAgICAgIGxldCBfNSA6IHVuaXQgPSBPYmoubWFnaWMgXzUgaW5cbiAgICAgICAgbGV0IHR5IDogKEd0eXBlcy5ndHlwZSkgPSBPYmoubWFnaWMgdHkgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgeCA6IChcbiMgMSBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxMjYxIFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3Rib2RfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxMjggXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuRnVuICh4LCB0eSwgdGJvZCkpIClcbiMgMTI3MSBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHRib2Q7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190Ym9kXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdGJvZF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5WDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190eVhfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlYXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0Ym9kIDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHRib2QgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgdHlYIDogKFxuIyAyIFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDEzMTIgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0eVggaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190Ym9kXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTMxIFwibGliL3BhcnNlci5tbHlcIlxuICAgICggKGNwb3MgX3N0YXJ0cG9zLCBTdXJmLkJpZ0xhbWJkYSAodHlYLCB0Ym9kKSkgKVxuIyAxMzIyIFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdGs7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190a187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RrXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF81O1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fNV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzVfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHg7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3hfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHRrIDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHRrIGluXG4gICAgICAgIGxldCBfNSA6IHVuaXQgPSBPYmoubWFnaWMgXzUgaW5cbiAgICAgICAgbGV0IHQgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdCBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB4IDogKFxuIyAxIFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDEzNzcgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB4IGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdGtfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxMzQgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuTGV0ICh0LCB4LCB0aykpIClcbiMgMTM4NyBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHRmO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGZfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190Zl87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzVfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX181XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR0O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R0XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R0XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0YjtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGJfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3RiXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0ZiA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0ZiBpblxuICAgICAgICBsZXQgXzUgOiB1bml0ID0gT2JqLm1hZ2ljIF81IGluXG4gICAgICAgIGxldCB0dCA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0dCBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB0YiA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0YiBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3RmXyBpblxuICAgICAgICBsZXQgX3YgOiAoU3VyZi50bSkgPSBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBcbiMgMTM3IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggKGNwb3MgX3N0YXJ0cG9zLCBTdXJmLklmICh0Yix0dCx0ZikpIClcbiMgMTQ0OCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHRrO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdGtfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190a187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfOTtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzlfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX185XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHQ7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190XztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF83O1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzdfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fN187XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNjtcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzZfO1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX182XztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHgyO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3gyXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3gyXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF80O1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzRfO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNF87XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfeDFfO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3gxXztcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18yXztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0ayA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0ayBpblxuICAgICAgICBsZXQgXzkgOiB1bml0ID0gT2JqLm1hZ2ljIF85IGluXG4gICAgICAgIGxldCB0IDogKFN1cmYudG0pID0gT2JqLm1hZ2ljIHQgaW5cbiAgICAgICAgbGV0IF83IDogdW5pdCA9IE9iai5tYWdpYyBfNyBpblxuICAgICAgICBsZXQgXzYgOiB1bml0ID0gT2JqLm1hZ2ljIF82IGluXG4gICAgICAgIGxldCB4MiA6IChcbiMgMSBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxNTI4IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeDIgaW5cbiAgICAgICAgbGV0IF80IDogdW5pdCA9IE9iai5tYWdpYyBfNCBpblxuICAgICAgICBsZXQgeDEgOiAoXG4jIDEgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTUzNCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHgxIGluXG4gICAgICAgIGxldCBfMiA6IHVuaXQgPSBPYmoubWFnaWMgXzIgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190a18gaW5cbiAgICAgICAgbGV0IF92IDogKFN1cmYudG0pID0gbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgXG4jIDE0MCBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIChjcG9zIF9zdGFydHBvcywgU3VyZi5QbVBhaXIgKHQsIHgxLCB4MiwgdGspKSApXG4jIDE1NDUgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0aztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RrXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdGtfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzk7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX185XztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fOV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0O1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3RfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX183XztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzdfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzY7XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX182XztcbiAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fNl87XG4gICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB4O1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3hfO1xuICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfeF87XG4gICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfNDtcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX180XztcbiAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzRfO1xuICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdHlYO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190eVhfO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5WF87XG4gICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMl87XG4gICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdGsgOiAoU3VyZi50bSkgPSBPYmoubWFnaWMgdGsgaW5cbiAgICAgICAgbGV0IF85IDogdW5pdCA9IE9iai5tYWdpYyBfOSBpblxuICAgICAgICBsZXQgdCA6IChTdXJmLnRtKSA9IE9iai5tYWdpYyB0IGluXG4gICAgICAgIGxldCBfNyA6IHVuaXQgPSBPYmoubWFnaWMgXzcgaW5cbiAgICAgICAgbGV0IF82IDogdW5pdCA9IE9iai5tYWdpYyBfNiBpblxuICAgICAgICBsZXQgeCA6IChcbiMgMSBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxNjI1IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgeCBpblxuICAgICAgICBsZXQgXzQgOiB1bml0ID0gT2JqLm1hZ2ljIF80IGluXG4gICAgICAgIGxldCB0eVggOiAoXG4jIDIgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTYzMSBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHR5WCBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdGtfIGluXG4gICAgICAgIGxldCBfdiA6IChTdXJmLnRtKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIFxuIyAxNDIgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCAoY3BvcyBfc3RhcnRwb3MsIFN1cmYuVW5wYWNrICh0LCB0eVgsIHgsIHRrKSkgKVxuIyAxNjQyIFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKEd0eXBlcy5ndHlwZSkgPSBcbiMgMTQ3IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggR3R5cGVzLkJvb2wgKVxuIyAxNjY3IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18xXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8xIDogdW5pdCA9IE9iai5tYWdpYyBfMSBpblxuICAgICAgICBsZXQgX2VuZHBvc19fMF8gPSBfbWVuaGlyX3N0YWNrLk1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfXzFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF92IDogKEd0eXBlcy5ndHlwZSkgPSBcbiMgMTQ5IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggR3R5cGVzLk51bSApXG4jIDE2OTIgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5WDtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5WF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5WF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdHlYIDogKFxuIyAyIFwibGliL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDE3MTMgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgKSA9IE9iai5tYWdpYyB0eVggaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3R5WF8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3R5WF8gaW5cbiAgICAgICAgbGV0IF92IDogKEd0eXBlcy5ndHlwZSkgPSBcbiMgMTUxIFwibGliL3BhcnNlci5tbHlcIlxuICAgICggR3R5cGVzLk5hbWUgKFZhck5hbWUgdHlYKSApXG4jIDE3MjEgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18xXyBpblxuICAgICAgICBsZXQgX3YgOiAoR3R5cGVzLmd0eXBlKSA9IFxuIyAxNTMgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCBHdHlwZXMuRHluIClcbiMgMTc0NiBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5MjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5Ml87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5Ml87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMjtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18yXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdHkxO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5MV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190eTFfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0eTIgOiAoR3R5cGVzLmd0eXBlKSA9IE9iai5tYWdpYyB0eTIgaW5cbiAgICAgICAgbGV0IF8yIDogdW5pdCA9IE9iai5tYWdpYyBfMiBpblxuICAgICAgICBsZXQgdHkxIDogKEd0eXBlcy5ndHlwZSkgPSBPYmoubWFnaWMgdHkxIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc190eTFfIGluXG4gICAgICAgIGxldCBfZW5kcG9zID0gX2VuZHBvc190eTJfIGluXG4gICAgICAgIGxldCBfdiA6IChHdHlwZXMuZ3R5cGUpID0gXG4jIDE1NSBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIEd0eXBlcy5UaW1lcyAodHkxLCB0eTIpKVxuIyAxNzg1IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gdHkyO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHkyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHkyXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8yO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMl87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfXzJfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eTE7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHkxXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5MV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IHR5MiA6IChHdHlwZXMuZ3R5cGUpID0gT2JqLm1hZ2ljIHR5MiBpblxuICAgICAgICBsZXQgXzIgOiB1bml0ID0gT2JqLm1hZ2ljIF8yIGluXG4gICAgICAgIGxldCB0eTEgOiAoR3R5cGVzLmd0eXBlKSA9IE9iai5tYWdpYyB0eTEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX3R5MV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3R5Ml8gaW5cbiAgICAgICAgbGV0IF92IDogKEd0eXBlcy5ndHlwZSkgPSBcbiMgMTU3IFwibGliL3BhcnNlci5tbHlcIlxuICAgICggR3R5cGVzLkZ1biAodHkxLCB0eTIpIClcbiMgMTgyNCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgICAoZnVuIF9tZW5oaXJfZW52IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gX21lbmhpcl9lbnYuTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YWNrIGluXG4gICAgICAgIGxldCB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc190eV87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzNfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5WDtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190eVhfO1xuICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlYXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzE7XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18xXztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB0eSA6IChHdHlwZXMuZ3R5cGUpID0gT2JqLm1hZ2ljIHR5IGluXG4gICAgICAgIGxldCBfMyA6IHVuaXQgPSBPYmoubWFnaWMgXzMgaW5cbiAgICAgICAgbGV0IHR5WCA6IChcbiMgMiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxODY1IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICkgPSBPYmoubWFnaWMgdHlYIGluXG4gICAgICAgIGxldCBfMSA6IHVuaXQgPSBPYmoubWFnaWMgXzEgaW5cbiAgICAgICAgbGV0IF9lbmRwb3NfXzBfID0gX21lbmhpcl9zdGFjay5NZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICBsZXQgX2VuZHBvcyA9IF9lbmRwb3NfdHlfIGluXG4gICAgICAgIGxldCBfdiA6IChHdHlwZXMuZ3R5cGUpID0gXG4jIDE1OSBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAoIEd0eXBlcy5GcmV4aXN0cyAodHlYLCB0eSkgKVxuIyAxODc0IFwibGliL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICB7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gX21lbmhpcl9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gT2JqLnJlcHIgX3Y7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICB9KTtcbiAgICAgIChmdW4gX21lbmhpcl9lbnYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBfbWVuaGlyX2Vudi5NZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhY2sgaW5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fM187XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX18zXztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IHR5O1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc190eV87XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlfO1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSB7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBfMTtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXJ0cCA9IF9zdGFydHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF8zIDogdW5pdCA9IE9iai5tYWdpYyBfMyBpblxuICAgICAgICBsZXQgdHkgOiAoR3R5cGVzLmd0eXBlKSA9IE9iai5tYWdpYyB0eSBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX18zXyBpblxuICAgICAgICBsZXQgX3YgOiAoR3R5cGVzLmd0eXBlKSA9IFxuIyAxNjEgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCB0eSApXG4jIDE5MTMgXCJsaWIvcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIHtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhdGUgPSBfbWVuaGlyX3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSBPYmoucmVwciBfdjtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IF9tZW5oaXJfc3RhY2s7XG4gICAgICAgIH0pO1xuICAgICAgKGZ1biBfbWVuaGlyX2VudiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IF9tZW5oaXJfZW52Lk1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFjayBpblxuICAgICAgICBsZXQge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF87XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eTtcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX3R5XztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuZW5kcCA9IF9lbmRwb3NfdHlfO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zZW12ID0gXzM7XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc3RhcnRwID0gX3N0YXJ0cG9zX18zXztcbiAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fM187XG4gICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMubmV4dCA9IHtcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnN0YXRlID0gXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLnNlbXYgPSB0eVg7XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfdHlYXztcbiAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zX3R5WF87XG4gICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0ge1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IF8xO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3NfXzFfO1xuICAgICAgICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5lbmRwID0gX2VuZHBvc19fMV87XG4gICAgICAgICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLm5leHQgPSBfbWVuaGlyX3N0YWNrO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9ID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgdHkgOiAoR3R5cGVzLmd0eXBlKSA9IE9iai5tYWdpYyB0eSBpblxuICAgICAgICBsZXQgXzMgOiB1bml0ID0gT2JqLm1hZ2ljIF8zIGluXG4gICAgICAgIGxldCB0eVggOiAoXG4jIDIgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTk1NCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICApID0gT2JqLm1hZ2ljIHR5WCBpblxuICAgICAgICBsZXQgXzEgOiB1bml0ID0gT2JqLm1hZ2ljIF8xIGluXG4gICAgICAgIGxldCBfZW5kcG9zX18wXyA9IF9tZW5oaXJfc3RhY2suTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgbGV0IF9lbmRwb3MgPSBfZW5kcG9zX3R5XyBpblxuICAgICAgICBsZXQgX3YgOiAoR3R5cGVzLmd0eXBlKSA9IFxuIyAxNjMgXCJsaWIvcGFyc2VyLm1seVwiXG4gICAgKCBHdHlwZXMuRnJmb3JhbGwgKHR5WCwgdHkpIClcbiMgMTk2MyBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAge1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGF0ZSA9IF9tZW5oaXJfcztcbiAgICAgICAgICBNZW5oaXJMaWIuRW5naW5lVHlwZXMuc2VtdiA9IE9iai5yZXByIF92O1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5zdGFydHAgPSBfc3RhcnRwb3M7XG4gICAgICAgICAgTWVuaGlyTGliLkVuZ2luZVR5cGVzLmVuZHAgPSBfZW5kcG9zO1xuICAgICAgICAgIE1lbmhpckxpYi5FbmdpbmVUeXBlcy5uZXh0ID0gX21lbmhpcl9zdGFjaztcbiAgICAgICAgfSk7XG4gICAgfF1cbiAgXG4gIGFuZCB0cmFjZSA9XG4gICAgTm9uZVxuICBcbmVuZFxuXG5tb2R1bGUgTWVuaGlySW50ZXJwcmV0ZXIgPSBzdHJ1Y3RcbiAgXG4gIG1vZHVsZSBFVCA9IE1lbmhpckxpYi5UYWJsZUludGVycHJldGVyLk1ha2VFbmdpbmVUYWJsZSAoVGFibGVzKVxuICBcbiAgbW9kdWxlIFRJID0gTWVuaGlyTGliLkVuZ2luZS5NYWtlIChFVClcbiAgXG4gIGluY2x1ZGUgVElcbiAgXG5lbmRcblxubGV0IHByb2cgPVxuICBmdW4gbGV4ZXIgbGV4YnVmIC0+XG4gICAgKE9iai5tYWdpYyAoTWVuaGlySW50ZXJwcmV0ZXIuZW50cnkgMCBsZXhlciBsZXhidWYpIDogKFxuIyA0NiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoU3VyZi50bSlcbiMgMTk5NCBcImxpYi9wYXJzZXIubWxcIlxuICAgICkpXG5cbm1vZHVsZSBJbmNyZW1lbnRhbCA9IHN0cnVjdFxuICBcbiAgbGV0IHByb2cgPVxuICAgIGZ1biBpbml0aWFsX3Bvc2l0aW9uIC0+XG4gICAgICAoT2JqLm1hZ2ljIChNZW5oaXJJbnRlcnByZXRlci5zdGFydCAwIGluaXRpYWxfcG9zaXRpb24pIDogKFxuIyA0NiBcImxpYi9wYXJzZXIubWx5XCJcbiAgICAgICAoU3VyZi50bSlcbiMgMjAwNCBcImxpYi9wYXJzZXIubWxcIlxuICAgICAgKSBNZW5oaXJJbnRlcnByZXRlci5jaGVja3BvaW50KVxuICBcbmVuZFxuXG4jIDI2OSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgXG5cbiMgMjAxMiBcImxpYi9wYXJzZXIubWxcIlxuIiwiIyAxIFwibGliL2xleGVyLm1sbFwiXG4gXG5vcGVuIExleGluZzs7XG5vcGVuIFBhcnNlcjs7XG5cbmV4Y2VwdGlvbiBMZXhpbmdFcnJvciBvZiBzdHJpbmc7O1xuXG5sZXQgbmV4dF9saW5lIGxleGJ1ZiA9XG4gIGxldCBwb3MgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgIHsgcG9zIHdpdGggcG9zX2JvbCA9IGxleGJ1Zi5sZXhfY3Vycl9wb3M7XG4gICAgICAgICAgICAgICBwb3NfbG51bSA9IHBvcy5wb3NfbG51bSArIDFcbiAgICB9XG5cbiMgMTYgXCJsaWIvbGV4ZXIubWxcIlxubGV0IF9fb2NhbWxfbGV4X3RhYmxlcyA9IHtcbiAgTGV4aW5nLmxleF9iYXNlID1cbiAgIFwiXFwwMDBcXDAwMFxcMjE2XFwyNTVcXDIxN1xcMjU1XFwwODVcXDAwMFxcMTkyXFwwMDBcXDAyMFxcMDAxXFwxMDRcXDAwMVxcMTg4XFwwMDFcXFxuICAgIFxcMDE2XFwwMDJcXDEwMFxcMDAyXFwxODRcXDAwMlxcMDEyXFwwMDNcXDA5NlxcMDAzXFwxODBcXDAwM1xcMDA4XFwwMDRcXDIzNlxcMjU1XFxcbiAgICBcXDIzN1xcMjU1XFwyMzhcXDI1NVxcMDAxXFwwMDBcXDAwMFxcMDAwXFwyNDNcXDI1NVxcMjQ0XFwyNTVcXDI0NVxcMjU1XFwyNDZcXDI1NVxcXG4gICAgXFwyNDdcXDI1NVxcMjQ4XFwyNTVcXDI0OVxcMjU1XFwyNTBcXDI1NVxcMTYwXFwwMDBcXDE3MFxcMDAwXFwwMjdcXDAwMFxcMjU0XFwyNTVcXFxuICAgIFxcMDAxXFwwMDBcXDAwNVxcMDAwXFwwMzFcXDAwMFxcMDE3XFwwMDBcXDAxNVxcMDAwXFwwNDNcXDAwMFxcMjUzXFwyNTVcXDAzN1xcMDAwXFxcbiAgICBcXDAzMVxcMDAwXFwwNDZcXDAwMFxcMjUyXFwyNTVcXDIzNVxcMjU1XFwyNDJcXDI1NVxcMjM5XFwyNTVcXDA5MlxcMDA0XFwxNzZcXDAwNFxcXG4gICAgXFwwMDRcXDAwNVxcMDg4XFwwMDVcXDE3MlxcMDA1XFwwMDBcXDAwNlxcMDg0XFwwMDZcXDE2OFxcMDA2XFwyNTJcXDAwNlxcMDgwXFwwMDdcXFxuICAgIFxcMTY0XFwwMDdcXDI0OFxcMDA3XFwwNzZcXDAwOFxcMTYwXFwwMDhcXDI0NFxcMDA4XFwwNzJcXDAwOVxcMTU2XFwwMDlcXDI0MFxcMDA5XFxcbiAgICBcXDA2OFxcMDEwXFwxNTJcXDAxMFxcMjM2XFwwMTBcXDA2NFxcMDExXFwxNDhcXDAxMVxcMjMyXFwwMTFcXDA2MFxcMDEyXFwxNDRcXDAxMlxcXG4gICAgXFwyMjhcXDAxMlxcMDU2XFwwMTNcXDE0MFxcMDEzXFwyMjRcXDAxM1xcMDUyXFwwMTRcXDEzNlxcMDE0XFwyMjBcXDAxNFxcMDQ4XFwwMTVcXFxuICAgIFxcMTMyXFwwMTVcXDIxNlxcMDE1XFwwNDRcXDAxNlxcMTI4XFwwMTZcXDIxMlxcMDE2XFwwNDBcXDAxN1xcMTI0XFwwMTdcXDIwOFxcMDE3XFxcbiAgICBcXDAzNlxcMDE4XFwxMjBcXDAxOFxcMjA0XFwwMThcXDAzMlxcMDE5XFwxMTZcXDAxOVxcMjAwXFwwMTlcXDAyOFxcMDIwXCI7XG4gIExleGluZy5sZXhfYmFja3RyayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDM3XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFxcbiAgICBcXDAzN1xcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxNVxcMDAwXFwwMTRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNFxcMDAwXFwwMzhcXDAwMFxcMDM4XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMjNcXDAwMFxcMDIxXFwwMDBcXFxuICAgIFxcMDMzXFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDIyXFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAyOFxcMDAwXFxcbiAgICBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDI0XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAyNVxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzMFxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAyNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDI3XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM1XFwwMDBcXDAzN1xcMDAwXFxcbiAgICBcXDAzN1xcMDAwXFwwMzdcXDAwMFxcMDM3XFwwMDBcXDAyOVxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzFcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzJcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzRcXDAwMFwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDAwMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF90cmFucyA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMzNcXDAwMFxcMDMxXFwwMDBcXDAzMVxcMDAwXFwwMDBcXDAwMFxcMDMyXFwwMDBcXDAzM1xcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAzM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAzMFxcMDAwXFwwMDBcXDAwMFxcMDMzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMjZcXDAwMFxcMDI1XFwwMDBcXDAxNlxcMDAwXFwwMjdcXDAwMFxcMDIwXFwwMDBcXDAyOVxcMDAwXFwwMTdcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFxcbiAgICBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDE4XFwwMDBcXDA0NVxcMDAwXFwwMjJcXDAwMFxcMDE5XFwwMDBcXDAyMVxcMDAwXFwwMTVcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwOFxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDZcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMTFcXDAwMFxcMDA3XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMTRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMTNcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMTBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDVcXDAwMFxcMDEyXFwwMDBcXDAwOVxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDI0XFwwMDBcXDAwM1xcMDAwXFwwMjNcXDAwMFxcMDQ0XFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAzOVxcMDAwXFwwMzRcXDAwMFxcMDAzXFwwMDBcXDAzNlxcMDAwXFwwMzdcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDM1XFwwMDBcXFxuICAgIFxcMDM4XFwwMDBcXDA0MFxcMDAwXFwwNDFcXDAwMFxcMDQyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXFxuICAgIFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFxcbiAgICBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwNDNcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDFcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDkyXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwODlcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDg0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDA3OVxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwNzBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDA2N1xcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDYwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwNTlcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDA1NlxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDQ5XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDUwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDQ2XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDA0N1xcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDQ4XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDUyXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDA1M1xcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDA1NFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDU1XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDU3XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDA1OFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwNjNcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDA2MVxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwNjJcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwNjRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwNjZcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDY4XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDY5XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDA3MlxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDA3MVxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwNzZcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDczXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDc0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDc1XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDc3XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwNzhcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDgwXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDA4MVxcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDA4MlxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDgzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDg1XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDA4NlxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDg3XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwODhcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwOTBcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDkxXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDkzXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwOTRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXCI7XG4gIExleGluZy5sZXhfY2hlY2sgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMzJcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMzNcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAzM1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMThcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMzRcXDAwMFxcMDMwXFwwMDBcXDAwM1xcMDAwXFwwMzVcXDAwMFxcMDM2XFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAzMFxcMDAwXFxcbiAgICBcXDAzN1xcMDAwXFwwMzlcXDAwMFxcMDQwXFwwMDBcXDA0MVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAzXFwwMDBcXDI1NVxcMjU1XFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI4XFwwMDBcXDAyOFxcMDAwXFxcbiAgICBcXDAyOFxcMDAwXFwwMjhcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcXG4gICAgXFwwMjlcXDAwMFxcMDI5XFwwMDBcXDAyOVxcMDAwXFwwMjlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA0XFwwMDBcXFxuICAgIFxcMDI5XFwwMDBcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNFxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDA1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMjU1XFwyNTVcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNlxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwN1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDA3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMjU1XFwyNTVcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA4XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcXG4gICAgXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFxcbiAgICBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcXG4gICAgXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXFxuICAgIFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwOFxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcXG4gICAgXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXFxuICAgIFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOFxcMDAwXFxcbiAgICBcXDAwOFxcMDAwXFwwMDhcXDAwMFxcMDA4XFwwMDBcXDAwOVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwOVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDA5XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXFxuICAgIFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcXG4gICAgXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXFxuICAgIFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFxcbiAgICBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDlcXDAwMFxcMjU1XFwyNTVcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXFxuICAgIFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFxcbiAgICBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcXG4gICAgXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDA5XFwwMDBcXDAwOVxcMDAwXFwwMDlcXDAwMFxcMDEwXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcXG4gICAgXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFxcbiAgICBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcXG4gICAgXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXFxuICAgIFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxMFxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcXG4gICAgXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXFxuICAgIFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMFxcMDAwXFxcbiAgICBcXDAxMFxcMDAwXFwwMTBcXDAwMFxcMDEwXFwwMDBcXDAxMVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxMVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDExXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXFxuICAgIFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcXG4gICAgXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXFxuICAgIFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFxcbiAgICBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTFcXDAwMFxcMjU1XFwyNTVcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXFxuICAgIFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFxcbiAgICBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcXG4gICAgXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDEyXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcXG4gICAgXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFxcbiAgICBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcXG4gICAgXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXFxuICAgIFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxMlxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcXG4gICAgXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXFxuICAgIFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxMlxcMDAwXFxcbiAgICBcXDAxMlxcMDAwXFwwMTJcXDAwMFxcMDEyXFwwMDBcXDAxM1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxM1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDEzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTNcXDAwMFxcMjU1XFwyNTVcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXFxuICAgIFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFxcbiAgICBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcXG4gICAgXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDEzXFwwMDBcXDAxM1xcMDAwXFwwMTNcXDAwMFxcMDE0XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcXG4gICAgXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFxcbiAgICBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcXG4gICAgXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXFxuICAgIFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxNFxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcXG4gICAgXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXFxuICAgIFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDAxNFxcMDAwXFxcbiAgICBcXDAxNFxcMDAwXFwwMTRcXDAwMFxcMDE0XFwwMDBcXDA0NlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDQ2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDZcXDAwMFxcMjU1XFwyNTVcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0N1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0OFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDQ4XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDhcXDAwMFxcMjU1XFwyNTVcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0OVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA1MFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDUwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTBcXDAwMFxcMjU1XFwyNTVcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1MVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDUyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTJcXDAwMFxcMjU1XFwyNTVcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1M1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1NFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDU0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXFxuICAgIFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcXG4gICAgXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXFxuICAgIFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFxcbiAgICBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTRcXDAwMFxcMjU1XFwyNTVcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXFxuICAgIFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFxcbiAgICBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcXG4gICAgXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU0XFwwMDBcXDA1NFxcMDAwXFwwNTRcXDAwMFxcMDU1XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcXG4gICAgXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFxcbiAgICBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcXG4gICAgXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXFxuICAgIFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1NVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcXG4gICAgXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXFxuICAgIFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NVxcMDAwXFxcbiAgICBcXDA1NVxcMDAwXFwwNTVcXDAwMFxcMDU1XFwwMDBcXDA1NlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDU2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXFxuICAgIFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcXG4gICAgXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXFxuICAgIFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFxcbiAgICBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTZcXDAwMFxcMjU1XFwyNTVcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXFxuICAgIFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFxcbiAgICBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcXG4gICAgXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU2XFwwMDBcXDA1NlxcMDAwXFwwNTZcXDAwMFxcMDU3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcXG4gICAgXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFxcbiAgICBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcXG4gICAgXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXFxuICAgIFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1N1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcXG4gICAgXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXFxuICAgIFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1N1xcMDAwXFxcbiAgICBcXDA1N1xcMDAwXFwwNTdcXDAwMFxcMDU3XFwwMDBcXDA1OFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDU4XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXFxuICAgIFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcXG4gICAgXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXFxuICAgIFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFxcbiAgICBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNThcXDAwMFxcMjU1XFwyNTVcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXFxuICAgIFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFxcbiAgICBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcXG4gICAgXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU4XFwwMDBcXDA1OFxcMDAwXFwwNThcXDAwMFxcMDU5XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcXG4gICAgXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFxcbiAgICBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcXG4gICAgXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXFxuICAgIFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1OVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcXG4gICAgXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXFxuICAgIFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA1OVxcMDAwXFxcbiAgICBcXDA1OVxcMDAwXFwwNTlcXDAwMFxcMDU5XFwwMDBcXDA2MFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDYwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXFxuICAgIFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcXG4gICAgXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXFxuICAgIFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFxcbiAgICBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjBcXDAwMFxcMjU1XFwyNTVcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXFxuICAgIFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFxcbiAgICBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcXG4gICAgXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYwXFwwMDBcXDA2MFxcMDAwXFwwNjBcXDAwMFxcMDYxXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcXG4gICAgXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFxcbiAgICBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcXG4gICAgXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXFxuICAgIFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2MVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcXG4gICAgXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXFxuICAgIFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFxcbiAgICBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDYyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXFxuICAgIFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcXG4gICAgXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXFxuICAgIFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFxcbiAgICBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjJcXDAwMFxcMjU1XFwyNTVcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXFxuICAgIFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFxcbiAgICBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcXG4gICAgXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYyXFwwMDBcXDA2MlxcMDAwXFwwNjJcXDAwMFxcMDYzXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcXG4gICAgXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFxcbiAgICBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcXG4gICAgXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXFxuICAgIFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2M1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcXG4gICAgXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXFxuICAgIFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFxcbiAgICBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2NFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDY0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXFxuICAgIFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcXG4gICAgXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXFxuICAgIFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFxcbiAgICBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjRcXDAwMFxcMjU1XFwyNTVcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXFxuICAgIFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFxcbiAgICBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcXG4gICAgXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2NVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDY2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXFxuICAgIFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcXG4gICAgXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXFxuICAgIFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFxcbiAgICBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjZcXDAwMFxcMjU1XFwyNTVcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXFxuICAgIFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFxcbiAgICBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcXG4gICAgXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDY3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcXG4gICAgXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFxcbiAgICBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcXG4gICAgXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXFxuICAgIFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2N1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcXG4gICAgXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXFxuICAgIFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFxcbiAgICBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2OFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDY4XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXFxuICAgIFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcXG4gICAgXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXFxuICAgIFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFxcbiAgICBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjhcXDAwMFxcMjU1XFwyNTVcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXFxuICAgIFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFxcbiAgICBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcXG4gICAgXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY4XFwwMDBcXDA2OFxcMDAwXFwwNjhcXDAwMFxcMDY5XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcXG4gICAgXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFxcbiAgICBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcXG4gICAgXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXFxuICAgIFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2OVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcXG4gICAgXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXFxuICAgIFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA2OVxcMDAwXFxcbiAgICBcXDA2OVxcMDAwXFwwNjlcXDAwMFxcMDY5XFwwMDBcXDA3MFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDcwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXFxuICAgIFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcXG4gICAgXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXFxuICAgIFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFxcbiAgICBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzBcXDAwMFxcMjU1XFwyNTVcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXFxuICAgIFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFxcbiAgICBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcXG4gICAgXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcwXFwwMDBcXDA3MFxcMDAwXFwwNzBcXDAwMFxcMDcxXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcXG4gICAgXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFxcbiAgICBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcXG4gICAgXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXFxuICAgIFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3MVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcXG4gICAgXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXFxuICAgIFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MVxcMDAwXFxcbiAgICBcXDA3MVxcMDAwXFwwNzFcXDAwMFxcMDcxXFwwMDBcXDA3MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDcyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXFxuICAgIFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcXG4gICAgXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXFxuICAgIFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFxcbiAgICBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzJcXDAwMFxcMjU1XFwyNTVcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXFxuICAgIFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFxcbiAgICBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcXG4gICAgXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDcyXFwwMDBcXDA3MlxcMDAwXFwwNzJcXDAwMFxcMDczXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcXG4gICAgXFwwNzNcXDAwMFxcMDczXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFxcbiAgICBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcXG4gICAgXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXFxuICAgIFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3M1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcXG4gICAgXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXFxuICAgIFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3M1xcMDAwXFxcbiAgICBcXDA3M1xcMDAwXFwwNzNcXDAwMFxcMDczXFwwMDBcXDA3NFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDc0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXFxuICAgIFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcXG4gICAgXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXFxuICAgIFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFxcbiAgICBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzRcXDAwMFxcMjU1XFwyNTVcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXFxuICAgIFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFxcbiAgICBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcXG4gICAgXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc0XFwwMDBcXDA3NFxcMDAwXFwwNzRcXDAwMFxcMDc1XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcXG4gICAgXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFxcbiAgICBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcXG4gICAgXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXFxuICAgIFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3NVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcXG4gICAgXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXFxuICAgIFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NVxcMDAwXFxcbiAgICBcXDA3NVxcMDAwXFwwNzVcXDAwMFxcMDc1XFwwMDBcXDA3NlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDc2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXFxuICAgIFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcXG4gICAgXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXFxuICAgIFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFxcbiAgICBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzZcXDAwMFxcMjU1XFwyNTVcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXFxuICAgIFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFxcbiAgICBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcXG4gICAgXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc2XFwwMDBcXDA3NlxcMDAwXFwwNzZcXDAwMFxcMDc3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcXG4gICAgXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFxcbiAgICBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcXG4gICAgXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXFxuICAgIFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3N1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcXG4gICAgXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXFxuICAgIFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3N1xcMDAwXFxcbiAgICBcXDA3N1xcMDAwXFwwNzdcXDAwMFxcMDc3XFwwMDBcXDA3OFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDc4XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXFxuICAgIFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcXG4gICAgXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXFxuICAgIFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFxcbiAgICBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzhcXDAwMFxcMjU1XFwyNTVcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXFxuICAgIFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFxcbiAgICBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcXG4gICAgXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc4XFwwMDBcXDA3OFxcMDAwXFwwNzhcXDAwMFxcMDc5XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcXG4gICAgXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFxcbiAgICBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcXG4gICAgXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXFxuICAgIFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3OVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcXG4gICAgXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXFxuICAgIFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA3OVxcMDAwXFxcbiAgICBcXDA3OVxcMDAwXFwwNzlcXDAwMFxcMDc5XFwwMDBcXDA4MFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDgwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXFxuICAgIFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcXG4gICAgXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXFxuICAgIFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFxcbiAgICBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODBcXDAwMFxcMjU1XFwyNTVcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXFxuICAgIFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFxcbiAgICBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcXG4gICAgXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgwXFwwMDBcXDA4MFxcMDAwXFwwODBcXDAwMFxcMDgxXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcXG4gICAgXFwwODFcXDAwMFxcMDgxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFxcbiAgICBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcXG4gICAgXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXFxuICAgIFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4MVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcXG4gICAgXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXFxuICAgIFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MVxcMDAwXFxcbiAgICBcXDA4MVxcMDAwXFwwODFcXDAwMFxcMDgxXFwwMDBcXDA4MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDgyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXFxuICAgIFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcXG4gICAgXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXFxuICAgIFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFxcbiAgICBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODJcXDAwMFxcMjU1XFwyNTVcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXFxuICAgIFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFxcbiAgICBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcXG4gICAgXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgyXFwwMDBcXDA4MlxcMDAwXFwwODJcXDAwMFxcMDgzXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcXG4gICAgXFwwODNcXDAwMFxcMDgzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFxcbiAgICBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcXG4gICAgXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXFxuICAgIFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4M1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcXG4gICAgXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXFxuICAgIFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4M1xcMDAwXFxcbiAgICBcXDA4M1xcMDAwXFwwODNcXDAwMFxcMDgzXFwwMDBcXDA4NFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDg0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXFxuICAgIFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcXG4gICAgXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXFxuICAgIFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFxcbiAgICBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODRcXDAwMFxcMjU1XFwyNTVcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXFxuICAgIFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFxcbiAgICBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcXG4gICAgXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg0XFwwMDBcXDA4NFxcMDAwXFwwODRcXDAwMFxcMDg1XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcXG4gICAgXFwwODVcXDAwMFxcMDg1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFxcbiAgICBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcXG4gICAgXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXFxuICAgIFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4NVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcXG4gICAgXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXFxuICAgIFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NVxcMDAwXFxcbiAgICBcXDA4NVxcMDAwXFwwODVcXDAwMFxcMDg1XFwwMDBcXDA4NlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDg2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXFxuICAgIFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcXG4gICAgXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXFxuICAgIFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFxcbiAgICBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODZcXDAwMFxcMjU1XFwyNTVcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXFxuICAgIFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFxcbiAgICBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcXG4gICAgXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg2XFwwMDBcXDA4NlxcMDAwXFwwODZcXDAwMFxcMDg3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcXG4gICAgXFwwODdcXDAwMFxcMDg3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFxcbiAgICBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcXG4gICAgXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXFxuICAgIFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4N1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcXG4gICAgXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXFxuICAgIFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4N1xcMDAwXFxcbiAgICBcXDA4N1xcMDAwXFwwODdcXDAwMFxcMDg3XFwwMDBcXDA4OFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDg4XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXFxuICAgIFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcXG4gICAgXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXFxuICAgIFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFxcbiAgICBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODhcXDAwMFxcMjU1XFwyNTVcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXFxuICAgIFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFxcbiAgICBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcXG4gICAgXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg4XFwwMDBcXDA4OFxcMDAwXFwwODhcXDAwMFxcMDg5XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcXG4gICAgXFwwODlcXDAwMFxcMDg5XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFxcbiAgICBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcXG4gICAgXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXFxuICAgIFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4OVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcXG4gICAgXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXFxuICAgIFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA4OVxcMDAwXFxcbiAgICBcXDA4OVxcMDAwXFwwODlcXDAwMFxcMDg5XFwwMDBcXDA5MFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA5MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDkwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXFxuICAgIFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcXG4gICAgXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXFxuICAgIFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFxcbiAgICBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwOTBcXDAwMFxcMjU1XFwyNTVcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXFxuICAgIFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFxcbiAgICBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcXG4gICAgXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkwXFwwMDBcXDA5MFxcMDAwXFwwOTBcXDAwMFxcMDkxXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwOTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwOTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcXG4gICAgXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFxcbiAgICBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcXG4gICAgXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXFxuICAgIFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA5MVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcXG4gICAgXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXFxuICAgIFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MVxcMDAwXFxcbiAgICBcXDA5MVxcMDAwXFwwOTFcXDAwMFxcMDkxXFwwMDBcXDA5MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA5MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDkyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXFxuICAgIFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcXG4gICAgXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXFxuICAgIFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFxcbiAgICBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwOTJcXDAwMFxcMjU1XFwyNTVcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXFxuICAgIFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFxcbiAgICBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcXG4gICAgXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkyXFwwMDBcXDA5MlxcMDAwXFwwOTJcXDAwMFxcMDkzXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwOTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwOTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcXG4gICAgXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFxcbiAgICBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcXG4gICAgXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXFxuICAgIFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA5M1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcXG4gICAgXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXFxuICAgIFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5M1xcMDAwXFxcbiAgICBcXDA5M1xcMDAwXFwwOTNcXDAwMFxcMDkzXFwwMDBcXDA5NFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA5NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDk0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXFxuICAgIFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcXG4gICAgXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXFxuICAgIFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFxcbiAgICBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwOTRcXDAwMFxcMjU1XFwyNTVcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXFxuICAgIFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFxcbiAgICBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcXG4gICAgXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMDk0XFwwMDBcXDA5NFxcMDAwXFwwOTRcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2Jhc2VfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmtfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHRfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X3RyYW5zX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jaGVja19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY29kZSA9XG4gICBcIlwiO1xufVxuXG5sZXQgcmVjIHJlYWQgbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3JlYWRfcmVjIGxleGJ1ZiAwXG5hbmQgX19vY2FtbF9sZXhfcmVhZF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyAyNCBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAgICggcmVhZCBsZXhidWYgKVxuIyAxNDMyIFwibGliL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgMjUgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAoIG5leHRfbGluZSBsZXhidWY7IHJlYWQgbGV4YnVmIClcbiMgMTQzNyBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAyIC0+XG4jIDI2IFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAoIFRSVUUgKVxuIyAxNDQyIFwibGliL2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgMjcgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAoIEZBTFNFIClcbiMgMTQ0NyBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCA0IC0+XG4jIDI4IFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICggTlVNQkVSIChpbnRfb2Zfc3RyaW5nIChMZXhpbmcubGV4ZW1lIGxleGJ1ZikpIClcbiMgMTQ1MiBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCA1IC0+XG4jIDI5IFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICggUExVUyApXG4jIDE0NTcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgNiAtPlxuIyAzMCBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAoIExFRlRfUEFSRU4gKVxuIyAxNDYyIFwibGliL2xleGVyLm1sXCJcblxuICB8IDcgLT5cbiMgMzEgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBSSUdIVF9QQVJFTiApXG4jIDE0NjcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgOCAtPlxuIyAzMiBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAoIExFRlRfQlJBQ0UgKVxuIyAxNDcyIFwibGliL2xleGVyLm1sXCJcblxuICB8IDkgLT5cbiMgMzMgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBSSUdIVF9CUkFDRSApXG4jIDE0NzcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMTAgLT5cbiMgMzQgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBMRUZUX0FOR0xFIClcbiMgMTQ4MiBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAxMSAtPlxuIyAzNSBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAoIFJJR0hUX0FOR0xFIClcbiMgMTQ4NyBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAxMiAtPlxuIyAzNiBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAoIENPTU1BIClcbiMgMTQ5MiBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAxMyAtPlxuIyAzNyBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAgKCBFUVVJViApXG4jIDE0OTcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMTQgLT5cbiMgMzggXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBFUVVBTCApXG4jIDE1MDIgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMTUgLT5cbiMgMzkgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBDT0xPTiApXG4jIDE1MDcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMTYgLT5cbiMgNDAgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgICggRE9VQkxFX0NPTE9OIClcbiMgMTUxMiBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAxNyAtPlxuIyA0MSBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAoIFBFUklPRCApXG4jIDE1MTcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMTggLT5cbiMgNDIgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBBU1RFUklTSyApXG4jIDE1MjIgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMTkgLT5cbiMgNDMgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBRVUVTVElPTl9NQVJLIClcbiMgMTUyNyBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAyMCAtPlxuIyA0NCBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAgKCBUSElOX0FSUk9XIClcbiMgMTUzMiBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAyMSAtPlxuIyA0NSBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAgKCBJTiApXG4jIDE1MzcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMjIgLT5cbiMgNDYgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgICAoIExFVCApXG4jIDE1NDIgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMjMgLT5cbiMgNDcgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgICggSUYgKVxuIyAxNTQ3IFwibGliL2xleGVyLm1sXCJcblxuICB8IDI0IC0+XG4jIDQ4IFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICAgICggVEhFTiApXG4jIDE1NTIgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMjUgLT5cbiMgNDkgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgKCBFTFNFIClcbiMgMTU1NyBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAyNiAtPlxuIyA1MCBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAgICAoIFBBQ0sgKVxuIyAxNTYyIFwibGliL2xleGVyLm1sXCJcblxuICB8IDI3IC0+XG4jIDUxIFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgKCBVTlBBQ0sgKVxuIyAxNTY3IFwibGliL2xleGVyLm1sXCJcblxuICB8IDI4IC0+XG4jIDUyIFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgKCBGVU4gKVxuIyAxNTcyIFwibGliL2xleGVyLm1sXCJcblxuICB8IDI5IC0+XG4jIDUzIFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgKCBCSUdfTEFNQkRBIClcbiMgMTU3NyBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAzMCAtPlxuIyA1NCBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICggRVhJU1RTIClcbiMgMTU4MiBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAzMSAtPlxuIyA1NSBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICggRk9SQUxMIClcbiMgMTU4NyBcImxpYi9sZXhlci5tbFwiXG5cbiAgfCAzMiAtPlxuIyA1NiBcImxpYi9sZXhlci5tbGxcIlxuICAgICAgICAgICAoIEJPT0wgKVxuIyAxNTkyIFwibGliL2xleGVyLm1sXCJcblxuICB8IDMzIC0+XG4jIDU3IFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICAgKCBJTlQgKVxuIyAxNTk3IFwibGliL2xleGVyLm1sXCJcblxuICB8IDM0IC0+XG4jIDU4IFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICAgICggU0VBTCApXG4jIDE2MDIgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMzUgLT5cbiMgNTkgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAoIFVOU0VBTCApXG4jIDE2MDcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMzYgLT5cbiMgNjAgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBWQVJJQUJMRSAoTGV4aW5nLmxleGVtZSBsZXhidWYpKVxuIyAxNjEyIFwibGliL2xleGVyLm1sXCJcblxuICB8IDM3IC0+XG4jIDYxIFwibGliL2xleGVyLm1sbFwiXG4gICAgICAgICAgKCBUWVBFX1ZBUklBQkxFIChMZXhpbmcubGV4ZW1lIGxleGJ1ZikgKVxuIyAxNjE3IFwibGliL2xleGVyLm1sXCJcblxuICB8IDM4IC0+XG4jIDYyIFwibGliL2xleGVyLm1sbFwiXG4gICAgICAoIHJhaXNlIChMZXhpbmdFcnJvciAoXCJVbmV4cGVjdGVkIGNoYXI6IFwiIF4gTGV4aW5nLmxleGVtZSBsZXhidWYpKSApXG4jIDE2MjIgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgMzkgLT5cbiMgNjMgXCJsaWIvbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAoIEVPRiApXG4jIDE2MjcgXCJsaWIvbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9yZWFkX3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuOztcblxuIiwiKCogQXJjaGl0ZWN0dXJlXG4gKlxuICogUGFyc2luZyByZXN1bHRzIGluIHN1cmZzeW50YXgsIHdoaWNoIGlzIHR5cGUtY2hlY2tlZCBhbmQgZXhwYW5kZWQgdG8gY2FzdGNhbGNcbiAqIE9wIHNlbWFudGljcyBpcyBkZWZpbmVkIG9uIGNhc3RjYWxjLlxuXG4gKiAqICopXG5cbm9wZW4gR3R5cGVzOztcbm9wZW4gQ0M7O1xub3BlbiBQUHJpbnQ7O1xubW9kdWxlIFAgPSBQUHJpbnQ7O1xudHlwZSBzdG9yZSA9IGludCAqIGd0eXBlIGxpc3Q7O1xuXG5sZXQgcmVjIHByZXR0eV9zdG9yZSA9IGZ1bmN0aW9uXG4gIHwgKF8sIFtdKSAtPiBQLnN0cmluZyBcInt9XCJcbiAgfCAobiwgeDo6eHMpIC0+XG4gICAgIFAuc3RyaW5nIChzdHJpbmdfb2ZfaW50IG4pIF5eIFAuc3RyaW5nIFwiIHwtPiBcIiBeXiBQLmdyb3VwIChQcmV0dHkucHB0eSB4KSBeXlxuICAgICBQLnN0cmluZyBcIlxcbjo6IFwiIF5eIHByZXR0eV9zdG9yZSAobi0xLCB4cylcbjs7XG5cbnR5cGUgJ2Egb3J2YWwgID0gVmFsdWUgfCBSdW5uaW5nIG9mICdhOztcbnR5cGUgJ2EgaW50ZXJwTSA9IHN0b3JlIC0+IHN0b3JlICogKCdhLCBQLmRvY3VtZW50KSByZXN1bHQ7O1xudHlwZSAnYSBzdGVwTSA9ICgnYSBpbnRlcnBNKSBvcnZhbFxuXG5sZXQgYmluZCBtIGsgc3RvID0gbWF0Y2ggbSBzdG8gd2l0aFxuICB8IChzdG8sIE9rIHgpIC0+IGsgeCBzdG9cbiAgfCAoc3RvLCBFcnJvciBlKSAtPiAoc3RvLCBFcnJvciBlKVxubGV0IHJldCB4IHN0byA9IChzdG8sIE9rIHgpXG5sZXQgZm1hcCBmIG0gPSBiaW5kIG0gKGZ1biB4IC0+IHJldCAoZiB4KSlcbiAgICAgICAgICAgICBcbmxldCBmYWlsdXJlIDogUC5kb2N1bWVudCAtPiB0bSBpbnRlcnBNID1cbiAgZnVuIGUgc3RvIC0+IChzdG8sIEVycm9yIGUpXG5sZXQgcnVubWFwIGYgb3YgPSBtYXRjaCBvdiB3aXRoXG4gIHwgVmFsdWUgLT4gVmFsdWVcbiAgfCBSdW5uaW5nIHggLT4gUnVubmluZyAoZiB4KTs7XG5cbmxldCBub3BlIHMgPSBmYWlsdXJlIChQLnN0cmluZyBcIlNob3VsZG4ndCBoYXBwZW46XCIgXi9eIFAuc3RyaW5nIHMpOztcblxubGV0IGFsbG9jYXRlIDogZ3R5cGUgLT4gc2VhbCBpbnRlcnBNID0gXG4gIGZ1biB0eSAobGVuLCB0eXMpIC0+ICgobGVuICsgMSwgdHkgOjogdHlzKSwgT2sgKGxlbiArIDEpKTs7XG5sZXQgZGVyZWYgOiBzZWFsIC0+IGd0eXBlIGludGVycE0gPVxuICBsZXQgcmVjIGxvb3AgOiBpbnQgLT4gZ3R5cGUgbGlzdCAtPiAoZ3R5cGUsIGRvY3VtZW50KSByZXN1bHQgPVxuICAgIGZ1biBzbCB0eXMgLT5cbiAgICBtYXRjaCAoc2wsIHR5cykgd2l0aFxuICAgIHwgKDAsIHR5IDo6IF90eXMpIC0+IE9rIHR5XG4gICAgfCAobiwgX3R5IDo6IHR5cykgLT4gbG9vcCAobi0xKSB0eXNcbiAgICB8IF8gLT4gRXJyb3IgKFAuc3RyaW5nIFwidHJpZWQgdG8gbG9va3VwIGEgc2VhbCB0aGF0IHdhc24ndCBhbGxvY2F0ZWRcIilcbiAgaW4gZnVuIHNsIChsZW4sIHR5cykgLT4gKChsZW4sIHR5cyksIGxvb3Agc2wgdHlzKTs7XG5cbigqIHN0ZXAgOiB0bSAtPiAoc3RvcmUgLT4gc3RvcmUgKiB0bSByZXN1bHQpIG9ydmFsICopXG5cbmxldCBhcHBseUNhc3RzIHNsIChjc3RzIDogKHN0cmluZyAqIHByZWNpc2lvbiAqIGRpcikgbGlzdCkgKHQgOiB0bSkgPVxuICBMaXN0LmZvbGRfcmlnaHQgKGZ1biAodHlYLCBwLCBkKSB0IC0+IENhc3QgKHNsc3Vic3RwcmVjIHNsIHR5WCBwLCBkLCB0KSkgY3N0cyB0OztcblxubGV0IHJlYyBzdGVwIDogdG0gLT4gKHRtIGludGVycE0pIG9ydmFsID0gZnVuY3Rpb25cbiAgfCBUbVZhciB4IC0+IFJ1bm5pbmcgKG5vcGUgKFwidW5ib3VuZCB2YXJpYWJsZTogXCIgXiB4KSlcbiAgfCBMZXQgKHQsIHgsIHRrKSAtPiBSdW5uaW5nIChcbiAgICAgbWF0Y2ggc3RlcCB0IHdpdGhcbiAgICAgfCBWYWx1ZSAtPiByZXQgKHN1YnN0IHQgeCB0aylcbiAgICAgfCBSdW5uaW5nIHIgLT4gZm1hcCAoZnVuIHQnIC0+IExldCAodCcsIHgsIHRrKSkgcilcbiAgfCBTZWFsaW5qICh0eSwgbSkgLT4gcnVubWFwIChmbWFwIChmdW4gbScgLT4gU2VhbGluaiAodHksIG0nKSkpIChzdGVwIG0pXG4gIHwgU2VhbHByaiAodHksIG0pIC0+IFJ1bm5pbmcgKFxuICAgICBtYXRjaCBzdGVwIG0gd2l0aFxuICAgICB8IFJ1bm5pbmcgciAtPiBmbWFwIChmdW4gbScgLT4gU2VhbHByaiAodHksIG0nKSkgclxuICAgICB8IFZhbHVlIC0+XG4gICAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICB8IFNlYWxpbmogKF90eScsIHYpIC0+IHJldCB2XG4gICAgICAgIHwgXyAtPiBub3BlIFwic2VhbHByaiBvZiBub24tc2VhbFwiKVxuICB8IEludCBfbiAtPiBWYWx1ZVxuICB8IFBsdXMgKHRsLCB0cikgLT4gUnVubmluZyAoXG4gICAgIG1hdGNoIHN0ZXAgdGwgd2l0aFxuICAgICB8IFJ1bm5pbmcgciAtPiBmbWFwIChmdW4gdGwnIC0+IFBsdXMgKHRsJywgdHIpKSByXG4gICAgIHwgVmFsdWUgLT5cbiAgICAgbWF0Y2ggc3RlcCB0ciB3aXRoXG4gICAgIHwgUnVubmluZyByIC0+IGZtYXAgKGZ1biB0cicgLT4gUGx1cyAodGwsIHRyJykpIHJcbiAgICAgfCBWYWx1ZSAtPlxuICAgICBtYXRjaCAodGwsIHRyKSB3aXRoXG4gICAgIHwgKEludCBubCwgSW50IG5yKSAtPiByZXQgKEludCAobmwgKyBucikpXG4gICAgIHwgXyAtPiBub3BlIFwiYWRkZWQgbm9uIGludHNcIilcbiAgfCBCb29sbGl0IF9iIC0+IFZhbHVlXG4gIHwgSWYgKGIsdCxmKSAtPiBSdW5uaW5nIChcbiAgICAgbWF0Y2ggc3RlcCBiIHdpdGhcbiAgICAgfCBSdW5uaW5nIHIgLT4gZm1hcCAoZnVuIGInIC0+IElmIChiJywgdCwgZikpIHJcbiAgICAgfCBWYWx1ZSAtPlxuICAgICAgICBtYXRjaCBiIHdpdGhcbiAgICAgICAgfCBCb29sbGl0IGIgLT4gaWYgYiB0aGVuIHJldCB0IGVsc2UgcmV0IGZcbiAgICAgICAgfCBfIC0+IG5vcGUgXCJpZiBvZiBhIG5vbi1ib29sXCIpXG4gIHwgUGFpciAodDEsIHQyKSAtPlxuICAgICBiZWdpbiBtYXRjaCBzdGVwIHQxIHdpdGhcbiAgICAgfCBSdW5uaW5nIHIgLT4gUnVubmluZyAoZm1hcCAoZnVuIHQxJyAtPiBQYWlyICh0MScsIHQyKSkgcilcbiAgICAgfCBWYWx1ZSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBzdGVwIHQyIHdpdGhcbiAgICAgICAgfCBSdW5uaW5nIHIgLT4gUnVubmluZyAoZm1hcCAoZnVuIHQyJyAtPiBQYWlyICh0MSwgdDInKSkgcilcbiAgICAgICAgfCBWYWx1ZSAtPiBWYWx1ZVxuICAgICAgICBlbmRcbiAgICAgZW5kXG4gIHwgUG1QYWlyICh0cCx4MSx4Mix0aykgLT4gUnVubmluZyAoXG4gICAgIGJlZ2luIG1hdGNoIHN0ZXAgdHAgd2l0aFxuICAgICB8IFJ1bm5pbmcgciAtPiBmbWFwIChmdW4gdHAnIC0+IFBtUGFpciAodHAnLCB4MSx4Mix0aykpIHJcbiAgICAgfCBWYWx1ZSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCB0cCB3aXRoXG4gICAgICAgIHwgUGFpciAodjEsdjIpIC0+IHJldCAoc3Vic3QgdjEgeDEgKHN1YnN0IHYyIHgyIHRrKSlcbiAgICAgICAgfCBfIC0+IG5vcGUgXCJwYWlyIHBhdHRlcm4gbWF0Y2ggb24gbm9uLXBhaXJcIlxuICAgICAgICBlbmRcbiAgICAgZW5kKVxuICB8IEZ1biBfIC0+IFZhbHVlXG4gIHwgRnVuQXBwICh0ZiwgdGEpIC0+IFJ1bm5pbmcgKFxuICAgICBiZWdpbiBtYXRjaCBzdGVwIHRmIHdpdGhcbiAgICAgfCBSdW5uaW5nIHIgLT4gZm1hcCAoZnVuIHRmJyAtPiBGdW5BcHAgKHRmJywgdGEpKSByXG4gICAgIHwgVmFsdWUgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RlcCB0YSB3aXRoXG4gICAgICAgIHwgUnVubmluZyByIC0+IGZtYXAgKGZ1biB0YScgLT4gRnVuQXBwICh0ZiwgdGEnKSkgclxuICAgICAgICB8IFZhbHVlIC0+XG4gICAgICAgICAgIGJlZ2luIG1hdGNoIHRmIHdpdGhcbiAgICAgICAgICAgfCBGdW4gKHgsXyx0Ym9kKSAtPiByZXQgKHN1YnN0IHRhIHggdGJvZClcbiAgICAgICAgICAgfCBDYXN0IChGdW5QcmVjIChpbnAsIG91dHApLCBkLCB2KSAtPlxuICAgICAgICAgICAgICByZXQgKENhc3QgKG91dHAsIGQsIEZ1bkFwcCAodiwgQ2FzdCAoaW5wLCBjb21wbGVtZW50IGQsIHRhKSkpKVxuICAgICAgICAgICB8IF8gLT4gbm9wZSBcIm5vbi1mdW5jdGlvbi9wcm94eSBpbiBmdW5jdGlvbiBhcHBsaWNhdGlvbiBwb3NpdGlvblwiXG4gICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgZW5kKVxuICB8IFBhY2sgKHR5WCx0eSxtKSAtPiBSdW5uaW5nIChyZXQgKENhc3RQYWNrICh0eVgsIHR5LCBbXSwgbSkpKVxuICB8IENhc3RQYWNrIChfdHlYLCBfdHksIF9jc3RzLCBfbSkgLT4gVmFsdWVcbiAgfCBVbnBhY2sgKGUsdHlYLHgsbWspIC0+IFJ1bm5pbmcgKFxuICAgICBiZWdpbiBtYXRjaCBzdGVwIGUgd2l0aFxuICAgICB8IFJ1bm5pbmcgciAtPiBmbWFwIChmdW4gZScgLT4gVW5wYWNrIChlJyx0eVgseCxtaykpIHJcbiAgICAgfCBWYWx1ZSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBlIHdpdGhcbiAgICAgICAgfCBDYXN0UGFjayAodHlYJywgdHksIGNzdHMsIHRib2QpIC0+XG4gICAgICAgICAgIGJpbmQgKGFsbG9jYXRlIHR5KSAoZnVuIHNsIC0+XG4gICAgICAgICAgICAgICByZXQgKExldCAoYXBwbHlDYXN0cyBzbCBjc3RzIChzbHN1YnN0IHNsIHR5WCcgdGJvZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBzbHN1YnN0IHNsIHR5WCBtaykpKVxuICAgICAgICB8IF8gLT4gbm9wZSBcInRyaWVkIHRvIHVucGFjayBhIG5vbi1wYWNrXCJcbiAgICAgICAgZW5kXG4gICAgIGVuZClcbiAgfCBCaWdMYW1iZGEgKF8gLCBfKSAtPiBWYWx1ZVxuICB8IEluc3QgKHQsIG5tLCBhKSAtPiBSdW5uaW5nIChcbiAgICAgYmVnaW4gbWF0Y2ggc3RlcCB0IHdpdGhcbiAgICAgfCBSdW5uaW5nIHIgLT4gZm1hcCAoZnVuIHQnIC0+IEluc3QgKHQnLCBubSwgYSkpIHJcbiAgICAgfCBWYWx1ZSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCAodCwgbm0pIHdpdGhcbiAgICAgICAgfCAoXywgVmFyTmFtZSB0eVgpIC0+IG5vcGUgKFwiZnJlZSB0eXBlIHZhcmlhYmxlOiBcIiBeIHR5WClcbiAgICAgICAgfCAoQmlnTGFtYmRhICh0eVgsIHRib2QpLCBTZWFsTmFtZSBzbCkgLT4gcmV0IChzbHN1YnN0IHNsIHR5WCB0Ym9kKVxuICAgICAgICB8IChDYXN0IChGcmZvcmFsbFByZWMgKHR5WCwgcCksIGQsIHQpLCBTZWFsTmFtZSBzbCkgLT5cbiAgICAgICAgICAgcmV0IChDYXN0IChzbHN1YnN0cHJlYyBzbCB0eVggcCwgZCwgSW5zdCAodCwgU2VhbE5hbWUgc2wsIGEpKSlcbiAgICAgICAgfCAoXyxfKSAtPiBub3BlIChcInRyaWVkIHRvIGluc3RhbnRpYXRlIGEgbm9uLUxhbWJkYS9wcm94eVwiKVxuICAgICAgICBlbmRcbiAgICAgZW5kKVxuICB8IEhpZGUgKHR5WCwgYSwgdCkgLT5cbiAgICAgUnVubmluZyAoYmluZCAoYWxsb2NhdGUgYSkgKGZ1biBzbCAtPiByZXQgKHNsc3Vic3Qgc2wgdHlYIHQpKSlcbiAgfCBDYXN0IChwcmVjLCBkLCB0KSAtPlxuICAgICBiZWdpbiBtYXRjaCBzdGVwIHQgd2l0aFxuICAgICB8IFJ1bm5pbmcgciAtPiBSdW5uaW5nIChmbWFwIChmdW4gdCcgLT4gQ2FzdCAocHJlYywgZCwgdCcpKSByKVxuICAgICB8IFZhbHVlIC0+IGNzdHN0ZXAgdCBkIHByZWNcbiAgICAgZW5kXG4gIHwgRGluaiAoZywgdCkgLT5cbiAgICAgYmVnaW4gbWF0Y2ggc3RlcCB0IHdpdGhcbiAgICAgfCBWYWx1ZSAtPiBWYWx1ZVxuICAgICB8IFJ1bm5pbmcgciAtPiBSdW5uaW5nIChmbWFwIChmdW4gdCcgLT4gRGluaiAoZywgdCcpKSByKVxuICAgICBlbmRcbiAgfCBIYXNUYWcgKGcsIHQpIC0+XG4gICAgIFJ1bm5pbmcgYmVnaW4gbWF0Y2ggc3RlcCB0IHdpdGhcbiAgICAgICB8IFJ1bm5pbmcgciAtPiBmbWFwIChmdW4gdCcgLT4gSGFzVGFnIChnLCB0JykpIHJcbiAgICAgICB8IFZhbHVlIC0+IGJlZ2luIG1hdGNoIHQgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBEaW5qIChnJywgXykgLT5cbiAgICAgICAgICAgICAgICAgICAgIHJldChpZiBnID0gZydcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIEJvb2xsaXQgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgQm9vbGxpdCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIHwgXyAtPiBub3BlIFwiaGFzLXRhZyBvbiBzb21ldGhpbmcgdGhhdCB3YXNuJ3QgYSBkeW4gaW5qLlwiXG4gICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICBlbmRcbmFuZCBjc3RzdGVwIHYgZCBwID0gbWF0Y2ggcCB3aXRoXG4gIHwgRHluUmVmbCB8IE5hbWVSZWZsIF8gfCBCb29sUmVmbCB8IE51bVJlZmwgLT4gUnVubmluZyAocmV0IHYpXG4gIHwgRnVuUHJlYyBfIHwgRnJmb3JhbGxQcmVjIF8gLT4gVmFsdWVcbiAgfCBEeW5JbmogKGcsIHByZWMpIC0+XG4gICAgIGJlZ2luIG1hdGNoIGQgd2l0aFxuICAgICB8IFVwICAgLT4gUnVubmluZyAocmV0IChEaW5qIChnLCBDYXN0IChwcmVjLCBVcCwgdikpKSlcbiAgICAgfCBEb3duIC0+XG4gICAgICAgIFJ1bm5pbmcgXG4gICAgICAgIGJlZ2luIG1hdGNoIHYgd2l0aFxuICAgICAgICB8IERpbmogKGcnLCB2KSAtPlxuICAgICAgICAgICBpZiBnID0gZydcbiAgICAgICAgICAgdGhlbiByZXQgKENhc3QgKHByZWMsIERvd24sIHYpKVxuICAgICAgICAgICBlbHNlIGZhaWx1cmUgUFByaW50LihzdHJpbmcgXCJUcmllZCB0byBjYXN0IHNvbWV0aGluZyB3aXRoIHRhZ1wiIF4vXiBQcmV0dHkucHB0YWcgZycgXi9eIHN0cmluZyBcInRvIGEgdHlwZSB3aXRoIHRhZ1wiIF4vXiBQcmV0dHkucHB0YWcgZylcbiAgICAgICAgfCBfIC0+IG5vcGUgXCJkeW4gZG93bmNhc3Qgb24gbm9uLWR5biB2YWx1ZVwiXG4gICAgICAgIGVuZFxuICAgICBlbmRcbiAgfCBQcm9kUHJlYyAocDEsIHAyKSAtPlxuICAgICBSdW5uaW5nIGJlZ2luIG1hdGNoIHYgd2l0aFxuICAgICB8IFBhaXIgKHYxLCB2MikgLT4gcmV0IChQYWlyIChDYXN0IChwMSwgZCwgdjEpLCBDYXN0IChwMiwgZCwgdjIpKSlcbiAgICAgfCBfIC0+IG5vcGUgXCJwcm9kIGNhc3Qgb24gbm9uLXBhaXIgdmFsdWVcIlxuICAgICBlbmRcbiAgfCBGcmV4aXN0c1ByZWMgKHR5WCwgcCkgLT5cbiAgICAgUnVubmluZyBiZWdpbiBtYXRjaCB2IHdpdGhcbiAgICAgfCBDYXN0UGFjayAodHlZLCB0eSwgY2FzdHMsIG0pIC0+XG4gICAgICAgIHJldCAoQ2FzdFBhY2sgKHR5WSwgdHksICh0eVgsIHAsIGQpIDo6IGNhc3RzLCBtKSlcbiAgICAgfCBfIC0+IG5vcGUgXCJleGlzdGVudGlhbCBjYXN0IG9uIG5vbi1jYXN0cGFja1wiXG4gICAgICAgZW5kXG4gIDs7XG5cbmxldCBpbml0X3N0b3JlIDogc3RvcmUgPSAoMCwgW10pXG5cbmxldCBiaWdfc3RlcCA6IHRtIC0+ICh0bSwgUC5kb2N1bWVudCkgcmVzdWx0ID0gZnVuIHQgLT5cbiAgbGV0IHJlYyBsb29wIHQgc3QgPSBcbiAgICBtYXRjaCBzdGVwIHQgd2l0aFxuICAgIHwgVmFsdWUgLT4gT2sgdFxuICAgIHwgUnVubmluZyBrIC0+XG4gICAgICAgYmVnaW4gbWF0Y2ggayBzdCB3aXRoXG4gICAgICAgfCAoXywgRXJyb3IgZSkgLT4gRXJyb3IgZVxuICAgICAgIHwgKHN0LCBPayB0KSAtPiBsb29wIHQgc3RcbiAgICAgICBlbmRcbiAgaW4gbG9vcCB0IGluaXRfc3RvcmVcbiIsIlxubGV0IHVuc2VlYWJsZSA9IFwidW5wYWNrIDxZLCB5PiA9IHBhY2s8WCA9fiBib29sLCBzZWFsIFggI3RydWU+IGluIHkgOjogP1wiXG5sZXQgZmFpbHVyZV90b19zZWUgPSB1bnNlZWFibGUgXiBcIiA6OiBib29sXCJcblxubGV0IGJvb2wgPSBcImxldCB4ID0gI3RydWUgaW4gaWYgeCB0aGVuICNmYWxzZSBlbHNlIHhcIlxuXG5sZXQgcGFpciA9IFwibGV0ICh4LHkpID0gKCN0cnVlLCAjZmFsc2UpIGluICh4LCBpZiB5IHRoZW4geCBlbHNlIHkpXCJcblxubGV0IGV4aXN0X2Z1biA9XG4gIFwidW5wYWNrIDxZLCB5PiA9IHBhY2s8WCA9fiBib29sLCAobGFtYmRhIHggOiBYLiB1bnNlYWwgWCB4LCBzZWFsIFggI3RydWUpPiBpbiBsZXQgKGYsIGIpID0geSBpbiBmIGJcIlxuXG5sZXQgZXhfaW5jb21wYXQgPVxuICBcImxldCBmID0gbGFtYmRhIGIgOiBib29sLiBwYWNrPFggPX4gYm9vbCwgc2VhbCBYIGI+IGluXG4gICB1bnBhY2sgPFksIHk+ID0gZiAjdHJ1ZSBpblxuICAgdW5wYWNrIDxaLCB6PiA9IGYgI2ZhbHNlIGluXG4gICB5IDo6ID8gOjogWiA6OiA/XCJcblxubGV0IGZ1bl9jYXN0ID1cbiAgXCJsZXQgZiA9IChsYW1iZGEgYiA6IGJvb2wuIChiLCBiKSkgOjogPyAtPiA/IGluIGYgI3RydWVcIlxuXG5cbmxldCBwYXBlcl8xX25vc2VhbCA9XG4gIFwiKChMYW1iZGEgWC4gbGFtYmRhIHggOiBYLiB4KSB7WCA9fiBpbnR9IDEpICsgM1wiXG5sZXQgcGFwZXJfMV9zZWFsID1cbiAgXCJ1bnNlYWwgWCAoKExhbWJkYSBYLiBsYW1iZGEgeCA6IFguIHgpIHtYID1+IGludH0gKHNlYWwgWCAxKSkgKyAzXCJcblxubGV0IHBhcGVyXzJfbm9zZWFsID1cbiAgXCIoKExhbWJkYSBYLiBsYW1iZGEgeCA6IFguIHgpIDo6ID8pIHtYID1+IGludH0gI3RydWVcIlxubGV0IHBhcGVyXzJfc2VhbCA9XG4gIFwidW5zZWFsIFggKCgoTGFtYmRhIFguIGxhbWJkYSB4IDogWC4geCkgOjogPykge1ggPX4gaW50fSAoc2VhbCBYICN0cnVlKSlcIlxuXG5sZXQgcGFwZXJfM19ub3NlYWwgPVxuICBcIigoTGFtYmRhIFguIGxhbWJkYSB4IDogWC4geCkgOjogZm9yYWxsIFguID8gLT4gWCkge1ggPX4gaW50fSA1XCJcbmxldCBwYXBlcl8zX3NlYWwgPVxuICBcInVuc2VhbCBYICgoKExhbWJkYSBYLiBsYW1iZGEgeCA6IFguIHgpIDo6IGZvcmFsbCBYLiA/IC0+IFgpIHtYID1+IGludH0gKHNlYWwgWCA1KSlcIlxuXG5sZXQgcGFwZXJfNF9ub3NlYWwgPVxuICBcIigoTGFtYmRhIFguIGxhbWJkYSB4IDogWC4gI3RydWUpIDo6IGZvcmFsbCBYLiA/IC0+IGJvb2wpIHtYID1+IGludH0gNVwiXG5sZXQgcGFwZXJfNF9zZWFsID1cbiAgXCIoKExhbWJkYSBYLiBsYW1iZGEgeCA6IFguICN0cnVlKSA6OiBmb3JhbGwgWC4gPyAtPiBib29sKSB7WCA9fiBpbnR9IChzZWFsIFggNSlcIlxuXG5sZXQgcGFwZXJfNV9ub3NlYWwgPVxuICBcIigoTGFtYmRhIFguIGxhbWJkYSB4IDogWC4gI3RydWUpIDo6IGZvcmFsbCBYLiA/IC0+IGJvb2wpIHtYID1+IGJvb2x9IDVcIlxuXG5sZXQgcGFwZXJfNV9zZWFsID1cbiAgXCIoKExhbWJkYSBYLiBsYW1iZGEgeCA6IFguICN0cnVlKSA6OiBmb3JhbGwgWC4gPyAtPiBib29sKSB7WCA9fiBib29sfSAoc2VhbCBYIDUpXCJcblxubGV0IHBhcGVyXzZfbm9zZWFsID1cbiAgXCIoKExhbWJkYSBYLiBsYW1iZGEgeCA6ID8uICN0cnVlKSA6OiBmb3JhbGwgWC4gPyAtPiBib29sKSB7WCA9fiBib29sfSA1XCJcbmxldCBwYXBlcl82X3NlYWwgPVxuICBcIigoTGFtYmRhIFguIGxhbWJkYSB4IDogPy4gI3RydWUpIDo6IGZvcmFsbCBYLiA/IC0+IGJvb2wpIHtYID1+IGJvb2x9IChzZWFsIFggNSlcIlxuXG5cbmxldCBnb29kX2lkX2luaXQgPSBcImxldCBpZCA9IChMYW1iZGEgWC4gbGFtYmRhIHggOiBYLiB4KSBpblxcblwiXG5sZXQgYmFkX2lkX2luaXQgPSBcImxldCBiYWRfaWQgPSAoTGFtYmRhIFguIGxhbWJkYSB4IDogWC4gI3RydWUgOjogPyA6OiBYKSBpblxcblwiXG5sZXQgaWRfa18xIG5tID0gXCJ1bnNlYWwgWCAoXCJebm1eXCIge1ggPX4gYm9vbH0gKHNlYWwgWCAjdHJ1ZSkpXCJcbmxldCBpZF9rXzIgbm0gPSBcImxldCB5ID0gXCJebm1eXCIge1ggPX4gaW50fSAoc2VhbCBYIDUpIGluXFxuI3RydWVcIlxuXG4gICAgICAgICAgICAgICAgIFxubGV0IGlkXzEgPSBnb29kX2lkX2luaXQgXiBpZF9rXzEgXCJpZFwiXG5sZXQgaWRfMiA9IGdvb2RfaWRfaW5pdCBeIGlkX2tfMiBcImlkXCJcbmxldCBiYWRfaWRfMSA9IGJhZF9pZF9pbml0IF4gaWRfa18xIFwiYmFkX2lkXCJcbmxldCBiYWRfaWRfMiA9IGJhZF9pZF9pbml0IF4gaWRfa18yIFwiYmFkX2lkXCJcblxubGV0IGdvb2Rfc3dhcF9pbml0ID0gXCJsZXQgc3dhcCA9IChMYW1iZGEgWC4gTGFtYmRhIFkuIGxhbWJkYSBwIDogWCAqIFkuIGxldCAoeCx5KSA9IHAgaW4gKHkseCkpIGluXFxuXCJcblxubGV0IGJhZF9zd2FwX2luaXQgPSBcImxldCBiYWRfc3dhcCA9IChMYW1iZGEgWC4gTGFtYmRhIFkuIGxhbWJkYSBwIDogWCAqIFkuIGxldCAoeCwgeSkgPSBwIGluICh5LCB5IDo6ID8gOjogWCkpIGluXFxuXCJcblxubGV0IHN3YXBfa18xIG5tID0gXCJsZXQgKHkseCkgPSBcIl5ubV5cIiB7WCA9fiBib29sfXtZID1+IGludH0oc2VhbCBYICN0cnVlLCBzZWFsIFkgNDIpIGluXFxuKHVuc2VhbCBYIHgsIHVuc2VhbCBZIHkpXCJcblxubGV0IHN3YXBfa18yIG5tID0gXCJsZXQgKHkseCkgPSBcIl5ubV5cIiB7WCA9fiBpbnR9e1kgPX4gYm9vbH0oc2VhbCBYIDQyLCBzZWFsIFkgI3RydWUpIGluXFxuKHVuc2VhbCBZIHksIHVuc2VhbCBYIHgpXCJcblxubGV0IHN3YXBfMSA9IGdvb2Rfc3dhcF9pbml0IF4gc3dhcF9rXzEgXCJzd2FwXCJcbmxldCBzd2FwXzIgPSBnb29kX3N3YXBfaW5pdCBeIHN3YXBfa18yIFwic3dhcFwiXG5sZXQgYmFkX3N3YXBfMSA9IGJhZF9zd2FwX2luaXQgXiBzd2FwX2tfMSBcImJhZF9zd2FwXCJcbmxldCBiYWRfc3dhcF8yID0gYmFkX3N3YXBfaW5pdCBeIHN3YXBfa18yIFwiYmFkX3N3YXBcIlxuICBcbmxldCBnb29kX2ZsaXBwZXJfYyBmID1cbiAgXCJsZXQgbm90ID0gbGFtYmRhIGIgOiBib29sLiBpZiBiIHRoZW4gI2ZhbHNlIGVsc2UgI3RydWUgaW5cXG51bnBhY2sgPFgscD4gPSBcIlxuICBeIGYgXiBcImluXFxubGV0IChpbml0LHAnKSA9IHAgaW5cXG5sZXQgKGZsaXAsIHJlYWQpID0gcCcgaW5cXG4ocmVhZCBpbml0LCByZWFkIChmbGlwIGluaXQpKVwiXG5sZXQgYmFkX2ZsaXBwZXJfYyBmID1cbiAgXCJsZXQgbm90ID0gbGFtYmRhIGIgOiBib29sLiBpZiBiIHRoZW4gI2ZhbHNlIGVsc2UgI3RydWUgaW5cXG51bnBhY2sgPFgscD4gPSBcIlxuICBeIGYgXlxuICBcImluXFxubGV0IChpbml0LHAnKSA9IHAgaW5cXG5sZXQgKGZsaXAsIHJlYWQpID0gcCcgaW5cXG5yZWFkIChmbGlwICgjdHJ1ZSA6OiA/IDo6IFgpKVwiXG5cbmxldCBmbGlwcGVyX3BfMSA9XG4gIFwicGFjayA8WCA9fiBib29sLCAoc2VhbCBYICN0cnVlLCAobGFtYmRhIHggOiBYLiBzZWFsIFggKG5vdCAodW5zZWFsIFggeCkpLCBsYW1iZGEgeCA6IFguIHVuc2VhbCBYIHgpKT5cIlxuXG5sZXQgZmxpcHBlcl9wXzIgPVxuICBcInBhY2sgPFggPX4gYm9vbCwgKHNlYWwgWCAjZmFsc2UsIChsYW1iZGEgeCA6IFguIHNlYWwgWCAobm90ICh1bnNlYWwgWCB4KSksIGxhbWJkYSB4IDogWC4gbm90ICh1bnNlYWwgWCB4KSkpPlwiXG4gICAgXG5sZXQgZmxpcHBlcl8xID0gZ29vZF9mbGlwcGVyX2MgZmxpcHBlcl9wXzFcbmxldCBmbGlwcGVyXzIgPSBnb29kX2ZsaXBwZXJfYyBmbGlwcGVyX3BfMlxubGV0IGJhZF9mbGlwcGVyXzEgPSBiYWRfZmxpcHBlcl9jIGZsaXBwZXJfcF8xXG5sZXQgYmFkX2ZsaXBwZXJfMiA9IGJhZF9mbGlwcGVyX2MgZmxpcHBlcl9wXzJcbiIsIlxudHlwZSBzdXBwbHkgPSBpbnQgcmVmXG5bQEBkZXJpdmluZyBzaG93XVxuOztcblxubGV0IGluaXRfc3VwcGx5ICgpID0gcmVmIDA7O1xuXG5sZXQgdHlWYXIgc3VwcCA9XG4gIGxldCBuID0gIXN1cHAgaW5cbiAgc3VwcCA6PSBuKzE7IChcImZyZXNoXCIgXiBzdHJpbmdfb2ZfaW50IG4pOztcbiAgXG4iLCJ0eXBlIHNlYWwgPSBpbnRcbltAQGRlcml2aW5nIHNob3csIGVxXVxuOztcbnR5cGUgdHluYW1lID0gU2VhbE5hbWUgb2Ygc2VhbCB8IFZhck5hbWUgb2Ygc3RyaW5nXG5bQEBkZXJpdmluZyBzaG93LCBlcV1cblxudHlwZSB0YWd0eSA9IE5hbWV0YWcgb2YgdHluYW1lIHwgQm9vbHRhZyB8IE51bXRhZyB8IFByb2R0YWcgfCBGdW50YWcgfCBFeHRhZyB8IEFsbHRhZ1xuW0BAZGVyaXZpbmcgc2hvdywgZXFdXG47O1xuXG50eXBlIGd0eXBlICA9XG4gIHwgTmFtZSBvZiB0eW5hbWUgXG4gIHwgRHluIHwgQm9vbCB8IE51bVxuICB8IFRpbWVzIG9mIGd0eXBlICogZ3R5cGVcbiAgfCBGdW4gb2YgZ3R5cGUgKiBndHlwZVxuICB8IEZyZXhpc3RzIG9mIHN0cmluZyAqIGd0eXBlXG4gIHwgRnJmb3JhbGwgb2Ygc3RyaW5nICogZ3R5cGVcbltAQGRlcml2aW5nIHNob3csIGVxXVxuOztcblxubGV0IHR5dmFyIHggPSBOYW1lIChWYXJOYW1lIHgpXG5cbmxldCByZWMgcmVuYW1lVHlWYXIgfmZyb206ZnJvbVR5IH50b286dG9UeSBzdXBwID1cbiAgbGV0IHJlYyBmIHR5ID0gbWF0Y2ggdHkgd2l0aFxuICAgIHwgTmFtZSAoU2VhbE5hbWUgXykgfCBEeW4gfCBCb29sIHwgTnVtIC0+IHR5XG4gICAgfCBOYW1lIChWYXJOYW1lIHR5WikgLT4gTmFtZSAoVmFyTmFtZSAoaWYgdHlaID0gZnJvbVR5IHRoZW4gdG9UeSBlbHNlIHR5WikpXG4gICAgfCBUaW1lcyAoYSxiKSAtPiBUaW1lcyAoZiBhLCBmIGIpXG4gICAgfCBGdW4gKGEsIGIpIC0+IEZ1biAoZiBhLCBmIGIpXG4gICAgfCBGcmV4aXN0cyAodHlaLCBhKSAtPiAoKiBxdWFkcmF0aWMgcGVyZj8gKilcbiAgICAgICBsZXQgdHlaJyA9IEZyZXNoLnR5VmFyIHN1cHAgaW5cbiAgICAgICBGcmV4aXN0cyAodHlaJywgZiAocmVuYW1lVHlWYXIgfmZyb206dHlaIH50b286dHlaJyBzdXBwIGEpKVxuICAgIHwgRnJmb3JhbGwgKHR5WiwgYSkgLT4gKCogcXVhZHJhdGljIHBlcmY/ICopXG4gICAgICAgbGV0IHR5WicgPSBGcmVzaC50eVZhciBzdXBwIGluXG4gICAgICAgRnJmb3JhbGwgKHR5WicsIGYgKHJlbmFtZVR5VmFyIH5mcm9tOnR5WiB+dG9vOnR5Wicgc3VwcCBhKSlcbiAgaW4gZlxuOztcblxuKCogaW52YXJpYW50OiB0aGUgaW50IGlzIHRoZSBsZW5ndGggb2YgdGhlIGxpc3QgKilcbmxldCB0eXBfZnJvbV90YWcgPSBmdW5jdGlvblxuICB8IE5hbWV0YWcgbm0gLT4gTmFtZSBubVxuICB8IEJvb2x0YWcgLT4gQm9vbFxuICB8IE51bXRhZyAtPiBOdW1cbiAgfCBQcm9kdGFnIC0+IFRpbWVzIChEeW4sIER5bilcbiAgfCBGdW50YWcgIC0+IEZ1biAoRHluLER5bilcbiAgfCBFeHRhZyAgIC0+IEZyZXhpc3RzIChcIl9cIiwgRHluKVxuICB8IEFsbHRhZyAgIC0+IEZyZm9yYWxsIChcIl9cIiwgRHluKVxuOztcblxudHlwZSBwcmVjaXNpb24gPVxuICBEeW5SZWZsIHwgRHluSW5qIG9mIHRhZ3R5ICogcHJlY2lzaW9uIHwgTmFtZVJlZmwgb2YgdHluYW1lXG4gIHwgQm9vbFJlZmwgfCBOdW1SZWZsXG4gIHwgUHJvZFByZWMgb2YgcHJlY2lzaW9uICogcHJlY2lzaW9uXG4gIHwgRnVuUHJlYyBvZiBwcmVjaXNpb24gKiBwcmVjaXNpb25cbiAgfCBGcmV4aXN0c1ByZWMgb2Ygc3RyaW5nICogcHJlY2lzaW9uXG4gIHwgRnJmb3JhbGxQcmVjIG9mIHN0cmluZyAqIHByZWNpc2lvblxuIFtAQGRlcml2aW5nIHNob3csIGVxXTs7XG5cbmxldCByZWMgcmVmbCA9IGZ1bmN0aW9uXG4gIHwgTmFtZSBubSAtPiBOYW1lUmVmbCBubVxuICB8IER5biAtPiBEeW5SZWZsXG4gIHwgQm9vbCAtPiBCb29sUmVmbFxuICB8IE51bSAtPiBOdW1SZWZsXG4gIHwgVGltZXMgKGEsYikgLT4gUHJvZFByZWMgKHJlZmwgYSwgcmVmbCBiKVxuICB8IEZ1biAoYSxiKSAtPiBGdW5QcmVjIChyZWZsIGEsIHJlZmwgYilcbiAgfCBGcmV4aXN0cyAoeCwgYSkgLT4gRnJleGlzdHNQcmVjICh4LCByZWZsIGEpXG4gIHwgRnJmb3JhbGwgKHgsIGEpIC0+IEZyZm9yYWxsUHJlYyAoeCwgcmVmbCBhKTs7XG5cbmxldCByZWMgZHluVG9wID0gZnVuY3Rpb25cbiAgfCBOYW1lIG5tIC0+IER5bkluaiAoTmFtZXRhZyBubSwgTmFtZVJlZmwgbm0pXG4gIHwgRHluIC0+IER5blJlZmxcbiAgfCBCb29sIC0+IER5bkluaiAoQm9vbHRhZywgQm9vbFJlZmwpXG4gIHwgTnVtIC0+IER5bkluaiAoTnVtdGFnLCBOdW1SZWZsKVxuICB8IFRpbWVzIChhLCBiKSAtPiBEeW5JbmogKFByb2R0YWcsIFByb2RQcmVjIChkeW5Ub3AgYSwgZHluVG9wIGIpKVxuICB8IEZ1biAoYSwgYikgLT4gRHluSW5qIChGdW50YWcsIEZ1blByZWMgKGR5blRvcCBhLCBkeW5Ub3AgYikpXG4gIHwgRnJleGlzdHMgKHgsIGEpIC0+IER5bkluaiAoRXh0YWcsIEZyZXhpc3RzUHJlYyAoeCwgZHluVG9wIGEpKVxuICB8IEZyZm9yYWxsICh4LCBhKSAtPiBEeW5JbmogKEFsbHRhZywgRnJmb3JhbGxQcmVjICh4LCBkeW5Ub3AgYSkpXG47O1xuXG4oKiAqKVxuKCogZm9yYWxsIGEgYiwgT3B0aW9uIChhL1xcYiAqIGEvXFxiIDw9IGEgKiBhL1xcYiA8PSBiKSAqKVxubGV0IG9iaW5kIG0gayA9IG1hdGNoIG0gd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGsgeDs7XG5cbmxldCByZWMgbWtNZWV0IGEgYiBzdXBwID1cbiAgbWF0Y2ggKGEsIGIpIHdpdGhcbiAgfCAoRHluLCBiKSAtPiBTb21lIChiLCBkeW5Ub3AgYiwgcmVmbCBiKVxuICB8IChhLCBEeW4pIC0+IFNvbWUgKGEsIHJlZmwgYSwgZHluVG9wIGEpXG4gIHwgKE5hbWUgKFZhck5hbWUgdHlYKSwgTmFtZSAoVmFyTmFtZSB0eVkpKSAtPlxuICAgICBpZiB0eVggPSB0eVkgdGhlbiBTb21lIChhLCByZWZsIGEsIHJlZmwgYSkgZWxzZSBOb25lXG4gIHwgKE5hbWUgKFNlYWxOYW1lIHNsKSwgTmFtZSAoU2VhbE5hbWUgc2wnKSkgLT4gXG4gICAgIGlmIHNsID0gc2wnIHRoZW4gU29tZSAoYSwgcmVmbCBhLCByZWZsIGEpIGVsc2UgTm9uZVxuICB8IChCb29sLCBCb29sKSAtPiBTb21lIChCb29sLCBCb29sUmVmbCwgQm9vbFJlZmwpXG4gIHwgKE51bSwgTnVtKSAtPiBTb21lIChOdW0sIE51bVJlZmwsIE51bVJlZmwpXG4gIHwgKFRpbWVzIChhMSwgYTIpLCBUaW1lcyAoYjEsIGIyKSkgLT5cbiAgICAgb2JpbmQgKG1rTWVldCBhMSBiMSBzdXBwKSAoZnVuIChjMSwgcDFsLCBwMXIpIC0+XG4gICAgIG9iaW5kIChta01lZXQgYTIgYjIgc3VwcCkgKGZ1biAoYzIsIHAybCwgcDJyKSAtPlxuICAgICBTb21lIChUaW1lcyAoYzEsIGMyKSwgUHJvZFByZWMgKHAxbCwgcDJsKSwgUHJvZFByZWMgKHAxciwgcDJyKSkpKVxuICB8IChGdW4gKGExLCBhMiksIEZ1biAoYjEsIGIyKSkgLT5cbiAgICAgb2JpbmQgKG1rTWVldCBhMSBiMSBzdXBwKSAoZnVuIChjMSwgcDFsLCBwMXIpIC0+XG4gICAgIG9iaW5kIChta01lZXQgYTIgYjIgc3VwcCkgKGZ1biAoYzIsIHAybCwgcDJyKSAtPlxuICAgICBTb21lIChUaW1lcyAoYzEsIGMyKSwgRnVuUHJlYyAocDFsLCBwMmwpLCBGdW5QcmVjIChwMXIsIHAycikpKSlcbiAgfCAoRnJleGlzdHMgKHR5WCwgYSksIEZyZXhpc3RzICh0eVksIGIpKSAtPlxuICAgICBsZXQgdHlaID0gRnJlc2gudHlWYXIgc3VwcCBpblxuICAgICBsZXQgYVpmb3JYID0gcmVuYW1lVHlWYXIgfmZyb206dHlYIH50b286dHlaIHN1cHAgYSBpblxuICAgICBsZXQgYlpmb3JZID0gcmVuYW1lVHlWYXIgfmZyb206dHlZIH50b286dHlaIHN1cHAgYiBpblxuICAgICBvYmluZCAobWtNZWV0IGFaZm9yWCBiWmZvclkgc3VwcCkgKGZ1biAoYywgcGEsIHBiKSAtPlxuICAgICBTb21lIChjLCBGcmV4aXN0c1ByZWMgKHR5WiwgcGEpLCBGcmV4aXN0c1ByZWMgKHR5WiwgcGIpKSlcbiAgfCAoRnJmb3JhbGwgKHR5WCwgYSksIEZyZm9yYWxsICh0eVksIGIpKSAtPlxuICAgICBsZXQgdHlaID0gRnJlc2gudHlWYXIgc3VwcCBpblxuICAgICBsZXQgYVpmb3JYID0gcmVuYW1lVHlWYXIgfmZyb206dHlYIH50b286dHlaIHN1cHAgYSBpblxuICAgICBsZXQgYlpmb3JZID0gcmVuYW1lVHlWYXIgfmZyb206dHlZIH50b286dHlaIHN1cHAgYiBpblxuICAgICBvYmluZCAobWtNZWV0IGFaZm9yWCBiWmZvclkgc3VwcCkgKGZ1biAoYywgcGEsIHBiKSAtPlxuICAgICBTb21lIChjLCBGcmZvcmFsbFByZWMgKHR5WiwgcGEpLCBGcmZvcmFsbFByZWMgKHR5WiwgcGIpKSlcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCBjaGVja0NvbnNpc3RlbnQgOiBndHlwZSAtPiBndHlwZSAtPiBGcmVzaC5zdXBwbHkgLT4gYm9vbCA9IGZ1biBhIGIgc3VwcCAtPlxuICBtYXRjaCBta01lZXQgYSBiIHN1cHAgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIF8gLT4gdHJ1ZTs7XG5cbigqIGxldCByZWMgbWtQcmVjaXNpb24gYSBiID1cbiAqICAgbWF0Y2ggKGEsIGIpIHdpdGhcbiAqICAgfCAoRHluLCBEeW4pID0gICopXG5sZXQgc2xzdWJzdG5hbWUgc2wgdHlYID0gZnVuY3Rpb25cbiAgfCBTZWFsTmFtZSBzbCcgLT4gU2VhbE5hbWUgc2wnXG4gIHwgVmFyTmFtZSB0eVkgLT4gaWYgdHlYID0gdHlZIHRoZW4gU2VhbE5hbWUgc2wgZWxzZSBWYXJOYW1lIHR5WTs7XG5sZXQgc2xzdWJzdHR5IHNsIHR5WCA9XG4gIGxldCByZWMgZiA9IGZ1bmN0aW9uXG4gICAgfCBOYW1lIG5tIC0+IE5hbWUgKHNsc3Vic3RuYW1lIHNsIHR5WCBubSlcbiAgICB8IER5biAtPiBEeW5cbiAgICB8IEJvb2wgLT4gQm9vbFxuICAgIHwgTnVtIC0+IE51bVxuICAgIHwgVGltZXMgKHR5MSwgdHkyKSAtPiBUaW1lcyAoZiB0eTEsIGYgdHkyKVxuICAgIHwgRnVuICh0eTEsIHR5MikgLT4gRnVuIChmIHR5MSwgZiB0eTIpXG4gICAgfCBGcmV4aXN0cyAodHlZLCB0eSkgLT4gRnJleGlzdHMgKHR5WSwgaWYgdHlYID0gdHlZIHRoZW4gdHkgZWxzZSBmIHR5KVxuICAgIHwgRnJmb3JhbGwgKHR5WSwgdHkpIC0+IEZyZm9yYWxsICh0eVksIGlmIHR5WCA9IHR5WSB0aGVuIHR5IGVsc2UgZiB0eSlcbiAgaW4gZjs7XG5sZXQgc2xzdWJzdHRhZyBzbCB0eVggPSBmdW5jdGlvblxuICB8IE5hbWV0YWcgbm0gLT4gTmFtZXRhZyAoc2xzdWJzdG5hbWUgc2wgdHlYIG5tKVxuICB8IEJvb2x0YWcgLT4gQm9vbHRhZ1xuICB8IE51bXRhZyAtPiBOdW10YWdcbiAgfCBQcm9kdGFnIC0+IFByb2R0YWdcbiAgfCBGdW50YWcgLT4gRnVudGFnXG4gIHwgRXh0YWcgLT4gRXh0YWdcbiAgfCBBbGx0YWcgLT4gQWxsdGFnXG47O1xuXG5sZXQgc2xzdWJzdHByZWMgc2wgdHlYID1cbiAgbGV0IHJlYyBmID0gZnVuY3Rpb25cbiAgICB8IE5hbWVSZWZsIG5tIC0+IE5hbWVSZWZsIChzbHN1YnN0bmFtZSBzbCB0eVggbm0pXG4gICAgfCBEeW5SZWZsIC0+IER5blJlZmxcbiAgICB8IEJvb2xSZWZsIC0+IEJvb2xSZWZsXG4gICAgfCBOdW1SZWZsIC0+IE51bVJlZmxcbiAgICB8IER5bkluaiAodGFnLCBwcmVjKSAtPiBEeW5JbmogKHNsc3Vic3R0YWcgc2wgdHlYIHRhZywgZiBwcmVjKVxuICAgIHwgUHJvZFByZWMgKHAxLCBwMikgLT4gUHJvZFByZWMgKGYgcDEsIGYgcDIpXG4gICAgfCBGdW5QcmVjIChwMSwgcDIpIC0+IEZ1blByZWMgKGYgcDEsIGYgcDIpXG4gICAgfCBGcmV4aXN0c1ByZWMgKHR5WSwgcCkgLT4gRnJleGlzdHNQcmVjICh0eVksIGlmIHR5WCA9IHR5WSB0aGVuIHAgZWxzZSBmIHApXG4gICAgfCBGcmZvcmFsbFByZWMgKHR5WSwgcCkgLT4gRnJmb3JhbGxQcmVjICh0eVksIGlmIHR5WCA9IHR5WSB0aGVuIHAgZWxzZSBmIHApXG4gIGluIGY7O1xuIiwib3BlbiBHdHlwZXM7O1xuXG50eXBlIGRpciA9IFVwIHwgRG93blxuW0BAZGVyaXZpbmcgc2hvdywgZXFdXG47O1xuXG5sZXQgY29tcGxlbWVudCA9IGZ1bmN0aW9uXG4gIHwgVXAgLT4gRG93blxuICB8IERvd24gLT4gVXA7O1xuXG50eXBlIHRtID0gVG1WYXIgb2Ygc3RyaW5nXG4gICAgICAgIHwgTGV0IG9mIHRtICogc3RyaW5nICogdG1cbiAgICAgICAgfCBTZWFsaW5qIG9mIHR5bmFtZSAqIHRtIHwgU2VhbHByaiBvZiB0eW5hbWUgKiB0bVxuICAgICAgICB8IEJvb2xsaXQgb2YgYm9vbCB8IElmIG9mIHRtICogdG0gKiB0bSB8IFBhaXIgb2YgdG0gKiB0bVxuICAgICAgICB8IFBtUGFpciBvZiB0bSAqIHN0cmluZyAqIHN0cmluZyAqIHRtXG4gICAgICAgIHwgRnVuIG9mIHN0cmluZyAqIGd0eXBlICogdG0gfCBGdW5BcHAgb2YgdG0gKiB0bVxuICAgICAgICB8IFBhY2sgb2Ygc3RyaW5nICogZ3R5cGUgKiB0bSB8IFVucGFjayBvZiB0bSAqIHN0cmluZyAqIHN0cmluZyAqIHRtXG4gICAgICAgIHwgQ2FzdFBhY2sgb2Ygc3RyaW5nICogZ3R5cGUgKiAoc3RyaW5nICogcHJlY2lzaW9uICogZGlyKSBsaXN0ICogdG1cbiAgICAgICAgfCBCaWdMYW1iZGEgb2YgKHN0cmluZyAqIHRtKVxuICAgICAgICB8IEluc3Qgb2YgKHRtICogdHluYW1lICogZ3R5cGUpXG4gICAgICAgIHwgSGlkZSBvZiBzdHJpbmcgKiBndHlwZSAqIHRtXG4gICAgICAgIHwgQ2FzdCBvZiBwcmVjaXNpb24gKiBkaXIgKiB0bVxuICAgICAgICB8IERpbmogb2YgdGFndHkgKiB0bVxuICAgICAgICB8IEludCBvZiBpbnRcbiAgICAgICAgfCBQbHVzIG9mIHRtICogdG1cbiAgICAgICAgfCBIYXNUYWcgb2YgdGFndHkgKiB0bVxuW0BAZGVyaXZpbmcgc2hvdywgZXFdXG47O1xuXG5sZXQgc2xzdWJzdCBzbCB0eVggPVxuICBsZXQgcmVjIGYgPSBmdW5jdGlvblxuICAgIHwgVG1WYXIgeSAtPiBUbVZhciB5XG4gICAgfCBMZXQgKHQseCx0aykgLT4gTGV0IChmIHQsIHgsIGYgdGspXG4gICAgfCBJbnQgbiAtPiBJbnQgblxuICAgIHwgUGx1cyAodGwsIHRyKSAtPiBQbHVzIChmIHRsLCBmIHRyKVxuICAgIHwgU2VhbGluaiAobm0sIHQpIC0+IFNlYWxpbmogKHNsc3Vic3RuYW1lIHNsIHR5WCBubSwgZiB0KVxuICAgIHwgU2VhbHByaiAobm0sIHQpIC0+IFNlYWxwcmogKHNsc3Vic3RuYW1lIHNsIHR5WCBubSwgZiB0KVxuICAgIHwgQm9vbGxpdCBiIC0+IEJvb2xsaXQgYlxuICAgIHwgSWYgKGIsIHR0LCB0ZikgLT4gSWYgKGYgYiwgZiB0dCwgZiB0ZilcbiAgICB8IFBhaXIgKHQxLCB0MikgLT4gUGFpciAoZiB0MSwgZiB0MilcbiAgICB8IFBtUGFpciAodHAsIHgxLCB4MiwgdGspIC0+IFBtUGFpciAoZiB0cCwgeDEsIHgyLCBmIHRrKVxuICAgIHwgRnVuICh4LCB0eSwgdCkgLT4gRnVuICh4LCBzbHN1YnN0dHkgc2wgdHlYIHR5LCBmIHQpXG4gICAgfCBGdW5BcHAgKHRmLCB0YSkgLT4gRnVuQXBwIChmIHRmLCBmIHRhKVxuICAgIHwgUGFjayAodHlZLCB0eSwgdGJvZCkgLT5cbiAgICAgICBQYWNrICh0eVksIHNsc3Vic3R0eSBzbCB0eVggdHksIGlmIHR5WCA9IHR5WSB0aGVuIHRib2QgZWxzZSBmIHRib2QpXG4gICAgfCBDYXN0UGFjayAodHlZLCB0eSwgY3N0cywgdGJvZCkgLT5cbiAgICAgICBDYXN0UGFjayAodHlZLFxuICAgICAgICAgICAgICAgICBzbHN1YnN0dHkgc2wgdHlYIHR5LFxuICAgICAgICAgICAgICAgICBMaXN0Lm1hcFxuICAgICAgICAgICAgICAgICAgIChmdW4gKHR5WSwgcCwgZCkgLT4gKHR5WSwgKGlmIHR5WCA9IHR5WSB0aGVuIHAgZWxzZSBzbHN1YnN0cHJlYyBzbCB0eVggcCksIGQpKVxuICAgICAgICAgICAgICAgICAgIGNzdHMsXG4gICAgICAgICAgICAgICAgIGlmIHR5WCA9IHR5WSB0aGVuIHRib2QgZWxzZSBmIHRib2QpXG4gICAgfCBVbnBhY2sgKHQsIHR5WSwgeCwgdGspIC0+XG4gICAgICAgVW5wYWNrIChmIHQsIHR5WSwgeCwgaWYgdHlYID0gdHlZIHRoZW4gdGsgZWxzZSBmIHRrKVxuICAgIHwgQmlnTGFtYmRhICh0eVksIHQpIC0+IEJpZ0xhbWJkYSAodHlZLCBpZiB0eVggPSB0eVkgdGhlbiB0IGVsc2UgZiB0KVxuICAgIHwgSW5zdCAodGYsIG5tLCBhKSAtPiBJbnN0IChmIHRmLCBzbHN1YnN0bmFtZSBzbCB0eVggbm0sIHNsc3Vic3R0eSBzbCB0eVggYSlcbiAgICB8IEhpZGUgKHR5WSwgYSwgdCkgLT4gSGlkZSAodHlZLCBhLCBpZiB0eVggPSB0eVkgdGhlbiB0IGVsc2UgZiB0KVxuICAgIHwgQ2FzdCAocCwgZCwgdCkgLT4gQ2FzdCAoc2xzdWJzdHByZWMgc2wgdHlYIHAsIGQsIGYgdClcbiAgICB8IERpbmogKGcsIHQpIC0+IERpbmogKHNsc3Vic3R0YWcgc2wgdHlYIGcsIGYgdClcbiAgICB8IEhhc1RhZyAodGcsIHQpIC0+IEhhc1RhZyAoc2xzdWJzdHRhZyBzbCB0eVggdGcsIGYgdClcbiAgaW4gZjs7XG4gIFxubGV0IHN1YnN0IHYgeCA9XG4gIGxldCByZWMgZiA9IGZ1bmN0aW9uXG4gICAgfCBUbVZhciB5IC0+IGlmIHggPSB5IHRoZW4gdiBlbHNlIFRtVmFyIHlcbiAgICB8IExldCAodCx5LHRrKSAtPiBMZXQgKGYgdCwgeSwgaWYgeCA9IHkgdGhlbiB0ayBlbHNlIGYgdGsgKVxuICAgIHwgSW50IG4gLT4gSW50IG5cbiAgICB8IFBsdXMgKHRsLCB0cikgLT4gUGx1cyAoZiB0bCwgZiB0cilcbiAgICB8IFNlYWxpbmogKHR5LCBtKSAtPiBTZWFsaW5qICh0eSwgKGYgbSkpXG4gICAgfCBTZWFscHJqICh0eSwgbSkgLT4gU2VhbHByaiAodHksIChmIG0pKVxuICAgIHwgQm9vbGxpdCBiIC0+IEJvb2xsaXQgYlxuICAgIHwgSWYgKGIsdHQsZnQpIC0+IElmIChmIGIsIGYgdHQsIGYgZnQpXG4gICAgfCBQYWlyICh0MSwgdDIpIC0+IFBhaXIgKGYgdDEsIGYgdDIpXG4gICAgfCBQbVBhaXIgKHRwLCB4MSwgeDIsIGt0KSAtPiBQbVBhaXIgKGYgdHAsIHgxLCB4MiwgaWYgeCA9IHgxIHx8IHggPSB4MiB0aGVuIGt0IGVsc2UgZiBrdClcbiAgICB8IEZ1biAoeSwgdHksIHRib2QpIC0+IEZ1biAoeSwgdHksIGlmIHggPSB5IHRoZW4gdGJvZCBlbHNlIGYgdGJvZClcbiAgICB8IEZ1bkFwcCAodGYsIHRhKSAtPiBGdW5BcHAgKGYgdGYsIGYgdGEpXG4gICAgfCBQYWNrICh0eVgsIHR5LCBtKSAtPiBQYWNrICh0eVgsIHR5LCBmIG0pXG4gICAgfCBVbnBhY2sgKHQsIHR5WCwgeSwgdGspIC0+IFVucGFjayAoZiB0LCB0eVgsIHksIGlmIHggPSB5IHRoZW4gdGsgZWxzZSBmIHRrKVxuICAgIHwgQ2FzdFBhY2sgKHR5WCwgdHksIGNzdHMsIHQpIC0+IENhc3RQYWNrICh0eVgsIHR5LCBjc3RzLCBmIHQpXG4gICAgfCBCaWdMYW1iZGEgKHR5WCwgdCkgLT4gQmlnTGFtYmRhICh0eVgsIGYgdClcbiAgICB8IEluc3QgKHRmLCBubSwgYSkgLT4gSW5zdCAoZiB0Ziwgbm0sIGEpXG4gICAgfCBIaWRlICh0eVgsIGEsIHQpIC0+IEhpZGUgKHR5WCwgYSwgZiB0KVxuICAgIHwgQ2FzdCAocHJlYywgZCwgdCkgLT4gQ2FzdCAocHJlYywgZCwgZiB0KVxuICAgIHwgRGluaiAoZywgdCkgLT4gRGluaiAoZywgZiB0KVxuICAgIHwgSGFzVGFnIChnLCB0KSAtPiBIYXNUYWcgKGcsIGYgdClcbiAgaW4gZjs7XG4iLCJvcGVuIEd0eXBlczs7XG5cbnR5cGUgdHl2YXIgPSBzdHJpbmdcbltAQGRlcml2aW5nIHNob3csZXFdXG47O1xudHlwZSB0bXZhciA9IHN0cmluZ1xuW0BAZGVyaXZpbmcgc2hvdyxlcV1cbjs7XG5cbnR5cGUgc3JjX2xvYyA9IHsgbGluZSA6IGludDsgY29sIDogaW50IH1cbltAQGRlcml2aW5nIHNob3ddXG5cbmxldCBlcXVhbF9zcmNfbG9jIF8gXyA9IHRydWVcbiAgICAgICAgICAgICBcbnR5cGUgdG0gPSBzcmNfbG9jICogdG1jdG9yXG5hbmRcbnRtY3RvciA9IFRtVmFyIG9mIHRtdmFyXG4gICAgICAgIHwgTGV0IG9mIHRtICogdG12YXIgKiB0bVxuICAgICAgICB8IFNlYWxpbmogb2YgdHl2YXIgKiB0bSB8IFNlYWxwcmogb2YgdHl2YXIgKiB0bVxuICAgICAgICB8IEJvb2xsaXQgb2YgYm9vbCB8IElmIG9mIHRtICogdG0gKiB0bVxuICAgICAgICB8IEludCBvZiBpbnQgfCBQbHVzIG9mIHRtICogdG1cbiAgICAgICAgfCBQYWlyIG9mIHRtICogdG1cbiAgICAgICAgfCBQbVBhaXIgb2YgdG0gKiB0bXZhciAqIHRtdmFyICogdG1cbiAgICAgICAgfCBGdW4gb2Ygc3RyaW5nICogZ3R5cGUgKiB0bSB8IEZ1bkFwcCBvZiB0bSAqIHRtXG4gICAgICAgIHwgUGFjayBvZiB0eXZhciAqIGd0eXBlICogdG0gfCBVbnBhY2sgb2YgdG0gKiB0eXZhciAqIHRtdmFyICogdG1cbiAgICAgICAgfCBCaWdMYW1iZGEgb2YgKHR5dmFyICogdG0pXG4gICAgICAgIHwgSW5zdCBvZiAodG0gKiB0eXZhciAqIGd0eXBlKVxuICAgICAgICB8IEFubiBvZiBndHlwZSAqIHRtXG4gICAgICAgIHwgSGFzVGFnIG9mIHRhZ3R5ICogdG1cbltAQGRlcml2aW5nIHNob3csIGVxXVxuIiwib3BlbiBQUHJpbnQ7O1xub3BlbiBHdHlwZXM7O1xub3BlbiBDQzs7XG5cbmxldCBpbnQgbiA9IHN0cmluZyAoc3RyaW5nX29mX2ludCBuKTs7XG5cbnR5cGUgY3R4ID0gVW5yZXN0cmljdGVkIHwgTGVmdE9wIHwgUmlnaHRUaW1lcyB8IFJBcHA7O1xuXG5sZXQgYXJncyBkb2NzID0gYWxpZ24gKGdyb3VwIChzZXBhcmF0ZSAoY29tbWEgXl4gYnJlYWsgMSkgKExpc3QubWFwIGdyb3VwIGRvY3MpKSlcbiAgICAgICAgICAgICAgXG5sZXQgYmluZGluZyBuYW1lIHBhdHRlcm4gc2NydXRpbmVlIGtvbnQgPVxuICBncm91cCAoKCghXm5hbWUgXl4gc3BhY2UgXl4gYWxpZ24gcGF0dGVybiBeXiBzcGFjZSBeXiAhXlwiPVwiKSBeLy9eIGFsaWduIHNjcnV0aW5lZSkgXi9eICFeIFwiaW5cIikgXi9eIGtvbnRcblxubGV0IGFwcCByYXRvciByYW5kID1cbiAgcmF0b3IgXi8vXiByYW5kXG5cbmxldCBzcmNfbG9jIHsgU3VyZi5saW5lOyBjb2wgfSA9ICFeXCJsaW5lXCIgXl4gc3BhY2UgXl4gaW50IGxpbmUgXl4gc3BhY2UgXl4gIV5cImNvbHVtblwiICBeXiBzcGFjZSBeXiBpbnQgY29sXG5cbmxldCBwcHRhZyA9XG4gIGZ1bmN0aW9uXG4gIHwgTmFtZXRhZyAoU2VhbE5hbWUgbikgLT4gc3RyaW5nIEBAIHN0cmluZ19vZl9pbnQgblxuICB8IE5hbWV0YWcgKFZhck5hbWUgeCkgLT4gc3RyaW5nIHhcbiAgfCBCb29sdGFnIC0+IHN0cmluZyBcImJvb2xcIlxuICB8IE51bXRhZyAtPiBzdHJpbmcgXCJpbnRcIlxuICB8IFByb2R0YWcgLT4gc3RyaW5nIFwiKlwiXG4gIHwgRnVudGFnIC0+IHN0cmluZyBcIi0+XCJcbiAgfCBFeHRhZyAtPiBzdHJpbmcgXCJleGlzdHNcIlxuICB8IEFsbHRhZyAtPiBzdHJpbmcgXCJmb3JhbGxcIlxuXG5sZXQgcHBwcmVjID1cbiAgbGV0IHJlYyBsb29wIGN0eCA9IFxuICAgIGZ1bmN0aW9uXG4gICAgfCBOYW1lUmVmbCAoU2VhbE5hbWUgbikgLT4gaW50IG5cbiAgICB8IE5hbWVSZWZsIChWYXJOYW1lIHgpIC0+IHN0cmluZyB4XG4gICAgfCBEeW5SZWZsIC0+IHN0cmluZyBcIj9cIlxuICAgIHwgRHluSW5qICh0YWcsIHApIC0+XG4gICAgICAgIV5cInRhZ1wiIF5eIHBhcmVucyAoYXJncyBbcHB0YWcgdGFnOyBsb29wIFVucmVzdHJpY3RlZCBwXSlcbiAgICB8IEJvb2xSZWZsIC0+IHN0cmluZyBcImJvb2xcIlxuICAgIHwgTnVtUmVmbCAtPiBzdHJpbmcgXCJpbnRcIlxuICAgIHwgUHJvZFByZWMgKGEgLCBiKSAtPlxuICAgICAgIGxldCB3cmFwIHggPSBiZWdpbiBtYXRjaCBjdHggd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IExlZnRPcHxSQXBwIC0+IHBhcmVucyB4XG4gICAgICAgICAgICAgICAgICAgIHwgVW5yZXN0cmljdGVkIHwgUmlnaHRUaW1lcyAtPiB4XG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgIGluIFxuICAgICAgIHdyYXAgKGxvb3AgTGVmdE9wIGEgXl4gc3RyaW5nIFwiICogXCIgXl4gbG9vcCBSaWdodFRpbWVzIGIpXG4gICAgfCBGdW5QcmVjIChhICwgYikgLT5cbiAgICAgICBsZXQgd3JhcCB4ID0gYmVnaW4gbWF0Y2ggY3R4IHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBMZWZ0T3AgfCBSaWdodFRpbWVzfFJBcHAgLT4gcGFyZW5zIHhcbiAgICAgICAgICAgICAgICAgICAgfCBVbnJlc3RyaWN0ZWQgLT4geFxuICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICBpbiB3cmFwIChsb29wIExlZnRPcCBhIF5eIHNwYWNlIF5eICFeIFwiLT5cIiBeL14gbG9vcCBVbnJlc3RyaWN0ZWQgYilcbiAgICB8IEZyZXhpc3RzUHJlYyAoeCwgYSkgLT5cbiAgICAgICAhXlwiZXhpc3RzXCIgXl4gc3BhY2UgXl4gIV54IF5eIGRvdCBeL14gbG9vcCBVbnJlc3RyaWN0ZWQgYVxuICAgIHwgRnJmb3JhbGxQcmVjICh4LCBhKSAtPlxuICAgICAgICFeXCJmb3JhbGxcIiBeXiBzcGFjZSBeXiAhXnggXl4gZG90IF4vXiBsb29wIFVucmVzdHJpY3RlZCBhXG4gIGluIGxvb3AgVW5yZXN0cmljdGVkXG47O1xuXG5sZXQgcHB0eSBhID0gcHBwcmVjIChyZWZsIGEpOztcbmxldCBwcG5tIG5tID0gcHB0eSAoTmFtZSBubSk7O1xuICBcbmxldCBwcGRpciA9IGZ1bmN0aW9uXG4gIHwgVXAgLT4gc3RyaW5nIFwidXBcIlxuICB8IERvd24gLT4gc3RyaW5nIFwiZG93blwiOztcbmxldCBwcGNhc3QgKHAsIGQpID0gcHBkaXIgZCBeXiBhbmdsZXMgQEAgYWxpZ24gQEAgZ3JvdXAgQEAgcHBwcmVjIHA7O1xubGV0IHBwcGFja2Nhc3QgKHR5WCwgcCwgZCkgPSBwcGNhc3QgKEZyZXhpc3RzUHJlYyAodHlYLCBwKSwgZCk7O1xubGV0IHBwcGFja2Nhc3RzIGNzdHMgPVxuICBsZXQgcHJldHR5X2Nhc3QgKHR5WCwgcCwgZCkgPSBwcGNhc3QgKEZyZXhpc3RzUHJlYyAodHlYLCBwKSwgZCkgaW5cbiAgYnJhY2VzIChhcmdzIChMaXN0Lm1hcCBwcmV0dHlfY2FzdCBjc3RzKSlcblxudHlwZSB0bV9jdHggPVxuICBVbnJlc3RyaWN0ZWRcbnwgTEFwcFxufCBSQXBwXG58IEFublxufCBTdW1tYW5kXG58IFNjcnV0aW5lZVxuW0BAZGVyaXZpbmcgZXFdXG5cbmxldCB3cmFwX2lmIGN0eCBjdHhzIHggPVxuICBpZiBMaXN0LmV4aXN0cyAoZXF1YWxfdG1fY3R4IGN0eCkgY3R4cyB0aGVuIHBhcmVucyBAQCBhbGlnbiB4IGVsc2UgeFxuXG5sZXQgcHB0bSA9XG4gIGxldCByZWMgbG9vcCBjdHggPSBmdW5jdGlvblxuICAgIHwgVG1WYXIgeCAtPiBzdHJpbmcgeFxuICAgIHwgTGV0ICh0LCB4LCB0aykgLT5cbiAgICAgICB3cmFwX2lmIGN0eCBbTEFwcDsgUkFwcDsgQW5uOyBTdW1tYW5kOyBTY3J1dGluZWVdIChcbiAgICAgICBiaW5kaW5nIFwibGV0XCIgKCFeIHgpIChsb29wIFNjcnV0aW5lZSB0KSAobG9vcCBVbnJlc3RyaWN0ZWQgdGspKVxuICB8IFNlYWxpbmogKG5tLCBtKSAtPlxuICAgICB3cmFwX2lmIGN0eCBbUkFwcDsgQW5uXVxuICAgICAgIChhcHAgKCFeIFwic2VhbFwiIF5eIHNwYWNlIF5eIHBwbm0gbm0pIChsb29wIFJBcHAgbSkpXG4gIHwgU2VhbHByaiAobm0sIG0pIC0+XG4gICAgIHdyYXBfaWYgY3R4IFtSQXBwOyBBbm5dIFxuICAgICAgIChhcHAgKCFeIFwidW5zZWFsXCIgXl4gc3BhY2UgXl4gcHBubSBubSkgKGxvb3AgUkFwcCBtKSlcbiAgfCBCb29sbGl0IGIgLT4gc3RyaW5nIChpZiBiIHRoZW4gXCIjdHJ1ZVwiIGVsc2UgXCIjZmFsc2VcIilcbiAgfCBJZiAoYnQsdHQsZnQpIC0+XG4gICAgIHdyYXBfaWYgY3R4IFtMQXBwOyBSQXBwOyBBbm47IFN1bW1hbmQ7IFNjcnV0aW5lZV0gKFxuICAgICBhbGlnbiAoZ3JvdXBcbiAgICAgICAoc3RyaW5nIFwiaWYgXCIgXl4gYWxpZ24gKGxvb3AgU2NydXRpbmVlIGJ0KSBeL14gc3RyaW5nIFwidGhlbiBcIiBeXiBhbGlnbiAobG9vcCBVbnJlc3RyaWN0ZWQgdHQpIF4vXiBzdHJpbmcgXCJlbHNlIFwiIF5eIGFsaWduIChsb29wIFVucmVzdHJpY3RlZCBmdCkpKSlcbiAgfCBQYWlyICh0MSx0MikgLT4gcGFyZW5zIChhcmdzIFtsb29wIFVucmVzdHJpY3RlZCB0MTsgbG9vcCBVbnJlc3RyaWN0ZWQgdDJdKVxuICB8IFBtUGFpciAocHQsIHgxLCB4Miwga3QpIC0+XG4gICAgIHdyYXBfaWYgY3R4IFtMQXBwOyBSQXBwOyBBbm47IFN1bW1hbmQ7IFNjcnV0aW5lZV0gKFxuICAgICBiaW5kaW5nIFwibGV0XCJcbiAgICAgICAocGFyZW5zIEBAIGFyZ3MgWyFeIHgxOyAhXiB4Ml0pXG4gICAgICAgKGxvb3AgU2NydXRpbmVlIHB0KVxuICAgICAgIChsb29wIFVucmVzdHJpY3RlZCBrdCkpXG4gIHwgRnVuICh4LCBhLCB0KSAtPlxuICAgICB3cmFwX2lmIGN0eCBbTEFwcDsgUkFwcDsgQW5uOyBTdW1tYW5kOyBTY3J1dGluZWVdIChcbiAgICAgZ3JvdXAgKHN0cmluZyBcImZ1biBcIiBeXiBzdHJpbmcgeCBeXiBzdHJpbmcgXCIgOiBcIiBeXiBhbGlnbiAocHB0eSBhKSBeXiBzdHJpbmcgXCIgPT5cIiBeL14gbG9vcCBVbnJlc3RyaWN0ZWQgdCkpXG4gIHwgRnVuQXBwICh0ZiwgdGEpIC0+XG4gICAgIHdyYXBfaWYgY3R4IFtSQXBwOyBBbm5dIChhcHAgKGxvb3AgTEFwcCB0ZikgKGxvb3AgUkFwcCB0YSkpXG4gIHwgUGFjayAodHlYLCB0eSwgbSkgLT5cbiAgICAgc3RyaW5nIFwicGFjazxcIiBeXiBhbGlnbiAoZ3JvdXAgKHN0cmluZyB0eVggXl4gc3RyaW5nIFwiID1+IFwiIF5eIHBwdHkgdHkgXl4gc3RyaW5nIFwiLFwiIF4vXiBsb29wIFVucmVzdHJpY3RlZCBtKSApXl4gc3RyaW5nIFwiPlwiXG4gIHwgQ2FzdFBhY2sgKHR5WCwgdHksIHByZWNzLCBtKSAtPlxuICAgICBzdHJpbmcgXCJwYWNrPFwiIF5eIGFsaWduIChncm91cCAoc3RyaW5nIHR5WCBeXiBzdHJpbmcgXCIgPX4gXCIgXl4gYWxpZ24gKHBwdHkgdHkpIF5eIHN0cmluZyBcIixcIiBeL14gYWxpZ24gKHBwcGFja2Nhc3RzIHByZWNzKSBeXiBzdHJpbmcgXCIsXCIgXi9eIGFsaWduIChsb29wIFVucmVzdHJpY3RlZCBtKSkpIF5eIHN0cmluZyBcIj5cIlxuICB8IFVucGFjayAodCwgdHlYLCB4LCBrdCkgLT5cbiAgICAgd3JhcF9pZiBjdHggW0xBcHA7IFJBcHA7IEFubjsgU3VtbWFuZDsgU2NydXRpbmVlXSAoXG4gICAgIGJpbmRpbmcgXCJ1bnBhY2tcIlxuICAgICAgIChhbmdsZXMgQEAgYXJncyBbIV4gdHlYOyAhXiB4XSlcbiAgICAgICAobG9vcCBTY3J1dGluZWUgdClcbiAgICAgICAobG9vcCBVbnJlc3RyaWN0ZWQga3QpKVxuICB8IEJpZ0xhbWJkYSAodHlYLCB0KSAtPlxuICAgICB3cmFwX2lmIGN0eCBbTEFwcDsgUkFwcDsgQW5uOyBTdW1tYW5kOyBTY3J1dGluZWVdIChcbiAgICAgZ3JvdXAgKHN0cmluZyBcIkxhbWJkYSBcIiBeXiBzdHJpbmcgdHlYIF5eIHN0cmluZyBcIiA9PlwiIF4vL14gbG9vcCBVbnJlc3RyaWN0ZWQgdCkpXG4gIHwgSW5zdCAodCwgbm0sIGEpIC0+XG4gICAgIHdyYXBfaWYgY3R4IFtSQXBwOyBBbm47IFN1bW1hbmRdXG4gICAgICAgKGFwcCAobG9vcCBMQXBwIHQpIChicmFjZXMgKHBwbm0gbm0gXl4gc3BhY2UgXl4gIV5cIj1+XCIgXl4gc3BhY2UgXl4gcHB0eSBhKSkpXG4gIHwgSGlkZSAodHlYLCBhLCB0KSAtPlxuICAgICB3cmFwX2lmIGN0eCBbTEFwcDsgUkFwcDsgQW5uOyBTdW1tYW5kOyBTY3J1dGluZWVdIChcbiAgICAgZ3JvdXAgKHN0cmluZyBcImhpZGUgXCIgXl4gc3RyaW5nIHR5WCBeXiBzdHJpbmcgXCIgPX4gXCIgXl4gcHB0eSBhIF5eIHN0cmluZyBcIiBpblwiIF4vXiBsb29wIFVucmVzdHJpY3RlZCB0KSlcbiAgfCBDYXN0IChwLCBkLCB0KSAtPlxuICAgICB3cmFwX2lmIGN0eCBbTEFwcDsgUkFwcDsgQW5uOyBTdW1tYW5kOyBTY3J1dGluZWVdXG4gICAgICAgKGFwcCAocHBjYXN0IChwLCBkKSkgKGxvb3AgUkFwcCB0KSlcbiAgfCBEaW5qIChnLCB0KSAtPlxuICAgICB3cmFwX2lmIGN0eCBbUkFwcDsgQW5uOyBTdW1tYW5kXVxuICAgICAgIChhcHAgKCFeXCJkaW5qXCIgXl4gYW5nbGVzIChwcHRhZyBnKSkgKGxvb3AgUkFwcCB0KSlcbiAgfCBJbnQgbiAtPiBzdHJpbmcgKHN0cmluZ19vZl9pbnQgbilcbiAgfCBQbHVzICh0bCwgdHIpIC0+XG4gICAgIHdyYXBfaWYgY3R4IFtMQXBwOyBSQXBwOyBBbm5dXG4gICAgICAgKGxvb3AgU3VtbWFuZCB0bCBeXiBzdHJpbmcgXCIgKyBcIiBeXiBsb29wIFN1bW1hbmQgdHIpXG4gIHwgSGFzVGFnIChnLCB0KSAtPlxuICAgICB3cmFwX2lmIGN0eCBbUkFwcDsgQW5uXSBAQFxuICAgICAgIGFwcCAocHB0YWcgZykgKGxvb3AgUkFwcCB0KVxuICBpbiBsb29wIFVucmVzdHJpY3RlZFxuOztcblxubGV0IHN0cmluZ19vZl9kb2MgZCA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDAgaW5cbiAgUFByaW50LlRvQnVmZmVyLnByZXR0eSAwLjggMTAwIGIgZDtcbiAgQnVmZmVyLmNvbnRlbnRzIGJcbiIsIm9wZW4gR3R5cGVzOztcblxudHlwZSBiaW5kaW5nID1cbiAgfCBUbVZhciBvZiAoc3RyaW5nICogZ3R5cGUpXG4gIHwgS25vd25UeVZhciBvZiAoc3RyaW5nICogZ3R5cGUpXG4gIHwgVW5rbm93blR5VmFyIG9mIHN0cmluZ1xuW0BAZGVyaXZpbmcgc2hvd107O1xuXG50eXBlIGtub3duX3R5X3ZhciA9IHN0cmluZyAqIGd0eXBlXG5bQEBkZXJpdmluZyBzaG93XTs7XG5cbnR5cGUgZW52ID0gYmluZGluZyBsaXN0ICogRnJlc2guc3VwcGx5XG5bQEBkZXJpdmluZyBzaG93XTs7XG5cbmxldCBwcmV0dHlfZW52IChiaW5kaW5ncywgXykgPVxuICBsZXQgcHJldHR5X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgIHwgVG1WYXIgKHgsdHkpIC0+IFBQcmludC4oc3RyaW5nIHggXl4gc3RyaW5nIFwiIDogXCIgXl4gUHJldHR5LnBwdHkgdHkpXG4gICAgfCBLbm93blR5VmFyICh0eVgsdHkpIC0+IFBQcmludC4oc3RyaW5nIHR5WCBeXiBzdHJpbmcgXCIgPX4gXCIgXl4gUHJldHR5LnBwdHkgdHkpXG4gICAgfCBVbmtub3duVHlWYXIgdHlYIC0+IFBQcmludC5zdHJpbmcgdHlYXG4gIGluXG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBQUHJpbnQuc3RyaW5nIFwiKC8pXCJcbiAgICB8IGJuZCA6OiBiaW5kaW5ncyAtPlxuICAgICAgUFByaW50Lihsb29wIGJpbmRpbmdzIF5eIHN0cmluZyBcIixcIiBeL14gcHJldHR5X2JpbmRpbmcgYm5kKVxuICBpbiBQUHJpbnQuZ3JvdXAgKGxvb3AgYmluZGluZ3MpXG5cbmxldCBpc19mcmVlIHR5WCA9XG4gIGxldCByZWMgZiA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiB0cnVlXG4gICAgfCBUbVZhciBfIDo6IGVudicgLT4gZiBlbnYnXG4gICAgfCBLbm93blR5VmFyICh0eVksIF8pIDo6IGVudicgfCBVbmtub3duVHlWYXIgdHlZIDo6IGVudicgLT5cbiAgICAgIGlmIHR5WCA9IHR5WSB0aGVuIGZhbHNlIGVsc2UgZiBlbnYnXG4gIGluIGZcblxubW9kdWxlIHR5cGUgRGVsdGFfc2lnID0gc2lnXG4gIHR5cGUgdFxuICB2YWwgZW1wdHkgOiB0XG4gIHZhbCBwdXNoIDogdCAtPiBlbnYgLT4gZW52XG4gIHZhbCBjb25jYXQgOiB0IC0+IHQgLT4gdFxuICB2YWwgaW50ZXJzZWN0IDogdCAtPiB0IC0+IHRcbiAgdmFsIGhpZGVfbWFueSA6IHQgLT4gdCAtPiBDQy50bSAtPiBDQy50bVxuICB2YWwgaW5zIDogc3RyaW5nIC0+IGd0eXBlIC0+IHQgLT4gdFxuICB2YWwgcmVzdHJpY3QgOiB0IC0+IHN0cmluZyAtPiB0XG5lbmRcblxubW9kdWxlIERlbHRhIDogRGVsdGFfc2lnID0gc3RydWN0XG4gIHR5cGUgdCA9IChzdHJpbmcgKiBndHlwZSkgbGlzdDs7XG4gIG1vZHVsZSBTTWFwID0gTWFwLk1ha2UoU3RyaW5nKVxuICBsZXQgZW1wdHkgPSBbXVxuICBsZXQgcHVzaCBkZWx0YSBlbnYgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biBibmRpbmcgKGJuZGluZ3MsIHN1cHApIC0+IChLbm93blR5VmFyIGJuZGluZyA6OiBibmRpbmdzLCBzdXBwKSkgZGVsdGEgZW52XG4gIGxldCBjb25jYXQgZDEgZDIgPSBMaXN0LmFwcGVuZCBkMSBkMlxuXG4gIGxldCByZXN0cmljdF9hbGwgOiB0IC0+IHVuaXQgU01hcC50IC0+IHQgPSBmdW4gZCBiYWRYcyAtPlxuICAgIGxldCBzdGVwICh0eVgsIGEpIChkLCBiYWRYcykgPVxuICAgICAgaWYgU01hcC5tZW0gdHlYIGJhZFhzXG4gICAgICB0aGVuIChkLCBTTWFwLmFkZCB0eVggKCkgYmFkWHMpXG4gICAgICBlbHNlICgodHlYLCBhKSA6OiBkLCBiYWRYcylcbiAgICBpblxuICAgIGZzdCAoTGlzdC5mb2xkX3JpZ2h0IHN0ZXAgZCAoW10sIGJhZFhzKSlcbiAgbGV0IHJlc3RyaWN0IGQgdHlYID0gcmVzdHJpY3RfYWxsIGQgKFNNYXAuc2luZ2xldG9uIHR5WCAoKSlcbiAgbGV0IGludGVyc2VjdCBkMSBkMiA9XG4gICAgbGV0IHRvX21hcCBkID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBtYXAgKHR5WCwgYSkgLT4gU01hcC5hZGQgdHlYIGEgbWFwKSBTTWFwLmVtcHR5IGQgaW5cbiAgICBsZXQgY29uZmxpY3RzID1cbiAgICAgIGxldCBmIF8gbTEgbTIgPVxuICAgICAgICBtYXRjaCAobTEsIG0yKSB3aXRoXG4gICAgICAgIHwgKFNvbWUgdjEsIFNvbWUgdjIpIC0+IGlmIHYxID0gdjIgdGhlbiBOb25lIGVsc2UgU29tZSAoKVxuICAgICAgICB8IChTb21lIF8sIF8pIC0+IFNvbWUgKClcbiAgICAgICAgfCAoXywgU29tZSBfKSAtPiBTb21lICgpXG4gICAgICAgIHwgKE5vbmUsIE5vbmUpIC0+IE5vbmVcbiAgICAgIGluIFNNYXAubWVyZ2UgZiAodG9fbWFwIGQxKSAodG9fbWFwIGQyKVxuICAgIGluIHJlc3RyaWN0X2FsbCBkMSBjb25mbGljdHNcbiAgbGV0IGlucyB0eVggYSBkID0gKHR5WCwgYSkgOjogZFxuICBsZXQgcmVjIGhpZGVfbWFueSBkX3NtYWxsIGRfYmlnIHQgPVxuICAgIGxldCBzbWFsbF9oYXNfWCB0eVggPSBtYXRjaCBkX3NtYWxsIHdpdGhcbiAgICAgIHwgWyBdIC0+IGZhbHNlXG4gICAgICB8ICh0eVksIF8pIDo6IF8gLT4gdHlYID0gdHlZXG4gICAgaW5cbiAgICBtYXRjaCBkX2JpZyB3aXRoXG4gICAgfCBbXSAtPiB0XG4gICAgfCAodHlYLCBhKSA6OiBkX2JpZycgLT5cbiAgICAgICBpZiBzbWFsbF9oYXNfWCB0eVhcbiAgICAgICB0aGVuIGhpZGVfbWFueSAoTGlzdC50bCBkX3NtYWxsKSBkX2JpZycgdFxuICAgICAgIGVsc2UgaGlkZV9tYW55IGRfc21hbGwgZF9iaWcnIChDQy5IaWRlICh0eVgsIGEsIHQpKVxuZW5kXG5cbmxldCByZXQgeCA9IE9rIHg7O1xubGV0IGJpbmQgbSBrID0gbWF0Y2ggbSB3aXRoXG4gIHwgT2sgeCAtPiBrIHhcbiAgfCBFcnJvciBlIC0+IEVycm9yIGU7O1xuXG5sZXQgcmVjIGxvb2t1cEtub3duVmFyIHR5WCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IEtub3duVHlWYXIgKHR5WSwgdHkpIDo6IGVudiAtPiBpZiB0eVggPSB0eVkgdGhlbiBTb21lIHR5IGVsc2UgbG9va3VwS25vd25WYXIgdHlYIGVudlxuICB8IF8gOjogZW52IC0+IGxvb2t1cEtub3duVmFyIHR5WCBlbnY7O1xubGV0IHJlYyBsb29rdXBUbVZhciB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgKFRtVmFyICh5LCB0eSkgOjogZW52KSAtPlxuICAgICBpZiB4ID0geSB0aGVuIFNvbWUgdHkgZWxzZSBsb29rdXBUbVZhciB4IGVudlxuICB8IF8gOjogZW52IC0+IGxvb2t1cFRtVmFyIHggZW52OztcblxubGV0IG1rQ2FzdCB+ZnJvbXR5OmZyb210eSB+dG90eTp0b3R5IHRtID1cbiAgQ0MuQ2FzdCAoZHluVG9wIHRvdHksIERvd24sIENDLkNhc3QgKGR5blRvcCBmcm9tdHksIFVwLCB0bSkpOztcbmxldCBndWFyZCBjb25kIHQgZSBtID0gaWYgY29uZCB0aGVuIG0gKCkgZWxzZSBFcnJvciAoZnN0IHQsIGUpOztcblxuKCogcHJlLWNvbmRpdGlvbjogdGhlIHR5cGUgaXMgY29uc2lzdGVudCB3aXRoIHRoZSB0YWd0eSAqKVxubGV0IHN0cmVycm9yIHQgeCA9IEVycm9yIChmc3QgdCwgUFByaW50LnN0cmluZyB4KVxubGV0IHRhZ0RuY2FzdCB0YWd0eSB0eSB0bSA9XG4gIG1hdGNoIHR5IHdpdGhcbiAgfCBEeW4gLT4gQ0MuQ2FzdCAoZHluVG9wICh0eXBfZnJvbV90YWcgdGFndHkpLCBEb3duLCB0bSlcbiAgfCBfICAgLT4gdG07O1xubGV0IHVucGFpciB0bSA9IGZ1bmN0aW9uXG4gIHwgRHluIC0+IE9rIChEeW4sIER5bilcbiAgfCBUaW1lcyAoYSwgYikgLT4gT2sgKGEsIGIpXG4gIHwgXyAtPiBzdHJlcnJvciB0bSBcInRyaWVkIGEgcGFpciBwYXR0ZXJuLW1hdGNoIG9uIHNvbWV0aGluZyB3aXRoIHR5cGUgaW5jb21wYXRpYmxlIHdpdGggcGFpclwiOztcbmxldCB1bmZ1biB0bSA9IGZ1bmN0aW9uXG4gIHwgRHluIC0+IE9rIChEeW4sIER5bilcbiAgfCBGdW4gKGEsIGIpIC0+IE9rIChhLGIpXG4gIHwgXyAtPiBzdHJlcnJvciB0bSBcInRyaWVkIHRvIGFwcGx5IHNvbWV0aGluZyB0aGF0IGlzbid0IGEgZnVuY3Rpb25cIjs7XG5cbmxldCB1bmV4aXN0cyB0bSA9IGZ1bmN0aW9uXG4gIHwgRHluIC0+IE9rIChcIl9cIiwgRHluKVxuICB8IEZyZXhpc3RzICh0eVgsIGEpIC0+IE9rICh0eVgsIGEpXG4gIHwgXyAtPiBzdHJlcnJvciB0bSBcInRyaWVkIHRvIHVucGFjayBzb21ldGhpbmcgd2l0aCB0eXBlIGluY29tcGF0aWJsZSB3aXRoIGV4aXN0ZW50aWFsIHF1YW50aWZpZXJcIjs7XG5sZXQgdW5mb3JhbGwgdG0gPSBmdW5jdGlvblxuICB8IER5biAtPiBPayAoXCJfXCIsIER5bilcbiAgfCBGcmZvcmFsbCAodHlYLCBhKSAtPiBPayAodHlYLCBhKVxuICB8IF8gLT4gc3RyZXJyb3IgdG0gXCJ0cmllZCB0byBpbnN0YW50aWF0ZSBzb21ldGhpbmcgd2l0aCB0eXBlIGluY29tcGF0aWJsZSB3aXRoIHVuaXZlcnNhbCBxdWFudGlmaWVyXCI7O1xubGV0IHJlYyBpc0JvdW5kIHR5WCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoVG1WYXIgXyA6OiBlbnYpIC0+IGlzQm91bmQgdHlYIGVudlxuICB8IChLbm93blR5VmFyICh0eVksIF8pIDo6IGVudikgLT4gdHlYID0gdHlZIHx8IGlzQm91bmQgdHlYIGVudlxuICB8IChVbmtub3duVHlWYXIgdHlZIDo6IGVudikgLT4gdHlYID0gdHlZIHx8IGlzQm91bmQgdHlYIGVudjs7XG5cbigqIGVudiAtPiBndHlwZSAtPiBib29sXG4gKiB0cnVlIHdoZW4gZXZlcnkgZnJlZSB2YXJpYWJsZSBpbiBndHlwZSBvY2N1cnMgaW4gZW52XG4gKiBmYWxzZSB3aGVuIHNvbWUgZnJlZSB2YXIgaW4gZ3R5cGUgaXMgZnJlZSBpbiBlbnZcbiAqICopXG5sZXQgcmVzX2FuZCBtMSBtMiA9XG4gIG1hdGNoIG0xICgpIHdpdGhcbiAgfCBPayAoKSAtPiBtMiAoKVxuICB8IEVycm9yIGUgLT4gRXJyb3IgZTs7XG5cbmxldCByZWMgY292ZXJzIGVudiA9IGZ1bmN0aW9uXG4gIHwgRHluIHwgQm9vbCB8IE51bSB8IE5hbWUgKFNlYWxOYW1lIF8pIC0+IE9rICgpXG4gIHwgVGltZXMgKGEsIGIpIHwgRnVuIChhLCBiKSAtPiByZXNfYW5kIChmdW4gXyAtPiBjb3ZlcnMgZW52IGEpIChmdW4gXyAtPiBjb3ZlcnMgZW52IGIpXG4gIHwgRnJleGlzdHMgKHR5WCwgYSkgfCBGcmZvcmFsbCAodHlYLCBhKSAtPlxuICAgICBjb3ZlcnMgKFVua25vd25UeVZhciB0eVggOjogZW52KSBhXG4gIHwgTmFtZSAoVmFyTmFtZSB0eVgpIC0+XG4gICAgIGlmIGlzQm91bmQgdHlYIGVudiB0aGVuIE9rICgpIGVsc2UgRXJyb3IgdHlYIDs7XG5cbmxldCBwdXNoIHR5IChiaW5kaW5ncywgc3VwcCkgPSAodHkgOjogYmluZGluZ3MsIHN1cHApOztcblxubGV0IGluaXRfZW52ICgpID0gKFtdLCBGcmVzaC5pbml0X3N1cHBseSAoKSlcbiAgICAgICAgICAgICAgICBcbigqIHR5cGUgY2hlY2tzIGFuZCBlbGFib3JhdGVzICopXG5cbmxldCBta0Vycm9yIHRtIG1zZyA9IEVycm9yIChmc3QgdG0sIG1zZylcblxudHlwZSB0eXBlRXJyb3IgPSBTdXJmLnNyY19sb2MgKiBQUHJpbnQuZG9jdW1lbnRcbmxldCByZWMgZWxhYl90bSA6IChlbnYgLT4gU3VyZi50bSAtPiAoKENDLnRtICogRGVsdGEudCAqIGd0eXBlKSwgdHlwZUVycm9yKSByZXN1bHQpID0gZnVuIGVudiB0bSAtPlxuICBtYXRjaCBzbmQgdG0gd2l0aFxuICB8IFN1cmYuVG1WYXIgeCAtPlxuICAgICBiZWdpbiBtYXRjaCBsb29rdXBUbVZhciB4IChmc3QgZW52KSB3aXRoXG4gICAgIHwgU29tZSB0eSAtPiBPayAoQ0MuVG1WYXIgeCwgRGVsdGEuZW1wdHksIHR5KVxuICAgICB8IE5vbmUgICAgLT4gbWtFcnJvciB0bSAgUFByaW50LihzdHJpbmcgXCJ1bmJvdW5kIHZhcmlhYmxlOlwiIF4vXiBzdHJpbmcgeClcbiAgICAgZW5kXG4gIHwgU3VyZi5MZXQgKHQsIHgsIHRrKSAtPlxuICAgICBiaW5kIChlbGFiX3RtIGVudiB0KSAoZnVuICh0JywgZW52ZHQsIHR5eCkgLT5cbiAgICAgbGV0IGVudicgPSAocHVzaCAoVG1WYXIgKHgsIHR5eCkpIChEZWx0YS5wdXNoIGVudmR0IGVudikpIGluXG4gICAgIGJpbmQgKGVsYWJfdG0gZW52JyB0aykgKGZ1biAodGsnLCBlbnZkdCcsIHR5bykgLT5cbiAgICAgICByZXQgKENDLkxldCAodCcsIHgsIHRrJyksIERlbHRhLmNvbmNhdCBlbnZkdCcgZW52ZHQsIHR5bykpKVxuICB8IFN1cmYuU2VhbGluaiAodHlYLCB0KSAtPlxuICAgICBiaW5kIChlbGFiX3RtIGVudiB0KSAoZnVuICh0JywgZW52ZHQsIHR0eSkgLT5cbiAgICAgbGV0IGVudicgPSBEZWx0YS5wdXNoIGVudmR0IGVudiBpblxuICAgICBiZWdpbiBtYXRjaCBsb29rdXBLbm93blZhciB0eVggKGZzdCBlbnYnKSB3aXRoXG4gICAgIHwgU29tZSB0eSAtPlxuICAgICAgICBndWFyZCAoY2hlY2tDb25zaXN0ZW50IHR5IHR0eSAoc25kIGVudicpKVxuICAgICAgICAgIHRtXG4gICAgICAgICAgUFByaW50LihzdHJpbmcgXCJUcmllZCB0byBzZWFsIGEgdmFsIG9mIHR5cGVcIiBeLy9eIChQcmV0dHkucHB0eSB0dHkpIF4vXiBzdHJpbmcgXCJhdCBpbmNvbXBhdGlibGUgdHlwZVwiIF4vL14gUHJldHR5LnBwdHkgdHkgXi9eIHN0cmluZyBcInNlYWxlZCBhc1wiIF4vXiBzdHJpbmcgdHlYKVxuICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgIE9rIChDQy5TZWFsaW5qIChWYXJOYW1lIHR5WCwgKG1rQ2FzdCB+ZnJvbXR5OnR0eSB+dG90eTp0eSB0JykpLCBlbnZkdCwgTmFtZSAoVmFyTmFtZSB0eVgpKSlcbiAgICAgfCBOb25lIC0+XG4gICAgICAgIG1rRXJyb3IgdG0gIFBQcmludC4oc3RyaW5nIFwidW5ib3VuZCBvciB1bmtub3duIHR5cGUgdmFyaWFibGUgdXNlZCBmb3Igc2VhbGluZzpcIiBeL14gc3RyaW5nIHR5WCBeL14gc3RyaW5nIFwiaW4gZW52XCIgXi9eIHByZXR0eV9lbnYgZW52JylcbiAgICAgZW5kKVxuICB8IFN1cmYuU2VhbHByaiAodHlYLCB0KSAtPlxuICAgICBiaW5kIChlbGFiX3RtIGVudiB0KSAoZnVuICh0JywgZW52ZHQsIHR0eSkgLT5cbiAgICAgbGV0IGVudicgPSBEZWx0YS5wdXNoIGVudmR0IGVudiBpblxuICAgICBiZWdpbiBtYXRjaCBsb29rdXBLbm93blZhciB0eVggKGZzdCBlbnYnKSB3aXRoXG4gICAgIHwgU29tZSB0eSAtPlxuICAgICAgICBndWFyZCAoY2hlY2tDb25zaXN0ZW50IChOYW1lIChWYXJOYW1lIHR5WCkpIHR0eSAoc25kIGVudicpKVxuICAgICAgICB0bVxuICAgICAgICAoUFByaW50LnN0cmluZyBcIlRyaWVkIHRvIHVuc2VhbCBhIHZhbCB3aXRoIGluY29tcGF0aWJsZSB0eXBlXCIpXG4gICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgT2sgKENDLlNlYWxwcmogKFZhck5hbWUgdHlYLCB0YWdEbmNhc3QgKE5hbWV0YWcgKFZhck5hbWUgdHlYKSkgdHR5IHQnKSwgZW52ZHQsIHR5KSlcbiAgICAgfCBOb25lIC0+IG1rRXJyb3IgdG0gIFBQcmludC4oc3RyaW5nIFwidW5ib3VuZCBvciB1bmtub3duIHR5cGUgdmFyaWFibGUgdXNlZCBmb3IgdW5zZWFsaW5nOiBcIiBeXiBzdHJpbmcgdHlYKVxuICAgICBlbmQpXG4gIHwgU3VyZi5JbnQgbiAtPiBPayAoQ0MuSW50IG4sIERlbHRhLmVtcHR5LCBOdW0pXG4gIHwgU3VyZi5QbHVzICh0bCwgdHIpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gZW52IHRsKSAoZnVuICh0bCcsIGRlbHRhX3RsLCB0eWwpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gKERlbHRhLnB1c2ggZGVsdGFfdGwgZW52KSB0cikgKGZ1biAodHInICwgZGVsdGFfdHIsIHR5cikgLT5cbiAgICAgZ3VhcmQgKGNoZWNrQ29uc2lzdGVudCB0eWwgTnVtIChzbmQgZW52KSlcbiAgICAgICB0bVxuICAgICAgIFBQcmludC4oc3RyaW5nIFwiVHJpZWQgdG8gYWRkIHNvbWV0aGluZyBvZiB0eXBlIFwiIF5eIFByZXR0eS5wcHR5IHR5bClcbiAgICAgICAoZnVuIF8gLT5cbiAgICAgZ3VhcmQgKGNoZWNrQ29uc2lzdGVudCB0eXIgTnVtIChzbmQgZW52KSlcbiAgICAgICB0bVxuICAgICAgIFBQcmludC4oc3RyaW5nIFwiVHJpZWQgdG8gYWRkIHNvbWV0aGluZyBvZiB0eXBlIFwiIF5eIFByZXR0eS5wcHR5IHR5bClcbiAgICAgICAoZnVuIF8gLT5cbiAgICAgT2sgKENDLlBsdXMgKHRhZ0RuY2FzdCBOdW10YWcgdHlsIHRsJywgdGFnRG5jYXN0IE51bXRhZyB0eXIgdHInKSwgRGVsdGEuY29uY2F0IGRlbHRhX3RsIGRlbHRhX3RyLCBOdW0pKSkpKVxuICB8IFN1cmYuQm9vbGxpdCBiIC0+IE9rIChDQy5Cb29sbGl0IGIsIERlbHRhLmVtcHR5LCBCb29sKVxuICB8IFN1cmYuSWYgKHRiLCB0dCwgdGYpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gZW52IHRiKSAoZnVuICh0YicsIGRlbHRiLCB0YnR5KSAtPlxuICAgICBsZXQgZW52YiA9IERlbHRhLnB1c2ggZGVsdGIgZW52IGluXG4gICAgIGJpbmQgKGVsYWJfdG0gZW52YiB0dCkgKGZ1biAodHQnLCBkZWx0dCwgdHR0eSkgLT5cbiAgICAgYmluZCAoZWxhYl90bSBlbnZiIHRmKSAoZnVuICh0ZicsIGRlbHRmLCB0ZnR5KSAtPlxuICAgICBndWFyZCAoY2hlY2tDb25zaXN0ZW50IHRidHkgQm9vbCAoc25kIGVudmIpKVxuICAgICAgIHRtXG4gICAgICAgUFByaW50LihzdHJpbmcgXCJUcmllZCB0byBkbyBhbiBpZiBvbiBzb21ldGhpbmcgaW5jb25zaXN0ZW50IHdpdGggYm9vbFwiKSAoZnVuICgpIC0+XG4gICAgIG1hdGNoIG1rTWVldCB0dHR5IHRmdHkgKHNuZCBlbnZiKSB3aXRoXG4gICAgIHwgTm9uZSAtPiBta0Vycm9yIHRtICBQUHJpbnQuKHN0cmluZyBcIkJyYW5jaGVzIG9mIGFuIGlmIHdlcmUgbm90IGNvbnNpc3RlbnRcIilcbiAgICAgfCBTb21lIChtZWV0dHksIGx0dHR5LCBsdGZ0eSkgLT5cbiAgICAgbGV0IGRlbHR0YW5kdGYgPSAoRGVsdGEuaW50ZXJzZWN0IGRlbHR0IGRlbHRmKSBpblxuICAgICBsZXQgZGVsYnRmID0gRGVsdGEuY29uY2F0IGRlbHR0YW5kdGYgZGVsdGIgaW5cbiAgICAgbGV0IGVudnRmID0gRGVsdGEucHVzaCBkZWx0dGFuZHRmIGVudmIgaW5cbiAgICAgYmVnaW4gbWF0Y2ggY292ZXJzIChmc3QgZW52dGYpIG1lZXR0eSB3aXRoXG4gICAgIHwgT2sgKCkgLT5cbiAgICAgICAgT2sgKENDLklmICh0YWdEbmNhc3QgQm9vbHRhZyB0YnR5IHRiJywgQ0MuQ2FzdCAobHR0dHksIERvd24sIERlbHRhLmhpZGVfbWFueSBkZWx0dGFuZHRmIGRlbHR0IHR0JyksIENDLkNhc3QgKGx0ZnR5LCBEb3duLCBEZWx0YS5oaWRlX21hbnkgZGVsdHRhbmR0ZiBkZWx0ZiB0ZicpKSxcbiAgICAgICAgICAgIGRlbGJ0ZixcbiAgICAgICAgICAgIG1lZXR0eSlcbiAgICAgfCBFcnJvciB1bmJvdW5kWCAtPiBta0Vycm9yIHRtICBQUHJpbnQuKHN0cmluZyBcInR5cGUgdmFyaWFibGUgaW4gb3V0cHV0IG9mIGlmIG9uZSBicmFuY2ggYnV0IG5vdCBhbm90aGVyOiBcIiBeXiBzdHJpbmcgdW5ib3VuZFgpXG4gICAgIGVuZCkpKSlcbiAgfCBQYWlyICh0MSwgdDIpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gZW52IHQxKSAoZnVuICh0MScsIGVudmQxLCB0eTEpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gKERlbHRhLnB1c2ggZW52ZDEgZW52KSB0MikgKGZ1biAodDInLCBlbnZkMiwgdHkyKSAtPlxuICAgICAgICAgT2sgKENDLlBhaXIgKHQxJywgdDInKSwgRGVsdGEuY29uY2F0IGVudmQxIGVudmQyLCBUaW1lcyAodHkxLCB0eTIpKSkpXG4gIHwgUG1QYWlyICh0cCwgeDEsIHgyLCB0aykgLT5cbiAgICAgYmluZCAoZWxhYl90bSBlbnYgdHApIChmdW4gKHRwJywgZW52ZHAsIHRwdHkpIC0+XG4gICAgIGJpbmQgKHVucGFpciB0bSB0cHR5KSAoZnVuICh0eTEsIHR5MikgLT5cbiAgICAgYmluZCAoZWxhYl90bSAocHVzaCAoVG1WYXIgKHgyLCB0eTIpKSAocHVzaCAoVG1WYXIgKHgxLCB0eTEpKSAoRGVsdGEucHVzaCBlbnZkcCBlbnYpKSkgdGspIChmdW4gKHRrJywgZW52ZGssIGt0eSkgLT5cbiAgICAgT2sgKENDLlBtUGFpciAodGFnRG5jYXN0IFByb2R0YWcgdHB0eSB0cCcsIHgxLCB4MiwgdGsnKSwgRGVsdGEuY29uY2F0IGVudmRwIGVudmRrLCBrdHkpXG4gICAgICAgKSkpXG4gIHwgRnVuICh4LCB0eSwgdGJvZCkgLT5cbiAgICAgYmVnaW4gbWF0Y2ggY292ZXJzIChmc3QgZW52KSB0eSB3aXRoXG4gICAgIHwgRXJyb3IgdW5ib3VuZFggLT5cbiAgICAgICAgc3RyZXJyb3IgdG0gKFwiVW5ib3VuZCB0eXBlIHZhcmlhYmxlIFwiIF4gdW5ib3VuZFggXiBcIiBpbiBhcmd1bWVudCB0byBmdW5jdGlvblwiKVxuICAgICB8IE9rICgpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gKHB1c2ggKFRtVmFyICh4LCB0eSkpIGVudikgdGJvZCkgKGZ1biAodGJvZCcsIGRlbHRhX2JvZCwgdHknKSAtPlxuICAgICAgICAgbWF0Y2ggY292ZXJzIChmc3QgZW52KSB0eScgd2l0aFxuICAgICAgICAgfCBPayAoKSAtPiBPayAoKENDLkZ1biAoeCwgdHksIERlbHRhLmhpZGVfbWFueSBEZWx0YS5lbXB0eSBkZWx0YV9ib2QgdGJvZCcpKSwgRGVsdGEuZW1wdHksIEd0eXBlcy5GdW4gKHR5LCB0eScpKVxuICAgICB8IEVycm9yIHVuYm91bmRYIC0+XG4gICAgICAgIHN0cmVycm9yIHRtIChcIkxlYWtlZCB0eXBlIHZhcmlhYmxlIFwiIF4gdW5ib3VuZFggXiBcIiBpbiBmdW5jdGlvbiBib2R5XCIpIClcbiAgICAgZW5kXG4gIHwgRnVuQXBwICh0ZiwgdGEpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gZW52IHRmKSAoZnVuICh0ZicsIGRlbHRhX3RmLCB0eWYpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gKERlbHRhLnB1c2ggZGVsdGFfdGYgZW52KSB0YSkgKGZ1biAodGEnICwgZGVsdGFfdGEsIHR5YSkgLT5cbiAgICAgYmluZCAodW5mdW4gdG0gdHlmKSAoZnVuICh0eWRvbSx0eWNvZCkgLT5cbiAgICAgZ3VhcmQgKGNoZWNrQ29uc2lzdGVudCB0eWEgdHlkb20gKHNuZCBlbnYpKVxuICAgICAgIHRtXG4gICAgICAgUFByaW50LihzdHJpbmcgXCJBcHBsaWVkIGEgZnVuY3Rpb24gb2Ygd2l0aCBkb21haW4gXCIgXl4gUHJldHR5LnBwdHkgdHlkb20gXl4gc3RyaW5nIFwiIHRvIGFuIGFyZyBvZiBpbmNvbXBhdGlibGUgdHlwZSBcIiBeXiBQcmV0dHkucHB0eSB0eWEpIChmdW4gXyAtPlxuICAgICBPayAoQ0MuRnVuQXBwICh0YWdEbmNhc3QgRnVudGFnIHR5ZiB0ZicsIENDLkNhc3QgKGR5blRvcCB0eWRvbSwgRG93biwgQ0MuQ2FzdCAoZHluVG9wIHR5YSwgVXAsIHRhJykpKSxcbiAgICAgICAgIERlbHRhLmNvbmNhdCBkZWx0YV90ZiBkZWx0YV90YSxcbiAgICAgICAgIHR5Y29kKSkpKSlcbiAgfCBQYWNrICh0eVgsIHR5LCB0Ym9kKSAtPlxuICAgICBsZXQgZW52JyA9IHB1c2ggKEtub3duVHlWYXIgKCB0eVgsIHR5ICkpIGVudiBpblxuICAgICBiaW5kIChlbGFiX3RtIGVudicgdGJvZCkgKGZ1biAodGJvZCcsIGRlbHRhX2JvZCwgdHlib2QpIC0+XG4gICAgIG1hdGNoIGNvdmVycyAoZnN0IGVudicpIHR5Ym9kIHdpdGhcbiAgICAgfCBPayAoKSAtPiBPayAoQ0MuUGFjayAodHlYLCB0eSwgRGVsdGEuaGlkZV9tYW55IERlbHRhLmVtcHR5IGRlbHRhX2JvZCB0Ym9kJyksIERlbHRhLmVtcHR5LCBGcmV4aXN0cyAodHlYLCB0eWJvZCkpXG4gICAgIHwgRXJyb3IgdW5ib3VuZFggLT4gbWtFcnJvciB0bSAgUFByaW50LihzdHJpbmcgXCJ0eXBlIHZhcmlhYmxlIFwiIF5eIHN0cmluZyB1bmJvdW5kWCBeXiBzdHJpbmcgXCIgbGVha2VkIGluIGJvZHkgb2YgcGFja1wiKSlcbiAgfCBVbnBhY2sgKHRwLCB0eVgsIHgsIHRrKSAtPlxuICAgICBiaW5kIChlbGFiX3RtIGVudiB0cCkgKGZ1biAodHAnLCBkZWx0YV90cCwgdHl0cCkgLT5cbiAgICAgYmluZCAodW5leGlzdHMgdG0gdHl0cCkgKGZ1biAodHlZLCB0eXRwYm9kKSAtPlxuICAgICBiaW5kIChlbGFiX3RtIChwdXNoIChUbVZhciAoeCwgcmVuYW1lVHlWYXIgfmZyb206dHlZIH50b286dHlYIChzbmQgZW52KSB0eXRwYm9kKSkgKHB1c2ggKFVua25vd25UeVZhciB0eVgpIGVudikpIHRrKSAoZnVuICh0aycsIGRlbHRhX3RrLCB0a3RwKSAtPlxuICAgICBsZXQgZGVsdGFfdGsnID0gRGVsdGEucmVzdHJpY3QgZGVsdGFfdGsgdHlYIGluXG4gICAgIGxldCBiaWdfZGVsdGEgPSBEZWx0YS5jb25jYXQgZGVsdGFfdGsnIGRlbHRhX3RwIGluXG4gICAgIG1hdGNoIGNvdmVycyAoZnN0IChEZWx0YS5wdXNoIGJpZ19kZWx0YSBlbnYpKSB0a3RwIHdpdGhcbiAgICAgfCBFcnJvciB1bmJvdW5kWCAtPlxuICAgICAgIG1rRXJyb3IgdG0gIFBQcmludC4oc3RyaW5nIFwiTGVha2VkIGEgdHlwZSB2YXJpYWJsZSBcIiBeXiBzdHJpbmcgdW5ib3VuZFggXl4gc3RyaW5nIFwiIGJvdW5kIGluIHRoZSBrb250IG9mIGFuIHVucGFjay5cIilcbiAgICAgfCBPayAoKSAtPiBPayAoQ0MuVW5wYWNrICh0YWdEbmNhc3QgRXh0YWcgdHl0cCB0cCcsIHR5WCwgeCwgdGsnKSwgYmlnX2RlbHRhLCB0a3RwKSkpKVxuICB8IEFubiAodHksIHQpIC0+XG4gICAgIGJpbmQgKGVsYWJfdG0gZW52IHQpIChmdW4gKHQnLCBkZWx0YSwgdHR5KSAtPlxuICAgICBndWFyZCAoY2hlY2tDb25zaXN0ZW50IHR0eSB0eSAoc25kIGVudikpXG4gICAgIHRtXG4gICAgIFBQcmludC4oc3RyaW5nIFwiVHJpZWQgdG8gY2FzdCBmcm9tIHR5cGVcIiBeL14gUHJldHR5LnBwdHkgdHR5IF5eIHN0cmluZyBcIiB0byBhbiBpbmNvbnNpc3RlbnQgdHlwZVwiIF4vXiBQcmV0dHkucHB0eSB0eSkgKGZ1biAoKSAtPlxuICAgICBPayAoQ0MuQ2FzdCAoZHluVG9wIHR5LCBEb3duLCBDQy5DYXN0IChkeW5Ub3AgdHR5LCBVcCwgdCcpKSwgZGVsdGEsIHR5KSkpXG4gIHwgU3VyZi5CaWdMYW1iZGEgKHR5WCwgdGJvZCkgLT5cbiAgICAgYmluZCAoZWxhYl90bSAocHVzaCAoVW5rbm93blR5VmFyIHR5WCkgZW52KSB0Ym9kKSAoZnVuICh0Ym9kJywgZGVsdGFfYm9kLCBib2R0eSkgLT5cbiAgICAgT2sgKENDLkJpZ0xhbWJkYSAodHlYLCBEZWx0YS5oaWRlX21hbnkgRGVsdGEuZW1wdHkgZGVsdGFfYm9kIHRib2QnKSwgRGVsdGEuZW1wdHksIEZyZm9yYWxsICh0eVgsIGJvZHR5KSkpXG4gIHwgU3VyZi5JbnN0ICh0LCB0eVgsIGEpIC0+XG4gICAgIGd1YXJkIChpc19mcmVlIHR5WCAoZnN0IGVudikpXG4gICAgIHRtXG4gICAgIFBQcmludC4oc3RyaW5nIFwiSW5zdGFudGlhdGluZyB2YXJpYWJsZXMgbXVzdCBiZSB1bmlxdWUsIGJ1dCB5b3UgdXNlZCBcIiBeXiBzdHJpbmcgdHlYIF5eIHN0cmluZyBcIiB0d2ljZS5cIikgKGZ1biAoKSAtPlxuICAgICBiaW5kIChlbGFiX3RtIGVudiB0KSAoZnVuICh0JywgZGVsdGEsIHR0eSkgLT5cbiAgICAgYmluZCAodW5mb3JhbGwgdG0gdHR5KSAoZnVuICh0eVksIGIpIC0+XG4gICAgICAgICBPayAoQ0MuSW5zdCAodGFnRG5jYXN0IEFsbHRhZyB0dHkgdCcsIFZhck5hbWUgdHlYLCBhKSwgRGVsdGEuaW5zIHR5WCBhIGRlbHRhLCByZW5hbWVUeVZhciB+ZnJvbTp0eVkgfnRvbzp0eVggKHNuZCBlbnYpIGIpKSkpXG4gIHwgU3VyZi5IYXNUYWcodGcsdCkgLT5cbiAgICAgYmVnaW4gbWF0Y2ggY292ZXJzIChmc3QgZW52KSBAQCB0eXBfZnJvbV90YWcgdGcgd2l0aFxuICAgICB8IEVycm9yIHVuYm91bmRYIC0+XG4gICAgICAgc3RyZXJyb3IgdG0gKFwiVW5ib3VuZCB0eXBlIHZhcmlhYmxlIFwiIF4gdW5ib3VuZFggXiBcIiB0YWctY2hlY2tcIilcbiAgICAgfCBPayAoKSAtPlxuICAgICAgICBiaW5kIChlbGFiX3RtIGVudiB0KSAoZnVuICh0JywgZGVsdGEsIHR0eSkgLT5cbiAgICAgICAgT2sgKENDLkhhc1RhZyAodGcsIENhc3QgKGR5blRvcCB0dHksIFVwLCB0JykpLCBkZWx0YSwgQm9vbCkpICAgICAgICAgIFxuICAgICBlbmRcbjs7XG5cbmxldCBlbGFiX3Byb2cgOiBTdXJmLnRtIC0+IChDQy50bSAqIGd0eXBlLCB0eXBlRXJyb3IpIHJlc3VsdCA9IGZ1biB0IC0+XG4gIGxldCBlbnYgPSBpbml0X2VudiAoKSBpblxuICBiaW5kIChlbGFiX3RtIGVudiB0KSAoZnVuICh0JywgZGVsdGEsIHR0eSkgLT5cbiAgbWF0Y2ggY292ZXJzIFtdIHR0eSB3aXRoXG4gIHwgRXJyb3IgdW5ib3VuZFggLT5cbiAgICBta0Vycm9yIHQgUFByaW50LihcbiAgICAgIHN0cmluZyBcIlR5cGUgb2YgYSBwcm9ncmFtIHNob3VsZCBiZSBjbG9zZWQsIGJ1dCBcIlxuICAgICAgXl4gc3RyaW5nIHVuYm91bmRYXG4gICAgICBeXiBzdHJpbmcgXCIgb2NjdXJzIGZyZWUgaW4gaW5mZXJyZWQgdHlwZSBcIlxuICAgICAgXl4gUHJldHR5LnBwdHkgdHR5KVxuICB8IE9rICgpIC0+IE9rIChEZWx0YS5oaWRlX21hbnkgRGVsdGEuZW1wdHkgZGVsdGEgdCcsIHR0eSlcbiAgKVxuICBcbiIsIiV0b2tlbiA8c3RyaW5nPiBWQVJJQUJMRVxuJXRva2VuIDxzdHJpbmc+IFRZUEVfVkFSSUFCTEVcbiV0b2tlbiA8aW50PiBOVU1CRVJcbiV0b2tlbiBUUlVFXG4ldG9rZW4gRkFMU0VcbiV0b2tlbiBMRUZUX1BBUkVOXG4ldG9rZW4gUklHSFRfUEFSRU5cbiV0b2tlbiBMRUZUX0JSQUNFXG4ldG9rZW4gUklHSFRfQlJBQ0VcbiV0b2tlbiBMRUZUX0FOR0xFXG4ldG9rZW4gUklHSFRfQU5HTEVcbiV0b2tlbiBDT01NQVxuJXRva2VuIEVRVUlWXG4ldG9rZW4gRVFVQUxcbiV0b2tlbiBFT0ZcbiV0b2tlbiBDT0xPTlxuJXRva2VuIERPVUJMRV9DT0xPTlxuJXRva2VuIFBFUklPRFxuJXRva2VuIFFVRVNUSU9OX01BUktcbiV0b2tlbiBUSElOX0FSUk9XXG4ldG9rZW4gQVNURVJJU0tcbiV0b2tlbiBQTFVTXG5cbiV0b2tlbiBJTlxuJXRva2VuIExFVFxuJXRva2VuIFNFQUxcbiV0b2tlbiBVTlNFQUxcbiV0b2tlbiBJRlxuJXRva2VuIFRIRU5cbiV0b2tlbiBFTFNFXG4ldG9rZW4gUEFDS1xuJXRva2VuIFVOUEFDS1xuJXRva2VuIEVYSVNUU1xuJXRva2VuIEZPUkFMTFxuJXRva2VuIElOVFxuJXRva2VuIEZVTlxuJXRva2VuIEJJR19MQU1CREFcblxuJXRva2VuIEJPT0xcblxuJW5vbmFzc29jIFBFUklPRFxuJXJpZ2h0IFRISU5fQVJST1dcbiVyaWdodCBBU1RFUklTS1xuJXJpZ2h0IFBMVVNcblxuJXN0YXJ0IDxTdXJmLnRtPiBwcm9nXG5cbiV7IG9wZW4gU3VyZlxuXG4gICBsZXQgY3BvcyB7IExleGluZy5wb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2w7IF8gfSA9XG4gICAgIGxldCBsaW5lID0gcG9zX2xudW0gaW5cbiAgICAgbGV0IGNvbCA9IHBvc19jbnVtIC0gcG9zX2JvbCBpblxuICAgICB7bGluZSA9IGxpbmU7IGNvbCA9IGNvbH1cbiV9XG5cbiUlXG5wcm9nOlxuICB8IHQgPSB0bSBFT0YgeyB0IH07XG5cbmJhc2VfdG06XG4gIHwgTEVGVF9QQVJFTjsgdCA9IHRtOyBSSUdIVF9QQVJFTlxuICAgIHsgdCB9XG4gIHwgbiA9IE5VTUJFUlxuICAgIHsgKGNwb3MgJHN0YXJ0cG9zICwgU3VyZi5JbnQgbikgfVxuICB8IHggPSBWQVJJQUJMRVxuICAgIHsgKGNwb3MgJHN0YXJ0cG9zLCBTdXJmLlRtVmFyIHgpIH1cbiAgfCBUUlVFXG4gICAgeyAoY3BvcyAkc3RhcnRwb3MsIFN1cmYuQm9vbGxpdCB0cnVlKSB9XG4gIHwgRkFMU0VcbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5Cb29sbGl0IGZhbHNlKSB9XG4gIHwgTEVGVF9QQVJFTjsgdDEgPSB0bTsgQ09NTUE7IHQyID0gdG07IFJJR0hUX1BBUkVOXG4gICAgeyAoY3BvcyAkc3RhcnRwb3MsIFN1cmYuUGFpciAodDEsIHQyKSkgfVxuICB8IFBBQ0s7IExFRlRfQU5HTEU7IHR5eCA9IFRZUEVfVkFSSUFCTEU7IEVRVUlWIDsgdHkgPSB0eXA7IENPTU1BOyB0Ym9kID0gdG07IFJJR0hUX0FOR0xFXG4gICAgeyAoY3BvcyAkc3RhcnRwb3MsIFN1cmYuUGFjayAodHl4LCB0eSwgdGJvZCkpIH1cbjtcblxuYW5uX3NwaW5lOlxuICB8IHQgPSBiYXNlX3RtXG4gICAgeyB0IH1cblxuICB8IHQgPSBhbm5fc3BpbmU7IERPVUJMRV9DT0xPTjsgdHkgPSB0eXBcbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5Bbm4gKHR5LCB0KSkgfVxuXG5hcHBfc3BpbmU6XG4gIHwgdCA9IGJhc2VfdG1cbiAgICB7IHQgfVxuXG4gIHwgU0VBTDsgdHlYID0gVFlQRV9WQVJJQUJMRTsgdCA9IGJhc2VfdG1cbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5TZWFsaW5qICh0eVgsIHQpKSB9XG5cbiAgfCBVTlNFQUw7IHR5WCA9IFRZUEVfVkFSSUFCTEU7IHQgPSBiYXNlX3RtXG4gICAgeyAoY3BvcyAkc3RhcnRwb3MsIFN1cmYuU2VhbHByaiAodHlYLCB0KSkgfVxuXG4gIHwgdGYgPSBhcHBfc3BpbmU7IHRhID0gYmFzZV90bVxuICAgIHsgKGNwb3MgJHN0YXJ0cG9zLCBTdXJmLkZ1bkFwcCAodGYsIHRhKSkgfVxuXG4gIHwgdGYgPSBhcHBfc3BpbmU7IExFRlRfQlJBQ0U7IHR5WCA9IFRZUEVfVkFSSUFCTEU7IEVRVUlWOyBhID0gdHlwOyBSSUdIVF9CUkFDRVxuICAgIHsgKGNwb3MgJHN0YXJ0cG9zLCBTdXJmLkluc3QgKHRmLCB0eVgsIGEpKSB9XG5cbmFyaXRoOlxuICB8IHQgPSBhcHBfc3BpbmVcbiAgICB7IHQgfVxuICB8IHRsID0gYXJpdGg7IFBMVVM7IHRyID0gYXJpdGhcbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5QbHVzICh0bCwgdHIpKSB9XG5cbnRtOlxuICB8IHQgPSBiYXNlX3RtXG4gICAgeyB0IH1cbiAgfCB0ID0gYW5uX3NwaW5lOyBET1VCTEVfQ09MT047IHR5ID0gdHlwXG4gICAgeyAoY3BvcyAkc3RhcnRwb3MsIFN1cmYuQW5uICh0eSwgdCkpIH1cblxuICB8IFNFQUw7IHR5WCA9IFRZUEVfVkFSSUFCTEU7IHQgPSBiYXNlX3RtXG4gICAgeyAoY3BvcyAkc3RhcnRwb3MsIFN1cmYuU2VhbGluaiAodHlYLCB0KSkgfVxuXG4gIHwgVU5TRUFMOyB0eVggPSBUWVBFX1ZBUklBQkxFOyB0ID0gYmFzZV90bVxuICAgIHsgKGNwb3MgJHN0YXJ0cG9zLCBTdXJmLlNlYWxwcmogKHR5WCwgdCkpIH1cblxuICB8IHRmID0gYXBwX3NwaW5lOyB0YSA9IGJhc2VfdG1cbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5GdW5BcHAgKHRmLCB0YSkpIH1cblxuICB8IHRmID0gYXBwX3NwaW5lOyBMRUZUX0JSQUNFOyB0eVggPSBUWVBFX1ZBUklBQkxFOyBFUVVJVjsgYSA9IHR5cDsgUklHSFRfQlJBQ0VcbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5JbnN0ICh0ZiwgdHlYLCBhKSkgfVxuXG4gIHwgdGwgPSBhcml0aDsgUExVUzsgdHIgPSBhcml0aFxuICAgIHsgKGNwb3MgJHN0YXJ0cG9zLCBTdXJmLlBsdXMgKHRsLCB0cikpIH1cblxuICB8IEZVTjsgeCA9IFZBUklBQkxFOyBDT0xPTjsgdHkgPSB0eXA7IFBFUklPRDsgdGJvZCA9IHRtXG4gICAgeyAoY3BvcyAkc3RhcnRwb3MsIFN1cmYuRnVuICh4LCB0eSwgdGJvZCkpIH1cblxuICB8IEJJR19MQU1CREE7IHR5WCA9IFRZUEVfVkFSSUFCTEU7IFBFUklPRDsgdGJvZCA9IHRtXG4gICAgeyAoY3BvcyAkc3RhcnRwb3MsIFN1cmYuQmlnTGFtYmRhICh0eVgsIHRib2QpKSB9XG5cbiAgfCBMRVQ7IHggPSBWQVJJQUJMRTsgRVFVQUw7IHQgPSB0bTsgSU47IHRrID0gdG1cbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5MZXQgKHQsIHgsIHRrKSkgfVxuXG4gIHwgSUY7IHRiID0gdG07IFRIRU47IHR0ID0gdG07IEVMU0U7IHRmID0gdG1cbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5JZiAodGIsdHQsdGYpKSB9XG5cbiAgfCBMRVQ7IExFRlRfUEFSRU47IHgxID0gVkFSSUFCTEU7IENPTU1BOyB4MiA9IFZBUklBQkxFOyBSSUdIVF9QQVJFTjsgRVFVQUw7IHQgPSB0bTsgSU47IHRrID0gdG1cbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5QbVBhaXIgKHQsIHgxLCB4MiwgdGspKSB9XG4gIHwgVU5QQUNLOyBMRUZUX0FOR0xFOyB0eVggPSBUWVBFX1ZBUklBQkxFOyBDT01NQTsgeCA9IFZBUklBQkxFOyBSSUdIVF9BTkdMRTsgRVFVQUw7IHQgPSB0bTsgSU47IHRrID0gdG1cbiAgICB7IChjcG9zICRzdGFydHBvcywgU3VyZi5VbnBhY2sgKHQsIHR5WCwgeCwgdGspKSB9XG47XG5cbnR5cDpcbiAgfCBCT09MXG4gICAgeyBHdHlwZXMuQm9vbCB9XG4gIHwgSU5UXG4gICAgeyBHdHlwZXMuTnVtIH1cbiAgfCB0eVggPSBUWVBFX1ZBUklBQkxFXG4gICAgeyBHdHlwZXMuTmFtZSAoVmFyTmFtZSB0eVgpIH1cbiAgfCBRVUVTVElPTl9NQVJLXG4gICAgeyBHdHlwZXMuRHluIH1cbiAgfCB0eTEgPSB0eXA7IEFTVEVSSVNLOyB0eTIgPSB0eXA7XG4gICAgeyBHdHlwZXMuVGltZXMgKHR5MSwgdHkyKX1cbiAgfCB0eTEgPSB0eXA7IFRISU5fQVJST1c7IHR5MiA9IHR5cDtcbiAgICB7IEd0eXBlcy5GdW4gKHR5MSwgdHkyKSB9XG4gIHwgRVhJU1RTOyB0eVggPSBUWVBFX1ZBUklBQkxFOyBQRVJJT0Q7IHR5ID0gdHlwXG4gICAgeyBHdHlwZXMuRnJleGlzdHMgKHR5WCwgdHkpIH1cbiAgfCBMRUZUX1BBUkVOOyB0eSA9IHR5cDsgUklHSFRfUEFSRU5cbiAgICB7IHR5IH1cbiAgfCBGT1JBTEw7IHR5WCA9IFRZUEVfVkFSSUFCTEU7IFBFUklPRDsgdHkgPSB0eXBcbiAgICB7IEd0eXBlcy5GcmZvcmFsbCAodHlYLCB0eSkgfVxuO1xuIiwie1xub3BlbiBMZXhpbmc7O1xub3BlbiBQYXJzZXI7O1xuXG5leGNlcHRpb24gTGV4aW5nRXJyb3Igb2Ygc3RyaW5nOztcblxubGV0IG5leHRfbGluZSBsZXhidWYgPVxuICBsZXQgcG9zID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICB7IHBvcyB3aXRoIHBvc19ib2wgPSBsZXhidWYubGV4X2N1cnJfcG9zO1xuICAgICAgICAgICAgICAgcG9zX2xudW0gPSBwb3MucG9zX2xudW0gKyAxXG4gICAgfVxufVxuXG5cbmxldCB2YXIgPSBbICdhJy0neicgXSBbICdhJy0neicgJ0EnLSdaJyAnMCctJzknICctJyAnXycgJyonICdcXCcnIF0qXG5sZXQgdHl2YXIgPSBbICdBJy0nWicgXSBbICdhJy0neicgJ0EnLSdaJyAnMCctJzknICctJyAnXycgJyonICdcXCcnIF0qXG5sZXQgd2hpdGUgPSBbJyAnICdcXHQnXStcbmxldCBuZXdsaW5lID0gJ1xccicgfCAnXFxuJyB8IFwiXFxyXFxuXCJcbmxldCBudW0gPSBbICctJyBdPyBbICcwJy0nOScgXStcblxucnVsZSByZWFkID1cbiAgcGFyc2VcbiAgfCB3aGl0ZSB7IHJlYWQgbGV4YnVmIH1cbiAgfCBuZXdsaW5lICB7IG5leHRfbGluZSBsZXhidWY7IHJlYWQgbGV4YnVmIH1cbiAgfCBcIiN0cnVlXCIgeyBUUlVFIH1cbiAgfCBcIiNmYWxzZVwiIHsgRkFMU0UgfVxuICB8IG51bSB7IE5VTUJFUiAoaW50X29mX3N0cmluZyAoTGV4aW5nLmxleGVtZSBsZXhidWYpKSB9XG4gIHwgJysnIHsgUExVUyB9XG4gIHwgJygnIHsgTEVGVF9QQVJFTiB9XG4gIHwgJyknIHsgUklHSFRfUEFSRU4gfVxuICB8ICd7JyB7IExFRlRfQlJBQ0UgfVxuICB8ICd9JyB7IFJJR0hUX0JSQUNFIH1cbiAgfCAnPCcgeyBMRUZUX0FOR0xFIH1cbiAgfCAnPicgeyBSSUdIVF9BTkdMRSB9XG4gIHwgJywnIHsgQ09NTUEgfVxuICB8IFwiPX5cIiB7IEVRVUlWIH1cbiAgfCAnPScgeyBFUVVBTCB9XG4gIHwgJzonIHsgQ09MT04gfVxuICB8IFwiOjpcIiB7IERPVUJMRV9DT0xPTiB9XG4gIHwgJy4nIHsgUEVSSU9EIH1cbiAgfCAnKicgeyBBU1RFUklTSyB9XG4gIHwgJz8nIHsgUVVFU1RJT05fTUFSSyB9XG4gIHwgXCItPlwiIHsgVEhJTl9BUlJPVyB9XG4gIHwgXCJpblwiIHsgSU4gfVxuICB8IFwibGV0XCIgeyBMRVQgfVxuICB8IFwiaWZcIiB7IElGIH1cbiAgfCBcInRoZW5cIiB7IFRIRU4gfVxuICB8IFwiZWxzZVwiIHsgRUxTRSB9XG4gIHwgXCJwYWNrXCIgeyBQQUNLIH1cbiAgfCBcInVucGFja1wiIHsgVU5QQUNLIH1cbiAgfCBcImxhbWJkYVwiIHsgRlVOIH1cbiAgfCBcIkxhbWJkYVwiIHsgQklHX0xBTUJEQSB9XG4gIHwgXCJleGlzdHNcIiB7IEVYSVNUUyB9XG4gIHwgXCJmb3JhbGxcIiB7IEZPUkFMTCB9XG4gIHwgXCJib29sXCIgeyBCT09MIH1cbiAgfCBcImludFwiIHsgSU5UIH1cbiAgfCBcInNlYWxcIiB7IFNFQUwgfVxuICB8IFwidW5zZWFsXCIgeyBVTlNFQUwgfVxuICB8IHZhciB7IFZBUklBQkxFIChMZXhpbmcubGV4ZW1lIGxleGJ1Zil9XG4gIHwgdHl2YXIgeyBUWVBFX1ZBUklBQkxFIChMZXhpbmcubGV4ZW1lIGxleGJ1ZikgfVxuICB8IF8geyByYWlzZSAoTGV4aW5nRXJyb3IgKFwiVW5leHBlY3RlZCBjaGFyOiBcIiBeIExleGluZy5sZXhlbWUgbGV4YnVmKSkgfVxuICB8IGVvZiAgICAgIHsgRU9GIH1cbiIsIlxubGV0IHByaW50X3Bvc2l0aW9uIGxleGJ1ZiA9XG4gIGxldCBwb3MgPSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3AgaW5cbiAgUHJpbnRmLnNwcmludGYgXCJsaW5lICVkLCBzdGFydGluZyBhdCBjaGFyYWN0ZXIgJWRcIiBwb3MucG9zX2xudW0gKHBvcy5wb3NfY251bSAtIHBvcy5wb3NfYm9sICsgMSk7O1xuXG5sZXQgbGluZV9udW0gbGV4YnVmID0gbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wLnBvc19sbnVtXG5cbmxldCBmcm9tX3N0cmluZyBzID1cbiAgbGV0IGxleGJ1ZiA9IExleGluZy5mcm9tX3N0cmluZyBzIGluXG4gIG1hdGNoIFBhcnNlci5wcm9nIExleGVyLnJlYWQgbGV4YnVmIHdpdGhcbiAgfCB0IC0+IE9rIHRcbiAgfCBleGNlcHRpb24gTGV4ZXIuTGV4aW5nRXJyb3IgZSAtPlxuICAgICBFcnJvciAobGluZV9udW0gbGV4YnVmLCBwcmludF9wb3NpdGlvbiBsZXhidWYgXiBcIlxcblwiIF4gZSlcbiAgfCBleGNlcHRpb24gUGFyc2VyLkVycm9yIC0+IEVycm9yIChsaW5lX251bSBsZXhidWYsIHByaW50X3Bvc2l0aW9uIGxleGJ1ZiBeIFwiXFxuY3VycmVudCBsZXhlbWU6IFwiIF4gTGV4aW5nLmxleGVtZSBsZXhidWYpOztcbiIsIm9wZW4gSnNfb2Zfb2NhbWw7O1xub3BlbiBQb2x5R05ldzs7XG5tb2R1bGUgSCA9IERvbV9odG1sOztcbm1vZHVsZSBJID0gSW50ZXJwcmV0ZXI7O1xub3BlbiBHdHlwZXM7O1xuKCogb3BlbiBQUHJpbnQ7OyAqKVxuXG5sZXQgc2V0X2Vycm9yIGxuIG0gPVxuICBsZXQgXyA9IEpzLlVuc2FmZS4oKGNvZXJjZSBnbG9iYWwpIyNzZXRlcnJvciAoSnMubnVtYmVyX29mX2Zsb2F0IChmbG9hdF9vZl9pbnQgbG4pKSAoSnMuc3RyaW5nIG0pKSBpblxuICAoKVxuXG5sZXQgY2xlYXJfZXJyb3JzIF8gPVxuICBsZXQgXyA9IEpzLlVuc2FmZS4oKGNvZXJjZSBnbG9iYWwpIyNjbGVhcmVycm9ycykgaW5cbiAgKCk7O1xubGV0IHNldF9jbGljayBpIGggPVxuICBILigoZ2V0RWxlbWVudEJ5SWQgaSkjIy5vbmNsaWNrIDo9IGgpO1xuICAoKVxuXG5sZXQgaGlkZV9tYWNoaW5lIF8gPVxuICBILigoZ2V0RWxlbWVudEJ5SWQgXCJtYWNoaW5lXCIpIyNzZXRBdHRyaWJ1dGUgKEpzLnN0cmluZyBcImhpZGRlblwiKSAoSnMuc3RyaW5nIFwib25cIikpOztcbmxldCByZXZlYWxfbWFjaGluZSBfID1cbiAgSC4oKGdldEVsZW1lbnRCeUlkIFwibWFjaGluZVwiKSMjcmVtb3ZlQXR0cmlidXRlIChKcy5zdHJpbmcgXCJoaWRkZW5cIikpOztcbmxldCBzZXRfdGV4dCBpIHQgPVxuICBsZXQgXyA9IEpzLlVuc2FmZS4oKGNvZXJjZSBnbG9iYWwpIyNzZXR0ZXh0IChKcy5zdHJpbmcgaSkgKEpzLnN0cmluZyB0KSkgaW5cbiAgKCk7O1xubGV0IHNldF9lZGl0b3IgdCA9XG4gIGxldCBvcGVuIEpzIGluXG4gIGNsZWFyX2Vycm9ycyAoKTtcbiAgaGlkZV9tYWNoaW5lICgpO1xuICBsZXQgXyA9IFVuc2FmZS4oKGNvZXJjZSAoZ2xvYmFsIyMuY29kZW1pcnJvcikpIyNzZXRWYWx1ZSAoc3RyaW5nIHQpKSBpblxuICAoKTs7XG5sZXQgZ2V0X2VkaXRvciAoKSA9XG4gIEpzLlVuc2FmZS4oKGNvZXJjZSAoZ2xvYmFsIyMuY29kZW1pcnJvcikpIyNnZXRWYWx1ZSk7O1xuXG5sZXQgZXhfaGFuZGxlIHMgPVxuICBILmhhbmRsZXIgKGZ1biBfIC0+IHNldF9lZGl0b3IgczsgSnMuX2ZhbHNlKVxuXG50eXBlIHRlcm1fc3RhdGUgPVxuICB8IEVyciBvZiBQUHJpbnQuZG9jdW1lbnRcbiAgfCBWYWwgb2YgQ0MudG1cbiAgfCBHb2luZyBvZiBDQy50bSAqIChDQy50bSBJLmludGVycE0pXG5cbmxldCBub19wYXN0IF8gPVxuICBILigoZ2V0RWxlbWVudEJ5SWQgXCJwcmV2XCIpIyNzZXRBdHRyaWJ1dGUgKEpzLnN0cmluZyBcImRpc2FibGVkXCIpIChKcy5zdHJpbmcgXCJvblwiKSk7XG4gIEguKChnZXRFbGVtZW50QnlJZCBcInByZXZtYW55XCIpIyNzZXRBdHRyaWJ1dGUgKEpzLnN0cmluZyBcImRpc2FibGVkXCIpIChKcy5zdHJpbmcgXCJvblwiKSk7XG4gICgpXG5cbmxldCBzb21lX3Bhc3QgXyA9XG4gIEguKChnZXRFbGVtZW50QnlJZCBcInByZXZcIikjI3JlbW92ZUF0dHJpYnV0ZSAoSnMuc3RyaW5nIFwiZGlzYWJsZWRcIikpO1xuICBILigoZ2V0RWxlbWVudEJ5SWQgXCJwcmV2bWFueVwiKSMjcmVtb3ZlQXR0cmlidXRlIChKcy5zdHJpbmcgXCJkaXNhYmxlZFwiKSk7XG4gICgpXG4gIFxubGV0IG5vX2Z1dHVyZSBfID1cbiAgSC4oKGdldEVsZW1lbnRCeUlkIFwibmV4dFwiKSMjc2V0QXR0cmlidXRlIChKcy5zdHJpbmcgXCJkaXNhYmxlZFwiKSAoSnMuc3RyaW5nIFwib25cIikpO1xuICBILigoZ2V0RWxlbWVudEJ5SWQgXCJuZXh0bWFueVwiKSMjc2V0QXR0cmlidXRlIChKcy5zdHJpbmcgXCJkaXNhYmxlZFwiKSAoSnMuc3RyaW5nIFwib25cIikpO1xuICAoKVxuXG5sZXQgc29tZV9mdXR1cmUgXyA9XG4gIEguKChnZXRFbGVtZW50QnlJZCBcIm5leHRcIikjI3JlbW92ZUF0dHJpYnV0ZSAoSnMuc3RyaW5nIFwiZGlzYWJsZWRcIikpO1xuICBILigoZ2V0RWxlbWVudEJ5SWQgXCJuZXh0bWFueVwiKSMjcmVtb3ZlQXR0cmlidXRlIChKcy5zdHJpbmcgXCJkaXNhYmxlZFwiKSk7XG4gICgpXG5cbmxldCBuZXh0X3Rlcm1fc3RhdGUgdCA9XG4gIG1hdGNoIEkuc3RlcCB0IHdpdGhcbiAgfCBJLlZhbHVlICAgICAtPiBWYWwgdFxuICB8IEkuUnVubmluZyBpIC0+IEdvaW5nICh0LCBpKVxuXG5sZXQgaW5pdF9zdGF0ZSA9IChFcnIgKFBQcmludC4oc3RyaW5nIFwiVGhpcyBpcyBhIGJ1ZyxcIiBeL14gc3RyaW5nIFwidGhpcyB0ZXh0IHNob3VsZCBub3QgYmUgZGlzcGxheWVkIDopXCIpKSwgSS5pbml0X3N0b3JlLCBOb25lLCAwLCBbXSlcbmxldCAoKSA9XG4gICgqIEEgc3RlcHBlciBzdGF0ZSBjb25zaXN0cyBvZlxuICAgKiAxLiBUaGUgY3VycmVudCB0ZXJtIHN0YXRlXG4gICAqIDIuIFRoZSBjdXJyZW50IHN0b3JlXG4gICAqIDMuIFRoZSBsZW5ndGggb2YgdGhlIGhpc3RvcnlcbiAgICogNC4gVGhlIGhpc3RvcnlcbiAgICogKilcbiAgbGV0IHN0YXRlIDogKHRlcm1fc3RhdGUgKiBJLnN0b3JlICogZ3R5cGUgb3B0aW9uICogaW50ICogKHRlcm1fc3RhdGUgKiBJLnN0b3JlKSBsaXN0KSByZWZcbiAgICA9IHJlZiBpbml0X3N0YXRlXG4gIGluXG4gIGxldCByZW5kZXIgXyA9XG4gICAgbGV0ICh0bV9zdCwgc3RvLCBtYXlUeSwgcGMsIF9oaXN0KSA9ICFzdGF0ZSBpblxuICAgIChpZiBwYyA9IDAgdGhlbiBub19wYXN0IGVsc2Ugc29tZV9wYXN0KSAoKTtcbiAgICBzZXRfdGV4dCBcInRlcm1cIiAoUHJldHR5LnN0cmluZ19vZl9kb2MgYmVnaW4gbWF0Y2ggdG1fc3Qgd2l0aFxuICAgIHwgRXJyIHMgLT5cbiAgICAgICBub19mdXR1cmUgKCk7XG4gICAgICAgc1xuICAgIHwgVmFsIHYgLT5cbiAgICAgICBub19mdXR1cmUgKCk7XG4gICAgICAgUHJldHR5LnBwdG0gdlxuICAgIHwgR29pbmcgKHQsIF9tKSAtPlxuICAgICAgIHNvbWVfZnV0dXJlICgpO1xuICAgICAgIFByZXR0eS5wcHRtIHRcbiAgICBlbmQpO1xuICAgIHNldF90ZXh0IFwidHlwZVwiIGJlZ2luIG1hdGNoIG1heVR5IHdpdGhcbiAgICAgIHwgU29tZSB0eSAtPiBQcmV0dHkuc3RyaW5nX29mX2RvYyAoUHJldHR5LnBwdHkgdHkpXG4gICAgICB8IE5vbmUgICAgLT4gXCJcIlxuICAgICAgZW5kO1xuICAgIHNldF90ZXh0IFwic3RvcmVcIiAoUHJldHR5LnN0cmluZ19vZl9kb2MgKEkucHJldHR5X3N0b3JlIHN0bykpO1xuICAgIHNldF90ZXh0IFwicGNcIiAoc3RyaW5nX29mX2ludCBwYyk7XG4gICAgKClcbiAgaW5cbiAgbGV0IGxvYWQgXyA9XG4gICAgbGV0IHMgPSBKcy50b19zdHJpbmcgKGdldF9lZGl0b3IgKCkpIGluXG4gICAgY2xlYXJfZXJyb3JzICgpO1xuICAgIGJlZ2luIG1hdGNoIFBhcnNlLmZyb21fc3RyaW5nIHMgd2l0aFxuICAgIHwgRXJyb3IgKGxpbmUsIG1zZykgLT5cbiAgICAgICBzZXRfZXJyb3IgbGluZSAoXCJQYXJzZSBlcnJvciBhdCBcIiBeIG1zZyk7XG4gICAgICAgaGlkZV9tYWNoaW5lICgpXG4gICAgfCBPayB0ICAgIC0+XG4gICAgICAgbGV0IG1vZHVsZSBUQyA9IFRjRWxhYiBpblxuICAgICAgIGJlZ2luIG1hdGNoIFRDLmVsYWJfcHJvZyB0IHdpdGhcbiAgICAgICB8IEVycm9yIChsb2MsIG1zZykgLT5cbiAgICAgICAgICBzZXRfZXJyb3IgKGxvYy5TdXJmLmxpbmUpIChQcmV0dHkuc3RyaW5nX29mX2RvYyBQUHJpbnQuKCFeXCJTdGF0aWMgdHlwZSBlcnJvclwiIF5eIHNwYWNlIF5eIFByZXR0eS5zcmNfbG9jIGxvYyBeXiBicmVhayAwIF5eIG1zZykpO1xuICAgICAgICAgIGhpZGVfbWFjaGluZSAoKVxuICAgICAgIHwgT2sgKHQsIHR5KSAtPlxuICAgICAgICAgIGxldCB0bV9zdCA9IG5leHRfdGVybV9zdGF0ZSB0IGluXG4gICAgICAgICAgc3RhdGUgOj0gKHRtX3N0LCBJLmluaXRfc3RvcmUsIFNvbWUgdHksIDAsIFtdKTtcbiAgICAgICAgICByZXZlYWxfbWFjaGluZSAoKVxuICAgICAgIGVuZFxuICAgIGVuZDtcbiAgICByZW5kZXIgKCk7XG4gICAgSnMuX2ZhbHNlXG4gIGluXG4gIGxldCBzdGVwIF8gPVxuICAgIGxldCAodG1fc3QsIHN0bywgbWF5VHksIHBjLCBoaXN0KSA9ICFzdGF0ZSBpblxuICAgIGJlZ2luIG1hdGNoIHRtX3N0IHdpdGhcbiAgICB8IEdvaW5nIChfLCBtKSAtPlxuICAgICAgIGxldCAoc3RvJywgcmVzKSA9IG0gc3RvIGluXG4gICAgICAgbGV0IHRtX3N0JyA9IGJlZ2luIG1hdGNoIHJlcyB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgRXJyb3IgZSAtPiBFcnIgUFByaW50LihuZXN0IDIgKHN0cmluZyBcIlJ1bnRpbWUgZXJyb3I6XCIgXi9eIChncm91cCBlKSkpXG4gICAgICAgICAgICAgICAgICAgIHwgT2sgdCcgLT4gbmV4dF90ZXJtX3N0YXRlIHQnXG4gICAgICAgICAgICAgICAgICAgIGVuZCBpblxuICAgICAgIHN0YXRlIDo9ICh0bV9zdCcsIHN0bycsIG1heVR5LCBwYyArIDEsICh0bV9zdCwgc3RvKSA6OiBoaXN0KVxuICAgIHwgXyAtPiAoKVxuICAgIGVuZDtcbiAgICByZW5kZXIgKCk7XG4gICAgSnMuX2ZhbHNlXG4gIGluXG4gIGxldCBzdGVwX2JhY2sgXyA9XG4gICAgbGV0IChfLCBfLCBtYXlUeSwgcGMsIGhpc3QpID0gIXN0YXRlIGluXG4gICAgYmVnaW4gbWF0Y2ggaGlzdCB3aXRoXG4gICAgfCBbIF0gLT4gMFxuICAgIHwgKHRzdCcsc3RvJykgOjogaGlzdCAtPlxuICAgICAgIGxldCBwYycgPSBwYyAtIDEgaW5cbiAgICAgICBzdGF0ZSA6PSAodHN0Jywgc3RvJywgbWF5VHksIHBjJywgaGlzdCk7XG4gICAgICAgcGMnXG4gICAgZW5kXG4gIGluXG4gIGxldCBwcmV2IF8gPVxuICAgIGxldCBfID0gc3RlcF9iYWNrICgpIGluXG4gICAgcmVuZGVyICgpO1xuICAgIEpzLl9mYWxzZVxuICBpblxuICBsZXQgcHJldl9tYW55IF8gPVxuICAgIGxldCByZWMgbG9vcCBfID1cbiAgICAgIGlmIHN0ZXBfYmFjayAoKSA9IDAgdGhlbiAoKSBlbHNlIGxvb3AgKClcbiAgICBpblxuICAgIGxvb3AgKCk7XG4gICAgcmVuZGVyICgpO1xuICAgIEpzLl9mYWxzZVxuICBpblxuICBsZXQgbmV4dF9tYW55IF8gPVxuICAgIGxldCByZWMgbG9vcCBuID1cbiAgICAgIGlmIG4gPSAwIHRoZW4gSnMuX2ZhbHNlIGVsc2UgbGV0IF8gPSBzdGVwICgpIGluIGxvb3AgKG4tMSlcbiAgICBpbiBsb29wIDEwMFxuICBpbiBcbiAgbGV0IG1vZHVsZSBFID0gRXhhbXBsZXMgaW5cbiAgc2V0X2NsaWNrIFwiZmFpbF9leGlzdF91bnNlYWxcIiAoZXhfaGFuZGxlIEUuZmFpbHVyZV90b19zZWUpO1xuICBzZXRfY2xpY2sgXCJib29sXCIgKGV4X2hhbmRsZSBFLmJvb2wpO1xuICBzZXRfY2xpY2sgXCJwYWlyXCIgKGV4X2hhbmRsZSBFLnBhaXIpO1xuICBzZXRfY2xpY2sgXCJleGlzdF9mdW5cIiAoZXhfaGFuZGxlIEUuZXhpc3RfZnVuKTtcbiAgc2V0X2NsaWNrIFwiZXhfbWlzbWF0Y2hcIiAoZXhfaGFuZGxlIEUuZXhfaW5jb21wYXQpO1xuICBzZXRfY2xpY2sgXCJmdW5fY2FzdFwiIChleF9oYW5kbGUgRS5mdW5fY2FzdCk7XG4gIHNldF9jbGljayBcInBhcGVyXzFfbm9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzFfbm9zZWFsKTtcbiAgc2V0X2NsaWNrIFwicGFwZXJfMV9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzFfc2VhbCk7XG4gIHNldF9jbGljayBcInBhcGVyXzJfbm9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzJfbm9zZWFsKTtcbiAgc2V0X2NsaWNrIFwicGFwZXJfMl9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzJfc2VhbCk7XG4gIHNldF9jbGljayBcInBhcGVyXzNfbm9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzNfbm9zZWFsKTtcbiAgc2V0X2NsaWNrIFwicGFwZXJfM19zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzNfc2VhbCk7XG4gIHNldF9jbGljayBcInBhcGVyXzRfbm9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzRfbm9zZWFsKTtcbiAgc2V0X2NsaWNrIFwicGFwZXJfNF9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzRfc2VhbCk7XG4gIHNldF9jbGljayBcInBhcGVyXzVfbm9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzVfbm9zZWFsKTtcbiAgc2V0X2NsaWNrIFwicGFwZXJfNV9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzVfc2VhbCk7XG4gIHNldF9jbGljayBcInBhcGVyXzZfbm9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzZfbm9zZWFsKTtcbiAgc2V0X2NsaWNrIFwicGFwZXJfNl9zZWFsXCIgKGV4X2hhbmRsZSBFLnBhcGVyXzZfc2VhbCk7XG5cbiAgc2V0X2NsaWNrIFwiaWRfMVwiIChleF9oYW5kbGUgRS5pZF8xKTtcbiAgc2V0X2NsaWNrIFwiaWRfMlwiIChleF9oYW5kbGUgRS5pZF8yKTtcbiAgc2V0X2NsaWNrIFwiYmFkX2lkXzFcIiAoZXhfaGFuZGxlIEUuYmFkX2lkXzEpO1xuICBzZXRfY2xpY2sgXCJiYWRfaWRfMlwiIChleF9oYW5kbGUgRS5iYWRfaWRfMik7XG5cbiAgc2V0X2NsaWNrIFwic3dhcF8xXCIgKGV4X2hhbmRsZSBFLnN3YXBfMSk7XG4gIHNldF9jbGljayBcInN3YXBfMlwiIChleF9oYW5kbGUgRS5zd2FwXzIpO1xuICBzZXRfY2xpY2sgXCJiYWRfc3dhcF8xXCIgKGV4X2hhbmRsZSBFLmJhZF9zd2FwXzEpO1xuICBzZXRfY2xpY2sgXCJiYWRfc3dhcF8yXCIgKGV4X2hhbmRsZSBFLmJhZF9zd2FwXzIpO1xuXG4gIHNldF9jbGljayBcImZsaXBwZXJfMVwiIChleF9oYW5kbGUgRS5mbGlwcGVyXzEpO1xuICBzZXRfY2xpY2sgXCJmbGlwcGVyXzJcIiAoZXhfaGFuZGxlIEUuZmxpcHBlcl8yKTtcbiAgc2V0X2NsaWNrIFwiYmFkX2ZsaXBwZXJfMVwiIChleF9oYW5kbGUgRS5iYWRfZmxpcHBlcl8xKTtcbiAgc2V0X2NsaWNrIFwiYmFkX2ZsaXBwZXJfMlwiIChleF9oYW5kbGUgRS5iYWRfZmxpcHBlcl8yKTtcbiAgXG4gIHNldF9jbGljayBcImxvYWRcIiAoSC5oYW5kbGVyIGxvYWQpO1xuICBzZXRfY2xpY2sgXCJuZXh0XCIgKEguaGFuZGxlciBzdGVwKTtcbiAgc2V0X2NsaWNrIFwicHJldlwiIChILmhhbmRsZXIgcHJldik7XG4gIHNldF9jbGljayBcInByZXZtYW55XCIgKEguaGFuZGxlciBwcmV2X21hbnkpO1xuICBzZXRfY2xpY2sgXCJuZXh0bWFueVwiIChILmhhbmRsZXIgbmV4dF9tYW55KTtcbiAgaGlkZV9tYWNoaW5lICgpO1xuICBzZXRfZWRpdG9yIEUuZmFpbHVyZV90b19zZWVcbiJdfQ==